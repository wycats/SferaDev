/**
 * Generated by Kubb (https://kubb.dev/).
 * Do not edit manually.
 */

import { z } from "zod";

export const deployValidationsReportSchema = z.object({
	id: z.optional(z.string().describe("The id of the deploy validations report")),
	deploy_id: z.optional(z.string().describe("The id of the deploy")),
	secret_scan_result: z.optional(
		z.object({
			scannedFilesCount: z.optional(z.int().describe("The number of files scanned")),
			secretsScanMatches: z.optional(
				z.array(z.string()).describe("The list of secrets scan matches"),
			),
		}),
	),
});

export const deployValidationsReportSecretScanResultSchema = z.object({
	scannedFilesCount: z.optional(z.int().describe("The number of files scanned")),
	secretsScanMatches: z.optional(z.array(z.string()).describe("The list of secrets scan matches")),
});

export const splitTestSetupSchema = z.object({
	branch_tests: z.optional(z.object({})),
});

export const splitTestsSchema = z.array(
	z.object({
		id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		name: z.optional(z.string()),
		path: z.optional(z.string()),
		branches: z.optional(z.array(z.object({}))),
		active: z.optional(z.boolean()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		unpublished_at: z.optional(z.string()),
	}),
);

export const splitTestSchema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	name: z.optional(z.string()),
	path: z.optional(z.string()),
	branches: z.optional(z.array(z.object({}))),
	active: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	unpublished_at: z.optional(z.string()),
});

export const serviceInstanceSchema = z.object({
	id: z.optional(z.string()),
	url: z.optional(z.string()),
	config: z.optional(z.object({})),
	external_attributes: z.optional(z.object({})),
	service_slug: z.optional(z.string()),
	service_path: z.optional(z.string()),
	service_name: z.optional(z.string()),
	env: z.optional(z.object({})),
	snippets: z.optional(z.array(z.object({}))),
	auth_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
});

export const serviceSchema = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	slug: z.optional(z.string()),
	service_path: z.optional(z.string()),
	long_description: z.optional(z.string()),
	description: z.optional(z.string()),
	events: z.optional(z.array(z.object({}))),
	tags: z.optional(z.array(z.string())),
	icon: z.optional(z.string()),
	manifest_url: z.optional(z.string()),
	environments: z.optional(z.array(z.string())),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
});

export const siteSchema = z.object({
	id: z.optional(z.string()),
	state: z.optional(z.string()),
	plan: z.optional(z.string()),
	name: z.optional(z.string()),
	custom_domain: z.optional(z.string()),
	domain_aliases: z.optional(z.array(z.string())),
	branch_deploy_custom_domain: z.optional(z.string()),
	deploy_preview_custom_domain: z.optional(z.string()),
	password: z.optional(z.string()),
	notification_email: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	user_id: z.optional(z.string()),
	session_id: z.optional(z.string()),
	ssl: z.optional(z.boolean()),
	force_ssl: z.optional(z.boolean()),
	managed_dns: z.optional(z.boolean()),
	deploy_url: z.optional(z.string()),
	published_deploy: z.optional(
		z.object({
			id: z.optional(z.string()),
			site_id: z.optional(z.string()),
			user_id: z.optional(z.string()),
			build_id: z.optional(z.string()),
			state: z.optional(z.string()),
			name: z.optional(z.string()),
			url: z.optional(z.string()),
			ssl_url: z.optional(z.string()),
			admin_url: z.optional(z.string()),
			deploy_url: z.optional(z.string()),
			deploy_ssl_url: z.optional(z.string()),
			screenshot_url: z.optional(z.string()),
			review_id: z.optional(z.number()),
			draft: z.optional(z.boolean()),
			required: z.optional(z.array(z.string())),
			required_functions: z.optional(z.array(z.string())),
			error_message: z.optional(z.string()),
			branch: z.optional(z.string()),
			commit_ref: z.optional(z.string()),
			commit_url: z.optional(z.string()),
			skipped: z.optional(z.boolean()),
			created_at: z.optional(z.string()),
			updated_at: z.optional(z.string()),
			published_at: z.optional(z.string()),
			title: z.optional(z.string()),
			context: z.optional(z.string()),
			locked: z.optional(z.boolean()),
			review_url: z.optional(z.string()),
			framework: z.optional(z.string()),
			skew_protection_token: z.optional(z.string()),
			function_schedules: z.optional(
				z.array(
					z.object({
						name: z.optional(z.string()),
						cron: z.optional(z.string()),
					}),
				),
			),
		}),
	),
	account_id: z.optional(z.string()),
	account_name: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	git_provider: z.optional(z.string()),
	deploy_hook: z.optional(z.string()),
	capabilities: z.optional(z.object({}).catchall(z.object({}))),
	processing_settings: z.optional(
		z.object({
			html: z.optional(
				z.object({
					pretty_urls: z.optional(z.boolean()),
				}),
			),
		}),
	),
	build_settings: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
	id_domain: z.optional(z.string()),
	default_hooks_data: z.optional(
		z.object({
			access_token: z.optional(z.string()),
		}),
	),
	build_image: z.optional(z.string()),
	prerender: z.optional(z.string()),
	functions_region: z.optional(z.string()),
	prevent_non_git_prod_deploys: z.optional(z.boolean().default(false)),
});

export const siteSetupSchema = z.object({
	id: z.optional(z.string()),
	state: z.optional(z.string()),
	plan: z.optional(z.string()),
	name: z.optional(z.string()),
	custom_domain: z.optional(z.string()),
	domain_aliases: z.optional(z.array(z.string())),
	branch_deploy_custom_domain: z.optional(z.string()),
	deploy_preview_custom_domain: z.optional(z.string()),
	password: z.optional(z.string()),
	notification_email: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	user_id: z.optional(z.string()),
	session_id: z.optional(z.string()),
	ssl: z.optional(z.boolean()),
	force_ssl: z.optional(z.boolean()),
	managed_dns: z.optional(z.boolean()),
	deploy_url: z.optional(z.string()),
	published_deploy: z.optional(
		z.object({
			id: z.optional(z.string()),
			site_id: z.optional(z.string()),
			user_id: z.optional(z.string()),
			build_id: z.optional(z.string()),
			state: z.optional(z.string()),
			name: z.optional(z.string()),
			url: z.optional(z.string()),
			ssl_url: z.optional(z.string()),
			admin_url: z.optional(z.string()),
			deploy_url: z.optional(z.string()),
			deploy_ssl_url: z.optional(z.string()),
			screenshot_url: z.optional(z.string()),
			review_id: z.optional(z.number()),
			draft: z.optional(z.boolean()),
			required: z.optional(z.array(z.string())),
			required_functions: z.optional(z.array(z.string())),
			error_message: z.optional(z.string()),
			branch: z.optional(z.string()),
			commit_ref: z.optional(z.string()),
			commit_url: z.optional(z.string()),
			skipped: z.optional(z.boolean()),
			created_at: z.optional(z.string()),
			updated_at: z.optional(z.string()),
			published_at: z.optional(z.string()),
			title: z.optional(z.string()),
			context: z.optional(z.string()),
			locked: z.optional(z.boolean()),
			review_url: z.optional(z.string()),
			framework: z.optional(z.string()),
			skew_protection_token: z.optional(z.string()),
			function_schedules: z.optional(
				z.array(
					z.object({
						name: z.optional(z.string()),
						cron: z.optional(z.string()),
					}),
				),
			),
		}),
	),
	account_id: z.optional(z.string()),
	account_name: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	git_provider: z.optional(z.string()),
	deploy_hook: z.optional(z.string()),
	capabilities: z.optional(z.object({}).catchall(z.object({}))),
	processing_settings: z.optional(
		z.object({
			html: z.optional(
				z.object({
					pretty_urls: z.optional(z.boolean()),
				}),
			),
		}),
	),
	build_settings: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
	id_domain: z.optional(z.string()),
	default_hooks_data: z.optional(
		z.object({
			access_token: z.optional(z.string()),
		}),
	),
	build_image: z.optional(z.string()),
	prerender: z.optional(z.string()),
	functions_region: z.optional(z.string()),
	prevent_non_git_prod_deploys: z.optional(z.boolean().default(false)),
	repo: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
});

export const repoInfoSchema = z.object({
	id: z.optional(z.int()),
	provider: z.optional(z.string()),
	deploy_key_id: z.optional(z.string()),
	repo_path: z.optional(z.string()),
	repo_branch: z.optional(z.string()),
	dir: z.optional(z.string()),
	functions_dir: z.optional(
		z
			.string()
			.describe(
				"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
			),
	),
	cmd: z.optional(
		z
			.string()
			.describe(
				"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
			),
	),
	allowed_branches: z.optional(z.array(z.string())),
	public_repo: z.optional(z.boolean()),
	private_logs: z.optional(z.boolean()),
	repo_url: z.optional(z.string()),
	env: z.optional(z.object({}).catchall(z.string())),
	installation_id: z.optional(z.int()),
	stop_builds: z.optional(
		z
			.boolean()
			.describe(
				"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
			),
	),
});

export const submissionSchema = z.object({
	id: z.optional(z.string()),
	number: z.optional(z.int()),
	email: z.optional(z.string()),
	name: z.optional(z.string()),
	first_name: z.optional(z.string()),
	last_name: z.optional(z.string()),
	company: z.optional(z.string()),
	summary: z.optional(z.string()),
	body: z.optional(z.string()),
	data: z.optional(z.object({})),
	created_at: z.optional(z.string()),
	site_url: z.optional(z.string()),
});

/**
 * @description Environment variable model definition
 */
export const envVarSchema = z
	.object({
		key: z.optional(
			z.string().describe("The environment variable key, like ALGOLIA_ID (case-sensitive)"),
		),
		scopes: z.optional(
			z
				.array(z.enum(["builds", "functions", "runtime", "post-processing"]))
				.describe("The scopes that this environment variable is set to"),
		),
		values: z.optional(
			z
				.array(
					z
						.object({
							id: z.optional(
								z.string().describe("The environment variable value's universally unique ID"),
							),
							value: z.optional(
								z.string().describe("The environment variable's unencrypted value"),
							),
							context: z.optional(
								z
									.enum([
										"all",
										"dev",
										"dev-server",
										"branch-deploy",
										"deploy-preview",
										"production",
										"branch",
									])
									.describe(
										"The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.",
									),
							),
							context_parameter: z.optional(
								z
									.string()
									.describe(
										"An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.",
									),
							),
						})
						.describe("Environment variable value model definition"),
				)
				.describe("An array of Value objects containing values and metadata"),
		),
		is_secret: z.optional(
			z
				.boolean()
				.describe(
					"Secret values are only readable by code running on Netlify's systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret.",
				),
		),
		updated_at: z.optional(
			z.string().datetime().describe("The timestamp of when the value was last updated"),
		),
		updated_by: z.optional(
			z.object({
				id: z.optional(z.string().describe("The user's unique identifier")),
				full_name: z.optional(z.string().describe("The user's full name (first and last)")),
				email: z.optional(z.string().describe("The user's email address")),
				avatar_url: z.optional(z.string().describe("A URL pointing to the user's avatar")),
			}),
		),
	})
	.describe("Environment variable model definition");

/**
 * @description Environment variable value model definition
 */
export const envVarValueSchema = z
	.object({
		id: z.optional(z.string().describe("The environment variable value's universally unique ID")),
		value: z.optional(z.string().describe("The environment variable's unencrypted value")),
		context: z.optional(
			z
				.enum([
					"all",
					"dev",
					"dev-server",
					"branch-deploy",
					"deploy-preview",
					"production",
					"branch",
				])
				.describe(
					"The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.",
				),
		),
		context_parameter: z.optional(
			z
				.string()
				.describe(
					"An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.",
				),
		),
	})
	.describe("Environment variable value model definition");

export const envVarUserSchema = z.object({
	id: z.optional(z.string().describe("The user's unique identifier")),
	full_name: z.optional(z.string().describe("The user's full name (first and last)")),
	email: z.optional(z.string().describe("The user's email address")),
	avatar_url: z.optional(z.string().describe("A URL pointing to the user's avatar")),
});

export const formSchema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	name: z.optional(z.string()),
	paths: z.optional(z.array(z.string())),
	submission_count: z.optional(z.int()),
	fields: z.optional(z.array(z.object({}))),
	created_at: z.optional(z.string()),
});

export const hookTypeSchema = z.object({
	name: z.optional(z.string()),
	events: z.optional(z.array(z.string())),
	fields: z.optional(z.array(z.object({}))),
});

export const hookSchema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	type: z.optional(z.string()),
	event: z.optional(z.string()),
	data: z.optional(z.object({})),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	disabled: z.optional(z.boolean()),
});

export const fileSchema = z.object({
	id: z.optional(z.string()),
	path: z.optional(z.string()),
	sha: z.optional(z.string()),
	mime_type: z.optional(z.string()),
	size: z.optional(z.int()),
});

export const functionSchema = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	sha: z.optional(z.string()),
});

export const snippetSchema = z.object({
	id: z.optional(z.int()),
	site_id: z.optional(z.string()),
	title: z.optional(z.string()),
	general: z.optional(z.string()),
	general_position: z.optional(z.string()),
	goal: z.optional(z.string()),
	goal_position: z.optional(z.string()),
});

export const purgeSchema = z.object({
	site_id: z.optional(z.string()),
	site_slug: z.optional(z.string()),
	cache_tags: z.optional(z.array(z.string())),
});

export const deploySchema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	user_id: z.optional(z.string()),
	build_id: z.optional(z.string()),
	state: z.optional(z.string()),
	name: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	deploy_url: z.optional(z.string()),
	deploy_ssl_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	review_id: z.optional(z.number()),
	draft: z.optional(z.boolean()),
	required: z.optional(z.array(z.string())),
	required_functions: z.optional(z.array(z.string())),
	error_message: z.optional(z.string()),
	branch: z.optional(z.string()),
	commit_ref: z.optional(z.string()),
	commit_url: z.optional(z.string()),
	skipped: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	published_at: z.optional(z.string()),
	title: z.optional(z.string()),
	context: z.optional(z.string()),
	locked: z.optional(z.boolean()),
	review_url: z.optional(z.string()),
	framework: z.optional(z.string()),
	skew_protection_token: z.optional(z.string()),
	function_schedules: z.optional(
		z.array(
			z.object({
				name: z.optional(z.string()),
				cron: z.optional(z.string()),
			}),
		),
	),
});

/**
 * @description Deploy files can be provided in two ways:\n1. As a JSON object using \'files\' (a hash mapping file paths to SHA1 digests), OR\n2. As a zip file using one of these methods:\n   - Set Content-Type to \'application/zip\' and send the zip file as the raw request body\n   - Include the zip file content in the \'zip\' field of this JSON object with Content-Type \'application/json\'\n
 */
export const deployFilesSchema = z
	.object({
		files: z.optional(
			z.object({}).describe("A hash mapping file paths to SHA1 digests of the file contents."),
		),
		zip: z.optional(
			z
				.instanceof(File)
				.describe(
					"A zip file containing the site files to deploy. Alternative to 'files'.\nTo use this field, set Content-Type to 'application/json' and include the zip content here.\nAlternatively, you can set Content-Type to 'application/zip' and send the zip as the raw request body (not as JSON).\n",
				),
		),
		draft: z.optional(z.boolean()),
		async: z.optional(z.boolean()),
		functions: z.optional(z.object({})),
		function_schedules: z.optional(
			z.array(
				z.object({
					name: z.optional(z.string()),
					cron: z.optional(z.string()),
				}),
			),
		),
		functions_config: z.optional(
			z.object({}).catchall(
				z.object({
					display_name: z.optional(z.string()),
					generator: z.optional(z.string()),
					build_data: z.optional(z.object({})),
					routes: z.optional(
						z.array(
							z.object({
								pattern: z.optional(z.string()),
								literal: z.optional(z.string()),
								expression: z.optional(z.string()),
								methods: z.optional(
									z.array(z.enum(["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"])),
								),
								prefer_static: z.optional(z.boolean()),
							}),
						),
					),
					excluded_routes: z.optional(
						z.array(
							z.object({
								pattern: z.optional(z.string()),
								literal: z.optional(z.string()),
								expression: z.optional(z.string()),
							}),
						),
					),
					priority: z.optional(z.int()),
					traffic_rules: z.optional(
						z.object({
							action: z.optional(
								z.object({
									type: z.optional(z.string()),
									config: z.optional(
										z.object({
											to: z.optional(z.string()),
											rate_limit_config: z.optional(
												z.object({
													algorithm: z.optional(z.enum(["sliding_window"])),
													window_size: z.optional(z.int()),
													window_limit: z.optional(z.int()),
												}),
											),
											aggregate: z.optional(
												z.object({
													keys: z.optional(
														z.array(
															z.object({
																type: z.optional(z.enum(["ip", "domain"])),
															}),
														),
													),
												}),
											),
										}),
									),
								}),
							),
						}),
					),
				}),
			),
		),
		branch: z.optional(z.string()),
		framework: z.optional(z.string()),
		framework_version: z.optional(z.string()),
	})
	.describe(
		"Deploy files can be provided in two ways:\n1. As a JSON object using 'files' (a hash mapping file paths to SHA1 digests), OR\n2. As a zip file using one of these methods:\n   - Set Content-Type to 'application/zip' and send the zip file as the raw request body\n   - Include the zip file content in the 'zip' field of this JSON object with Content-Type 'application/json'\n",
	);

export const pluginParamsSchema = z.object({
	pinned_version: z.optional(z.string()),
});

export const pluginSchema = z.object({
	package: z.optional(z.string()),
	pinned_version: z.optional(z.string()),
});

export const buildStatusSchema = z.object({
	active: z.optional(z.int()),
	pending_concurrency: z.optional(z.int()),
	enqueued: z.optional(z.int()),
	build_count: z.optional(z.int()),
	minutes: z.optional(
		z.object({
			current: z.optional(z.int()),
			current_average_sec: z.optional(z.int()),
			previous: z.optional(z.int()),
			period_start_date: z.optional(z.string()),
			period_end_date: z.optional(z.string()),
			last_updated_at: z.optional(z.string()),
			included_minutes: z.optional(z.string()),
			included_minutes_with_packs: z.optional(z.string()),
		}),
	),
});

export const buildSchema = z.object({
	id: z.optional(z.string()),
	deploy_id: z.optional(z.string()),
	sha: z.optional(z.string()),
	done: z.optional(z.boolean()),
	error: z.optional(z.string()),
	created_at: z.optional(z.string()),
});

export const buildLogMsgSchema = z.object({
	message: z.optional(z.string()),
	error: z.optional(z.boolean()),
	section: z.optional(
		z.enum(["initializing", "building", "deploying", "cleanup", "postprocessing"]),
	),
});

export const pluginRunDataSchema = z.object({
	package: z.optional(z.string()),
	version: z.optional(z.string()),
	state: z.optional(z.string()),
	reporting_event: z.optional(z.string()),
	title: z.optional(z.string()),
	summary: z.optional(z.string()),
	text: z.optional(z.string()),
});

export const pluginRunSchema = z.object({
	package: z.optional(z.string()),
	version: z.optional(z.string()),
	state: z.optional(z.string()),
	reporting_event: z.optional(z.string()),
	title: z.optional(z.string()),
	summary: z.optional(z.string()),
	text: z.optional(z.string()),
	deploy_id: z.optional(z.string()),
});

export const metadataSchema = z.object({});

export const dnsZoneSetupSchema = z.object({
	account_slug: z.optional(z.string()),
	site_id: z.optional(z.string()),
	name: z.optional(z.string()),
});

export const dnsZonesSchema = z.array(
	z.object({
		id: z.optional(z.string()),
		name: z.optional(z.string()),
		errors: z.optional(z.array(z.string())),
		supported_record_types: z.optional(z.array(z.string())),
		user_id: z.optional(z.string()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		records: z.optional(
			z.array(
				z.object({
					id: z.optional(z.string()),
					hostname: z.optional(z.string()),
					type: z.optional(z.string()),
					value: z.optional(z.string()),
					ttl: z.optional(z.int()),
					priority: z.optional(z.int()),
					dns_zone_id: z.optional(z.string()),
					site_id: z.optional(z.string()),
					flag: z.optional(z.int()),
					tag: z.optional(z.string()),
					managed: z.optional(z.boolean()),
				}),
			),
		),
		dns_servers: z.optional(z.array(z.string())),
		account_id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		account_slug: z.optional(z.string()),
		account_name: z.optional(z.string()),
		domain: z.optional(z.string()),
		ipv6_enabled: z.optional(z.boolean()),
		dedicated: z.optional(z.boolean()),
	}),
);

export const dnsZoneSchema = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	errors: z.optional(z.array(z.string())),
	supported_record_types: z.optional(z.array(z.string())),
	user_id: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	records: z.optional(
		z.array(
			z.object({
				id: z.optional(z.string()),
				hostname: z.optional(z.string()),
				type: z.optional(z.string()),
				value: z.optional(z.string()),
				ttl: z.optional(z.int()),
				priority: z.optional(z.int()),
				dns_zone_id: z.optional(z.string()),
				site_id: z.optional(z.string()),
				flag: z.optional(z.int()),
				tag: z.optional(z.string()),
				managed: z.optional(z.boolean()),
			}),
		),
	),
	dns_servers: z.optional(z.array(z.string())),
	account_id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	account_name: z.optional(z.string()),
	domain: z.optional(z.string()),
	ipv6_enabled: z.optional(z.boolean()),
	dedicated: z.optional(z.boolean()),
});

export const dnsRecordCreateSchema = z.object({
	type: z.optional(z.string()),
	hostname: z.optional(z.string()),
	value: z.optional(z.string()),
	ttl: z.optional(z.int()),
	priority: z.optional(z.int()),
	weight: z.optional(z.int()),
	port: z.optional(z.int()),
	flag: z.optional(z.int()),
	tag: z.optional(z.string()),
});

export const dnsRecordsSchema = z.array(
	z.object({
		id: z.optional(z.string()),
		hostname: z.optional(z.string()),
		type: z.optional(z.string()),
		value: z.optional(z.string()),
		ttl: z.optional(z.int()),
		priority: z.optional(z.int()),
		dns_zone_id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		flag: z.optional(z.int()),
		tag: z.optional(z.string()),
		managed: z.optional(z.boolean()),
	}),
);

export const dnsRecordSchema = z.object({
	id: z.optional(z.string()),
	hostname: z.optional(z.string()),
	type: z.optional(z.string()),
	value: z.optional(z.string()),
	ttl: z.optional(z.int()),
	priority: z.optional(z.int()),
	dns_zone_id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	flag: z.optional(z.int()),
	tag: z.optional(z.string()),
	managed: z.optional(z.boolean()),
});

export const sniCertificateSchema = z.object({
	state: z.optional(z.string()),
	domains: z.optional(z.array(z.string())),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	expires_at: z.optional(z.string()),
});

export const ticketSchema = z.object({
	id: z.optional(z.string()),
	client_id: z.optional(z.string()),
	authorized: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
});

export const accessTokenSchema = z.object({
	id: z.optional(z.string()),
	access_token: z.optional(z.string()),
	user_id: z.optional(z.string()),
	user_email: z.optional(z.string()),
	created_at: z.optional(z.string()),
});

export const assetSchema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	creator_id: z.optional(z.string()),
	name: z.optional(z.string()),
	state: z.optional(z.string()),
	content_type: z.optional(z.string()),
	url: z.optional(z.string()),
	key: z.optional(z.string()),
	visibility: z.optional(z.string()),
	size: z.optional(z.int()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
});

export const assetFormSchema = z.object({
	url: z.optional(z.string()),
	fields: z.optional(z.object({}).catchall(z.string())),
});

export const assetSignatureSchema = z.object({
	form: z.optional(
		z.object({
			url: z.optional(z.string()),
			fields: z.optional(z.object({}).catchall(z.string())),
		}),
	),
	asset: z.optional(
		z.object({
			id: z.optional(z.string()),
			site_id: z.optional(z.string()),
			creator_id: z.optional(z.string()),
			name: z.optional(z.string()),
			state: z.optional(z.string()),
			content_type: z.optional(z.string()),
			url: z.optional(z.string()),
			key: z.optional(z.string()),
			visibility: z.optional(z.string()),
			size: z.optional(z.int()),
			created_at: z.optional(z.string()),
			updated_at: z.optional(z.string()),
		}),
	),
});

export const assetPublicSignatureSchema = z.object({
	url: z.optional(z.string()),
});

export const deployKeySchema = z.object({
	id: z.optional(z.string()),
	public_key: z.optional(z.string()),
	created_at: z.optional(z.string()),
});

export const memberSchema = z.object({
	id: z.optional(z.string()),
	full_name: z.optional(z.string()),
	email: z.optional(z.string()),
	avatar: z.optional(z.string()),
	role: z.optional(z.string()),
});

export const paymentMethodSchema = z.object({
	id: z.optional(z.string()),
	method_name: z.optional(z.string()),
	type: z.optional(z.string()),
	state: z.optional(z.string()),
	data: z.optional(
		z.object({
			card_type: z.optional(z.string()),
			last4: z.optional(z.string()),
			email: z.optional(z.string()),
		}),
	),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
});

export const accountTypeSchema = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	description: z.optional(z.string()),
	capabilities: z.optional(z.object({})),
	monthly_dollar_price: z.optional(z.int()),
	yearly_dollar_price: z.optional(z.int()),
	monthly_seats_addon_dollar_price: z.optional(z.int()),
	yearly_seats_addon_dollar_price: z.optional(z.int()),
});

export const accountSetupSchema = z.object({
	name: z.string(),
	type_id: z.string(),
	payment_method_id: z.optional(z.string()),
	period: z.optional(z.enum(["monthly", "yearly"])),
	extra_seats_block: z.optional(z.int()),
});

export const accountUpdateSetupSchema = z.object({
	name: z.optional(z.string()),
	slug: z.optional(z.string()),
	type_id: z.optional(z.string()),
	extra_seats_block: z.optional(z.int()),
	billing_name: z.optional(z.string()),
	billing_email: z.optional(z.string()),
	billing_details: z.optional(z.string()),
});

export const accountAddMemberSetupSchema = z.object({
	role: z.optional(z.enum(["Owner", "Developer", "Billing Admin", "Reviewer"])),
	email: z.optional(z.string()),
});

export const accountUpdateMemberSetupSchema = z.object({
	role: z.optional(z.enum(["Owner", "Developer", "Billing Admin", "Reviewer"])),
	site_access: z.optional(z.enum(["all", "none", "selected"])),
	site_ids: z.optional(z.array(z.string())),
});

export const accountMembershipSchema = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	slug: z.optional(z.string()),
	type: z.optional(z.string()),
	capabilities: z.optional(
		z.object({
			sites: z.optional(
				z.object({
					included: z.optional(z.int()),
					used: z.optional(z.int()),
				}),
			),
			collaborators: z.optional(
				z.object({
					included: z.optional(z.int()),
					used: z.optional(z.int()),
				}),
			),
		}),
	),
	billing_name: z.optional(z.string()),
	billing_email: z.optional(z.string()),
	billing_details: z.optional(z.string()),
	billing_period: z.optional(z.string()),
	payment_method_id: z.optional(z.string()),
	type_name: z.optional(z.string()),
	type_id: z.optional(z.string()),
	owner_ids: z.optional(z.array(z.string())),
	roles_allowed: z.optional(z.array(z.string())),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
});

export const auditLogSchema = z.object({
	id: z.optional(z.string()),
	account_id: z.optional(z.string()),
	payload: z.optional(
		z
			.object({
				actor_id: z.optional(z.string()),
				actor_name: z.optional(z.string()),
				actor_email: z.optional(z.string()),
				action: z.optional(z.string()),
				timestamp: z.optional(z.string()),
				log_type: z.optional(z.string()),
			})
			.catchall(z.object({})),
	),
});

export const agentRunnerSchema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	parent_agent_runner_id: z.optional(z.string()),
	state: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	done_at: z.optional(z.string()),
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	result_branch: z.optional(z.string()),
	pr_url: z.optional(z.string()),
	pr_branch: z.optional(z.string()),
	pr_state: z.optional(z.string()),
	pr_number: z.optional(z.int()),
	pr_is_being_created: z.optional(z.boolean()),
	pr_error: z.optional(z.string()),
	current_task: z.optional(z.string()),
	result_diff: z.optional(z.string()),
	sha: z.optional(z.string()),
	merge_commit_sha: z.optional(z.string()),
	merge_commit_error: z.optional(z.string()),
	merge_commit_is_being_created: z.optional(z.boolean()),
	base_deploy_id: z.optional(z.string()),
	attached_file_keys: z.optional(z.array(z.string())),
	active_session_created_at: z.optional(z.string()),
	latest_session_deploy_id: z.optional(z.string()),
	latest_session_deploy_url: z.optional(z.string()),
	user: z.optional(
		z.object({
			id: z.optional(z.string()),
			full_name: z.optional(z.string()),
			email: z.optional(z.string()),
			avatar_url: z.optional(z.string()),
		}),
	),
});

export const agentRunnerSessionSchema = z.object({
	id: z.optional(z.string()),
	agent_runner_id: z.optional(z.string()),
	dev_server_id: z.optional(z.string()),
	state: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	done_at: z.optional(z.string()),
	title: z.optional(z.string()),
	prompt: z.optional(z.string()),
	agent_config: z.optional(
		z.object({
			agent: z.optional(z.string()),
			model: z.optional(z.string()),
		}),
	),
	result: z.optional(z.string()),
	result_diff: z.optional(z.string()),
	commit_sha: z.optional(z.string()),
	deploy_id: z.optional(z.string()),
	deploy_url: z.optional(z.string()),
	duration: z.optional(z.int()),
	steps: z.optional(
		z.array(
			z.object({
				title: z.optional(z.string()),
				message: z.optional(z.string()),
			}),
		),
	),
	user: z.optional(
		z.object({
			id: z.optional(z.string()),
			full_name: z.optional(z.string()),
			email: z.optional(z.string()),
			avatar_url: z.optional(z.string()),
		}),
	),
	attached_file_keys: z.optional(z.array(z.string())),
	result_zip_file_name: z.optional(z.string()),
	is_published: z.optional(z.boolean()),
});

export const agentRunnerSessionStepSchema = z.object({
	title: z.optional(z.string()),
	message: z.optional(z.string()),
});

export const agentRunnerSessionConfigSchema = z.object({
	agent: z.optional(z.string()),
	model: z.optional(z.string()),
});

export const agentRunnerUserSchema = z.object({
	id: z.optional(z.string()),
	full_name: z.optional(z.string()),
	email: z.optional(z.string()),
	avatar_url: z.optional(z.string()),
});

export const accountUsageCapabilitySchema = z.object({
	included: z.optional(z.int()),
	used: z.optional(z.int()),
});

export const buildSetupSchema = z.object({
	image: z.optional(z.string()),
	clear_cache: z.optional(z.boolean()),
});

export const buildHookSetupSchema = z.object({
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
});

export const buildHookSchema = z.object({
	id: z.optional(z.string()),
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	url: z.optional(z.string()),
	site_id: z.optional(z.string()),
	created_at: z.optional(z.string()),
});

export const deployedBranchSchema = z.object({
	id: z.optional(z.string()),
	deploy_id: z.optional(z.string()),
	name: z.optional(z.string()),
	slug: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
});

export const userSchema = z.object({
	id: z.optional(z.string()),
	uid: z.optional(z.string()),
	full_name: z.optional(z.string()),
	avatar_url: z.optional(z.string()),
	email: z.optional(z.string()),
	affiliate_id: z.optional(z.string()),
	site_count: z.optional(z.int()),
	created_at: z.optional(z.string()),
	last_login: z.optional(z.string()),
	login_providers: z.optional(z.array(z.string())),
	onboarding_progress: z.optional(
		z.object({
			slides: z.optional(z.string()),
		}),
	),
});

export const errorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const functionScheduleSchema = z.object({
	name: z.optional(z.string()),
	cron: z.optional(z.string()),
});

export const functionConfigSchema = z.object({
	display_name: z.optional(z.string()),
	generator: z.optional(z.string()),
	build_data: z.optional(z.object({})),
	routes: z.optional(
		z.array(
			z.object({
				pattern: z.optional(z.string()),
				literal: z.optional(z.string()),
				expression: z.optional(z.string()),
				methods: z.optional(z.array(z.enum(["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"]))),
				prefer_static: z.optional(z.boolean()),
			}),
		),
	),
	excluded_routes: z.optional(
		z.array(
			z.object({
				pattern: z.optional(z.string()),
				literal: z.optional(z.string()),
				expression: z.optional(z.string()),
			}),
		),
	),
	priority: z.optional(z.int()),
	traffic_rules: z.optional(
		z.object({
			action: z.optional(
				z.object({
					type: z.optional(z.string()),
					config: z.optional(
						z.object({
							to: z.optional(z.string()),
							rate_limit_config: z.optional(
								z.object({
									algorithm: z.optional(z.enum(["sliding_window"])),
									window_size: z.optional(z.int()),
									window_limit: z.optional(z.int()),
								}),
							),
							aggregate: z.optional(
								z.object({
									keys: z.optional(
										z.array(
											z.object({
												type: z.optional(z.enum(["ip", "domain"])),
											}),
										),
									),
								}),
							),
						}),
					),
				}),
			),
		}),
	),
});

export const functionRouteSchema = z.object({
	pattern: z.optional(z.string()),
	literal: z.optional(z.string()),
	expression: z.optional(z.string()),
	methods: z.optional(z.array(z.enum(["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"]))),
	prefer_static: z.optional(z.boolean()),
});

export const excludedFunctionRouteSchema = z.object({
	pattern: z.optional(z.string()),
	literal: z.optional(z.string()),
	expression: z.optional(z.string()),
});

export const trafficRulesConfigSchema = z.object({
	action: z.optional(
		z.object({
			type: z.optional(z.string()),
			config: z.optional(
				z.object({
					to: z.optional(z.string()),
					rate_limit_config: z.optional(
						z.object({
							algorithm: z.optional(z.enum(["sliding_window"])),
							window_size: z.optional(z.int()),
							window_limit: z.optional(z.int()),
						}),
					),
					aggregate: z.optional(
						z.object({
							keys: z.optional(
								z.array(
									z.object({
										type: z.optional(z.enum(["ip", "domain"])),
									}),
								),
							),
						}),
					),
				}),
			),
		}),
	),
});

export const trafficRulesRateLimitConfigSchema = z.object({
	algorithm: z.optional(z.enum(["sliding_window"])),
	window_size: z.optional(z.int()),
	window_limit: z.optional(z.int()),
});

export const trafficRulesAggregateConfigSchema = z.object({
	keys: z.optional(
		z.array(
			z.object({
				type: z.optional(z.enum(["ip", "domain"])),
			}),
		),
	),
});

export const siteFunctionSchema = z.object({
	branch: z.optional(z.string()),
	created_at: z.optional(z.string()),
	functions: z.optional(z.array(z.object({}))),
	id: z.optional(z.string()),
	log_type: z.optional(z.string()),
	provider: z.optional(z.string()),
});

export const devServerSchema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	branch: z.optional(z.string()),
	url: z.optional(z.string()),
	state: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	starting_at: z.optional(z.string()),
	error_at: z.optional(z.string()),
	live_at: z.optional(z.string()),
	done_at: z.optional(z.string()),
	title: z.optional(z.string()),
});

export const devServerHookSchema = z.object({
	id: z.optional(z.string()),
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	url: z.optional(z.string()),
	site_id: z.optional(z.string()),
	created_at: z.optional(z.string()),
	type: z.optional(z.enum(["new_dev_server", "content_refresh"])),
});

export const devServerHookSetupSchema = z.object({
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	type: z.optional(z.enum(["new_dev_server", "content_refresh"])),
});

export const providerDefinitionSchema = z.object({
	token_env_var: z.optional(z.string()),
	url_env_var: z.optional(z.string()),
	models: z.optional(z.array(z.string())),
});

export const aiGatewayTokenSchema = z.object({
	token: z.optional(z.string().describe("The AI Gateway authentication token")),
	url: z.optional(z.string().describe("AI gateway base url")),
	expires_at: z.optional(z.int().describe("Unix timestamp when the token expires")),
});

export const updateSiteMetadataMetadataSchema = z.object({});

/**
 * @description Deploy files can be provided in two ways:\n1. As a JSON object using \'files\' (a hash mapping file paths to SHA1 digests), OR\n2. As a zip file using one of these methods:\n   - Set Content-Type to \'application/zip\' and send the zip file as the raw request body\n   - Include the zip file content in the \'zip\' field of this JSON object with Content-Type \'application/json\'\n
 */
export const createSiteDeployDeploySchema = z
	.object({
		files: z.optional(
			z.object({}).describe("A hash mapping file paths to SHA1 digests of the file contents."),
		),
		zip: z.optional(
			z
				.instanceof(File)
				.describe(
					"A zip file containing the site files to deploy. Alternative to 'files'.\nTo use this field, set Content-Type to 'application/json' and include the zip content here.\nAlternatively, you can set Content-Type to 'application/zip' and send the zip as the raw request body (not as JSON).\n",
				),
		),
		draft: z.optional(z.boolean()),
		async: z.optional(z.boolean()),
		functions: z.optional(z.object({})),
		function_schedules: z.optional(
			z.array(
				z.object({
					name: z.optional(z.string()),
					cron: z.optional(z.string()),
				}),
			),
		),
		functions_config: z.optional(
			z.object({}).catchall(
				z.object({
					display_name: z.optional(z.string()),
					generator: z.optional(z.string()),
					build_data: z.optional(z.object({})),
					routes: z.optional(
						z.array(
							z.object({
								pattern: z.optional(z.string()),
								literal: z.optional(z.string()),
								expression: z.optional(z.string()),
								methods: z.optional(
									z.array(z.enum(["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"])),
								),
								prefer_static: z.optional(z.boolean()),
							}),
						),
					),
					excluded_routes: z.optional(
						z.array(
							z.object({
								pattern: z.optional(z.string()),
								literal: z.optional(z.string()),
								expression: z.optional(z.string()),
							}),
						),
					),
					priority: z.optional(z.int()),
					traffic_rules: z.optional(
						z.object({
							action: z.optional(
								z.object({
									type: z.optional(z.string()),
									config: z.optional(
										z.object({
											to: z.optional(z.string()),
											rate_limit_config: z.optional(
												z.object({
													algorithm: z.optional(z.enum(["sliding_window"])),
													window_size: z.optional(z.int()),
													window_limit: z.optional(z.int()),
												}),
											),
											aggregate: z.optional(
												z.object({
													keys: z.optional(
														z.array(
															z.object({
																type: z.optional(z.enum(["ip", "domain"])),
															}),
														),
													),
												}),
											),
										}),
									),
								}),
							),
						}),
					),
				}),
			),
		),
		branch: z.optional(z.string()),
		framework: z.optional(z.string()),
		framework_version: z.optional(z.string()),
	})
	.describe(
		"Deploy files can be provided in two ways:\n1. As a JSON object using 'files' (a hash mapping file paths to SHA1 digests), OR\n2. As a zip file using one of these methods:\n   - Set Content-Type to 'application/zip' and send the zip file as the raw request body\n   - Include the zip file content in the 'zip' field of this JSON object with Content-Type 'application/json'\n",
	);

export const createHookBySiteIdHookSchema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	type: z.optional(z.string()),
	event: z.optional(z.string()),
	data: z.optional(z.object({})),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	disabled: z.optional(z.boolean()),
});

export const createSiteSnippetSnippetSchema = z.object({
	id: z.optional(z.int()),
	site_id: z.optional(z.string()),
	title: z.optional(z.string()),
	general: z.optional(z.string()),
	general_position: z.optional(z.string()),
	goal: z.optional(z.string()),
	goal_position: z.optional(z.string()),
});

export const uploadDeployFileFileBodySchema = z.instanceof(File);

export const createSiteBuildHookBuildhookSchema = z.object({
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
});

export const createSiteSiteSchema = z.object({
	id: z.optional(z.string()),
	state: z.optional(z.string()),
	plan: z.optional(z.string()),
	name: z.optional(z.string()),
	custom_domain: z.optional(z.string()),
	domain_aliases: z.optional(z.array(z.string())),
	branch_deploy_custom_domain: z.optional(z.string()),
	deploy_preview_custom_domain: z.optional(z.string()),
	password: z.optional(z.string()),
	notification_email: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	user_id: z.optional(z.string()),
	session_id: z.optional(z.string()),
	ssl: z.optional(z.boolean()),
	force_ssl: z.optional(z.boolean()),
	managed_dns: z.optional(z.boolean()),
	deploy_url: z.optional(z.string()),
	published_deploy: z.optional(
		z.object({
			id: z.optional(z.string()),
			site_id: z.optional(z.string()),
			user_id: z.optional(z.string()),
			build_id: z.optional(z.string()),
			state: z.optional(z.string()),
			name: z.optional(z.string()),
			url: z.optional(z.string()),
			ssl_url: z.optional(z.string()),
			admin_url: z.optional(z.string()),
			deploy_url: z.optional(z.string()),
			deploy_ssl_url: z.optional(z.string()),
			screenshot_url: z.optional(z.string()),
			review_id: z.optional(z.number()),
			draft: z.optional(z.boolean()),
			required: z.optional(z.array(z.string())),
			required_functions: z.optional(z.array(z.string())),
			error_message: z.optional(z.string()),
			branch: z.optional(z.string()),
			commit_ref: z.optional(z.string()),
			commit_url: z.optional(z.string()),
			skipped: z.optional(z.boolean()),
			created_at: z.optional(z.string()),
			updated_at: z.optional(z.string()),
			published_at: z.optional(z.string()),
			title: z.optional(z.string()),
			context: z.optional(z.string()),
			locked: z.optional(z.boolean()),
			review_url: z.optional(z.string()),
			framework: z.optional(z.string()),
			skew_protection_token: z.optional(z.string()),
			function_schedules: z.optional(
				z.array(
					z.object({
						name: z.optional(z.string()),
						cron: z.optional(z.string()),
					}),
				),
			),
		}),
	),
	account_id: z.optional(z.string()),
	account_name: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	git_provider: z.optional(z.string()),
	deploy_hook: z.optional(z.string()),
	capabilities: z.optional(z.object({}).catchall(z.object({}))),
	processing_settings: z.optional(
		z.object({
			html: z.optional(
				z.object({
					pretty_urls: z.optional(z.boolean()),
				}),
			),
		}),
	),
	build_settings: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
	id_domain: z.optional(z.string()),
	default_hooks_data: z.optional(
		z.object({
			access_token: z.optional(z.string()),
		}),
	),
	build_image: z.optional(z.string()),
	prerender: z.optional(z.string()),
	functions_region: z.optional(z.string()),
	prevent_non_git_prod_deploys: z.optional(z.boolean().default(false)),
	repo: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
});

export const createSplitTestBranchTestsSchema = z.object({
	branch_tests: z.optional(z.object({})),
});

export const createSiteDevServerHookDevserverhookSchema = z.object({
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	type: z.optional(z.enum(["new_dev_server", "content_refresh"])),
});

export const listSitesQueryParamsSchema = z
	.object({
		name: z.optional(z.string()),
		filter: z.optional(z.enum(["all", "owner", "guest"])),
		page: z.optional(z.coerce.number().int()),
		per_page: z.optional(z.coerce.number().int()),
	})
	.optional();

/**
 * @description OK
 */
export const listSites200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		state: z.optional(z.string()),
		plan: z.optional(z.string()),
		name: z.optional(z.string()),
		custom_domain: z.optional(z.string()),
		domain_aliases: z.optional(z.array(z.string())),
		branch_deploy_custom_domain: z.optional(z.string()),
		deploy_preview_custom_domain: z.optional(z.string()),
		password: z.optional(z.string()),
		notification_email: z.optional(z.string()),
		url: z.optional(z.string()),
		ssl_url: z.optional(z.string()),
		admin_url: z.optional(z.string()),
		screenshot_url: z.optional(z.string()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		user_id: z.optional(z.string()),
		session_id: z.optional(z.string()),
		ssl: z.optional(z.boolean()),
		force_ssl: z.optional(z.boolean()),
		managed_dns: z.optional(z.boolean()),
		deploy_url: z.optional(z.string()),
		published_deploy: z.optional(
			z.object({
				id: z.optional(z.string()),
				site_id: z.optional(z.string()),
				user_id: z.optional(z.string()),
				build_id: z.optional(z.string()),
				state: z.optional(z.string()),
				name: z.optional(z.string()),
				url: z.optional(z.string()),
				ssl_url: z.optional(z.string()),
				admin_url: z.optional(z.string()),
				deploy_url: z.optional(z.string()),
				deploy_ssl_url: z.optional(z.string()),
				screenshot_url: z.optional(z.string()),
				review_id: z.optional(z.number()),
				draft: z.optional(z.boolean()),
				required: z.optional(z.array(z.string())),
				required_functions: z.optional(z.array(z.string())),
				error_message: z.optional(z.string()),
				branch: z.optional(z.string()),
				commit_ref: z.optional(z.string()),
				commit_url: z.optional(z.string()),
				skipped: z.optional(z.boolean()),
				created_at: z.optional(z.string()),
				updated_at: z.optional(z.string()),
				published_at: z.optional(z.string()),
				title: z.optional(z.string()),
				context: z.optional(z.string()),
				locked: z.optional(z.boolean()),
				review_url: z.optional(z.string()),
				framework: z.optional(z.string()),
				skew_protection_token: z.optional(z.string()),
				function_schedules: z.optional(
					z.array(
						z.object({
							name: z.optional(z.string()),
							cron: z.optional(z.string()),
						}),
					),
				),
			}),
		),
		account_id: z.optional(z.string()),
		account_name: z.optional(z.string()),
		account_slug: z.optional(z.string()),
		git_provider: z.optional(z.string()),
		deploy_hook: z.optional(z.string()),
		capabilities: z.optional(z.object({}).catchall(z.object({}))),
		processing_settings: z.optional(
			z.object({
				html: z.optional(
					z.object({
						pretty_urls: z.optional(z.boolean()),
					}),
				),
			}),
		),
		build_settings: z.optional(
			z.object({
				id: z.optional(z.int()),
				provider: z.optional(z.string()),
				deploy_key_id: z.optional(z.string()),
				repo_path: z.optional(z.string()),
				repo_branch: z.optional(z.string()),
				dir: z.optional(z.string()),
				functions_dir: z.optional(
					z
						.string()
						.describe(
							"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
						),
				),
				cmd: z.optional(
					z
						.string()
						.describe(
							"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
						),
				),
				allowed_branches: z.optional(z.array(z.string())),
				public_repo: z.optional(z.boolean()),
				private_logs: z.optional(z.boolean()),
				repo_url: z.optional(z.string()),
				env: z.optional(z.object({}).catchall(z.string())),
				installation_id: z.optional(z.int()),
				stop_builds: z.optional(
					z
						.boolean()
						.describe(
							"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
						),
				),
			}),
		),
		id_domain: z.optional(z.string()),
		default_hooks_data: z.optional(
			z.object({
				access_token: z.optional(z.string()),
			}),
		),
		build_image: z.optional(z.string()),
		prerender: z.optional(z.string()),
		functions_region: z.optional(z.string()),
		prevent_non_git_prod_deploys: z.optional(z.boolean().default(false)),
	}),
);

/**
 * @description error
 */
export const listSitesErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listSitesQueryResponseSchema = z.lazy(() => listSites200Schema);

export const createSiteQueryParamsSchema = z
	.object({
		configure_dns: z.optional(z.boolean()),
	})
	.optional();

/**
 * @description Created
 */
export const createSite201Schema = z.object({
	id: z.optional(z.string()),
	state: z.optional(z.string()),
	plan: z.optional(z.string()),
	name: z.optional(z.string()),
	custom_domain: z.optional(z.string()),
	domain_aliases: z.optional(z.array(z.string())),
	branch_deploy_custom_domain: z.optional(z.string()),
	deploy_preview_custom_domain: z.optional(z.string()),
	password: z.optional(z.string()),
	notification_email: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	user_id: z.optional(z.string()),
	session_id: z.optional(z.string()),
	ssl: z.optional(z.boolean()),
	force_ssl: z.optional(z.boolean()),
	managed_dns: z.optional(z.boolean()),
	deploy_url: z.optional(z.string()),
	published_deploy: z.optional(
		z.object({
			id: z.optional(z.string()),
			site_id: z.optional(z.string()),
			user_id: z.optional(z.string()),
			build_id: z.optional(z.string()),
			state: z.optional(z.string()),
			name: z.optional(z.string()),
			url: z.optional(z.string()),
			ssl_url: z.optional(z.string()),
			admin_url: z.optional(z.string()),
			deploy_url: z.optional(z.string()),
			deploy_ssl_url: z.optional(z.string()),
			screenshot_url: z.optional(z.string()),
			review_id: z.optional(z.number()),
			draft: z.optional(z.boolean()),
			required: z.optional(z.array(z.string())),
			required_functions: z.optional(z.array(z.string())),
			error_message: z.optional(z.string()),
			branch: z.optional(z.string()),
			commit_ref: z.optional(z.string()),
			commit_url: z.optional(z.string()),
			skipped: z.optional(z.boolean()),
			created_at: z.optional(z.string()),
			updated_at: z.optional(z.string()),
			published_at: z.optional(z.string()),
			title: z.optional(z.string()),
			context: z.optional(z.string()),
			locked: z.optional(z.boolean()),
			review_url: z.optional(z.string()),
			framework: z.optional(z.string()),
			skew_protection_token: z.optional(z.string()),
			function_schedules: z.optional(
				z.array(
					z.object({
						name: z.optional(z.string()),
						cron: z.optional(z.string()),
					}),
				),
			),
		}),
	),
	account_id: z.optional(z.string()),
	account_name: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	git_provider: z.optional(z.string()),
	deploy_hook: z.optional(z.string()),
	capabilities: z.optional(z.object({}).catchall(z.object({}))),
	processing_settings: z.optional(
		z.object({
			html: z.optional(
				z.object({
					pretty_urls: z.optional(z.boolean()),
				}),
			),
		}),
	),
	build_settings: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
	id_domain: z.optional(z.string()),
	default_hooks_data: z.optional(
		z.object({
			access_token: z.optional(z.string()),
		}),
	),
	build_image: z.optional(z.string()),
	prerender: z.optional(z.string()),
	functions_region: z.optional(z.string()),
	prevent_non_git_prod_deploys: z.optional(z.boolean().default(false)),
});

/**
 * @description error
 */
export const createSiteErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createSiteMutationRequestSchema = z.object({
	id: z.optional(z.string()),
	state: z.optional(z.string()),
	plan: z.optional(z.string()),
	name: z.optional(z.string()),
	custom_domain: z.optional(z.string()),
	domain_aliases: z.optional(z.array(z.string())),
	branch_deploy_custom_domain: z.optional(z.string()),
	deploy_preview_custom_domain: z.optional(z.string()),
	password: z.optional(z.string()),
	notification_email: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	user_id: z.optional(z.string()),
	session_id: z.optional(z.string()),
	ssl: z.optional(z.boolean()),
	force_ssl: z.optional(z.boolean()),
	managed_dns: z.optional(z.boolean()),
	deploy_url: z.optional(z.string()),
	published_deploy: z.optional(
		z.object({
			id: z.optional(z.string()),
			site_id: z.optional(z.string()),
			user_id: z.optional(z.string()),
			build_id: z.optional(z.string()),
			state: z.optional(z.string()),
			name: z.optional(z.string()),
			url: z.optional(z.string()),
			ssl_url: z.optional(z.string()),
			admin_url: z.optional(z.string()),
			deploy_url: z.optional(z.string()),
			deploy_ssl_url: z.optional(z.string()),
			screenshot_url: z.optional(z.string()),
			review_id: z.optional(z.number()),
			draft: z.optional(z.boolean()),
			required: z.optional(z.array(z.string())),
			required_functions: z.optional(z.array(z.string())),
			error_message: z.optional(z.string()),
			branch: z.optional(z.string()),
			commit_ref: z.optional(z.string()),
			commit_url: z.optional(z.string()),
			skipped: z.optional(z.boolean()),
			created_at: z.optional(z.string()),
			updated_at: z.optional(z.string()),
			published_at: z.optional(z.string()),
			title: z.optional(z.string()),
			context: z.optional(z.string()),
			locked: z.optional(z.boolean()),
			review_url: z.optional(z.string()),
			framework: z.optional(z.string()),
			skew_protection_token: z.optional(z.string()),
			function_schedules: z.optional(
				z.array(
					z.object({
						name: z.optional(z.string()),
						cron: z.optional(z.string()),
					}),
				),
			),
		}),
	),
	account_id: z.optional(z.string()),
	account_name: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	git_provider: z.optional(z.string()),
	deploy_hook: z.optional(z.string()),
	capabilities: z.optional(z.object({}).catchall(z.object({}))),
	processing_settings: z.optional(
		z.object({
			html: z.optional(
				z.object({
					pretty_urls: z.optional(z.boolean()),
				}),
			),
		}),
	),
	build_settings: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
	id_domain: z.optional(z.string()),
	default_hooks_data: z.optional(
		z.object({
			access_token: z.optional(z.string()),
		}),
	),
	build_image: z.optional(z.string()),
	prerender: z.optional(z.string()),
	functions_region: z.optional(z.string()),
	prevent_non_git_prod_deploys: z.optional(z.boolean().default(false)),
	repo: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
});

export const createSiteMutationResponseSchema = z.lazy(() => createSite201Schema);

export const getSitePathParamsSchema = z.object({
	site_id: z.string(),
});

export const getSiteQueryParamsSchema = z
	.object({
		feature_flags: z.optional(z.string()),
	})
	.optional();

/**
 * @description OK
 */
export const getSite200Schema = z.object({
	id: z.optional(z.string()),
	state: z.optional(z.string()),
	plan: z.optional(z.string()),
	name: z.optional(z.string()),
	custom_domain: z.optional(z.string()),
	domain_aliases: z.optional(z.array(z.string())),
	branch_deploy_custom_domain: z.optional(z.string()),
	deploy_preview_custom_domain: z.optional(z.string()),
	password: z.optional(z.string()),
	notification_email: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	user_id: z.optional(z.string()),
	session_id: z.optional(z.string()),
	ssl: z.optional(z.boolean()),
	force_ssl: z.optional(z.boolean()),
	managed_dns: z.optional(z.boolean()),
	deploy_url: z.optional(z.string()),
	published_deploy: z.optional(
		z.object({
			id: z.optional(z.string()),
			site_id: z.optional(z.string()),
			user_id: z.optional(z.string()),
			build_id: z.optional(z.string()),
			state: z.optional(z.string()),
			name: z.optional(z.string()),
			url: z.optional(z.string()),
			ssl_url: z.optional(z.string()),
			admin_url: z.optional(z.string()),
			deploy_url: z.optional(z.string()),
			deploy_ssl_url: z.optional(z.string()),
			screenshot_url: z.optional(z.string()),
			review_id: z.optional(z.number()),
			draft: z.optional(z.boolean()),
			required: z.optional(z.array(z.string())),
			required_functions: z.optional(z.array(z.string())),
			error_message: z.optional(z.string()),
			branch: z.optional(z.string()),
			commit_ref: z.optional(z.string()),
			commit_url: z.optional(z.string()),
			skipped: z.optional(z.boolean()),
			created_at: z.optional(z.string()),
			updated_at: z.optional(z.string()),
			published_at: z.optional(z.string()),
			title: z.optional(z.string()),
			context: z.optional(z.string()),
			locked: z.optional(z.boolean()),
			review_url: z.optional(z.string()),
			framework: z.optional(z.string()),
			skew_protection_token: z.optional(z.string()),
			function_schedules: z.optional(
				z.array(
					z.object({
						name: z.optional(z.string()),
						cron: z.optional(z.string()),
					}),
				),
			),
		}),
	),
	account_id: z.optional(z.string()),
	account_name: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	git_provider: z.optional(z.string()),
	deploy_hook: z.optional(z.string()),
	capabilities: z.optional(z.object({}).catchall(z.object({}))),
	processing_settings: z.optional(
		z.object({
			html: z.optional(
				z.object({
					pretty_urls: z.optional(z.boolean()),
				}),
			),
		}),
	),
	build_settings: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
	id_domain: z.optional(z.string()),
	default_hooks_data: z.optional(
		z.object({
			access_token: z.optional(z.string()),
		}),
	),
	build_image: z.optional(z.string()),
	prerender: z.optional(z.string()),
	functions_region: z.optional(z.string()),
	prevent_non_git_prod_deploys: z.optional(z.boolean().default(false)),
});

/**
 * @description error
 */
export const getSiteErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getSiteQueryResponseSchema = z.lazy(() => getSite200Schema);

export const updateSitePathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const updateSite200Schema = z.object({
	id: z.optional(z.string()),
	state: z.optional(z.string()),
	plan: z.optional(z.string()),
	name: z.optional(z.string()),
	custom_domain: z.optional(z.string()),
	domain_aliases: z.optional(z.array(z.string())),
	branch_deploy_custom_domain: z.optional(z.string()),
	deploy_preview_custom_domain: z.optional(z.string()),
	password: z.optional(z.string()),
	notification_email: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	user_id: z.optional(z.string()),
	session_id: z.optional(z.string()),
	ssl: z.optional(z.boolean()),
	force_ssl: z.optional(z.boolean()),
	managed_dns: z.optional(z.boolean()),
	deploy_url: z.optional(z.string()),
	published_deploy: z.optional(
		z.object({
			id: z.optional(z.string()),
			site_id: z.optional(z.string()),
			user_id: z.optional(z.string()),
			build_id: z.optional(z.string()),
			state: z.optional(z.string()),
			name: z.optional(z.string()),
			url: z.optional(z.string()),
			ssl_url: z.optional(z.string()),
			admin_url: z.optional(z.string()),
			deploy_url: z.optional(z.string()),
			deploy_ssl_url: z.optional(z.string()),
			screenshot_url: z.optional(z.string()),
			review_id: z.optional(z.number()),
			draft: z.optional(z.boolean()),
			required: z.optional(z.array(z.string())),
			required_functions: z.optional(z.array(z.string())),
			error_message: z.optional(z.string()),
			branch: z.optional(z.string()),
			commit_ref: z.optional(z.string()),
			commit_url: z.optional(z.string()),
			skipped: z.optional(z.boolean()),
			created_at: z.optional(z.string()),
			updated_at: z.optional(z.string()),
			published_at: z.optional(z.string()),
			title: z.optional(z.string()),
			context: z.optional(z.string()),
			locked: z.optional(z.boolean()),
			review_url: z.optional(z.string()),
			framework: z.optional(z.string()),
			skew_protection_token: z.optional(z.string()),
			function_schedules: z.optional(
				z.array(
					z.object({
						name: z.optional(z.string()),
						cron: z.optional(z.string()),
					}),
				),
			),
		}),
	),
	account_id: z.optional(z.string()),
	account_name: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	git_provider: z.optional(z.string()),
	deploy_hook: z.optional(z.string()),
	capabilities: z.optional(z.object({}).catchall(z.object({}))),
	processing_settings: z.optional(
		z.object({
			html: z.optional(
				z.object({
					pretty_urls: z.optional(z.boolean()),
				}),
			),
		}),
	),
	build_settings: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
	id_domain: z.optional(z.string()),
	default_hooks_data: z.optional(
		z.object({
			access_token: z.optional(z.string()),
		}),
	),
	build_image: z.optional(z.string()),
	prerender: z.optional(z.string()),
	functions_region: z.optional(z.string()),
	prevent_non_git_prod_deploys: z.optional(z.boolean().default(false)),
});

/**
 * @description error
 */
export const updateSiteErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateSiteMutationRequestSchema = z.object({
	id: z.optional(z.string()),
	state: z.optional(z.string()),
	plan: z.optional(z.string()),
	name: z.optional(z.string()),
	custom_domain: z.optional(z.string()),
	domain_aliases: z.optional(z.array(z.string())),
	branch_deploy_custom_domain: z.optional(z.string()),
	deploy_preview_custom_domain: z.optional(z.string()),
	password: z.optional(z.string()),
	notification_email: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	user_id: z.optional(z.string()),
	session_id: z.optional(z.string()),
	ssl: z.optional(z.boolean()),
	force_ssl: z.optional(z.boolean()),
	managed_dns: z.optional(z.boolean()),
	deploy_url: z.optional(z.string()),
	published_deploy: z.optional(
		z.object({
			id: z.optional(z.string()),
			site_id: z.optional(z.string()),
			user_id: z.optional(z.string()),
			build_id: z.optional(z.string()),
			state: z.optional(z.string()),
			name: z.optional(z.string()),
			url: z.optional(z.string()),
			ssl_url: z.optional(z.string()),
			admin_url: z.optional(z.string()),
			deploy_url: z.optional(z.string()),
			deploy_ssl_url: z.optional(z.string()),
			screenshot_url: z.optional(z.string()),
			review_id: z.optional(z.number()),
			draft: z.optional(z.boolean()),
			required: z.optional(z.array(z.string())),
			required_functions: z.optional(z.array(z.string())),
			error_message: z.optional(z.string()),
			branch: z.optional(z.string()),
			commit_ref: z.optional(z.string()),
			commit_url: z.optional(z.string()),
			skipped: z.optional(z.boolean()),
			created_at: z.optional(z.string()),
			updated_at: z.optional(z.string()),
			published_at: z.optional(z.string()),
			title: z.optional(z.string()),
			context: z.optional(z.string()),
			locked: z.optional(z.boolean()),
			review_url: z.optional(z.string()),
			framework: z.optional(z.string()),
			skew_protection_token: z.optional(z.string()),
			function_schedules: z.optional(
				z.array(
					z.object({
						name: z.optional(z.string()),
						cron: z.optional(z.string()),
					}),
				),
			),
		}),
	),
	account_id: z.optional(z.string()),
	account_name: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	git_provider: z.optional(z.string()),
	deploy_hook: z.optional(z.string()),
	capabilities: z.optional(z.object({}).catchall(z.object({}))),
	processing_settings: z.optional(
		z.object({
			html: z.optional(
				z.object({
					pretty_urls: z.optional(z.boolean()),
				}),
			),
		}),
	),
	build_settings: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
	id_domain: z.optional(z.string()),
	default_hooks_data: z.optional(
		z.object({
			access_token: z.optional(z.string()),
		}),
	),
	build_image: z.optional(z.string()),
	prerender: z.optional(z.string()),
	functions_region: z.optional(z.string()),
	prevent_non_git_prod_deploys: z.optional(z.boolean().default(false)),
	repo: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
});

export const updateSiteMutationResponseSchema = z.lazy(() => updateSite200Schema);

export const deleteSitePathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description Deleted
 */
export const deleteSite204Schema = z.unknown();

/**
 * @description error
 */
export const deleteSiteErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteSiteMutationResponseSchema = z.lazy(() => deleteSite204Schema);

export const provisionSiteTLSCertificatePathParamsSchema = z.object({
	site_id: z.string(),
});

export const provisionSiteTLSCertificateQueryParamsSchema = z
	.object({
		certificate: z.optional(
			z
				.string()
				.describe("PEM-encoded certificate. Required when updating an existing certificate."),
		),
		key: z.optional(
			z
				.string()
				.describe("PEM-encoded private key. Required when updating an existing certificate."),
		),
		ca_certificates: z.optional(
			z
				.string()
				.describe(
					"PEM-encoded CA certificate chain. Required when updating an existing certificate.",
				),
		),
	})
	.optional();

/**
 * @description OK
 */
export const provisionSiteTLSCertificate200Schema = z.object({
	state: z.optional(z.string()),
	domains: z.optional(z.array(z.string())),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	expires_at: z.optional(z.string()),
});

/**
 * @description Unprocessable Entity. Returns errors such as: \"certificate parameter is required when updating an existing certificate\" (when updating without params), \"No custom domain configured\", or \"bad dns for custom domain\"
 */
export const provisionSiteTLSCertificate422Schema = z.unknown();

/**
 * @description error
 */
export const provisionSiteTLSCertificateErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const provisionSiteTLSCertificateMutationResponseSchema = z.lazy(
	() => provisionSiteTLSCertificate200Schema,
);

export const showSiteTLSCertificatePathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const showSiteTLSCertificate200Schema = z.object({
	state: z.optional(z.string()),
	domains: z.optional(z.array(z.string())),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	expires_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const showSiteTLSCertificateErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const showSiteTLSCertificateQueryResponseSchema = z.lazy(
	() => showSiteTLSCertificate200Schema,
);

export const getAllCertificatesPathParamsSchema = z.object({
	site_id: z.string(),
});

export const getAllCertificatesQueryParamsSchema = z.object({
	domain: z.string(),
});

/**
 * @description Array of SNI Certificates
 */
export const getAllCertificates200Schema = z.array(
	z.object({
		state: z.optional(z.string()),
		domains: z.optional(z.array(z.string())),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		expires_at: z.optional(z.string()),
	}),
);

/**
 * @description Not Found
 */
export const getAllCertificates404Schema = z.unknown();

/**
 * @description Unprocessable Entity
 */
export const getAllCertificates422Schema = z.unknown();

export const getAllCertificatesQueryResponseSchema = z.lazy(() => getAllCertificates200Schema);

export const getEnvVarsPathParamsSchema = z.object({
	account_id: z.string().describe("Scope response to account_id"),
});

export const getEnvVarsQueryParamsSchema = z
	.object({
		context_name: z.optional(
			z
				.enum(["all", "dev", "dev-server", "branch-deploy", "deploy-preview", "production"])
				.describe("Filter by deploy context"),
		),
		scope: z.optional(
			z.enum(["builds", "functions", "runtime", "post-processing"]).describe("Filter by scope"),
		),
		site_id: z.optional(
			z.string().describe("If specified, only return environment variables set on this site"),
		),
	})
	.optional();

/**
 * @description OK
 */
export const getEnvVars200Schema = z.array(
	z
		.object({
			key: z.optional(
				z.string().describe("The environment variable key, like ALGOLIA_ID (case-sensitive)"),
			),
			scopes: z.optional(
				z
					.array(z.enum(["builds", "functions", "runtime", "post-processing"]))
					.describe("The scopes that this environment variable is set to"),
			),
			values: z.optional(
				z
					.array(
						z
							.object({
								id: z.optional(
									z.string().describe("The environment variable value's universally unique ID"),
								),
								value: z.optional(
									z.string().describe("The environment variable's unencrypted value"),
								),
								context: z.optional(
									z
										.enum([
											"all",
											"dev",
											"dev-server",
											"branch-deploy",
											"deploy-preview",
											"production",
											"branch",
										])
										.describe(
											"The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.",
										),
								),
								context_parameter: z.optional(
									z
										.string()
										.describe(
											"An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.",
										),
								),
							})
							.describe("Environment variable value model definition"),
					)
					.describe("An array of Value objects containing values and metadata"),
			),
			is_secret: z.optional(
				z
					.boolean()
					.describe(
						"Secret values are only readable by code running on Netlify's systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret.",
					),
			),
			updated_at: z.optional(
				z.string().datetime().describe("The timestamp of when the value was last updated"),
			),
			updated_by: z.optional(
				z.object({
					id: z.optional(z.string().describe("The user's unique identifier")),
					full_name: z.optional(z.string().describe("The user's full name (first and last)")),
					email: z.optional(z.string().describe("The user's email address")),
					avatar_url: z.optional(z.string().describe("A URL pointing to the user's avatar")),
				}),
			),
		})
		.describe("Environment variable model definition"),
);

/**
 * @description error
 */
export const getEnvVarsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getEnvVarsQueryResponseSchema = z.lazy(() => getEnvVars200Schema);

export const createEnvVarsPathParamsSchema = z.object({
	account_id: z.string().describe("Scope response to account_id"),
});

export const createEnvVarsQueryParamsSchema = z
	.object({
		site_id: z.optional(
			z
				.string()
				.describe(
					"If provided, create an environment variable on the site level, not the account level",
				),
		),
	})
	.optional();

/**
 * @description OK
 */
export const createEnvVars201Schema = z.array(
	z
		.object({
			key: z.optional(
				z.string().describe("The environment variable key, like ALGOLIA_ID (case-sensitive)"),
			),
			scopes: z.optional(
				z
					.array(z.enum(["builds", "functions", "runtime", "post-processing"]))
					.describe("The scopes that this environment variable is set to"),
			),
			values: z.optional(
				z
					.array(
						z
							.object({
								id: z.optional(
									z.string().describe("The environment variable value's universally unique ID"),
								),
								value: z.optional(
									z.string().describe("The environment variable's unencrypted value"),
								),
								context: z.optional(
									z
										.enum([
											"all",
											"dev",
											"dev-server",
											"branch-deploy",
											"deploy-preview",
											"production",
											"branch",
										])
										.describe(
											"The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.",
										),
								),
								context_parameter: z.optional(
									z
										.string()
										.describe(
											"An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.",
										),
								),
							})
							.describe("Environment variable value model definition"),
					)
					.describe("An array of Value objects containing values and metadata"),
			),
			is_secret: z.optional(
				z
					.boolean()
					.describe(
						"Secret values are only readable by code running on Netlify's systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret.",
					),
			),
			updated_at: z.optional(
				z.string().datetime().describe("The timestamp of when the value was last updated"),
			),
			updated_by: z.optional(
				z.object({
					id: z.optional(z.string().describe("The user's unique identifier")),
					full_name: z.optional(z.string().describe("The user's full name (first and last)")),
					email: z.optional(z.string().describe("The user's email address")),
					avatar_url: z.optional(z.string().describe("A URL pointing to the user's avatar")),
				}),
			),
		})
		.describe("Environment variable model definition"),
);

/**
 * @description error
 */
export const createEnvVarsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createEnvVarsMutationRequestSchema = z.array(
	z.object({
		key: z.optional(
			z
				.string()
				.describe("The existing or new name of the key, if you wish to rename it (case-sensitive)"),
		),
		scopes: z.optional(
			z
				.array(z.enum(["builds", "functions", "runtime", "post-processing"]))
				.describe("The scopes that this environment variable is set to (Pro plans and above)"),
		),
		values: z.optional(
			z.array(
				z
					.object({
						id: z.optional(
							z.string().describe("The environment variable value's universally unique ID"),
						),
						value: z.optional(z.string().describe("The environment variable's unencrypted value")),
						context: z.optional(
							z
								.enum([
									"all",
									"dev",
									"dev-server",
									"branch-deploy",
									"deploy-preview",
									"production",
									"branch",
								])
								.describe(
									"The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.",
								),
						),
						context_parameter: z.optional(
							z
								.string()
								.describe(
									"An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.",
								),
						),
					})
					.describe("Environment variable value model definition"),
			),
		),
		is_secret: z.optional(
			z
				.boolean()
				.describe(
					"Secret values are only readable by code running on Netlify's systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret.",
				),
		),
	}),
);

export const createEnvVarsMutationResponseSchema = z.lazy(() => createEnvVars201Schema);

export const getSiteEnvVarsPathParamsSchema = z.object({
	site_id: z.string().describe("Scope response to site_id"),
});

export const getSiteEnvVarsQueryParamsSchema = z
	.object({
		context_name: z.optional(
			z
				.enum(["all", "dev", "dev-server", "branch-deploy", "deploy-preview", "production"])
				.describe("Filter by deploy context"),
		),
		scope: z.optional(
			z.enum(["builds", "functions", "runtime", "post_processing"]).describe("Filter by scope"),
		),
	})
	.optional();

/**
 * @description OK
 */
export const getSiteEnvVars200Schema = z.array(
	z
		.object({
			key: z.optional(
				z.string().describe("The environment variable key, like ALGOLIA_ID (case-sensitive)"),
			),
			scopes: z.optional(
				z
					.array(z.enum(["builds", "functions", "runtime", "post-processing"]))
					.describe("The scopes that this environment variable is set to"),
			),
			values: z.optional(
				z
					.array(
						z
							.object({
								id: z.optional(
									z.string().describe("The environment variable value's universally unique ID"),
								),
								value: z.optional(
									z.string().describe("The environment variable's unencrypted value"),
								),
								context: z.optional(
									z
										.enum([
											"all",
											"dev",
											"dev-server",
											"branch-deploy",
											"deploy-preview",
											"production",
											"branch",
										])
										.describe(
											"The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.",
										),
								),
								context_parameter: z.optional(
									z
										.string()
										.describe(
											"An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.",
										),
								),
							})
							.describe("Environment variable value model definition"),
					)
					.describe("An array of Value objects containing values and metadata"),
			),
			is_secret: z.optional(
				z
					.boolean()
					.describe(
						"Secret values are only readable by code running on Netlify's systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret.",
					),
			),
			updated_at: z.optional(
				z.string().datetime().describe("The timestamp of when the value was last updated"),
			),
			updated_by: z.optional(
				z.object({
					id: z.optional(z.string().describe("The user's unique identifier")),
					full_name: z.optional(z.string().describe("The user's full name (first and last)")),
					email: z.optional(z.string().describe("The user's email address")),
					avatar_url: z.optional(z.string().describe("A URL pointing to the user's avatar")),
				}),
			),
		})
		.describe("Environment variable model definition"),
);

/**
 * @description error
 */
export const getSiteEnvVarsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getSiteEnvVarsQueryResponseSchema = z.lazy(() => getSiteEnvVars200Schema);

export const getEnvVarPathParamsSchema = z.object({
	account_id: z.string().describe("Scope response to account_id"),
	key: z.string().describe("The environment variable key (case-sensitive)"),
});

export const getEnvVarQueryParamsSchema = z
	.object({
		site_id: z.optional(
			z
				.string()
				.describe(
					"If provided, return the environment variable for a specific site (no merging is performed)",
				),
		),
	})
	.optional();

/**
 * @description OK
 */
export const getEnvVar200Schema = z
	.object({
		key: z.optional(
			z.string().describe("The environment variable key, like ALGOLIA_ID (case-sensitive)"),
		),
		scopes: z.optional(
			z
				.array(z.enum(["builds", "functions", "runtime", "post-processing"]))
				.describe("The scopes that this environment variable is set to"),
		),
		values: z.optional(
			z
				.array(
					z
						.object({
							id: z.optional(
								z.string().describe("The environment variable value's universally unique ID"),
							),
							value: z.optional(
								z.string().describe("The environment variable's unencrypted value"),
							),
							context: z.optional(
								z
									.enum([
										"all",
										"dev",
										"dev-server",
										"branch-deploy",
										"deploy-preview",
										"production",
										"branch",
									])
									.describe(
										"The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.",
									),
							),
							context_parameter: z.optional(
								z
									.string()
									.describe(
										"An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.",
									),
							),
						})
						.describe("Environment variable value model definition"),
				)
				.describe("An array of Value objects containing values and metadata"),
		),
		is_secret: z.optional(
			z
				.boolean()
				.describe(
					"Secret values are only readable by code running on Netlify's systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret.",
				),
		),
		updated_at: z.optional(
			z.string().datetime().describe("The timestamp of when the value was last updated"),
		),
		updated_by: z.optional(
			z.object({
				id: z.optional(z.string().describe("The user's unique identifier")),
				full_name: z.optional(z.string().describe("The user's full name (first and last)")),
				email: z.optional(z.string().describe("The user's email address")),
				avatar_url: z.optional(z.string().describe("A URL pointing to the user's avatar")),
			}),
		),
	})
	.describe("Environment variable model definition");

/**
 * @description error
 */
export const getEnvVarErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getEnvVarQueryResponseSchema = z.lazy(() => getEnvVar200Schema);

export const updateEnvVarPathParamsSchema = z.object({
	account_id: z.string().describe("Scope response to account_id"),
	key: z.string().describe("The existing environment variable key name (case-sensitive)"),
});

export const updateEnvVarQueryParamsSchema = z
	.object({
		site_id: z.optional(
			z.string().describe("If provided, update an environment variable set on this site"),
		),
	})
	.optional();

/**
 * @description OK
 */
export const updateEnvVar200Schema = z
	.object({
		key: z.optional(
			z.string().describe("The environment variable key, like ALGOLIA_ID (case-sensitive)"),
		),
		scopes: z.optional(
			z
				.array(z.enum(["builds", "functions", "runtime", "post-processing"]))
				.describe("The scopes that this environment variable is set to"),
		),
		values: z.optional(
			z
				.array(
					z
						.object({
							id: z.optional(
								z.string().describe("The environment variable value's universally unique ID"),
							),
							value: z.optional(
								z.string().describe("The environment variable's unencrypted value"),
							),
							context: z.optional(
								z
									.enum([
										"all",
										"dev",
										"dev-server",
										"branch-deploy",
										"deploy-preview",
										"production",
										"branch",
									])
									.describe(
										"The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.",
									),
							),
							context_parameter: z.optional(
								z
									.string()
									.describe(
										"An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.",
									),
							),
						})
						.describe("Environment variable value model definition"),
				)
				.describe("An array of Value objects containing values and metadata"),
		),
		is_secret: z.optional(
			z
				.boolean()
				.describe(
					"Secret values are only readable by code running on Netlify's systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret.",
				),
		),
		updated_at: z.optional(
			z.string().datetime().describe("The timestamp of when the value was last updated"),
		),
		updated_by: z.optional(
			z.object({
				id: z.optional(z.string().describe("The user's unique identifier")),
				full_name: z.optional(z.string().describe("The user's full name (first and last)")),
				email: z.optional(z.string().describe("The user's email address")),
				avatar_url: z.optional(z.string().describe("A URL pointing to the user's avatar")),
			}),
		),
	})
	.describe("Environment variable model definition");

/**
 * @description error
 */
export const updateEnvVarErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateEnvVarMutationRequestSchema = z.object({
	key: z.optional(
		z
			.string()
			.describe("The existing or new name of the key, if you wish to rename it (case-sensitive)"),
	),
	scopes: z.optional(
		z
			.array(z.enum(["builds", "functions", "runtime", "post-processing"]))
			.describe("The scopes that this environment variable is set to (Pro plans and above)"),
	),
	values: z.optional(
		z.array(
			z
				.object({
					id: z.optional(
						z.string().describe("The environment variable value's universally unique ID"),
					),
					value: z.optional(z.string().describe("The environment variable's unencrypted value")),
					context: z.optional(
						z
							.enum([
								"all",
								"dev",
								"dev-server",
								"branch-deploy",
								"deploy-preview",
								"production",
								"branch",
							])
							.describe(
								"The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.",
							),
					),
					context_parameter: z.optional(
						z
							.string()
							.describe(
								"An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.",
							),
					),
				})
				.describe("Environment variable value model definition"),
		),
	),
	is_secret: z.optional(
		z
			.boolean()
			.describe(
				"Secret values are only readable by code running on Netlify's systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret.",
			),
	),
});

export const updateEnvVarMutationResponseSchema = z.lazy(() => updateEnvVar200Schema);

export const setEnvVarValuePathParamsSchema = z.object({
	account_id: z.string().describe("Scope response to account_id"),
	key: z.string().describe("The existing environment variable key name (case-sensitive)"),
});

export const setEnvVarValueQueryParamsSchema = z
	.object({
		site_id: z.optional(
			z.string().describe("If provided, update an environment variable set on this site"),
		),
	})
	.optional();

/**
 * @description Created (success)
 */
export const setEnvVarValue201Schema = z
	.object({
		key: z.optional(
			z.string().describe("The environment variable key, like ALGOLIA_ID (case-sensitive)"),
		),
		scopes: z.optional(
			z
				.array(z.enum(["builds", "functions", "runtime", "post-processing"]))
				.describe("The scopes that this environment variable is set to"),
		),
		values: z.optional(
			z
				.array(
					z
						.object({
							id: z.optional(
								z.string().describe("The environment variable value's universally unique ID"),
							),
							value: z.optional(
								z.string().describe("The environment variable's unencrypted value"),
							),
							context: z.optional(
								z
									.enum([
										"all",
										"dev",
										"dev-server",
										"branch-deploy",
										"deploy-preview",
										"production",
										"branch",
									])
									.describe(
										"The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.",
									),
							),
							context_parameter: z.optional(
								z
									.string()
									.describe(
										"An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.",
									),
							),
						})
						.describe("Environment variable value model definition"),
				)
				.describe("An array of Value objects containing values and metadata"),
		),
		is_secret: z.optional(
			z
				.boolean()
				.describe(
					"Secret values are only readable by code running on Netlify's systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret.",
				),
		),
		updated_at: z.optional(
			z.string().datetime().describe("The timestamp of when the value was last updated"),
		),
		updated_by: z.optional(
			z.object({
				id: z.optional(z.string().describe("The user's unique identifier")),
				full_name: z.optional(z.string().describe("The user's full name (first and last)")),
				email: z.optional(z.string().describe("The user's email address")),
				avatar_url: z.optional(z.string().describe("A URL pointing to the user's avatar")),
			}),
		),
	})
	.describe("Environment variable model definition");

/**
 * @description error
 */
export const setEnvVarValueErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const setEnvVarValueMutationRequestSchema = z.object({
	context: z.optional(
		z
			.enum(["all", "dev", "dev-server", "branch-deploy", "deploy-preview", "production", "branch"])
			.describe(
				"The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`. `branch` must be provided with a value in `context_parameter`.",
			),
	),
	context_parameter: z.optional(
		z
			.string()
			.describe(
				"An additional parameter for custom branches. Currently, this is used for providing a branch name when `context=branch`.",
			),
	),
	value: z.optional(z.string().describe("The environment variable's unencrypted value")),
});

export const setEnvVarValueMutationResponseSchema = z.lazy(() => setEnvVarValue201Schema);

export const deleteEnvVarPathParamsSchema = z.object({
	account_id: z.string().describe("Scope response to account_id"),
	key: z.string().describe("The environment variable key (case-sensitive)"),
});

export const deleteEnvVarQueryParamsSchema = z
	.object({
		site_id: z.optional(
			z.string().describe("If provided, delete the environment variable from this site"),
		),
	})
	.optional();

/**
 * @description No Content (success)
 */
export const deleteEnvVar204Schema = z.unknown();

/**
 * @description error
 */
export const deleteEnvVarErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteEnvVarMutationResponseSchema = z.lazy(() => deleteEnvVar204Schema);

export const deleteEnvVarValuePathParamsSchema = z.object({
	account_id: z.string().describe("Scope response to account_id"),
	id: z.string().describe("The environment variable value's ID"),
	key: z.string().describe("The environment variable key name (case-sensitive)"),
});

export const deleteEnvVarValueQueryParamsSchema = z
	.object({
		site_id: z.optional(
			z
				.string()
				.describe("If provided, delete the value from an environment variable on this site"),
		),
	})
	.optional();

/**
 * @description No Content (success)
 */
export const deleteEnvVarValue204Schema = z.unknown();

/**
 * @description error
 */
export const deleteEnvVarValueErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteEnvVarValueMutationResponseSchema = z.lazy(() => deleteEnvVarValue204Schema);

export const searchSiteFunctionsPathParamsSchema = z.object({
	site_id: z.string(),
});

export const searchSiteFunctionsQueryParamsSchema = z
	.object({
		filter: z.optional(z.string()),
	})
	.optional();

/**
 * @description OK
 */
export const searchSiteFunctions200Schema = z.array(
	z.object({
		branch: z.optional(z.string()),
		created_at: z.optional(z.string()),
		functions: z.optional(z.array(z.object({}))),
		id: z.optional(z.string()),
		log_type: z.optional(z.string()),
		provider: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const searchSiteFunctionsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const searchSiteFunctionsQueryResponseSchema = z.lazy(() => searchSiteFunctions200Schema);

export const listSiteFormsPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const listSiteForms200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		name: z.optional(z.string()),
		paths: z.optional(z.array(z.string())),
		submission_count: z.optional(z.int()),
		fields: z.optional(z.array(z.object({}))),
		created_at: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listSiteFormsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listSiteFormsQueryResponseSchema = z.lazy(() => listSiteForms200Schema);

export const deleteSiteFormPathParamsSchema = z.object({
	site_id: z.string(),
	form_id: z.string(),
});

/**
 * @description Deleted
 */
export const deleteSiteForm204Schema = z.unknown();

/**
 * @description error
 */
export const deleteSiteFormErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteSiteFormMutationResponseSchema = z.lazy(() => deleteSiteForm204Schema);

export const listSiteSubmissionsPathParamsSchema = z.object({
	site_id: z.string(),
});

export const listSiteSubmissionsQueryParamsSchema = z
	.object({
		page: z.optional(z.coerce.number().int()),
		per_page: z.optional(z.coerce.number().int()),
	})
	.optional();

/**
 * @description OK
 */
export const listSiteSubmissions200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		number: z.optional(z.int()),
		email: z.optional(z.string()),
		name: z.optional(z.string()),
		first_name: z.optional(z.string()),
		last_name: z.optional(z.string()),
		company: z.optional(z.string()),
		summary: z.optional(z.string()),
		body: z.optional(z.string()),
		data: z.optional(z.object({})),
		created_at: z.optional(z.string()),
		site_url: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listSiteSubmissionsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listSiteSubmissionsQueryResponseSchema = z.lazy(() => listSiteSubmissions200Schema);

export const listSiteFilesPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const listSiteFiles200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		path: z.optional(z.string()),
		sha: z.optional(z.string()),
		mime_type: z.optional(z.string()),
		size: z.optional(z.int()),
	}),
);

/**
 * @description error
 */
export const listSiteFilesErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listSiteFilesQueryResponseSchema = z.lazy(() => listSiteFiles200Schema);

export const listSiteAssetsPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const listSiteAssets200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		creator_id: z.optional(z.string()),
		name: z.optional(z.string()),
		state: z.optional(z.string()),
		content_type: z.optional(z.string()),
		url: z.optional(z.string()),
		key: z.optional(z.string()),
		visibility: z.optional(z.string()),
		size: z.optional(z.int()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listSiteAssetsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listSiteAssetsQueryResponseSchema = z.lazy(() => listSiteAssets200Schema);

export const createSiteAssetPathParamsSchema = z.object({
	site_id: z.string(),
});

export const createSiteAssetQueryParamsSchema = z.object({
	name: z.string(),
	size: z.coerce.number().int(),
	content_type: z.string(),
	visibility: z.optional(z.string()),
});

/**
 * @description Created
 */
export const createSiteAsset201Schema = z.object({
	form: z.optional(
		z.object({
			url: z.optional(z.string()),
			fields: z.optional(z.object({}).catchall(z.string())),
		}),
	),
	asset: z.optional(
		z.object({
			id: z.optional(z.string()),
			site_id: z.optional(z.string()),
			creator_id: z.optional(z.string()),
			name: z.optional(z.string()),
			state: z.optional(z.string()),
			content_type: z.optional(z.string()),
			url: z.optional(z.string()),
			key: z.optional(z.string()),
			visibility: z.optional(z.string()),
			size: z.optional(z.int()),
			created_at: z.optional(z.string()),
			updated_at: z.optional(z.string()),
		}),
	),
});

/**
 * @description error
 */
export const createSiteAssetErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createSiteAssetMutationResponseSchema = z.lazy(() => createSiteAsset201Schema);

export const getSiteAssetInfoPathParamsSchema = z.object({
	site_id: z.string(),
	asset_id: z.string(),
});

/**
 * @description OK
 */
export const getSiteAssetInfo200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	creator_id: z.optional(z.string()),
	name: z.optional(z.string()),
	state: z.optional(z.string()),
	content_type: z.optional(z.string()),
	url: z.optional(z.string()),
	key: z.optional(z.string()),
	visibility: z.optional(z.string()),
	size: z.optional(z.int()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const getSiteAssetInfoErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getSiteAssetInfoQueryResponseSchema = z.lazy(() => getSiteAssetInfo200Schema);

export const updateSiteAssetPathParamsSchema = z.object({
	site_id: z.string(),
	asset_id: z.string(),
});

export const updateSiteAssetQueryParamsSchema = z.object({
	state: z.string(),
});

/**
 * @description Updated
 */
export const updateSiteAsset200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	creator_id: z.optional(z.string()),
	name: z.optional(z.string()),
	state: z.optional(z.string()),
	content_type: z.optional(z.string()),
	url: z.optional(z.string()),
	key: z.optional(z.string()),
	visibility: z.optional(z.string()),
	size: z.optional(z.int()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const updateSiteAssetErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateSiteAssetMutationResponseSchema = z.lazy(() => updateSiteAsset200Schema);

export const deleteSiteAssetPathParamsSchema = z.object({
	site_id: z.string(),
	asset_id: z.string(),
});

/**
 * @description Deleted
 */
export const deleteSiteAsset204Schema = z.unknown();

/**
 * @description error
 */
export const deleteSiteAssetErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteSiteAssetMutationResponseSchema = z.lazy(() => deleteSiteAsset204Schema);

export const getSiteAssetPublicSignaturePathParamsSchema = z.object({
	site_id: z.string(),
	asset_id: z.string(),
});

/**
 * @description OK
 */
export const getSiteAssetPublicSignature200Schema = z.object({
	url: z.optional(z.string()),
});

/**
 * @description error
 */
export const getSiteAssetPublicSignatureErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getSiteAssetPublicSignatureQueryResponseSchema = z.lazy(
	() => getSiteAssetPublicSignature200Schema,
);

export const getSiteFileByPathNamePathParamsSchema = z.object({
	site_id: z.string(),
	file_path: z.string(),
});

/**
 * @description OK
 */
export const getSiteFileByPathName200Schema = z.object({
	id: z.optional(z.string()),
	path: z.optional(z.string()),
	sha: z.optional(z.string()),
	mime_type: z.optional(z.string()),
	size: z.optional(z.int()),
});

/**
 * @description error
 */
export const getSiteFileByPathNameErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getSiteFileByPathNameQueryResponseSchema = z.lazy(
	() => getSiteFileByPathName200Schema,
);

/**
 * @description OK
 */
export const purgeCache202Schema = z.unknown();

/**
 * @description Invalid request parameters
 */
export const purgeCache400Schema = z.unknown();

/**
 * @description Site not found
 */
export const purgeCache404Schema = z.unknown();

export const purgeCacheMutationRequestSchema = z.object({
	site_id: z.optional(z.string()),
	site_slug: z.optional(z.string()),
	cache_tags: z.optional(z.array(z.string())),
});

export const purgeCacheMutationResponseSchema = z.lazy(() => purgeCache202Schema);

export const listSiteSnippetsPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const listSiteSnippets200Schema = z.array(
	z.object({
		id: z.optional(z.int()),
		site_id: z.optional(z.string()),
		title: z.optional(z.string()),
		general: z.optional(z.string()),
		general_position: z.optional(z.string()),
		goal: z.optional(z.string()),
		goal_position: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listSiteSnippetsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listSiteSnippetsQueryResponseSchema = z.lazy(() => listSiteSnippets200Schema);

export const createSiteSnippetPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const createSiteSnippet201Schema = z.object({
	id: z.optional(z.int()),
	site_id: z.optional(z.string()),
	title: z.optional(z.string()),
	general: z.optional(z.string()),
	general_position: z.optional(z.string()),
	goal: z.optional(z.string()),
	goal_position: z.optional(z.string()),
});

/**
 * @description error
 */
export const createSiteSnippetErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createSiteSnippetMutationRequestSchema = z.object({
	id: z.optional(z.int()),
	site_id: z.optional(z.string()),
	title: z.optional(z.string()),
	general: z.optional(z.string()),
	general_position: z.optional(z.string()),
	goal: z.optional(z.string()),
	goal_position: z.optional(z.string()),
});

export const createSiteSnippetMutationResponseSchema = z.lazy(() => createSiteSnippet201Schema);

export const getSiteSnippetPathParamsSchema = z.object({
	site_id: z.string(),
	snippet_id: z.string(),
});

/**
 * @description OK
 */
export const getSiteSnippet200Schema = z.object({
	id: z.optional(z.int()),
	site_id: z.optional(z.string()),
	title: z.optional(z.string()),
	general: z.optional(z.string()),
	general_position: z.optional(z.string()),
	goal: z.optional(z.string()),
	goal_position: z.optional(z.string()),
});

/**
 * @description error
 */
export const getSiteSnippetErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getSiteSnippetQueryResponseSchema = z.lazy(() => getSiteSnippet200Schema);

export const updateSiteSnippetPathParamsSchema = z.object({
	site_id: z.string(),
	snippet_id: z.string(),
});

/**
 * @description No content
 */
export const updateSiteSnippet204Schema = z.unknown();

/**
 * @description error
 */
export const updateSiteSnippetErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateSiteSnippetMutationRequestSchema = z.object({
	id: z.optional(z.int()),
	site_id: z.optional(z.string()),
	title: z.optional(z.string()),
	general: z.optional(z.string()),
	general_position: z.optional(z.string()),
	goal: z.optional(z.string()),
	goal_position: z.optional(z.string()),
});

export const updateSiteSnippetMutationResponseSchema = z.lazy(() => updateSiteSnippet204Schema);

export const deleteSiteSnippetPathParamsSchema = z.object({
	site_id: z.string(),
	snippet_id: z.string(),
});

/**
 * @description No content
 */
export const deleteSiteSnippet204Schema = z.unknown();

/**
 * @description error
 */
export const deleteSiteSnippetErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteSiteSnippetMutationResponseSchema = z.lazy(() => deleteSiteSnippet204Schema);

export const getSiteMetadataPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const getSiteMetadata200Schema = z.object({});

/**
 * @description error
 */
export const getSiteMetadataErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getSiteMetadataQueryResponseSchema = z.lazy(() => getSiteMetadata200Schema);

export const updateSiteMetadataPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description No content
 */
export const updateSiteMetadata204Schema = z.unknown();

/**
 * @description error
 */
export const updateSiteMetadataErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateSiteMetadataMutationRequestSchema = z.object({});

export const updateSiteMetadataMutationResponseSchema = z.lazy(() => updateSiteMetadata204Schema);

export const listSiteBuildHooksPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const listSiteBuildHooks200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		title: z.optional(z.string()),
		branch: z.optional(z.string()),
		url: z.optional(z.string()),
		site_id: z.optional(z.string()),
		created_at: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listSiteBuildHooksErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listSiteBuildHooksQueryResponseSchema = z.lazy(() => listSiteBuildHooks200Schema);

export const createSiteBuildHookPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description Created
 */
export const createSiteBuildHook201Schema = z.object({
	id: z.optional(z.string()),
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	url: z.optional(z.string()),
	site_id: z.optional(z.string()),
	created_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const createSiteBuildHookErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createSiteBuildHookMutationRequestSchema = z.object({
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
});

export const createSiteBuildHookMutationResponseSchema = z.lazy(() => createSiteBuildHook201Schema);

export const getSiteBuildHookPathParamsSchema = z.object({
	site_id: z.string(),
	id: z.string(),
});

/**
 * @description OK
 */
export const getSiteBuildHook200Schema = z.object({
	id: z.optional(z.string()),
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	url: z.optional(z.string()),
	site_id: z.optional(z.string()),
	created_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const getSiteBuildHookErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getSiteBuildHookQueryResponseSchema = z.lazy(() => getSiteBuildHook200Schema);

export const updateSiteBuildHookPathParamsSchema = z.object({
	site_id: z.string(),
	id: z.string(),
});

/**
 * @description No content
 */
export const updateSiteBuildHook204Schema = z.unknown();

/**
 * @description error
 */
export const updateSiteBuildHookErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateSiteBuildHookMutationRequestSchema = z.object({
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
});

export const updateSiteBuildHookMutationResponseSchema = z.lazy(() => updateSiteBuildHook204Schema);

export const deleteSiteBuildHookPathParamsSchema = z.object({
	site_id: z.string(),
	id: z.string(),
});

/**
 * @description No content
 */
export const deleteSiteBuildHook204Schema = z.unknown();

/**
 * @description error
 */
export const deleteSiteBuildHookErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteSiteBuildHookMutationResponseSchema = z.lazy(() => deleteSiteBuildHook204Schema);

export const listSiteDeploysPathParamsSchema = z.object({
	site_id: z.string(),
});

export const listSiteDeploysQueryParamsSchema = z
	.object({
		page: z.optional(z.coerce.number().int()),
		per_page: z.optional(z.coerce.number().int()),
		"deploy-previews": z.optional(z.boolean()),
		production: z.optional(z.boolean()),
		state: z.optional(
			z.enum([
				"new",
				"pending_review",
				"accepted",
				"rejected",
				"enqueued",
				"building",
				"uploading",
				"uploaded",
				"preparing",
				"prepared",
				"processing",
				"processed",
				"ready",
				"error",
				"retrying",
			]),
		),
		branch: z.optional(z.string()),
		"latest-published": z.optional(z.boolean()),
	})
	.optional();

/**
 * @description OK
 */
export const listSiteDeploys200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		user_id: z.optional(z.string()),
		build_id: z.optional(z.string()),
		state: z.optional(z.string()),
		name: z.optional(z.string()),
		url: z.optional(z.string()),
		ssl_url: z.optional(z.string()),
		admin_url: z.optional(z.string()),
		deploy_url: z.optional(z.string()),
		deploy_ssl_url: z.optional(z.string()),
		screenshot_url: z.optional(z.string()),
		review_id: z.optional(z.number()),
		draft: z.optional(z.boolean()),
		required: z.optional(z.array(z.string())),
		required_functions: z.optional(z.array(z.string())),
		error_message: z.optional(z.string()),
		branch: z.optional(z.string()),
		commit_ref: z.optional(z.string()),
		commit_url: z.optional(z.string()),
		skipped: z.optional(z.boolean()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		published_at: z.optional(z.string()),
		title: z.optional(z.string()),
		context: z.optional(z.string()),
		locked: z.optional(z.boolean()),
		review_url: z.optional(z.string()),
		framework: z.optional(z.string()),
		skew_protection_token: z.optional(z.string()),
		function_schedules: z.optional(
			z.array(
				z.object({
					name: z.optional(z.string()),
					cron: z.optional(z.string()),
				}),
			),
		),
	}),
);

/**
 * @description error
 */
export const listSiteDeploysErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listSiteDeploysQueryResponseSchema = z.lazy(() => listSiteDeploys200Schema);

export const createSiteDeployPathParamsSchema = z.object({
	site_id: z.string(),
});

export const createSiteDeployQueryParamsSchema = z
	.object({
		title: z.optional(z.string()),
		"deploy-previews": z.optional(z.boolean()),
		production: z.optional(z.boolean()),
		state: z.optional(
			z.enum([
				"new",
				"pending_review",
				"accepted",
				"rejected",
				"enqueued",
				"building",
				"uploading",
				"uploaded",
				"preparing",
				"prepared",
				"processing",
				"processed",
				"ready",
				"error",
				"retrying",
			]),
		),
		branch: z.optional(z.string()),
		"latest-published": z.optional(z.boolean()),
	})
	.optional();

/**
 * @description OK
 */
export const createSiteDeploy200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	user_id: z.optional(z.string()),
	build_id: z.optional(z.string()),
	state: z.optional(z.string()),
	name: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	deploy_url: z.optional(z.string()),
	deploy_ssl_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	review_id: z.optional(z.number()),
	draft: z.optional(z.boolean()),
	required: z.optional(z.array(z.string())),
	required_functions: z.optional(z.array(z.string())),
	error_message: z.optional(z.string()),
	branch: z.optional(z.string()),
	commit_ref: z.optional(z.string()),
	commit_url: z.optional(z.string()),
	skipped: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	published_at: z.optional(z.string()),
	title: z.optional(z.string()),
	context: z.optional(z.string()),
	locked: z.optional(z.boolean()),
	review_url: z.optional(z.string()),
	framework: z.optional(z.string()),
	skew_protection_token: z.optional(z.string()),
	function_schedules: z.optional(
		z.array(
			z.object({
				name: z.optional(z.string()),
				cron: z.optional(z.string()),
			}),
		),
	),
});

/**
 * @description error
 */
export const createSiteDeployErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createSiteDeployMutationRequestSchema = z
	.object({
		files: z.optional(
			z.object({}).describe("A hash mapping file paths to SHA1 digests of the file contents."),
		),
		zip: z.optional(
			z
				.instanceof(File)
				.describe(
					"A zip file containing the site files to deploy. Alternative to 'files'.\nTo use this field, set Content-Type to 'application/json' and include the zip content here.\nAlternatively, you can set Content-Type to 'application/zip' and send the zip as the raw request body (not as JSON).\n",
				),
		),
		draft: z.optional(z.boolean()),
		async: z.optional(z.boolean()),
		functions: z.optional(z.object({})),
		function_schedules: z.optional(
			z.array(
				z.object({
					name: z.optional(z.string()),
					cron: z.optional(z.string()),
				}),
			),
		),
		functions_config: z.optional(
			z.object({}).catchall(
				z.object({
					display_name: z.optional(z.string()),
					generator: z.optional(z.string()),
					build_data: z.optional(z.object({})),
					routes: z.optional(
						z.array(
							z.object({
								pattern: z.optional(z.string()),
								literal: z.optional(z.string()),
								expression: z.optional(z.string()),
								methods: z.optional(
									z.array(z.enum(["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"])),
								),
								prefer_static: z.optional(z.boolean()),
							}),
						),
					),
					excluded_routes: z.optional(
						z.array(
							z.object({
								pattern: z.optional(z.string()),
								literal: z.optional(z.string()),
								expression: z.optional(z.string()),
							}),
						),
					),
					priority: z.optional(z.int()),
					traffic_rules: z.optional(
						z.object({
							action: z.optional(
								z.object({
									type: z.optional(z.string()),
									config: z.optional(
										z.object({
											to: z.optional(z.string()),
											rate_limit_config: z.optional(
												z.object({
													algorithm: z.optional(z.enum(["sliding_window"])),
													window_size: z.optional(z.int()),
													window_limit: z.optional(z.int()),
												}),
											),
											aggregate: z.optional(
												z.object({
													keys: z.optional(
														z.array(
															z.object({
																type: z.optional(z.enum(["ip", "domain"])),
															}),
														),
													),
												}),
											),
										}),
									),
								}),
							),
						}),
					),
				}),
			),
		),
		branch: z.optional(z.string()),
		framework: z.optional(z.string()),
		framework_version: z.optional(z.string()),
	})
	.describe(
		"Deploy files can be provided in two ways:\n1. As a JSON object using 'files' (a hash mapping file paths to SHA1 digests), OR\n2. As a zip file using one of these methods:\n   - Set Content-Type to 'application/zip' and send the zip file as the raw request body\n   - Include the zip file content in the 'zip' field of this JSON object with Content-Type 'application/json'\n",
	);

export const createSiteDeployMutationResponseSchema = z.lazy(() => createSiteDeploy200Schema);

export const getSiteDeployPathParamsSchema = z.object({
	site_id: z.string(),
	deploy_id: z.string(),
});

/**
 * @description OK
 */
export const getSiteDeploy200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	user_id: z.optional(z.string()),
	build_id: z.optional(z.string()),
	state: z.optional(z.string()),
	name: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	deploy_url: z.optional(z.string()),
	deploy_ssl_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	review_id: z.optional(z.number()),
	draft: z.optional(z.boolean()),
	required: z.optional(z.array(z.string())),
	required_functions: z.optional(z.array(z.string())),
	error_message: z.optional(z.string()),
	branch: z.optional(z.string()),
	commit_ref: z.optional(z.string()),
	commit_url: z.optional(z.string()),
	skipped: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	published_at: z.optional(z.string()),
	title: z.optional(z.string()),
	context: z.optional(z.string()),
	locked: z.optional(z.boolean()),
	review_url: z.optional(z.string()),
	framework: z.optional(z.string()),
	skew_protection_token: z.optional(z.string()),
	function_schedules: z.optional(
		z.array(
			z.object({
				name: z.optional(z.string()),
				cron: z.optional(z.string()),
			}),
		),
	),
});

/**
 * @description error
 */
export const getSiteDeployErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getSiteDeployQueryResponseSchema = z.lazy(() => getSiteDeploy200Schema);

export const updateSiteDeployPathParamsSchema = z.object({
	site_id: z.string(),
	deploy_id: z.string(),
});

export const updateSiteDeployQueryParamsSchema = z
	.object({
		commit_ref: z.optional(z.string()),
	})
	.optional();

/**
 * @description OK
 */
export const updateSiteDeploy200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	user_id: z.optional(z.string()),
	build_id: z.optional(z.string()),
	state: z.optional(z.string()),
	name: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	deploy_url: z.optional(z.string()),
	deploy_ssl_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	review_id: z.optional(z.number()),
	draft: z.optional(z.boolean()),
	required: z.optional(z.array(z.string())),
	required_functions: z.optional(z.array(z.string())),
	error_message: z.optional(z.string()),
	branch: z.optional(z.string()),
	commit_ref: z.optional(z.string()),
	commit_url: z.optional(z.string()),
	skipped: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	published_at: z.optional(z.string()),
	title: z.optional(z.string()),
	context: z.optional(z.string()),
	locked: z.optional(z.boolean()),
	review_url: z.optional(z.string()),
	framework: z.optional(z.string()),
	skew_protection_token: z.optional(z.string()),
	function_schedules: z.optional(
		z.array(
			z.object({
				name: z.optional(z.string()),
				cron: z.optional(z.string()),
			}),
		),
	),
});

/**
 * @description error
 */
export const updateSiteDeployErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateSiteDeployMutationRequestSchema = z
	.object({
		files: z.optional(
			z.object({}).describe("A hash mapping file paths to SHA1 digests of the file contents."),
		),
		zip: z.optional(
			z
				.instanceof(File)
				.describe(
					"A zip file containing the site files to deploy. Alternative to 'files'.\nTo use this field, set Content-Type to 'application/json' and include the zip content here.\nAlternatively, you can set Content-Type to 'application/zip' and send the zip as the raw request body (not as JSON).\n",
				),
		),
		draft: z.optional(z.boolean()),
		async: z.optional(z.boolean()),
		functions: z.optional(z.object({})),
		function_schedules: z.optional(
			z.array(
				z.object({
					name: z.optional(z.string()),
					cron: z.optional(z.string()),
				}),
			),
		),
		functions_config: z.optional(
			z.object({}).catchall(
				z.object({
					display_name: z.optional(z.string()),
					generator: z.optional(z.string()),
					build_data: z.optional(z.object({})),
					routes: z.optional(
						z.array(
							z.object({
								pattern: z.optional(z.string()),
								literal: z.optional(z.string()),
								expression: z.optional(z.string()),
								methods: z.optional(
									z.array(z.enum(["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"])),
								),
								prefer_static: z.optional(z.boolean()),
							}),
						),
					),
					excluded_routes: z.optional(
						z.array(
							z.object({
								pattern: z.optional(z.string()),
								literal: z.optional(z.string()),
								expression: z.optional(z.string()),
							}),
						),
					),
					priority: z.optional(z.int()),
					traffic_rules: z.optional(
						z.object({
							action: z.optional(
								z.object({
									type: z.optional(z.string()),
									config: z.optional(
										z.object({
											to: z.optional(z.string()),
											rate_limit_config: z.optional(
												z.object({
													algorithm: z.optional(z.enum(["sliding_window"])),
													window_size: z.optional(z.int()),
													window_limit: z.optional(z.int()),
												}),
											),
											aggregate: z.optional(
												z.object({
													keys: z.optional(
														z.array(
															z.object({
																type: z.optional(z.enum(["ip", "domain"])),
															}),
														),
													),
												}),
											),
										}),
									),
								}),
							),
						}),
					),
				}),
			),
		),
		branch: z.optional(z.string()),
		framework: z.optional(z.string()),
		framework_version: z.optional(z.string()),
	})
	.describe(
		"Deploy files can be provided in two ways:\n1. As a JSON object using 'files' (a hash mapping file paths to SHA1 digests), OR\n2. As a zip file using one of these methods:\n   - Set Content-Type to 'application/zip' and send the zip file as the raw request body\n   - Include the zip file content in the 'zip' field of this JSON object with Content-Type 'application/json'\n",
	);

export const updateSiteDeployMutationResponseSchema = z.lazy(() => updateSiteDeploy200Schema);

export const deleteSiteDeployPathParamsSchema = z.object({
	deploy_id: z.string(),
	site_id: z.string(),
});

/**
 * @description No content
 */
export const deleteSiteDeploy204Schema = z.unknown();

/**
 * @description error
 */
export const deleteSiteDeployErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteSiteDeployMutationResponseSchema = z.lazy(() => deleteSiteDeploy204Schema);

export const cancelSiteDeployPathParamsSchema = z.object({
	deploy_id: z.string(),
});

/**
 * @description Cancelled
 */
export const cancelSiteDeploy201Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	user_id: z.optional(z.string()),
	build_id: z.optional(z.string()),
	state: z.optional(z.string()),
	name: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	deploy_url: z.optional(z.string()),
	deploy_ssl_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	review_id: z.optional(z.number()),
	draft: z.optional(z.boolean()),
	required: z.optional(z.array(z.string())),
	required_functions: z.optional(z.array(z.string())),
	error_message: z.optional(z.string()),
	branch: z.optional(z.string()),
	commit_ref: z.optional(z.string()),
	commit_url: z.optional(z.string()),
	skipped: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	published_at: z.optional(z.string()),
	title: z.optional(z.string()),
	context: z.optional(z.string()),
	locked: z.optional(z.boolean()),
	review_url: z.optional(z.string()),
	framework: z.optional(z.string()),
	skew_protection_token: z.optional(z.string()),
	function_schedules: z.optional(
		z.array(
			z.object({
				name: z.optional(z.string()),
				cron: z.optional(z.string()),
			}),
		),
	),
});

/**
 * @description error
 */
export const cancelSiteDeployErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const cancelSiteDeployMutationResponseSchema = z.lazy(() => cancelSiteDeploy201Schema);

export const restoreSiteDeployPathParamsSchema = z.object({
	site_id: z.string(),
	deploy_id: z.string(),
});

/**
 * @description Created
 */
export const restoreSiteDeploy201Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	user_id: z.optional(z.string()),
	build_id: z.optional(z.string()),
	state: z.optional(z.string()),
	name: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	deploy_url: z.optional(z.string()),
	deploy_ssl_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	review_id: z.optional(z.number()),
	draft: z.optional(z.boolean()),
	required: z.optional(z.array(z.string())),
	required_functions: z.optional(z.array(z.string())),
	error_message: z.optional(z.string()),
	branch: z.optional(z.string()),
	commit_ref: z.optional(z.string()),
	commit_url: z.optional(z.string()),
	skipped: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	published_at: z.optional(z.string()),
	title: z.optional(z.string()),
	context: z.optional(z.string()),
	locked: z.optional(z.boolean()),
	review_url: z.optional(z.string()),
	framework: z.optional(z.string()),
	skew_protection_token: z.optional(z.string()),
	function_schedules: z.optional(
		z.array(
			z.object({
				name: z.optional(z.string()),
				cron: z.optional(z.string()),
			}),
		),
	),
});

/**
 * @description error
 */
export const restoreSiteDeployErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const restoreSiteDeployMutationResponseSchema = z.lazy(() => restoreSiteDeploy201Schema);

export const listSiteBuildsPathParamsSchema = z.object({
	site_id: z.string(),
});

export const listSiteBuildsQueryParamsSchema = z
	.object({
		page: z.optional(z.coerce.number().int()),
		per_page: z.optional(z.coerce.number().int()),
	})
	.optional();

/**
 * @description OK
 */
export const listSiteBuilds200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		deploy_id: z.optional(z.string()),
		sha: z.optional(z.string()),
		done: z.optional(z.boolean()),
		error: z.optional(z.string()),
		created_at: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listSiteBuildsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listSiteBuildsQueryResponseSchema = z.lazy(() => listSiteBuilds200Schema);

export const createSiteBuildPathParamsSchema = z.object({
	site_id: z.string(),
});

export const createSiteBuildQueryParamsSchema = z
	.object({
		branch: z.optional(
			z
				.string()
				.describe(
					"If no branch is specified, it is treated as a production deploy If a branch IS specified and matches the main branch, it is also production If a branch is specified and doesn't match the main branch, it is a branch deploy",
				),
		),
		clear_cache: z.optional(
			z.boolean().describe("Whether to clear the build cache before building"),
		),
		image: z.optional(z.string().describe("The build image tag to use for the build")),
		template_id: z.optional(z.string().describe("The build template to use for the build")),
		title: z.optional(z.string().describe("The title of the build")),
	})
	.optional();

/**
 * @description OK
 */
export const createSiteBuild200Schema = z.object({
	id: z.optional(z.string()),
	deploy_id: z.optional(z.string()),
	sha: z.optional(z.string()),
	done: z.optional(z.boolean()),
	error: z.optional(z.string()),
	created_at: z.optional(z.string()),
});

/**
 * @description Bad Request
 */
export const createSiteBuild400Schema = z.unknown();

/**
 * @description Not Found
 */
export const createSiteBuild404Schema = z.unknown();

/**
 * @description Unprocessable Entity
 */
export const createSiteBuild422Schema = z.unknown();

/**
 * @description error
 */
export const createSiteBuildErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createSiteBuildMutationResponseSchema = z.lazy(() => createSiteBuild200Schema);

export const listSiteDeployedBranchesPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const listSiteDeployedBranches200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		deploy_id: z.optional(z.string()),
		name: z.optional(z.string()),
		slug: z.optional(z.string()),
		url: z.optional(z.string()),
		ssl_url: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listSiteDeployedBranchesErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listSiteDeployedBranchesQueryResponseSchema = z.lazy(
	() => listSiteDeployedBranches200Schema,
);

export const unlinkSiteRepoPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const unlinkSiteRepo200Schema = z.object({
	id: z.optional(z.string()),
	state: z.optional(z.string()),
	plan: z.optional(z.string()),
	name: z.optional(z.string()),
	custom_domain: z.optional(z.string()),
	domain_aliases: z.optional(z.array(z.string())),
	branch_deploy_custom_domain: z.optional(z.string()),
	deploy_preview_custom_domain: z.optional(z.string()),
	password: z.optional(z.string()),
	notification_email: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	user_id: z.optional(z.string()),
	session_id: z.optional(z.string()),
	ssl: z.optional(z.boolean()),
	force_ssl: z.optional(z.boolean()),
	managed_dns: z.optional(z.boolean()),
	deploy_url: z.optional(z.string()),
	published_deploy: z.optional(
		z.object({
			id: z.optional(z.string()),
			site_id: z.optional(z.string()),
			user_id: z.optional(z.string()),
			build_id: z.optional(z.string()),
			state: z.optional(z.string()),
			name: z.optional(z.string()),
			url: z.optional(z.string()),
			ssl_url: z.optional(z.string()),
			admin_url: z.optional(z.string()),
			deploy_url: z.optional(z.string()),
			deploy_ssl_url: z.optional(z.string()),
			screenshot_url: z.optional(z.string()),
			review_id: z.optional(z.number()),
			draft: z.optional(z.boolean()),
			required: z.optional(z.array(z.string())),
			required_functions: z.optional(z.array(z.string())),
			error_message: z.optional(z.string()),
			branch: z.optional(z.string()),
			commit_ref: z.optional(z.string()),
			commit_url: z.optional(z.string()),
			skipped: z.optional(z.boolean()),
			created_at: z.optional(z.string()),
			updated_at: z.optional(z.string()),
			published_at: z.optional(z.string()),
			title: z.optional(z.string()),
			context: z.optional(z.string()),
			locked: z.optional(z.boolean()),
			review_url: z.optional(z.string()),
			framework: z.optional(z.string()),
			skew_protection_token: z.optional(z.string()),
			function_schedules: z.optional(
				z.array(
					z.object({
						name: z.optional(z.string()),
						cron: z.optional(z.string()),
					}),
				),
			),
		}),
	),
	account_id: z.optional(z.string()),
	account_name: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	git_provider: z.optional(z.string()),
	deploy_hook: z.optional(z.string()),
	capabilities: z.optional(z.object({}).catchall(z.object({}))),
	processing_settings: z.optional(
		z.object({
			html: z.optional(
				z.object({
					pretty_urls: z.optional(z.boolean()),
				}),
			),
		}),
	),
	build_settings: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
	id_domain: z.optional(z.string()),
	default_hooks_data: z.optional(
		z.object({
			access_token: z.optional(z.string()),
		}),
	),
	build_image: z.optional(z.string()),
	prerender: z.optional(z.string()),
	functions_region: z.optional(z.string()),
	prevent_non_git_prod_deploys: z.optional(z.boolean().default(false)),
});

/**
 * @description Site not found
 */
export const unlinkSiteRepo404Schema = z.unknown();

export const unlinkSiteRepoMutationResponseSchema = z.lazy(() => unlinkSiteRepo200Schema);

export const enableSitePathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description No content
 */
export const enableSite204Schema = z.unknown();

/**
 * @description Cannot enable this site
 */
export const enableSite422Schema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

/**
 * @description error
 */
export const enableSiteErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const enableSiteMutationResponseSchema = z.lazy(() => enableSite204Schema);

export const disableSitePathParamsSchema = z.object({
	site_id: z.string(),
});

export const disableSiteQueryParamsSchema = z.object({
	reason: z.string().describe("Reason for disabling the site"),
});

/**
 * @description No content
 */
export const disableSite204Schema = z.unknown();

/**
 * @description error
 */
export const disableSiteErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const disableSiteMutationResponseSchema = z.lazy(() => disableSite204Schema);

export const getSiteBuildPathParamsSchema = z.object({
	build_id: z.string(),
});

/**
 * @description OK
 */
export const getSiteBuild200Schema = z.object({
	id: z.optional(z.string()),
	deploy_id: z.optional(z.string()),
	sha: z.optional(z.string()),
	done: z.optional(z.boolean()),
	error: z.optional(z.string()),
	created_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const getSiteBuildErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getSiteBuildQueryResponseSchema = z.lazy(() => getSiteBuild200Schema);

export const updateSiteBuildLogPathParamsSchema = z.object({
	build_id: z.string(),
});

/**
 * @description No content
 */
export const updateSiteBuildLog204Schema = z.unknown();

/**
 * @description error
 */
export const updateSiteBuildLogErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateSiteBuildLogMutationResponseSchema = z.lazy(() => updateSiteBuildLog204Schema);

export const notifyBuildStartPathParamsSchema = z.object({
	build_id: z.string(),
});

export const notifyBuildStartQueryParamsSchema = z
	.object({
		buildbot_version: z.optional(z.string()),
		build_version: z.optional(z.string()),
		task_id: z.optional(z.string()),
	})
	.optional();

/**
 * @description No content
 */
export const notifyBuildStart204Schema = z.unknown();

/**
 * @description error
 */
export const notifyBuildStartErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const notifyBuildStartMutationResponseSchema = z.lazy(() => notifyBuildStart204Schema);

export const getAccountBuildStatusPathParamsSchema = z.object({
	account_id: z.string(),
});

/**
 * @description OK
 */
export const getAccountBuildStatus200Schema = z.array(
	z.object({
		active: z.optional(z.int()),
		pending_concurrency: z.optional(z.int()),
		enqueued: z.optional(z.int()),
		build_count: z.optional(z.int()),
		minutes: z.optional(
			z.object({
				current: z.optional(z.int()),
				current_average_sec: z.optional(z.int()),
				previous: z.optional(z.int()),
				period_start_date: z.optional(z.string()),
				period_end_date: z.optional(z.string()),
				last_updated_at: z.optional(z.string()),
				included_minutes: z.optional(z.string()),
				included_minutes_with_packs: z.optional(z.string()),
			}),
		),
	}),
);

/**
 * @description error
 */
export const getAccountBuildStatusErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getAccountBuildStatusQueryResponseSchema = z.lazy(
	() => getAccountBuildStatus200Schema,
);

export const getDNSForSitePathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const getDNSForSite200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		name: z.optional(z.string()),
		errors: z.optional(z.array(z.string())),
		supported_record_types: z.optional(z.array(z.string())),
		user_id: z.optional(z.string()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		records: z.optional(
			z.array(
				z.object({
					id: z.optional(z.string()),
					hostname: z.optional(z.string()),
					type: z.optional(z.string()),
					value: z.optional(z.string()),
					ttl: z.optional(z.int()),
					priority: z.optional(z.int()),
					dns_zone_id: z.optional(z.string()),
					site_id: z.optional(z.string()),
					flag: z.optional(z.int()),
					tag: z.optional(z.string()),
					managed: z.optional(z.boolean()),
				}),
			),
		),
		dns_servers: z.optional(z.array(z.string())),
		account_id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		account_slug: z.optional(z.string()),
		account_name: z.optional(z.string()),
		domain: z.optional(z.string()),
		ipv6_enabled: z.optional(z.boolean()),
		dedicated: z.optional(z.boolean()),
	}),
);

/**
 * @description error
 */
export const getDNSForSiteErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getDNSForSiteQueryResponseSchema = z.lazy(() => getDNSForSite200Schema);

export const configureDNSForSitePathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const configureDNSForSite200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		name: z.optional(z.string()),
		errors: z.optional(z.array(z.string())),
		supported_record_types: z.optional(z.array(z.string())),
		user_id: z.optional(z.string()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		records: z.optional(
			z.array(
				z.object({
					id: z.optional(z.string()),
					hostname: z.optional(z.string()),
					type: z.optional(z.string()),
					value: z.optional(z.string()),
					ttl: z.optional(z.int()),
					priority: z.optional(z.int()),
					dns_zone_id: z.optional(z.string()),
					site_id: z.optional(z.string()),
					flag: z.optional(z.int()),
					tag: z.optional(z.string()),
					managed: z.optional(z.boolean()),
				}),
			),
		),
		dns_servers: z.optional(z.array(z.string())),
		account_id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		account_slug: z.optional(z.string()),
		account_name: z.optional(z.string()),
		domain: z.optional(z.string()),
		ipv6_enabled: z.optional(z.boolean()),
		dedicated: z.optional(z.boolean()),
	}),
);

/**
 * @description error
 */
export const configureDNSForSiteErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const configureDNSForSiteMutationResponseSchema = z.lazy(() => configureDNSForSite200Schema);

export const rollbackSiteDeployPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description No content
 */
export const rollbackSiteDeploy204Schema = z.unknown();

/**
 * @description error
 */
export const rollbackSiteDeployErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const rollbackSiteDeployMutationResponseSchema = z.lazy(() => rollbackSiteDeploy204Schema);

export const getDeployPathParamsSchema = z.object({
	deploy_id: z.string(),
});

/**
 * @description OK
 */
export const getDeploy200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	user_id: z.optional(z.string()),
	build_id: z.optional(z.string()),
	state: z.optional(z.string()),
	name: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	deploy_url: z.optional(z.string()),
	deploy_ssl_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	review_id: z.optional(z.number()),
	draft: z.optional(z.boolean()),
	required: z.optional(z.array(z.string())),
	required_functions: z.optional(z.array(z.string())),
	error_message: z.optional(z.string()),
	branch: z.optional(z.string()),
	commit_ref: z.optional(z.string()),
	commit_url: z.optional(z.string()),
	skipped: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	published_at: z.optional(z.string()),
	title: z.optional(z.string()),
	context: z.optional(z.string()),
	locked: z.optional(z.boolean()),
	review_url: z.optional(z.string()),
	framework: z.optional(z.string()),
	skew_protection_token: z.optional(z.string()),
	function_schedules: z.optional(
		z.array(
			z.object({
				name: z.optional(z.string()),
				cron: z.optional(z.string()),
			}),
		),
	),
});

/**
 * @description error
 */
export const getDeployErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getDeployQueryResponseSchema = z.lazy(() => getDeploy200Schema);

export const deleteDeployPathParamsSchema = z.object({
	deploy_id: z.string(),
});

/**
 * @description No content
 */
export const deleteDeploy204Schema = z.unknown();

/**
 * @description error
 */
export const deleteDeployErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteDeployMutationResponseSchema = z.lazy(() => deleteDeploy204Schema);

export const updateDeployValidationsPathParamsSchema = z.object({
	deploy_id: z.string().describe("The ID of the deploy"),
});

/**
 * @description OK
 */
export const updateDeployValidations200Schema = z.object({
	id: z.optional(z.string().describe("The id of the deploy validations report")),
	deploy_id: z.optional(z.string().describe("The id of the deploy")),
	secret_scan_result: z.optional(
		z.object({
			scannedFilesCount: z.optional(z.int().describe("The number of files scanned")),
			secretsScanMatches: z.optional(
				z.array(z.string()).describe("The list of secrets scan matches"),
			),
		}),
	),
});

export const updateDeployValidationsMutationRequestSchema = z.object({
	secrets_scan: z.optional(z.object({})),
});

export const updateDeployValidationsMutationResponseSchema = z.lazy(
	() => updateDeployValidations200Schema,
);

export const lockDeployPathParamsSchema = z.object({
	deploy_id: z.string(),
});

/**
 * @description OK
 */
export const lockDeploy200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	user_id: z.optional(z.string()),
	build_id: z.optional(z.string()),
	state: z.optional(z.string()),
	name: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	deploy_url: z.optional(z.string()),
	deploy_ssl_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	review_id: z.optional(z.number()),
	draft: z.optional(z.boolean()),
	required: z.optional(z.array(z.string())),
	required_functions: z.optional(z.array(z.string())),
	error_message: z.optional(z.string()),
	branch: z.optional(z.string()),
	commit_ref: z.optional(z.string()),
	commit_url: z.optional(z.string()),
	skipped: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	published_at: z.optional(z.string()),
	title: z.optional(z.string()),
	context: z.optional(z.string()),
	locked: z.optional(z.boolean()),
	review_url: z.optional(z.string()),
	framework: z.optional(z.string()),
	skew_protection_token: z.optional(z.string()),
	function_schedules: z.optional(
		z.array(
			z.object({
				name: z.optional(z.string()),
				cron: z.optional(z.string()),
			}),
		),
	),
});

/**
 * @description error
 */
export const lockDeployErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const lockDeployMutationResponseSchema = z.lazy(() => lockDeploy200Schema);

export const unlockDeployPathParamsSchema = z.object({
	deploy_id: z.string(),
});

/**
 * @description OK
 */
export const unlockDeploy200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	user_id: z.optional(z.string()),
	build_id: z.optional(z.string()),
	state: z.optional(z.string()),
	name: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	deploy_url: z.optional(z.string()),
	deploy_ssl_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	review_id: z.optional(z.number()),
	draft: z.optional(z.boolean()),
	required: z.optional(z.array(z.string())),
	required_functions: z.optional(z.array(z.string())),
	error_message: z.optional(z.string()),
	branch: z.optional(z.string()),
	commit_ref: z.optional(z.string()),
	commit_url: z.optional(z.string()),
	skipped: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	published_at: z.optional(z.string()),
	title: z.optional(z.string()),
	context: z.optional(z.string()),
	locked: z.optional(z.boolean()),
	review_url: z.optional(z.string()),
	framework: z.optional(z.string()),
	skew_protection_token: z.optional(z.string()),
	function_schedules: z.optional(
		z.array(
			z.object({
				name: z.optional(z.string()),
				cron: z.optional(z.string()),
			}),
		),
	),
});

/**
 * @description error
 */
export const unlockDeployErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const unlockDeployMutationResponseSchema = z.lazy(() => unlockDeploy200Schema);

export const uploadDeployFilePathParamsSchema = z.object({
	deploy_id: z.string(),
	path: z.string(),
});

export const uploadDeployFileQueryParamsSchema = z
	.object({
		size: z.optional(z.coerce.number().int()),
	})
	.optional();

/**
 * @description OK
 */
export const uploadDeployFile200Schema = z.object({
	id: z.optional(z.string()),
	path: z.optional(z.string()),
	sha: z.optional(z.string()),
	mime_type: z.optional(z.string()),
	size: z.optional(z.int()),
});

/**
 * @description error
 */
export const uploadDeployFileErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const uploadDeployFileMutationResponseSchema = z.lazy(() => uploadDeployFile200Schema);

export const uploadDeployFunctionPathParamsSchema = z.object({
	deploy_id: z.string(),
	name: z.string(),
});

export const uploadDeployFunctionQueryParamsSchema = z
	.object({
		runtime: z.optional(z.string()),
		invocation_mode: z.optional(z.string()),
		timeout: z.optional(z.coerce.number().int()),
		size: z.optional(z.coerce.number().int()),
	})
	.optional();

export const uploadDeployFunctionHeaderParamsSchema = z
	.object({
		"X-Nf-Retry-Count": z.optional(z.coerce.number().int()),
	})
	.optional();

/**
 * @description OK
 */
export const uploadDeployFunction200Schema = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	sha: z.optional(z.string()),
});

/**
 * @description error
 */
export const uploadDeployFunctionErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const uploadDeployFunctionMutationResponseSchema = z.lazy(
	() => uploadDeployFunction200Schema,
);

export const updatePluginPathParamsSchema = z.object({
	site_id: z.string(),
	package: z.string(),
});

/**
 * @description OK
 */
export const updatePlugin200Schema = z.object({
	package: z.optional(z.string()),
	pinned_version: z.optional(z.string()),
});

/**
 * @description error
 */
export const updatePluginErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updatePluginMutationRequestSchema = z.object({
	pinned_version: z.optional(z.string()),
});

export const updatePluginMutationResponseSchema = z.lazy(() => updatePlugin200Schema);

export const getLatestPluginRunsPathParamsSchema = z.object({
	site_id: z.string(),
});

export const getLatestPluginRunsQueryParamsSchema = z.object({
	packages: z.array(z.string()),
	state: z.optional(z.string()),
});

/**
 * @description OK
 */
export const getLatestPluginRuns200Schema = z.array(
	z.object({
		package: z.optional(z.string()),
		version: z.optional(z.string()),
		state: z.optional(z.string()),
		reporting_event: z.optional(z.string()),
		title: z.optional(z.string()),
		summary: z.optional(z.string()),
		text: z.optional(z.string()),
		deploy_id: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const getLatestPluginRunsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getLatestPluginRunsQueryResponseSchema = z.lazy(() => getLatestPluginRuns200Schema);

export const createPluginRunPathParamsSchema = z.object({
	deploy_id: z.string(),
});

/**
 * @description CREATED
 */
export const createPluginRun201Schema = z.object({
	package: z.optional(z.string()),
	version: z.optional(z.string()),
	state: z.optional(z.string()),
	reporting_event: z.optional(z.string()),
	title: z.optional(z.string()),
	summary: z.optional(z.string()),
	text: z.optional(z.string()),
	deploy_id: z.optional(z.string()),
});

/**
 * @description error
 */
export const createPluginRunErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createPluginRunMutationRequestSchema = z.object({
	package: z.optional(z.string()),
	version: z.optional(z.string()),
	state: z.optional(z.string()),
	reporting_event: z.optional(z.string()),
	title: z.optional(z.string()),
	summary: z.optional(z.string()),
	text: z.optional(z.string()),
});

export const createPluginRunMutationResponseSchema = z.lazy(() => createPluginRun201Schema);

export const listFormSubmissionsPathParamsSchema = z.object({
	form_id: z.string(),
});

export const listFormSubmissionsQueryParamsSchema = z
	.object({
		page: z.optional(z.coerce.number().int()),
		per_page: z.optional(z.coerce.number().int()),
	})
	.optional();

/**
 * @description OK
 */
export const listFormSubmissions200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		number: z.optional(z.int()),
		email: z.optional(z.string()),
		name: z.optional(z.string()),
		first_name: z.optional(z.string()),
		last_name: z.optional(z.string()),
		company: z.optional(z.string()),
		summary: z.optional(z.string()),
		body: z.optional(z.string()),
		data: z.optional(z.object({})),
		created_at: z.optional(z.string()),
		site_url: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listFormSubmissionsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listFormSubmissionsQueryResponseSchema = z.lazy(() => listFormSubmissions200Schema);

export const listHooksBySiteIdQueryParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const listHooksBySiteId200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		type: z.optional(z.string()),
		event: z.optional(z.string()),
		data: z.optional(z.object({})),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		disabled: z.optional(z.boolean()),
	}),
);

/**
 * @description error
 */
export const listHooksBySiteIdErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listHooksBySiteIdQueryResponseSchema = z.lazy(() => listHooksBySiteId200Schema);

export const createHookBySiteIdQueryParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const createHookBySiteId201Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	type: z.optional(z.string()),
	event: z.optional(z.string()),
	data: z.optional(z.object({})),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	disabled: z.optional(z.boolean()),
});

/**
 * @description error
 */
export const createHookBySiteIdErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createHookBySiteIdMutationRequestSchema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	type: z.optional(z.string()),
	event: z.optional(z.string()),
	data: z.optional(z.object({})),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	disabled: z.optional(z.boolean()),
});

export const createHookBySiteIdMutationResponseSchema = z.lazy(() => createHookBySiteId201Schema);

export const getHookPathParamsSchema = z.object({
	hook_id: z.string(),
});

/**
 * @description OK
 */
export const getHook200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	type: z.optional(z.string()),
	event: z.optional(z.string()),
	data: z.optional(z.object({})),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	disabled: z.optional(z.boolean()),
});

/**
 * @description error
 */
export const getHookErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getHookQueryResponseSchema = z.lazy(() => getHook200Schema);

export const updateHookPathParamsSchema = z.object({
	hook_id: z.string(),
});

/**
 * @description OK
 */
export const updateHook200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	type: z.optional(z.string()),
	event: z.optional(z.string()),
	data: z.optional(z.object({})),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	disabled: z.optional(z.boolean()),
});

/**
 * @description error
 */
export const updateHookErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateHookMutationRequestSchema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	type: z.optional(z.string()),
	event: z.optional(z.string()),
	data: z.optional(z.object({})),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	disabled: z.optional(z.boolean()),
});

export const updateHookMutationResponseSchema = z.lazy(() => updateHook200Schema);

export const deleteHookPathParamsSchema = z.object({
	hook_id: z.string(),
});

/**
 * @description No content
 */
export const deleteHook204Schema = z.unknown();

export const deleteHookMutationResponseSchema = z.lazy(() => deleteHook204Schema);

export const enableHookPathParamsSchema = z.object({
	hook_id: z.string(),
});

/**
 * @description OK
 */
export const enableHook200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	type: z.optional(z.string()),
	event: z.optional(z.string()),
	data: z.optional(z.object({})),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	disabled: z.optional(z.boolean()),
});

/**
 * @description error
 */
export const enableHookErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const enableHookMutationResponseSchema = z.lazy(() => enableHook200Schema);

/**
 * @description OK
 */
export const listHookTypes200Schema = z.array(
	z.object({
		name: z.optional(z.string()),
		events: z.optional(z.array(z.string())),
		fields: z.optional(z.array(z.object({}))),
	}),
);

/**
 * @description error
 */
export const listHookTypesErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listHookTypesQueryResponseSchema = z.lazy(() => listHookTypes200Schema);

export const createTicketQueryParamsSchema = z.object({
	client_id: z.string(),
});

/**
 * @description ok
 */
export const createTicket201Schema = z.object({
	id: z.optional(z.string()),
	client_id: z.optional(z.string()),
	authorized: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const createTicketErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createTicketMutationResponseSchema = z.lazy(() => createTicket201Schema);

export const showTicketPathParamsSchema = z.object({
	ticket_id: z.string(),
});

/**
 * @description ok
 */
export const showTicket200Schema = z.object({
	id: z.optional(z.string()),
	client_id: z.optional(z.string()),
	authorized: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const showTicketErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const showTicketQueryResponseSchema = z.lazy(() => showTicket200Schema);

export const exchangeTicketPathParamsSchema = z.object({
	ticket_id: z.string(),
});

/**
 * @description ok
 */
export const exchangeTicket201Schema = z.object({
	id: z.optional(z.string()),
	access_token: z.optional(z.string()),
	user_id: z.optional(z.string()),
	user_email: z.optional(z.string()),
	created_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const exchangeTicketErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const exchangeTicketMutationResponseSchema = z.lazy(() => exchangeTicket201Schema);

/**
 * @description OK
 */
export const listDeployKeys200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		public_key: z.optional(z.string()),
		created_at: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listDeployKeysErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listDeployKeysQueryResponseSchema = z.lazy(() => listDeployKeys200Schema);

/**
 * @description Created
 */
export const createDeployKey201Schema = z.object({
	id: z.optional(z.string()),
	public_key: z.optional(z.string()),
	created_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const createDeployKeyErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createDeployKeyMutationResponseSchema = z.lazy(() => createDeployKey201Schema);

export const getDeployKeyPathParamsSchema = z.object({
	key_id: z.string(),
});

/**
 * @description OK
 */
export const getDeployKey200Schema = z.object({
	id: z.optional(z.string()),
	public_key: z.optional(z.string()),
	created_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const getDeployKeyErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getDeployKeyQueryResponseSchema = z.lazy(() => getDeployKey200Schema);

export const deleteDeployKeyPathParamsSchema = z.object({
	key_id: z.string(),
});

/**
 * @description Not Content
 */
export const deleteDeployKey204Schema = z.unknown();

/**
 * @description error
 */
export const deleteDeployKeyErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteDeployKeyMutationResponseSchema = z.lazy(() => deleteDeployKey204Schema);

export const createSiteInTeamPathParamsSchema = z.object({
	account_slug: z.string(),
});

export const createSiteInTeamQueryParamsSchema = z
	.object({
		configure_dns: z.optional(z.boolean()),
	})
	.optional();

/**
 * @description Created
 */
export const createSiteInTeam201Schema = z.object({
	id: z.optional(z.string()),
	state: z.optional(z.string()),
	plan: z.optional(z.string()),
	name: z.optional(z.string()),
	custom_domain: z.optional(z.string()),
	domain_aliases: z.optional(z.array(z.string())),
	branch_deploy_custom_domain: z.optional(z.string()),
	deploy_preview_custom_domain: z.optional(z.string()),
	password: z.optional(z.string()),
	notification_email: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	user_id: z.optional(z.string()),
	session_id: z.optional(z.string()),
	ssl: z.optional(z.boolean()),
	force_ssl: z.optional(z.boolean()),
	managed_dns: z.optional(z.boolean()),
	deploy_url: z.optional(z.string()),
	published_deploy: z.optional(
		z.object({
			id: z.optional(z.string()),
			site_id: z.optional(z.string()),
			user_id: z.optional(z.string()),
			build_id: z.optional(z.string()),
			state: z.optional(z.string()),
			name: z.optional(z.string()),
			url: z.optional(z.string()),
			ssl_url: z.optional(z.string()),
			admin_url: z.optional(z.string()),
			deploy_url: z.optional(z.string()),
			deploy_ssl_url: z.optional(z.string()),
			screenshot_url: z.optional(z.string()),
			review_id: z.optional(z.number()),
			draft: z.optional(z.boolean()),
			required: z.optional(z.array(z.string())),
			required_functions: z.optional(z.array(z.string())),
			error_message: z.optional(z.string()),
			branch: z.optional(z.string()),
			commit_ref: z.optional(z.string()),
			commit_url: z.optional(z.string()),
			skipped: z.optional(z.boolean()),
			created_at: z.optional(z.string()),
			updated_at: z.optional(z.string()),
			published_at: z.optional(z.string()),
			title: z.optional(z.string()),
			context: z.optional(z.string()),
			locked: z.optional(z.boolean()),
			review_url: z.optional(z.string()),
			framework: z.optional(z.string()),
			skew_protection_token: z.optional(z.string()),
			function_schedules: z.optional(
				z.array(
					z.object({
						name: z.optional(z.string()),
						cron: z.optional(z.string()),
					}),
				),
			),
		}),
	),
	account_id: z.optional(z.string()),
	account_name: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	git_provider: z.optional(z.string()),
	deploy_hook: z.optional(z.string()),
	capabilities: z.optional(z.object({}).catchall(z.object({}))),
	processing_settings: z.optional(
		z.object({
			html: z.optional(
				z.object({
					pretty_urls: z.optional(z.boolean()),
				}),
			),
		}),
	),
	build_settings: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
	id_domain: z.optional(z.string()),
	default_hooks_data: z.optional(
		z.object({
			access_token: z.optional(z.string()),
		}),
	),
	build_image: z.optional(z.string()),
	prerender: z.optional(z.string()),
	functions_region: z.optional(z.string()),
	prevent_non_git_prod_deploys: z.optional(z.boolean().default(false)),
});

/**
 * @description error
 */
export const createSiteInTeamErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createSiteInTeamMutationRequestSchema = z.object({
	id: z.optional(z.string()),
	state: z.optional(z.string()),
	plan: z.optional(z.string()),
	name: z.optional(z.string()),
	custom_domain: z.optional(z.string()),
	domain_aliases: z.optional(z.array(z.string())),
	branch_deploy_custom_domain: z.optional(z.string()),
	deploy_preview_custom_domain: z.optional(z.string()),
	password: z.optional(z.string()),
	notification_email: z.optional(z.string()),
	url: z.optional(z.string()),
	ssl_url: z.optional(z.string()),
	admin_url: z.optional(z.string()),
	screenshot_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	user_id: z.optional(z.string()),
	session_id: z.optional(z.string()),
	ssl: z.optional(z.boolean()),
	force_ssl: z.optional(z.boolean()),
	managed_dns: z.optional(z.boolean()),
	deploy_url: z.optional(z.string()),
	published_deploy: z.optional(
		z.object({
			id: z.optional(z.string()),
			site_id: z.optional(z.string()),
			user_id: z.optional(z.string()),
			build_id: z.optional(z.string()),
			state: z.optional(z.string()),
			name: z.optional(z.string()),
			url: z.optional(z.string()),
			ssl_url: z.optional(z.string()),
			admin_url: z.optional(z.string()),
			deploy_url: z.optional(z.string()),
			deploy_ssl_url: z.optional(z.string()),
			screenshot_url: z.optional(z.string()),
			review_id: z.optional(z.number()),
			draft: z.optional(z.boolean()),
			required: z.optional(z.array(z.string())),
			required_functions: z.optional(z.array(z.string())),
			error_message: z.optional(z.string()),
			branch: z.optional(z.string()),
			commit_ref: z.optional(z.string()),
			commit_url: z.optional(z.string()),
			skipped: z.optional(z.boolean()),
			created_at: z.optional(z.string()),
			updated_at: z.optional(z.string()),
			published_at: z.optional(z.string()),
			title: z.optional(z.string()),
			context: z.optional(z.string()),
			locked: z.optional(z.boolean()),
			review_url: z.optional(z.string()),
			framework: z.optional(z.string()),
			skew_protection_token: z.optional(z.string()),
			function_schedules: z.optional(
				z.array(
					z.object({
						name: z.optional(z.string()),
						cron: z.optional(z.string()),
					}),
				),
			),
		}),
	),
	account_id: z.optional(z.string()),
	account_name: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	git_provider: z.optional(z.string()),
	deploy_hook: z.optional(z.string()),
	capabilities: z.optional(z.object({}).catchall(z.object({}))),
	processing_settings: z.optional(
		z.object({
			html: z.optional(
				z.object({
					pretty_urls: z.optional(z.boolean()),
				}),
			),
		}),
	),
	build_settings: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
	id_domain: z.optional(z.string()),
	default_hooks_data: z.optional(
		z.object({
			access_token: z.optional(z.string()),
		}),
	),
	build_image: z.optional(z.string()),
	prerender: z.optional(z.string()),
	functions_region: z.optional(z.string()),
	prevent_non_git_prod_deploys: z.optional(z.boolean().default(false)),
	repo: z.optional(
		z.object({
			id: z.optional(z.int()),
			provider: z.optional(z.string()),
			deploy_key_id: z.optional(z.string()),
			repo_path: z.optional(z.string()),
			repo_branch: z.optional(z.string()),
			dir: z.optional(z.string()),
			functions_dir: z.optional(
				z
					.string()
					.describe(
						"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
					),
			),
			cmd: z.optional(
				z
					.string()
					.describe(
						"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
					),
			),
			allowed_branches: z.optional(z.array(z.string())),
			public_repo: z.optional(z.boolean()),
			private_logs: z.optional(z.boolean()),
			repo_url: z.optional(z.string()),
			env: z.optional(z.object({}).catchall(z.string())),
			installation_id: z.optional(z.int()),
			stop_builds: z.optional(
				z
					.boolean()
					.describe(
						"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
					),
			),
		}),
	),
});

export const createSiteInTeamMutationResponseSchema = z.lazy(() => createSiteInTeam201Schema);

export const listSitesForAccountPathParamsSchema = z.object({
	account_slug: z.string(),
});

export const listSitesForAccountQueryParamsSchema = z
	.object({
		name: z.optional(z.string()),
		page: z.optional(z.coerce.number().int()),
		per_page: z.optional(z.coerce.number().int()),
	})
	.optional();

/**
 * @description OK
 */
export const listSitesForAccount200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		state: z.optional(z.string()),
		plan: z.optional(z.string()),
		name: z.optional(z.string()),
		custom_domain: z.optional(z.string()),
		domain_aliases: z.optional(z.array(z.string())),
		branch_deploy_custom_domain: z.optional(z.string()),
		deploy_preview_custom_domain: z.optional(z.string()),
		password: z.optional(z.string()),
		notification_email: z.optional(z.string()),
		url: z.optional(z.string()),
		ssl_url: z.optional(z.string()),
		admin_url: z.optional(z.string()),
		screenshot_url: z.optional(z.string()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		user_id: z.optional(z.string()),
		session_id: z.optional(z.string()),
		ssl: z.optional(z.boolean()),
		force_ssl: z.optional(z.boolean()),
		managed_dns: z.optional(z.boolean()),
		deploy_url: z.optional(z.string()),
		published_deploy: z.optional(
			z.object({
				id: z.optional(z.string()),
				site_id: z.optional(z.string()),
				user_id: z.optional(z.string()),
				build_id: z.optional(z.string()),
				state: z.optional(z.string()),
				name: z.optional(z.string()),
				url: z.optional(z.string()),
				ssl_url: z.optional(z.string()),
				admin_url: z.optional(z.string()),
				deploy_url: z.optional(z.string()),
				deploy_ssl_url: z.optional(z.string()),
				screenshot_url: z.optional(z.string()),
				review_id: z.optional(z.number()),
				draft: z.optional(z.boolean()),
				required: z.optional(z.array(z.string())),
				required_functions: z.optional(z.array(z.string())),
				error_message: z.optional(z.string()),
				branch: z.optional(z.string()),
				commit_ref: z.optional(z.string()),
				commit_url: z.optional(z.string()),
				skipped: z.optional(z.boolean()),
				created_at: z.optional(z.string()),
				updated_at: z.optional(z.string()),
				published_at: z.optional(z.string()),
				title: z.optional(z.string()),
				context: z.optional(z.string()),
				locked: z.optional(z.boolean()),
				review_url: z.optional(z.string()),
				framework: z.optional(z.string()),
				skew_protection_token: z.optional(z.string()),
				function_schedules: z.optional(
					z.array(
						z.object({
							name: z.optional(z.string()),
							cron: z.optional(z.string()),
						}),
					),
				),
			}),
		),
		account_id: z.optional(z.string()),
		account_name: z.optional(z.string()),
		account_slug: z.optional(z.string()),
		git_provider: z.optional(z.string()),
		deploy_hook: z.optional(z.string()),
		capabilities: z.optional(z.object({}).catchall(z.object({}))),
		processing_settings: z.optional(
			z.object({
				html: z.optional(
					z.object({
						pretty_urls: z.optional(z.boolean()),
					}),
				),
			}),
		),
		build_settings: z.optional(
			z.object({
				id: z.optional(z.int()),
				provider: z.optional(z.string()),
				deploy_key_id: z.optional(z.string()),
				repo_path: z.optional(z.string()),
				repo_branch: z.optional(z.string()),
				dir: z.optional(z.string()),
				functions_dir: z.optional(
					z
						.string()
						.describe(
							"The directory where Netlify can find your compiled functions to deploy them. Defaults to netlify/functions if not set. You can also define and override this setting in your project’s netlify.toml file.",
						),
				),
				cmd: z.optional(
					z
						.string()
						.describe(
							"The build command to run. This is the command that Netlify runs to build your site. If a site has a netlify.toml file with a build command it will override this value.",
						),
				),
				allowed_branches: z.optional(z.array(z.string())),
				public_repo: z.optional(z.boolean()),
				private_logs: z.optional(z.boolean()),
				repo_url: z.optional(z.string()),
				env: z.optional(z.object({}).catchall(z.string())),
				installation_id: z.optional(z.int()),
				stop_builds: z.optional(
					z
						.boolean()
						.describe(
							"When true, Netlify will not build your project automatically. You can build locally via the CLI and then publish new deploys manually via the CLI or the API.",
						),
				),
			}),
		),
		id_domain: z.optional(z.string()),
		default_hooks_data: z.optional(
			z.object({
				access_token: z.optional(z.string()),
			}),
		),
		build_image: z.optional(z.string()),
		prerender: z.optional(z.string()),
		functions_region: z.optional(z.string()),
		prevent_non_git_prod_deploys: z.optional(z.boolean().default(false)),
	}),
);

/**
 * @description error
 */
export const listSitesForAccountErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listSitesForAccountQueryResponseSchema = z.lazy(() => listSitesForAccount200Schema);

export const listMembersForAccountPathParamsSchema = z.object({
	account_slug: z.string(),
});

/**
 * @description OK
 */
export const listMembersForAccount200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		full_name: z.optional(z.string()),
		email: z.optional(z.string()),
		avatar: z.optional(z.string()),
		role: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listMembersForAccountErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listMembersForAccountQueryResponseSchema = z.lazy(
	() => listMembersForAccount200Schema,
);

export const addMemberToAccountPathParamsSchema = z.object({
	account_slug: z.string(),
});

/**
 * @description OK
 */
export const addMemberToAccount200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		full_name: z.optional(z.string()),
		email: z.optional(z.string()),
		avatar: z.optional(z.string()),
		role: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const addMemberToAccountErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const addMemberToAccountMutationRequestSchema = z.object({
	role: z.optional(z.enum(["Owner", "Developer", "Billing Admin", "Reviewer"])),
	email: z.optional(z.string()),
});

export const addMemberToAccountMutationResponseSchema = z.lazy(() => addMemberToAccount200Schema);

export const getAccountMemberPathParamsSchema = z.object({
	account_slug: z.string(),
	member_id: z.string(),
});

/**
 * @description OK
 */
export const getAccountMember200Schema = z.object({
	id: z.optional(z.string()),
	full_name: z.optional(z.string()),
	email: z.optional(z.string()),
	avatar: z.optional(z.string()),
	role: z.optional(z.string()),
});

/**
 * @description error
 */
export const getAccountMemberErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getAccountMemberQueryResponseSchema = z.lazy(() => getAccountMember200Schema);

export const updateAccountMemberPathParamsSchema = z.object({
	account_slug: z.string(),
	member_id: z.string(),
});

/**
 * @description OK
 */
export const updateAccountMember200Schema = z.object({
	id: z.optional(z.string()),
	full_name: z.optional(z.string()),
	email: z.optional(z.string()),
	avatar: z.optional(z.string()),
	role: z.optional(z.string()),
});

/**
 * @description error
 */
export const updateAccountMemberErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateAccountMemberMutationRequestSchema = z.object({
	role: z.optional(z.enum(["Owner", "Developer", "Billing Admin", "Reviewer"])),
	site_access: z.optional(z.enum(["all", "none", "selected"])),
	site_ids: z.optional(z.array(z.string())),
});

export const updateAccountMemberMutationResponseSchema = z.lazy(() => updateAccountMember200Schema);

export const removeAccountMemberPathParamsSchema = z.object({
	account_slug: z.string(),
	member_id: z.string(),
});

/**
 * @description Not Content
 */
export const removeAccountMember204Schema = z.unknown();

/**
 * @description error
 */
export const removeAccountMemberErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const removeAccountMemberMutationResponseSchema = z.lazy(() => removeAccountMember204Schema);

/**
 * @description OK
 */
export const listPaymentMethodsForUser200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		method_name: z.optional(z.string()),
		type: z.optional(z.string()),
		state: z.optional(z.string()),
		data: z.optional(
			z.object({
				card_type: z.optional(z.string()),
				last4: z.optional(z.string()),
				email: z.optional(z.string()),
			}),
		),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listPaymentMethodsForUserErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listPaymentMethodsForUserQueryResponseSchema = z.lazy(
	() => listPaymentMethodsForUser200Schema,
);

/**
 * @description OK
 */
export const listAccountTypesForUser200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		name: z.optional(z.string()),
		description: z.optional(z.string()),
		capabilities: z.optional(z.object({})),
		monthly_dollar_price: z.optional(z.int()),
		yearly_dollar_price: z.optional(z.int()),
		monthly_seats_addon_dollar_price: z.optional(z.int()),
		yearly_seats_addon_dollar_price: z.optional(z.int()),
	}),
);

/**
 * @description error
 */
export const listAccountTypesForUserErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listAccountTypesForUserQueryResponseSchema = z.lazy(
	() => listAccountTypesForUser200Schema,
);

export const listAccountsForUserQueryParamsSchema = z
	.object({
		minimal: z.optional(z.boolean()),
	})
	.optional();

/**
 * @description OK
 */
export const listAccountsForUser200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		name: z.optional(z.string()),
		slug: z.optional(z.string()),
		type: z.optional(z.string()),
		capabilities: z.optional(
			z.object({
				sites: z.optional(
					z.object({
						included: z.optional(z.int()),
						used: z.optional(z.int()),
					}),
				),
				collaborators: z.optional(
					z.object({
						included: z.optional(z.int()),
						used: z.optional(z.int()),
					}),
				),
			}),
		),
		billing_name: z.optional(z.string()),
		billing_email: z.optional(z.string()),
		billing_details: z.optional(z.string()),
		billing_period: z.optional(z.string()),
		payment_method_id: z.optional(z.string()),
		type_name: z.optional(z.string()),
		type_id: z.optional(z.string()),
		owner_ids: z.optional(z.array(z.string())),
		roles_allowed: z.optional(z.array(z.string())),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listAccountsForUserErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listAccountsForUserQueryResponseSchema = z.lazy(() => listAccountsForUser200Schema);

/**
 * @description Created
 */
export const createAccount201Schema = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	slug: z.optional(z.string()),
	type: z.optional(z.string()),
	capabilities: z.optional(
		z.object({
			sites: z.optional(
				z.object({
					included: z.optional(z.int()),
					used: z.optional(z.int()),
				}),
			),
			collaborators: z.optional(
				z.object({
					included: z.optional(z.int()),
					used: z.optional(z.int()),
				}),
			),
		}),
	),
	billing_name: z.optional(z.string()),
	billing_email: z.optional(z.string()),
	billing_details: z.optional(z.string()),
	billing_period: z.optional(z.string()),
	payment_method_id: z.optional(z.string()),
	type_name: z.optional(z.string()),
	type_id: z.optional(z.string()),
	owner_ids: z.optional(z.array(z.string())),
	roles_allowed: z.optional(z.array(z.string())),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const createAccountErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createAccountMutationRequestSchema = z.object({
	name: z.string(),
	type_id: z.string(),
	payment_method_id: z.optional(z.string()),
	period: z.optional(z.enum(["monthly", "yearly"])),
	extra_seats_block: z.optional(z.int()),
});

export const createAccountMutationResponseSchema = z.lazy(() => createAccount201Schema);

export const getAccountPathParamsSchema = z.object({
	account_id: z.string(),
});

/**
 * @description OK
 */
export const getAccount200Schema = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	slug: z.optional(z.string()),
	type: z.optional(z.string()),
	capabilities: z.optional(
		z.object({
			sites: z.optional(
				z.object({
					included: z.optional(z.int()),
					used: z.optional(z.int()),
				}),
			),
			collaborators: z.optional(
				z.object({
					included: z.optional(z.int()),
					used: z.optional(z.int()),
				}),
			),
		}),
	),
	billing_name: z.optional(z.string()),
	billing_email: z.optional(z.string()),
	billing_details: z.optional(z.string()),
	billing_period: z.optional(z.string()),
	payment_method_id: z.optional(z.string()),
	type_name: z.optional(z.string()),
	type_id: z.optional(z.string()),
	owner_ids: z.optional(z.array(z.string())),
	roles_allowed: z.optional(z.array(z.string())),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const getAccountErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getAccountQueryResponseSchema = z.lazy(() => getAccount200Schema);

export const updateAccountPathParamsSchema = z.object({
	account_id: z.string(),
});

/**
 * @description OK
 */
export const updateAccount200Schema = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	slug: z.optional(z.string()),
	type: z.optional(z.string()),
	capabilities: z.optional(
		z.object({
			sites: z.optional(
				z.object({
					included: z.optional(z.int()),
					used: z.optional(z.int()),
				}),
			),
			collaborators: z.optional(
				z.object({
					included: z.optional(z.int()),
					used: z.optional(z.int()),
				}),
			),
		}),
	),
	billing_name: z.optional(z.string()),
	billing_email: z.optional(z.string()),
	billing_details: z.optional(z.string()),
	billing_period: z.optional(z.string()),
	payment_method_id: z.optional(z.string()),
	type_name: z.optional(z.string()),
	type_id: z.optional(z.string()),
	owner_ids: z.optional(z.array(z.string())),
	roles_allowed: z.optional(z.array(z.string())),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const updateAccountErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateAccountMutationRequestSchema = z.object({
	name: z.optional(z.string()),
	slug: z.optional(z.string()),
	type_id: z.optional(z.string()),
	extra_seats_block: z.optional(z.int()),
	billing_name: z.optional(z.string()),
	billing_email: z.optional(z.string()),
	billing_details: z.optional(z.string()),
});

export const updateAccountMutationResponseSchema = z.lazy(() => updateAccount200Schema);

export const cancelAccountPathParamsSchema = z.object({
	account_id: z.string(),
});

/**
 * @description Not Content
 */
export const cancelAccount204Schema = z.unknown();

/**
 * @description error
 */
export const cancelAccountErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const cancelAccountMutationResponseSchema = z.lazy(() => cancelAccount204Schema);

export const listAccountAuditEventsPathParamsSchema = z.object({
	account_id: z.string(),
});

export const listAccountAuditEventsQueryParamsSchema = z
	.object({
		query: z.optional(z.string()),
		log_type: z.optional(z.string()),
		page: z.optional(z.coerce.number().int()),
		per_page: z.optional(z.coerce.number().int()),
	})
	.optional();

/**
 * @description OK
 */
export const listAccountAuditEvents200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		account_id: z.optional(z.string()),
		payload: z.optional(
			z
				.object({
					actor_id: z.optional(z.string()),
					actor_name: z.optional(z.string()),
					actor_email: z.optional(z.string()),
					action: z.optional(z.string()),
					timestamp: z.optional(z.string()),
					log_type: z.optional(z.string()),
				})
				.catchall(z.object({})),
		),
	}),
);

/**
 * @description error
 */
export const listAccountAuditEventsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listAccountAuditEventsQueryResponseSchema = z.lazy(
	() => listAccountAuditEvents200Schema,
);

export const listAgentRunnersQueryParamsSchema = z.object({
	account_id: z.string(),
	site_id: z.string(),
	page: z.optional(z.coerce.number().int()),
	per_page: z.optional(z.coerce.number().int()),
	state: z.optional(z.enum(["live", "error"])),
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	result_branch: z.optional(z.string()),
	from: z.optional(z.coerce.number().int()),
	to: z.optional(z.coerce.number().int()),
});

/**
 * @description OK
 */
export const listAgentRunners200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		parent_agent_runner_id: z.optional(z.string()),
		state: z.optional(z.string()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		done_at: z.optional(z.string()),
		title: z.optional(z.string()),
		branch: z.optional(z.string()),
		result_branch: z.optional(z.string()),
		pr_url: z.optional(z.string()),
		pr_branch: z.optional(z.string()),
		pr_state: z.optional(z.string()),
		pr_number: z.optional(z.int()),
		pr_is_being_created: z.optional(z.boolean()),
		pr_error: z.optional(z.string()),
		current_task: z.optional(z.string()),
		result_diff: z.optional(z.string()),
		sha: z.optional(z.string()),
		merge_commit_sha: z.optional(z.string()),
		merge_commit_error: z.optional(z.string()),
		merge_commit_is_being_created: z.optional(z.boolean()),
		base_deploy_id: z.optional(z.string()),
		attached_file_keys: z.optional(z.array(z.string())),
		active_session_created_at: z.optional(z.string()),
		latest_session_deploy_id: z.optional(z.string()),
		latest_session_deploy_url: z.optional(z.string()),
		user: z.optional(
			z.object({
				id: z.optional(z.string()),
				full_name: z.optional(z.string()),
				email: z.optional(z.string()),
				avatar_url: z.optional(z.string()),
			}),
		),
	}),
);

/**
 * @description error
 */
export const listAgentRunnersErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listAgentRunnersQueryResponseSchema = z.lazy(() => listAgentRunners200Schema);

export const createAgentRunnerQueryParamsSchema = z.object({
	site_id: z.string(),
	deploy_id: z.optional(z.string()),
	branch: z.optional(z.string()),
	prompt: z.optional(z.string()),
	agent: z.optional(z.string()),
	model: z.optional(z.string()),
	parent_agent_runner_id: z.optional(z.string()),
	dev_server_image: z.optional(z.string()),
	file_keys: z.optional(z.array(z.string())),
});

/**
 * @description OK
 */
export const createAgentRunner200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	parent_agent_runner_id: z.optional(z.string()),
	state: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	done_at: z.optional(z.string()),
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	result_branch: z.optional(z.string()),
	pr_url: z.optional(z.string()),
	pr_branch: z.optional(z.string()),
	pr_state: z.optional(z.string()),
	pr_number: z.optional(z.int()),
	pr_is_being_created: z.optional(z.boolean()),
	pr_error: z.optional(z.string()),
	current_task: z.optional(z.string()),
	result_diff: z.optional(z.string()),
	sha: z.optional(z.string()),
	merge_commit_sha: z.optional(z.string()),
	merge_commit_error: z.optional(z.string()),
	merge_commit_is_being_created: z.optional(z.boolean()),
	base_deploy_id: z.optional(z.string()),
	attached_file_keys: z.optional(z.array(z.string())),
	active_session_created_at: z.optional(z.string()),
	latest_session_deploy_id: z.optional(z.string()),
	latest_session_deploy_url: z.optional(z.string()),
	user: z.optional(
		z.object({
			id: z.optional(z.string()),
			full_name: z.optional(z.string()),
			email: z.optional(z.string()),
			avatar_url: z.optional(z.string()),
		}),
	),
});

/**
 * @description Not Found
 */
export const createAgentRunner404Schema = z.unknown();

/**
 * @description Unprocessable Entity
 */
export const createAgentRunner422Schema = z.unknown();

/**
 * @description error
 */
export const createAgentRunnerErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createAgentRunnerMutationResponseSchema = z.lazy(() => createAgentRunner200Schema);

export const createAgentRunnerUploadUrlQueryParamsSchema = z.object({
	account_id: z.string(),
	filename: z.string(),
	content_type: z.string(),
});

/**
 * @description OK
 */
export const createAgentRunnerUploadUrl200Schema = z.unknown();

/**
 * @description Bad Request
 */
export const createAgentRunnerUploadUrl400Schema = z.unknown();

/**
 * @description Unprocessable Entity
 */
export const createAgentRunnerUploadUrl422Schema = z.unknown();

/**
 * @description error
 */
export const createAgentRunnerUploadUrlErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createAgentRunnerUploadUrlMutationResponseSchema = z.lazy(
	() => createAgentRunnerUploadUrl200Schema,
);

export const getAgentRunnerPathParamsSchema = z.object({
	agent_runner_id: z.string(),
});

/**
 * @description OK
 */
export const getAgentRunner200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	parent_agent_runner_id: z.optional(z.string()),
	state: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	done_at: z.optional(z.string()),
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	result_branch: z.optional(z.string()),
	pr_url: z.optional(z.string()),
	pr_branch: z.optional(z.string()),
	pr_state: z.optional(z.string()),
	pr_number: z.optional(z.int()),
	pr_is_being_created: z.optional(z.boolean()),
	pr_error: z.optional(z.string()),
	current_task: z.optional(z.string()),
	result_diff: z.optional(z.string()),
	sha: z.optional(z.string()),
	merge_commit_sha: z.optional(z.string()),
	merge_commit_error: z.optional(z.string()),
	merge_commit_is_being_created: z.optional(z.boolean()),
	base_deploy_id: z.optional(z.string()),
	attached_file_keys: z.optional(z.array(z.string())),
	active_session_created_at: z.optional(z.string()),
	latest_session_deploy_id: z.optional(z.string()),
	latest_session_deploy_url: z.optional(z.string()),
	user: z.optional(
		z.object({
			id: z.optional(z.string()),
			full_name: z.optional(z.string()),
			email: z.optional(z.string()),
			avatar_url: z.optional(z.string()),
		}),
	),
});

/**
 * @description error
 */
export const getAgentRunnerErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getAgentRunnerQueryResponseSchema = z.lazy(() => getAgentRunner200Schema);

export const updateAgentRunnerPathParamsSchema = z.object({
	agent_runner_id: z.string(),
});

/**
 * @description OK
 */
export const updateAgentRunner200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	parent_agent_runner_id: z.optional(z.string()),
	state: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	done_at: z.optional(z.string()),
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	result_branch: z.optional(z.string()),
	pr_url: z.optional(z.string()),
	pr_branch: z.optional(z.string()),
	pr_state: z.optional(z.string()),
	pr_number: z.optional(z.int()),
	pr_is_being_created: z.optional(z.boolean()),
	pr_error: z.optional(z.string()),
	current_task: z.optional(z.string()),
	result_diff: z.optional(z.string()),
	sha: z.optional(z.string()),
	merge_commit_sha: z.optional(z.string()),
	merge_commit_error: z.optional(z.string()),
	merge_commit_is_being_created: z.optional(z.boolean()),
	base_deploy_id: z.optional(z.string()),
	attached_file_keys: z.optional(z.array(z.string())),
	active_session_created_at: z.optional(z.string()),
	latest_session_deploy_id: z.optional(z.string()),
	latest_session_deploy_url: z.optional(z.string()),
	user: z.optional(
		z.object({
			id: z.optional(z.string()),
			full_name: z.optional(z.string()),
			email: z.optional(z.string()),
			avatar_url: z.optional(z.string()),
		}),
	),
});

/**
 * @description error
 */
export const updateAgentRunnerErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateAgentRunnerMutationResponseSchema = z.lazy(() => updateAgentRunner200Schema);

export const deleteAgentRunnerPathParamsSchema = z.object({
	agent_runner_id: z.string(),
});

/**
 * @description Accepted
 */
export const deleteAgentRunner202Schema = z.unknown();

/**
 * @description error
 */
export const deleteAgentRunnerErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteAgentRunnerMutationResponseSchema = z.lazy(() => deleteAgentRunner202Schema);

export const archiveAgentRunnerPathParamsSchema = z.object({
	agent_runner_id: z.string(),
});

/**
 * @description Accepted
 */
export const archiveAgentRunner202Schema = z.unknown();

/**
 * @description Not Found
 */
export const archiveAgentRunner404Schema = z.unknown();

/**
 * @description Unprocessable Entity
 */
export const archiveAgentRunner422Schema = z.unknown();

/**
 * @description error
 */
export const archiveAgentRunnerErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const archiveAgentRunnerMutationResponseSchema = z.lazy(() => archiveAgentRunner202Schema);

export const agentRunnerPullRequestPathParamsSchema = z.object({
	agent_runner_id: z.string(),
});

/**
 * @description OK
 */
export const agentRunnerPullRequest200Schema = z.unknown();

/**
 * @description Bad Request
 */
export const agentRunnerPullRequest400Schema = z.unknown();

/**
 * @description Conflict
 */
export const agentRunnerPullRequest409Schema = z.unknown();

/**
 * @description Unprocessable Entity
 */
export const agentRunnerPullRequest422Schema = z.unknown();

/**
 * @description error
 */
export const agentRunnerPullRequestErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const agentRunnerPullRequestMutationResponseSchema = z.lazy(
	() => agentRunnerPullRequest200Schema,
);

export const agentRunnerCommitToBranchPathParamsSchema = z.object({
	agent_runner_id: z.string(),
});

export const agentRunnerCommitToBranchQueryParamsSchema = z.object({
	target_branch: z.string(),
});

/**
 * @description OK
 */
export const agentRunnerCommitToBranch200Schema = z.unknown();

/**
 * @description Bad Request
 */
export const agentRunnerCommitToBranch400Schema = z.unknown();

/**
 * @description Conflict
 */
export const agentRunnerCommitToBranch409Schema = z.unknown();

/**
 * @description Unprocessable Entity
 */
export const agentRunnerCommitToBranch422Schema = z.unknown();

/**
 * @description error
 */
export const agentRunnerCommitToBranchErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const agentRunnerCommitToBranchMutationResponseSchema = z.lazy(
	() => agentRunnerCommitToBranch200Schema,
);

export const listAgentRunnerSessionsPathParamsSchema = z.object({
	agent_runner_id: z.string(),
});

export const listAgentRunnerSessionsQueryParamsSchema = z
	.object({
		page: z.optional(z.coerce.number().int()),
		per_page: z.optional(z.coerce.number().int()),
		state: z.optional(z.enum(["live", "error"])),
		from: z.optional(z.coerce.number().int()),
		to: z.optional(z.coerce.number().int()),
		order_by: z.optional(z.enum(["asc", "desc"])),
	})
	.optional();

/**
 * @description OK
 */
export const listAgentRunnerSessions200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		agent_runner_id: z.optional(z.string()),
		dev_server_id: z.optional(z.string()),
		state: z.optional(z.string()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		done_at: z.optional(z.string()),
		title: z.optional(z.string()),
		prompt: z.optional(z.string()),
		agent_config: z.optional(
			z.object({
				agent: z.optional(z.string()),
				model: z.optional(z.string()),
			}),
		),
		result: z.optional(z.string()),
		result_diff: z.optional(z.string()),
		commit_sha: z.optional(z.string()),
		deploy_id: z.optional(z.string()),
		deploy_url: z.optional(z.string()),
		duration: z.optional(z.int()),
		steps: z.optional(
			z.array(
				z.object({
					title: z.optional(z.string()),
					message: z.optional(z.string()),
				}),
			),
		),
		user: z.optional(
			z.object({
				id: z.optional(z.string()),
				full_name: z.optional(z.string()),
				email: z.optional(z.string()),
				avatar_url: z.optional(z.string()),
			}),
		),
		attached_file_keys: z.optional(z.array(z.string())),
		result_zip_file_name: z.optional(z.string()),
		is_published: z.optional(z.boolean()),
	}),
);

/**
 * @description error
 */
export const listAgentRunnerSessionsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listAgentRunnerSessionsQueryResponseSchema = z.lazy(
	() => listAgentRunnerSessions200Schema,
);

export const createAgentRunnerSessionPathParamsSchema = z.object({
	agent_runner_id: z.string(),
});

export const createAgentRunnerSessionQueryParamsSchema = z
	.object({
		prompt: z.optional(z.string()),
		agent: z.optional(z.string()),
		model: z.optional(z.string()),
		file_keys: z.optional(z.array(z.string())),
	})
	.optional();

/**
 * @description OK
 */
export const createAgentRunnerSession200Schema = z.object({
	id: z.optional(z.string()),
	agent_runner_id: z.optional(z.string()),
	dev_server_id: z.optional(z.string()),
	state: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	done_at: z.optional(z.string()),
	title: z.optional(z.string()),
	prompt: z.optional(z.string()),
	agent_config: z.optional(
		z.object({
			agent: z.optional(z.string()),
			model: z.optional(z.string()),
		}),
	),
	result: z.optional(z.string()),
	result_diff: z.optional(z.string()),
	commit_sha: z.optional(z.string()),
	deploy_id: z.optional(z.string()),
	deploy_url: z.optional(z.string()),
	duration: z.optional(z.int()),
	steps: z.optional(
		z.array(
			z.object({
				title: z.optional(z.string()),
				message: z.optional(z.string()),
			}),
		),
	),
	user: z.optional(
		z.object({
			id: z.optional(z.string()),
			full_name: z.optional(z.string()),
			email: z.optional(z.string()),
			avatar_url: z.optional(z.string()),
		}),
	),
	attached_file_keys: z.optional(z.array(z.string())),
	result_zip_file_name: z.optional(z.string()),
	is_published: z.optional(z.boolean()),
});

/**
 * @description Not Found
 */
export const createAgentRunnerSession404Schema = z.unknown();

/**
 * @description Unprocessable Entity
 */
export const createAgentRunnerSession422Schema = z.unknown();

/**
 * @description error
 */
export const createAgentRunnerSessionErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createAgentRunnerSessionMutationResponseSchema = z.lazy(
	() => createAgentRunnerSession200Schema,
);

export const getAgentRunnerSessionPathParamsSchema = z.object({
	agent_runner_id: z.string(),
	agent_runner_session_id: z.string(),
});

/**
 * @description OK
 */
export const getAgentRunnerSession200Schema = z.object({
	id: z.optional(z.string()),
	agent_runner_id: z.optional(z.string()),
	dev_server_id: z.optional(z.string()),
	state: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	done_at: z.optional(z.string()),
	title: z.optional(z.string()),
	prompt: z.optional(z.string()),
	agent_config: z.optional(
		z.object({
			agent: z.optional(z.string()),
			model: z.optional(z.string()),
		}),
	),
	result: z.optional(z.string()),
	result_diff: z.optional(z.string()),
	commit_sha: z.optional(z.string()),
	deploy_id: z.optional(z.string()),
	deploy_url: z.optional(z.string()),
	duration: z.optional(z.int()),
	steps: z.optional(
		z.array(
			z.object({
				title: z.optional(z.string()),
				message: z.optional(z.string()),
			}),
		),
	),
	user: z.optional(
		z.object({
			id: z.optional(z.string()),
			full_name: z.optional(z.string()),
			email: z.optional(z.string()),
			avatar_url: z.optional(z.string()),
		}),
	),
	attached_file_keys: z.optional(z.array(z.string())),
	result_zip_file_name: z.optional(z.string()),
	is_published: z.optional(z.boolean()),
});

/**
 * @description error
 */
export const getAgentRunnerSessionErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getAgentRunnerSessionQueryResponseSchema = z.lazy(
	() => getAgentRunnerSession200Schema,
);

export const updateAgentRunnerSessionPathParamsSchema = z.object({
	agent_runner_id: z.string(),
	agent_runner_session_id: z.string(),
});

export const updateAgentRunnerSessionQueryParamsSchema = z
	.object({
		is_published: z.optional(z.boolean()),
	})
	.optional();

/**
 * @description OK
 */
export const updateAgentRunnerSession200Schema = z.object({
	id: z.optional(z.string()),
	agent_runner_id: z.optional(z.string()),
	dev_server_id: z.optional(z.string()),
	state: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	done_at: z.optional(z.string()),
	title: z.optional(z.string()),
	prompt: z.optional(z.string()),
	agent_config: z.optional(
		z.object({
			agent: z.optional(z.string()),
			model: z.optional(z.string()),
		}),
	),
	result: z.optional(z.string()),
	result_diff: z.optional(z.string()),
	commit_sha: z.optional(z.string()),
	deploy_id: z.optional(z.string()),
	deploy_url: z.optional(z.string()),
	duration: z.optional(z.int()),
	steps: z.optional(
		z.array(
			z.object({
				title: z.optional(z.string()),
				message: z.optional(z.string()),
			}),
		),
	),
	user: z.optional(
		z.object({
			id: z.optional(z.string()),
			full_name: z.optional(z.string()),
			email: z.optional(z.string()),
			avatar_url: z.optional(z.string()),
		}),
	),
	attached_file_keys: z.optional(z.array(z.string())),
	result_zip_file_name: z.optional(z.string()),
	is_published: z.optional(z.boolean()),
});

/**
 * @description error
 */
export const updateAgentRunnerSessionErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateAgentRunnerSessionMutationResponseSchema = z.lazy(
	() => updateAgentRunnerSession200Schema,
);

export const deleteAgentRunnerSessionPathParamsSchema = z.object({
	agent_runner_id: z.string(),
	agent_runner_session_id: z.string(),
});

/**
 * @description Accepted
 */
export const deleteAgentRunnerSession202Schema = z.unknown();

/**
 * @description error
 */
export const deleteAgentRunnerSessionErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteAgentRunnerSessionMutationResponseSchema = z.lazy(
	() => deleteAgentRunnerSession202Schema,
);

export const listFormSubmissionPathParamsSchema = z.object({
	submission_id: z.string(),
});

export const listFormSubmissionQueryParamsSchema = z
	.object({
		query: z.optional(z.string()),
		page: z.optional(z.coerce.number().int()),
		per_page: z.optional(z.coerce.number().int()),
	})
	.optional();

/**
 * @description OK
 */
export const listFormSubmission200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		number: z.optional(z.int()),
		email: z.optional(z.string()),
		name: z.optional(z.string()),
		first_name: z.optional(z.string()),
		last_name: z.optional(z.string()),
		company: z.optional(z.string()),
		summary: z.optional(z.string()),
		body: z.optional(z.string()),
		data: z.optional(z.object({})),
		created_at: z.optional(z.string()),
		site_url: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listFormSubmissionErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listFormSubmissionQueryResponseSchema = z.lazy(() => listFormSubmission200Schema);

export const deleteSubmissionPathParamsSchema = z.object({
	submission_id: z.string(),
});

/**
 * @description Deleted
 */
export const deleteSubmission204Schema = z.unknown();

/**
 * @description error
 */
export const deleteSubmissionErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteSubmissionMutationResponseSchema = z.lazy(() => deleteSubmission204Schema);

export const listServiceInstancesForSitePathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const listServiceInstancesForSite200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		url: z.optional(z.string()),
		config: z.optional(z.object({})),
		external_attributes: z.optional(z.object({})),
		service_slug: z.optional(z.string()),
		service_path: z.optional(z.string()),
		service_name: z.optional(z.string()),
		env: z.optional(z.object({})),
		snippets: z.optional(z.array(z.object({}))),
		auth_url: z.optional(z.string()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listServiceInstancesForSiteErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listServiceInstancesForSiteQueryResponseSchema = z.lazy(
	() => listServiceInstancesForSite200Schema,
);

export const createServiceInstancePathParamsSchema = z.object({
	site_id: z.string(),
	addon: z.string(),
});

/**
 * @description Created
 */
export const createServiceInstance201Schema = z.object({
	id: z.optional(z.string()),
	url: z.optional(z.string()),
	config: z.optional(z.object({})),
	external_attributes: z.optional(z.object({})),
	service_slug: z.optional(z.string()),
	service_path: z.optional(z.string()),
	service_name: z.optional(z.string()),
	env: z.optional(z.object({})),
	snippets: z.optional(z.array(z.object({}))),
	auth_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const createServiceInstanceErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createServiceInstanceMutationRequestSchema = z.object({});

export const createServiceInstanceMutationResponseSchema = z.lazy(
	() => createServiceInstance201Schema,
);

export const showServiceInstancePathParamsSchema = z.object({
	site_id: z.string(),
	addon: z.string(),
	instance_id: z.string(),
});

/**
 * @description OK
 */
export const showServiceInstance200Schema = z.object({
	id: z.optional(z.string()),
	url: z.optional(z.string()),
	config: z.optional(z.object({})),
	external_attributes: z.optional(z.object({})),
	service_slug: z.optional(z.string()),
	service_path: z.optional(z.string()),
	service_name: z.optional(z.string()),
	env: z.optional(z.object({})),
	snippets: z.optional(z.array(z.object({}))),
	auth_url: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const showServiceInstanceErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const showServiceInstanceQueryResponseSchema = z.lazy(() => showServiceInstance200Schema);

export const updateServiceInstancePathParamsSchema = z.object({
	site_id: z.string(),
	addon: z.string(),
	instance_id: z.string(),
});

/**
 * @description No Content
 */
export const updateServiceInstance204Schema = z.unknown();

/**
 * @description error
 */
export const updateServiceInstanceErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateServiceInstanceMutationRequestSchema = z.object({});

export const updateServiceInstanceMutationResponseSchema = z.lazy(
	() => updateServiceInstance204Schema,
);

export const deleteServiceInstancePathParamsSchema = z.object({
	site_id: z.string(),
	addon: z.string(),
	instance_id: z.string(),
});

/**
 * @description Deleted
 */
export const deleteServiceInstance204Schema = z.unknown();

/**
 * @description error
 */
export const deleteServiceInstanceErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteServiceInstanceMutationResponseSchema = z.lazy(
	() => deleteServiceInstance204Schema,
);

export const getServicesQueryParamsSchema = z
	.object({
		search: z.optional(z.string()),
	})
	.optional();

/**
 * @description services
 */
export const getServices200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		name: z.optional(z.string()),
		slug: z.optional(z.string()),
		service_path: z.optional(z.string()),
		long_description: z.optional(z.string()),
		description: z.optional(z.string()),
		events: z.optional(z.array(z.object({}))),
		tags: z.optional(z.array(z.string())),
		icon: z.optional(z.string()),
		manifest_url: z.optional(z.string()),
		environments: z.optional(z.array(z.string())),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const getServicesErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getServicesQueryResponseSchema = z.lazy(() => getServices200Schema);

export const showServicePathParamsSchema = z.object({
	addonName: z.string(),
});

/**
 * @description services
 */
export const showService200Schema = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	slug: z.optional(z.string()),
	service_path: z.optional(z.string()),
	long_description: z.optional(z.string()),
	description: z.optional(z.string()),
	events: z.optional(z.array(z.object({}))),
	tags: z.optional(z.array(z.string())),
	icon: z.optional(z.string()),
	manifest_url: z.optional(z.string()),
	environments: z.optional(z.array(z.string())),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const showServiceErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const showServiceQueryResponseSchema = z.lazy(() => showService200Schema);

export const showServiceManifestPathParamsSchema = z.object({
	addonName: z.string(),
});

/**
 * @description retrieving from provider
 */
export const showServiceManifest201Schema = z.object({});

/**
 * @description error
 */
export const showServiceManifestErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const showServiceManifestQueryResponseSchema = z.lazy(() => showServiceManifest201Schema);

/**
 * @description OK
 */
export const getCurrentUser200Schema = z.object({
	id: z.optional(z.string()),
	uid: z.optional(z.string()),
	full_name: z.optional(z.string()),
	avatar_url: z.optional(z.string()),
	email: z.optional(z.string()),
	affiliate_id: z.optional(z.string()),
	site_count: z.optional(z.int()),
	created_at: z.optional(z.string()),
	last_login: z.optional(z.string()),
	login_providers: z.optional(z.array(z.string())),
	onboarding_progress: z.optional(
		z.object({
			slides: z.optional(z.string()),
		}),
	),
});

/**
 * @description error
 */
export const getCurrentUserErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getCurrentUserQueryResponseSchema = z.lazy(() => getCurrentUser200Schema);

export const createSplitTestPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description Created
 */
export const createSplitTest201Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	name: z.optional(z.string()),
	path: z.optional(z.string()),
	branches: z.optional(z.array(z.object({}))),
	active: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	unpublished_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const createSplitTestErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createSplitTestMutationRequestSchema = z.object({
	branch_tests: z.optional(z.object({})),
});

export const createSplitTestMutationResponseSchema = z.lazy(() => createSplitTest201Schema);

export const getSplitTestsPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description split_tests
 */
export const getSplitTests200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		name: z.optional(z.string()),
		path: z.optional(z.string()),
		branches: z.optional(z.array(z.object({}))),
		active: z.optional(z.boolean()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		unpublished_at: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const getSplitTestsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getSplitTestsQueryResponseSchema = z.lazy(() => getSplitTests200Schema);

export const updateSplitTestPathParamsSchema = z.object({
	site_id: z.string(),
	split_test_id: z.string(),
});

/**
 * @description Created
 */
export const updateSplitTest201Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	name: z.optional(z.string()),
	path: z.optional(z.string()),
	branches: z.optional(z.array(z.object({}))),
	active: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	unpublished_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const updateSplitTestErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateSplitTestMutationRequestSchema = z.object({
	branch_tests: z.optional(z.object({})),
});

export const updateSplitTestMutationResponseSchema = z.lazy(() => updateSplitTest201Schema);

export const getSplitTestPathParamsSchema = z.object({
	site_id: z.string(),
	split_test_id: z.string(),
});

/**
 * @description split_test
 */
export const getSplitTest200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	name: z.optional(z.string()),
	path: z.optional(z.string()),
	branches: z.optional(z.array(z.object({}))),
	active: z.optional(z.boolean()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	unpublished_at: z.optional(z.string()),
});

/**
 * @description error
 */
export const getSplitTestErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getSplitTestQueryResponseSchema = z.lazy(() => getSplitTest200Schema);

export const enableSplitTestPathParamsSchema = z.object({
	site_id: z.string(),
	split_test_id: z.string(),
});

/**
 * @description enable
 */
export const enableSplitTest204Schema = z.unknown();

/**
 * @description error
 */
export const enableSplitTestErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const enableSplitTestMutationResponseSchema = z.lazy(() => enableSplitTest204Schema);

export const disableSplitTestPathParamsSchema = z.object({
	site_id: z.string(),
	split_test_id: z.string(),
});

/**
 * @description disabled
 */
export const disableSplitTest204Schema = z.unknown();

/**
 * @description error
 */
export const disableSplitTestErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const disableSplitTestMutationResponseSchema = z.lazy(() => disableSplitTest204Schema);

/**
 * @description Created
 */
export const createDnsZone201Schema = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	errors: z.optional(z.array(z.string())),
	supported_record_types: z.optional(z.array(z.string())),
	user_id: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	records: z.optional(
		z.array(
			z.object({
				id: z.optional(z.string()),
				hostname: z.optional(z.string()),
				type: z.optional(z.string()),
				value: z.optional(z.string()),
				ttl: z.optional(z.int()),
				priority: z.optional(z.int()),
				dns_zone_id: z.optional(z.string()),
				site_id: z.optional(z.string()),
				flag: z.optional(z.int()),
				tag: z.optional(z.string()),
				managed: z.optional(z.boolean()),
			}),
		),
	),
	dns_servers: z.optional(z.array(z.string())),
	account_id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	account_name: z.optional(z.string()),
	domain: z.optional(z.string()),
	ipv6_enabled: z.optional(z.boolean()),
	dedicated: z.optional(z.boolean()),
});

/**
 * @description error
 */
export const createDnsZoneErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createDnsZoneMutationRequestSchema = z.object({
	account_slug: z.optional(z.string()),
	site_id: z.optional(z.string()),
	name: z.optional(z.string()),
});

export const createDnsZoneMutationResponseSchema = z.lazy(() => createDnsZone201Schema);

export const getDnsZonesQueryParamsSchema = z
	.object({
		account_slug: z.optional(z.string()),
	})
	.optional();

/**
 * @description get all DNS zones the user has access to
 */
export const getDnsZones200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		name: z.optional(z.string()),
		errors: z.optional(z.array(z.string())),
		supported_record_types: z.optional(z.array(z.string())),
		user_id: z.optional(z.string()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		records: z.optional(
			z.array(
				z.object({
					id: z.optional(z.string()),
					hostname: z.optional(z.string()),
					type: z.optional(z.string()),
					value: z.optional(z.string()),
					ttl: z.optional(z.int()),
					priority: z.optional(z.int()),
					dns_zone_id: z.optional(z.string()),
					site_id: z.optional(z.string()),
					flag: z.optional(z.int()),
					tag: z.optional(z.string()),
					managed: z.optional(z.boolean()),
				}),
			),
		),
		dns_servers: z.optional(z.array(z.string())),
		account_id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		account_slug: z.optional(z.string()),
		account_name: z.optional(z.string()),
		domain: z.optional(z.string()),
		ipv6_enabled: z.optional(z.boolean()),
		dedicated: z.optional(z.boolean()),
	}),
);

/**
 * @description error
 */
export const getDnsZonesErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getDnsZonesQueryResponseSchema = z.lazy(() => getDnsZones200Schema);

export const getDnsZonePathParamsSchema = z.object({
	zone_id: z.string(),
});

/**
 * @description get a single DNS zone
 */
export const getDnsZone200Schema = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	errors: z.optional(z.array(z.string())),
	supported_record_types: z.optional(z.array(z.string())),
	user_id: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	records: z.optional(
		z.array(
			z.object({
				id: z.optional(z.string()),
				hostname: z.optional(z.string()),
				type: z.optional(z.string()),
				value: z.optional(z.string()),
				ttl: z.optional(z.int()),
				priority: z.optional(z.int()),
				dns_zone_id: z.optional(z.string()),
				site_id: z.optional(z.string()),
				flag: z.optional(z.int()),
				tag: z.optional(z.string()),
				managed: z.optional(z.boolean()),
			}),
		),
	),
	dns_servers: z.optional(z.array(z.string())),
	account_id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	account_name: z.optional(z.string()),
	domain: z.optional(z.string()),
	ipv6_enabled: z.optional(z.boolean()),
	dedicated: z.optional(z.boolean()),
});

/**
 * @description error
 */
export const getDnsZoneErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getDnsZoneQueryResponseSchema = z.lazy(() => getDnsZone200Schema);

export const deleteDnsZonePathParamsSchema = z.object({
	zone_id: z.string(),
});

/**
 * @description delete a single DNS zone
 */
export const deleteDnsZone204Schema = z.unknown();

/**
 * @description error
 */
export const deleteDnsZoneErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteDnsZoneMutationResponseSchema = z.lazy(() => deleteDnsZone204Schema);

export const transferDnsZonePathParamsSchema = z.object({
	zone_id: z.string(),
});

export const transferDnsZoneQueryParamsSchema = z.object({
	account_id: z.string().describe("the account of the dns zone"),
	transfer_account_id: z.string().describe("the account you want to transfer the dns zone to"),
	transfer_user_id: z.string().describe("the user you want to transfer the dns zone to"),
});

/**
 * @description transfer a DNS zone to another account
 */
export const transferDnsZone200Schema = z.object({
	id: z.optional(z.string()),
	name: z.optional(z.string()),
	errors: z.optional(z.array(z.string())),
	supported_record_types: z.optional(z.array(z.string())),
	user_id: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	records: z.optional(
		z.array(
			z.object({
				id: z.optional(z.string()),
				hostname: z.optional(z.string()),
				type: z.optional(z.string()),
				value: z.optional(z.string()),
				ttl: z.optional(z.int()),
				priority: z.optional(z.int()),
				dns_zone_id: z.optional(z.string()),
				site_id: z.optional(z.string()),
				flag: z.optional(z.int()),
				tag: z.optional(z.string()),
				managed: z.optional(z.boolean()),
			}),
		),
	),
	dns_servers: z.optional(z.array(z.string())),
	account_id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	account_slug: z.optional(z.string()),
	account_name: z.optional(z.string()),
	domain: z.optional(z.string()),
	ipv6_enabled: z.optional(z.boolean()),
	dedicated: z.optional(z.boolean()),
});

/**
 * @description error
 */
export const transferDnsZoneErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const transferDnsZoneMutationResponseSchema = z.lazy(() => transferDnsZone200Schema);

export const getDnsRecordsPathParamsSchema = z.object({
	zone_id: z.string(),
});

/**
 * @description get all DNS records for a single DNS zone
 */
export const getDnsRecords200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		hostname: z.optional(z.string()),
		type: z.optional(z.string()),
		value: z.optional(z.string()),
		ttl: z.optional(z.int()),
		priority: z.optional(z.int()),
		dns_zone_id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		flag: z.optional(z.int()),
		tag: z.optional(z.string()),
		managed: z.optional(z.boolean()),
	}),
);

/**
 * @description error
 */
export const getDnsRecordsErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getDnsRecordsQueryResponseSchema = z.lazy(() => getDnsRecords200Schema);

export const createDnsRecordPathParamsSchema = z.object({
	zone_id: z.string(),
});

/**
 * @description Created
 */
export const createDnsRecord201Schema = z.object({
	id: z.optional(z.string()),
	hostname: z.optional(z.string()),
	type: z.optional(z.string()),
	value: z.optional(z.string()),
	ttl: z.optional(z.int()),
	priority: z.optional(z.int()),
	dns_zone_id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	flag: z.optional(z.int()),
	tag: z.optional(z.string()),
	managed: z.optional(z.boolean()),
});

/**
 * @description error
 */
export const createDnsRecordErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createDnsRecordMutationRequestSchema = z.object({
	type: z.optional(z.string()),
	hostname: z.optional(z.string()),
	value: z.optional(z.string()),
	ttl: z.optional(z.int()),
	priority: z.optional(z.int()),
	weight: z.optional(z.int()),
	port: z.optional(z.int()),
	flag: z.optional(z.int()),
	tag: z.optional(z.string()),
});

export const createDnsRecordMutationResponseSchema = z.lazy(() => createDnsRecord201Schema);

export const getIndividualDnsRecordPathParamsSchema = z.object({
	zone_id: z.string(),
	dns_record_id: z.string(),
});

/**
 * @description get a single DNS record
 */
export const getIndividualDnsRecord200Schema = z.object({
	id: z.optional(z.string()),
	hostname: z.optional(z.string()),
	type: z.optional(z.string()),
	value: z.optional(z.string()),
	ttl: z.optional(z.int()),
	priority: z.optional(z.int()),
	dns_zone_id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	flag: z.optional(z.int()),
	tag: z.optional(z.string()),
	managed: z.optional(z.boolean()),
});

/**
 * @description error
 */
export const getIndividualDnsRecordErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getIndividualDnsRecordQueryResponseSchema = z.lazy(
	() => getIndividualDnsRecord200Schema,
);

export const deleteDnsRecordPathParamsSchema = z.object({
	zone_id: z.string(),
	dns_record_id: z.string(),
});

/**
 * @description record deleted
 */
export const deleteDnsRecord204Schema = z.unknown();

/**
 * @description error
 */
export const deleteDnsRecordErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteDnsRecordMutationResponseSchema = z.lazy(() => deleteDnsRecord204Schema);

export const listSiteDevServersPathParamsSchema = z.object({
	site_id: z.string(),
});

export const listSiteDevServersQueryParamsSchema = z
	.object({
		page: z.optional(z.coerce.number().int()),
		per_page: z.optional(z.coerce.number().int()),
	})
	.optional();

/**
 * @description OK
 */
export const listSiteDevServers200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		branch: z.optional(z.string()),
		url: z.optional(z.string()),
		state: z.optional(z.string()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		starting_at: z.optional(z.string()),
		error_at: z.optional(z.string()),
		live_at: z.optional(z.string()),
		done_at: z.optional(z.string()),
		title: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const listSiteDevServersErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listSiteDevServersQueryResponseSchema = z.lazy(() => listSiteDevServers200Schema);

export const createSiteDevServerPathParamsSchema = z.object({
	site_id: z.string(),
});

export const createSiteDevServerQueryParamsSchema = z
	.object({
		branch: z.optional(z.string()),
	})
	.optional();

/**
 * @description OK
 */
export const createSiteDevServer200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		site_id: z.optional(z.string()),
		branch: z.optional(z.string()),
		url: z.optional(z.string()),
		state: z.optional(z.string()),
		created_at: z.optional(z.string()),
		updated_at: z.optional(z.string()),
		starting_at: z.optional(z.string()),
		error_at: z.optional(z.string()),
		live_at: z.optional(z.string()),
		done_at: z.optional(z.string()),
		title: z.optional(z.string()),
	}),
);

/**
 * @description error
 */
export const createSiteDevServerErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createSiteDevServerMutationResponseSchema = z.lazy(() => createSiteDevServer200Schema);

export const deleteSiteDevServersPathParamsSchema = z.object({
	site_id: z.string(),
});

export const deleteSiteDevServersQueryParamsSchema = z
	.object({
		branch: z.optional(z.string()),
	})
	.optional();

/**
 * @description OK
 */
export const deleteSiteDevServers202Schema = z.unknown();

/**
 * @description error
 */
export const deleteSiteDevServersErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteSiteDevServersMutationResponseSchema = z.lazy(
	() => deleteSiteDevServers202Schema,
);

export const getSiteDevServerPathParamsSchema = z.object({
	site_id: z.string(),
	dev_server_id: z.string(),
});

/**
 * @description OK
 */
export const getSiteDevServer200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	branch: z.optional(z.string()),
	url: z.optional(z.string()),
	state: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	starting_at: z.optional(z.string()),
	error_at: z.optional(z.string()),
	live_at: z.optional(z.string()),
	done_at: z.optional(z.string()),
	title: z.optional(z.string()),
});

export const getSiteDevServerQueryResponseSchema = z.lazy(() => getSiteDevServer200Schema);

export const markDevServerActivityPathParamsSchema = z.object({
	site_id: z.string(),
	dev_server_id: z.string(),
});

/**
 * @description OK
 */
export const markDevServerActivity200Schema = z.unknown();

export const markDevServerActivityMutationResponseSchema = z.lazy(
	() => markDevServerActivity200Schema,
);

export const updateDevServerStatePathParamsSchema = z.object({
	site_id: z.string(),
	dev_server_id: z.string(),
});

/**
 * @description OK
 */
export const updateDevServerState200Schema = z.object({
	id: z.optional(z.string()),
	site_id: z.optional(z.string()),
	branch: z.optional(z.string()),
	url: z.optional(z.string()),
	state: z.optional(z.string()),
	created_at: z.optional(z.string()),
	updated_at: z.optional(z.string()),
	starting_at: z.optional(z.string()),
	error_at: z.optional(z.string()),
	live_at: z.optional(z.string()),
	done_at: z.optional(z.string()),
	title: z.optional(z.string()),
});

/**
 * @description Conflict
 */
export const updateDevServerState409Schema = z.unknown();

export const updateDevServerStateMutationRequestSchema = z.object({
	state: z.enum(["starting", "live", "error", "done"]),
	task_id: z.optional(z.string()),
	error: z.optional(z.string()),
});

export const updateDevServerStateMutationResponseSchema = z.lazy(
	() => updateDevServerState200Schema,
);

export const listSiteDevServerHooksPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description OK
 */
export const listSiteDevServerHooks200Schema = z.array(
	z.object({
		id: z.optional(z.string()),
		title: z.optional(z.string()),
		branch: z.optional(z.string()),
		url: z.optional(z.string()),
		site_id: z.optional(z.string()),
		created_at: z.optional(z.string()),
		type: z.optional(z.enum(["new_dev_server", "content_refresh"])),
	}),
);

/**
 * @description error
 */
export const listSiteDevServerHooksErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const listSiteDevServerHooksQueryResponseSchema = z.lazy(
	() => listSiteDevServerHooks200Schema,
);

export const createSiteDevServerHookPathParamsSchema = z.object({
	site_id: z.string(),
});

/**
 * @description Created
 */
export const createSiteDevServerHook201Schema = z.object({
	id: z.optional(z.string()),
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	url: z.optional(z.string()),
	site_id: z.optional(z.string()),
	created_at: z.optional(z.string()),
	type: z.optional(z.enum(["new_dev_server", "content_refresh"])),
});

/**
 * @description error
 */
export const createSiteDevServerHookErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const createSiteDevServerHookMutationRequestSchema = z.object({
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	type: z.optional(z.enum(["new_dev_server", "content_refresh"])),
});

export const createSiteDevServerHookMutationResponseSchema = z.lazy(
	() => createSiteDevServerHook201Schema,
);

export const getSiteDevServerHookPathParamsSchema = z.object({
	site_id: z.string(),
	id: z.string(),
});

/**
 * @description OK
 */
export const getSiteDevServerHook200Schema = z.object({
	id: z.optional(z.string()),
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	url: z.optional(z.string()),
	site_id: z.optional(z.string()),
	created_at: z.optional(z.string()),
	type: z.optional(z.enum(["new_dev_server", "content_refresh"])),
});

/**
 * @description error
 */
export const getSiteDevServerHookErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getSiteDevServerHookQueryResponseSchema = z.lazy(() => getSiteDevServerHook200Schema);

export const updateSiteDevServerHookPathParamsSchema = z.object({
	site_id: z.string(),
	id: z.string(),
});

/**
 * @description No content
 */
export const updateSiteDevServerHook204Schema = z.unknown();

/**
 * @description error
 */
export const updateSiteDevServerHookErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const updateSiteDevServerHookMutationRequestSchema = z.object({
	title: z.optional(z.string()),
	branch: z.optional(z.string()),
	type: z.optional(z.enum(["new_dev_server", "content_refresh"])),
});

export const updateSiteDevServerHookMutationResponseSchema = z.lazy(
	() => updateSiteDevServerHook204Schema,
);

export const deleteSiteDevServerHookPathParamsSchema = z.object({
	site_id: z.string(),
	id: z.string(),
});

/**
 * @description No content
 */
export const deleteSiteDevServerHook204Schema = z.unknown();

/**
 * @description error
 */
export const deleteSiteDevServerHookErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const deleteSiteDevServerHookMutationResponseSchema = z.lazy(
	() => deleteSiteDevServerHook204Schema,
);

/**
 * @description The mapping of providers and supported models
 */
export const getAIGatewayProviders200Schema = z.object({
	providers: z.optional(
		z.object({}).catchall(
			z.object({
				token_env_var: z.optional(z.string()),
				url_env_var: z.optional(z.string()),
				models: z.optional(z.array(z.string())),
			}),
		),
	),
});

/**
 * @description error
 */
export const getAIGatewayProvidersErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getAIGatewayProvidersQueryResponseSchema = z.lazy(
	() => getAIGatewayProviders200Schema,
);

export const getAIGatewayTokenPathParamsSchema = z.object({
	site_id: z.string().describe("The site ID"),
});

/**
 * @description AI Gateway token for the site
 */
export const getAIGatewayToken200Schema = z.object({
	token: z.optional(z.string().describe("The AI Gateway authentication token")),
	url: z.optional(z.string().describe("AI gateway base url")),
	expires_at: z.optional(z.int().describe("Unix timestamp when the token expires")),
});

/**
 * @description AI Gateway not available for this site
 */
export const getAIGatewayToken404Schema = z.unknown();

/**
 * @description error
 */
export const getAIGatewayTokenErrorSchema = z.object({
	code: z.optional(z.int()),
	message: z.string(),
});

export const getAIGatewayTokenQueryResponseSchema = z.lazy(() => getAIGatewayToken200Schema);
