/**
 * Generated by Kubb (https://kubb.dev/).
 * Do not edit manually.
 */

import {
	ApiClient,
	type ApiError,
	createClient,
	makeApiClientFromEnv,
	makeApiClientLive,
	NetworkError,
	runWithClient,
	serializeQueryParams,
	ValidationError,
} from "@sferadev/openapi-utils/effect";
import { Effect } from "effect";
import type {
	AcceptProjectTransferRequest400,
	AcceptProjectTransferRequest401,
	AcceptProjectTransferRequest403,
	AcceptProjectTransferRequest404,
	AcceptProjectTransferRequest422,
	AcceptProjectTransferRequestMutationResponse,
	AcceptProjectTransferRequestPathParams,
	AcceptProjectTransferRequestQueryParams,
	AddBypassIp400,
	AddBypassIp401,
	AddBypassIp403,
	AddBypassIp404,
	AddBypassIp500,
	AddBypassIpMutationResponse,
	AddBypassIpQueryParams,
	AddProjectDomain400,
	AddProjectDomain401,
	AddProjectDomain402,
	AddProjectDomain403,
	AddProjectDomain409,
	AddProjectDomainMutationResponse,
	AddProjectDomainPathParams,
	AddProjectDomainQueryParams,
	AddProjectMember400,
	AddProjectMember401,
	AddProjectMember403,
	AddProjectMember500,
	AddProjectMemberMutationResponse,
	AddProjectMemberPathParams,
	AddProjectMemberQueryParams,
	ApproveRollingReleaseStage400,
	ApproveRollingReleaseStage401,
	ApproveRollingReleaseStage403,
	ApproveRollingReleaseStage404,
	ApproveRollingReleaseStage500,
	ApproveRollingReleaseStageMutationResponse,
	ApproveRollingReleaseStagePathParams,
	ApproveRollingReleaseStageQueryParams,
	ArtifactQuery400,
	ArtifactQuery401,
	ArtifactQuery402,
	ArtifactQuery403,
	ArtifactQueryMutationResponse,
	ArtifactQueryQueryParams,
	AssignAlias400,
	AssignAlias401,
	AssignAlias402,
	AssignAlias403,
	AssignAlias404,
	AssignAlias409,
	AssignAliasMutationResponse,
	AssignAliasPathParams,
	AssignAliasQueryParams,
	BatchRemoveProjectEnv400,
	BatchRemoveProjectEnv401,
	BatchRemoveProjectEnv403,
	BatchRemoveProjectEnv404,
	BatchRemoveProjectEnv409,
	BatchRemoveProjectEnvMutationResponse,
	BatchRemoveProjectEnvPathParams,
	BatchRemoveProjectEnvQueryParams,
	BuyDomains400,
	BuyDomains401,
	BuyDomains403,
	BuyDomains429,
	BuyDomains500,
	BuyDomainsMutationResponse,
	BuyDomainsQueryParams,
	BuySingleDomain400,
	BuySingleDomain401,
	BuySingleDomain403,
	BuySingleDomain429,
	BuySingleDomain500,
	BuySingleDomainMutationResponse,
	BuySingleDomainPathParams,
	BuySingleDomainQueryParams,
	CancelDeployment400,
	CancelDeployment401,
	CancelDeployment403,
	CancelDeployment404,
	CancelDeploymentMutationResponse,
	CancelDeploymentPathParams,
	CancelDeploymentQueryParams,
	CompleteRollingRelease400,
	CompleteRollingRelease401,
	CompleteRollingRelease403,
	CompleteRollingRelease404,
	CompleteRollingReleaseMutationResponse,
	CompleteRollingReleasePathParams,
	CompleteRollingReleaseQueryParams,
	ConnectIntegrationResourceToProject400,
	ConnectIntegrationResourceToProject401,
	ConnectIntegrationResourceToProject403,
	ConnectIntegrationResourceToProject404,
	ConnectIntegrationResourceToProjectMutationResponse,
	ConnectIntegrationResourceToProjectPathParams,
	ConnectIntegrationResourceToProjectQueryParams,
	CreateAccessGroup400,
	CreateAccessGroup401,
	CreateAccessGroup403,
	CreateAccessGroupMutationResponse,
	CreateAccessGroupProject400,
	CreateAccessGroupProject401,
	CreateAccessGroupProject403,
	CreateAccessGroupProjectMutationResponse,
	CreateAccessGroupProjectPathParams,
	CreateAccessGroupProjectQueryParams,
	CreateAccessGroupQueryParams,
	CreateAuthToken400,
	CreateAuthToken401,
	CreateAuthToken403,
	CreateAuthTokenMutationResponse,
	CreateAuthTokenQueryParams,
	CreateCheck400,
	CreateCheck401,
	CreateCheck403,
	CreateCheck404,
	CreateCheckMutationResponse,
	CreateCheckPathParams,
	CreateCheckQueryParams,
	CreateConfigurableLogDrain400,
	CreateConfigurableLogDrain401,
	CreateConfigurableLogDrain403,
	CreateConfigurableLogDrainMutationResponse,
	CreateConfigurableLogDrainQueryParams,
	CreateCustomEnvironment400,
	CreateCustomEnvironment401,
	CreateCustomEnvironment402,
	CreateCustomEnvironment403,
	CreateCustomEnvironment500,
	CreateCustomEnvironmentMutationResponse,
	CreateCustomEnvironmentPathParams,
	CreateCustomEnvironmentQueryParams,
	CreateDeployment400,
	CreateDeployment401,
	CreateDeployment402,
	CreateDeployment403,
	CreateDeployment404,
	CreateDeployment409,
	CreateDeployment500,
	CreateDeploymentMutationResponse,
	CreateDeploymentQueryParams,
	CreateDrain400,
	CreateDrain401,
	CreateDrain403,
	CreateDrainMutationResponse,
	CreateDrainQueryParams,
	CreateEdgeConfig400,
	CreateEdgeConfig401,
	CreateEdgeConfig402,
	CreateEdgeConfig403,
	CreateEdgeConfigMutationResponse,
	CreateEdgeConfigQueryParams,
	CreateEdgeConfigToken400,
	CreateEdgeConfigToken401,
	CreateEdgeConfigToken402,
	CreateEdgeConfigToken403,
	CreateEdgeConfigToken404,
	CreateEdgeConfigToken409,
	CreateEdgeConfigTokenMutationResponse,
	CreateEdgeConfigTokenPathParams,
	CreateEdgeConfigTokenQueryParams,
	CreateEvent400,
	CreateEvent401,
	CreateEvent403,
	CreateEvent404,
	CreateEventMutationResponse,
	CreateEventPathParams,
	CreateExperimentationItem400,
	CreateExperimentationItem401,
	CreateExperimentationItem403,
	CreateExperimentationItem404,
	CreateExperimentationItemMutationResponse,
	CreateExperimentationItemPathParams,
	CreateIntegrationStoreDirect400,
	CreateIntegrationStoreDirect401,
	CreateIntegrationStoreDirect402,
	CreateIntegrationStoreDirect403,
	CreateIntegrationStoreDirect404,
	CreateIntegrationStoreDirect409,
	CreateIntegrationStoreDirect429,
	CreateIntegrationStoreDirect500,
	CreateIntegrationStoreDirectMutationResponse,
	CreateIntegrationStoreDirectQueryParams,
	CreateLogDrain400,
	CreateLogDrain401,
	CreateLogDrain403,
	CreateLogDrainMutationResponse,
	CreateLogDrainQueryParams,
	CreateNetwork400,
	CreateNetwork401,
	CreateNetwork402,
	CreateNetwork403,
	CreateNetwork404,
	CreateNetwork409,
	CreateNetworkMutationResponse,
	CreateNetworkQueryParams,
	CreateOrTransferDomain400,
	CreateOrTransferDomain401,
	CreateOrTransferDomain402,
	CreateOrTransferDomain403,
	CreateOrTransferDomain404,
	CreateOrTransferDomain409,
	CreateOrTransferDomainMutationResponse,
	CreateOrTransferDomainQueryParams,
	CreateProject400,
	CreateProject401,
	CreateProject402,
	CreateProject403,
	CreateProject404,
	CreateProject409,
	CreateProject428,
	CreateProject429,
	CreateProject500,
	CreateProjectEnv400,
	CreateProjectEnv401,
	CreateProjectEnv402,
	CreateProjectEnv403,
	CreateProjectEnv404,
	CreateProjectEnv409,
	CreateProjectEnv429,
	CreateProjectEnv500,
	CreateProjectEnvMutationResponse,
	CreateProjectEnvPathParams,
	CreateProjectEnvQueryParams,
	CreateProjectMutationResponse,
	CreateProjectQueryParams,
	CreateProjectTransferRequest400,
	CreateProjectTransferRequest401,
	CreateProjectTransferRequest403,
	CreateProjectTransferRequestMutationResponse,
	CreateProjectTransferRequestPathParams,
	CreateProjectTransferRequestQueryParams,
	CreateRecord400,
	CreateRecord401,
	CreateRecord402,
	CreateRecord403,
	CreateRecord404,
	CreateRecord409,
	CreateRecordMutationResponse,
	CreateRecordPathParams,
	CreateRecordQueryParams,
	CreateSharedEnvVariable400,
	CreateSharedEnvVariable401,
	CreateSharedEnvVariable402,
	CreateSharedEnvVariable403,
	CreateSharedEnvVariableMutationResponse,
	CreateSharedEnvVariableQueryParams,
	CreateTeam400,
	CreateTeam401,
	CreateTeam403,
	CreateTeamMutationResponse,
	CreateWebhook400,
	CreateWebhook401,
	CreateWebhook403,
	CreateWebhookMutationResponse,
	CreateWebhookQueryParams,
	DangerouslyDeleteBySrcImages400,
	DangerouslyDeleteBySrcImages401,
	DangerouslyDeleteBySrcImages402,
	DangerouslyDeleteBySrcImages403,
	DangerouslyDeleteBySrcImages404,
	DangerouslyDeleteBySrcImagesMutationResponse,
	DangerouslyDeleteBySrcImagesQueryParams,
	DangerouslyDeleteByTags400,
	DangerouslyDeleteByTags401,
	DangerouslyDeleteByTags403,
	DangerouslyDeleteByTags404,
	DangerouslyDeleteByTagsMutationResponse,
	DangerouslyDeleteByTagsQueryParams,
	DeleteAccessGroup400,
	DeleteAccessGroup401,
	DeleteAccessGroup403,
	DeleteAccessGroupMutationResponse,
	DeleteAccessGroupPathParams,
	DeleteAccessGroupProject400,
	DeleteAccessGroupProject401,
	DeleteAccessGroupProject403,
	DeleteAccessGroupProjectMutationResponse,
	DeleteAccessGroupProjectPathParams,
	DeleteAccessGroupProjectQueryParams,
	DeleteAccessGroupQueryParams,
	DeleteAlias400,
	DeleteAlias401,
	DeleteAlias403,
	DeleteAlias404,
	DeleteAliasMutationResponse,
	DeleteAliasPathParams,
	DeleteAliasQueryParams,
	DeleteAuthToken400,
	DeleteAuthToken401,
	DeleteAuthToken403,
	DeleteAuthToken404,
	DeleteAuthTokenMutationResponse,
	DeleteAuthTokenPathParams,
	DeleteConfigurableLogDrain400,
	DeleteConfigurableLogDrain401,
	DeleteConfigurableLogDrain403,
	DeleteConfigurableLogDrain404,
	DeleteConfigurableLogDrainMutationResponse,
	DeleteConfigurableLogDrainPathParams,
	DeleteConfigurableLogDrainQueryParams,
	DeleteConfiguration400,
	DeleteConfiguration401,
	DeleteConfiguration403,
	DeleteConfiguration404,
	DeleteConfigurationMutationResponse,
	DeleteConfigurationPathParams,
	DeleteConfigurationQueryParams,
	DeleteDeployment400,
	DeleteDeployment401,
	DeleteDeployment403,
	DeleteDeployment404,
	DeleteDeploymentMutationResponse,
	DeleteDeploymentPathParams,
	DeleteDeploymentQueryParams,
	DeleteDomain400,
	DeleteDomain401,
	DeleteDomain403,
	DeleteDomain404,
	DeleteDomain409,
	DeleteDomainMutationResponse,
	DeleteDomainPathParams,
	DeleteDomainQueryParams,
	DeleteDrain400,
	DeleteDrain401,
	DeleteDrain403,
	DeleteDrain404,
	DeleteDrainMutationResponse,
	DeleteDrainPathParams,
	DeleteDrainQueryParams,
	DeleteEdgeConfig400,
	DeleteEdgeConfig401,
	DeleteEdgeConfig403,
	DeleteEdgeConfig404,
	DeleteEdgeConfig409,
	DeleteEdgeConfigMutationResponse,
	DeleteEdgeConfigPathParams,
	DeleteEdgeConfigQueryParams,
	DeleteEdgeConfigSchema400,
	DeleteEdgeConfigSchema401,
	DeleteEdgeConfigSchema402,
	DeleteEdgeConfigSchema403,
	DeleteEdgeConfigSchema404,
	DeleteEdgeConfigSchema409,
	DeleteEdgeConfigSchemaMutationResponse,
	DeleteEdgeConfigSchemaPathParams,
	DeleteEdgeConfigSchemaQueryParams,
	DeleteEdgeConfigTokens400,
	DeleteEdgeConfigTokens401,
	DeleteEdgeConfigTokens402,
	DeleteEdgeConfigTokens403,
	DeleteEdgeConfigTokens404,
	DeleteEdgeConfigTokens409,
	DeleteEdgeConfigTokensMutationResponse,
	DeleteEdgeConfigTokensPathParams,
	DeleteEdgeConfigTokensQueryParams,
	DeleteExperimentationItem400,
	DeleteExperimentationItem401,
	DeleteExperimentationItem403,
	DeleteExperimentationItem404,
	DeleteExperimentationItemMutationResponse,
	DeleteExperimentationItemPathParams,
	DeleteIntegrationLogDrain400,
	DeleteIntegrationLogDrain401,
	DeleteIntegrationLogDrain403,
	DeleteIntegrationLogDrain404,
	DeleteIntegrationLogDrainMutationResponse,
	DeleteIntegrationLogDrainPathParams,
	DeleteIntegrationLogDrainQueryParams,
	DeleteIntegrationResource400,
	DeleteIntegrationResource401,
	DeleteIntegrationResource403,
	DeleteIntegrationResource404,
	DeleteIntegrationResourceMutationResponse,
	DeleteIntegrationResourcePathParams,
	DeleteNetwork400,
	DeleteNetwork401,
	DeleteNetwork402,
	DeleteNetwork403,
	DeleteNetwork404,
	DeleteNetwork409,
	DeleteNetworkMutationResponse,
	DeleteNetworkPathParams,
	DeleteNetworkQueryParams,
	DeleteProject400,
	DeleteProject401,
	DeleteProject403,
	DeleteProject409,
	DeleteProjectMutationResponse,
	DeleteProjectPathParams,
	DeleteProjectQueryParams,
	DeleteRedirects400,
	DeleteRedirects401,
	DeleteRedirects403,
	DeleteRedirects404,
	DeleteRedirects500,
	DeleteRedirectsMutationResponse,
	DeleteRedirectsQueryParams,
	DeleteRollingReleaseConfig400,
	DeleteRollingReleaseConfig401,
	DeleteRollingReleaseConfig403,
	DeleteRollingReleaseConfig404,
	DeleteRollingReleaseConfigMutationResponse,
	DeleteRollingReleaseConfigPathParams,
	DeleteRollingReleaseConfigQueryParams,
	DeleteSharedEnvVariable400,
	DeleteSharedEnvVariable401,
	DeleteSharedEnvVariable402,
	DeleteSharedEnvVariable403,
	DeleteSharedEnvVariableMutationResponse,
	DeleteSharedEnvVariableQueryParams,
	DeleteTeam400,
	DeleteTeam401,
	DeleteTeam402,
	DeleteTeam403,
	DeleteTeam409,
	DeleteTeamInviteCode400,
	DeleteTeamInviteCode401,
	DeleteTeamInviteCode403,
	DeleteTeamInviteCode404,
	DeleteTeamInviteCodeMutationResponse,
	DeleteTeamInviteCodePathParams,
	DeleteTeamMutationResponse,
	DeleteTeamPathParams,
	DeleteTeamQueryParams,
	DeleteWebhook400,
	DeleteWebhook401,
	DeleteWebhook403,
	DeleteWebhookMutationResponse,
	DeleteWebhookPathParams,
	DeleteWebhookQueryParams,
	DownloadArtifact400,
	DownloadArtifact401,
	DownloadArtifact402,
	DownloadArtifact403,
	DownloadArtifact404,
	DownloadArtifactHeaderParams,
	DownloadArtifactPathParams,
	DownloadArtifactQueryParams,
	DownloadArtifactQueryResponse,
	EditProjectEnv400,
	EditProjectEnv401,
	EditProjectEnv403,
	EditProjectEnv404,
	EditProjectEnv409,
	EditProjectEnv429,
	EditProjectEnv500,
	EditProjectEnvMutationResponse,
	EditProjectEnvPathParams,
	EditProjectEnvQueryParams,
	EditRedirect400,
	EditRedirect401,
	EditRedirect403,
	EditRedirect404,
	EditRedirect500,
	EditRedirectMutationResponse,
	EditRedirectQueryParams,
	ExchangeSsoToken400,
	ExchangeSsoToken403,
	ExchangeSsoToken500,
	ExchangeSsoTokenMutationResponse,
	FilterProjectEnvs400,
	FilterProjectEnvs401,
	FilterProjectEnvs403,
	FilterProjectEnvsPathParams,
	FilterProjectEnvsQueryParams,
	FilterProjectEnvsQueryResponse,
	GETV1SecurityFirewallEvents400,
	GETV1SecurityFirewallEvents401,
	GETV1SecurityFirewallEvents403,
	GETV1SecurityFirewallEvents404,
	GETV1SecurityFirewallEvents500,
	GETV1SecurityFirewallEventsQueryParams,
	GETV1SecurityFirewallEventsQueryResponse,
	GetAccountInfo400,
	GetAccountInfo401,
	GetAccountInfo403,
	GetAccountInfo404,
	GetAccountInfoPathParams,
	GetAccountInfoQueryResponse,
	GetActiveAttackStatus400,
	GetActiveAttackStatus401,
	GetActiveAttackStatus403,
	GetActiveAttackStatus404,
	GetActiveAttackStatusQueryParams,
	GetActiveAttackStatusQueryResponse,
	GetAlias400,
	GetAlias401,
	GetAlias403,
	GetAlias404,
	GetAliasPathParams,
	GetAliasQueryParams,
	GetAliasQueryResponse,
	GetAllChecks400,
	GetAllChecks401,
	GetAllChecks403,
	GetAllChecks404,
	GetAllChecksPathParams,
	GetAllChecksQueryParams,
	GetAllChecksQueryResponse,
	GetAllLogDrains400,
	GetAllLogDrains401,
	GetAllLogDrains403,
	GetAllLogDrains404,
	GetAllLogDrainsQueryParams,
	GetAllLogDrainsQueryResponse,
	GetAuthToken400,
	GetAuthToken401,
	GetAuthToken403,
	GetAuthToken404,
	GetAuthTokenPathParams,
	GetAuthTokenQueryResponse,
	GetAuthUser400,
	GetAuthUser401,
	GetAuthUser403,
	GetAuthUser409,
	GetAuthUserQueryResponse,
	GetBillingPlans400,
	GetBillingPlans401,
	GetBillingPlans403,
	GetBillingPlans404,
	GetBillingPlansPathParams,
	GetBillingPlansQueryParams,
	GetBillingPlansQueryResponse,
	GetBulkAvailability400,
	GetBulkAvailability401,
	GetBulkAvailability403,
	GetBulkAvailability429,
	GetBulkAvailability500,
	GetBulkAvailabilityMutationResponse,
	GetBulkAvailabilityQueryParams,
	GetBypassIp400,
	GetBypassIp401,
	GetBypassIp403,
	GetBypassIp404,
	GetBypassIp500,
	GetBypassIpQueryParams,
	GetBypassIpQueryResponse,
	GetCertById400,
	GetCertById401,
	GetCertById403,
	GetCertById404,
	GetCertByIdPathParams,
	GetCertByIdQueryParams,
	GetCertByIdQueryResponse,
	GetCheck400,
	GetCheck401,
	GetCheck403,
	GetCheck404,
	GetCheckPathParams,
	GetCheckQueryParams,
	GetCheckQueryResponse,
	GetConfigurableLogDrain400,
	GetConfigurableLogDrain401,
	GetConfigurableLogDrain403,
	GetConfigurableLogDrain404,
	GetConfigurableLogDrainPathParams,
	GetConfigurableLogDrainQueryParams,
	GetConfigurableLogDrainQueryResponse,
	GetConfiguration400,
	GetConfiguration401,
	GetConfiguration403,
	GetConfiguration404,
	GetConfigurationPathParams,
	GetConfigurationProducts400,
	GetConfigurationProducts401,
	GetConfigurationProducts403,
	GetConfigurationProducts404,
	GetConfigurationProducts500,
	GetConfigurationProductsPathParams,
	GetConfigurationProductsQueryParams,
	GetConfigurationProductsQueryResponse,
	GetConfigurationQueryParams,
	GetConfigurationQueryResponse,
	GetConfigurations400,
	GetConfigurations401,
	GetConfigurations403,
	GetConfigurationsQueryParams,
	GetConfigurationsQueryResponse,
	GetContactInfoSchema400,
	GetContactInfoSchema401,
	GetContactInfoSchema403,
	GetContactInfoSchema429,
	GetContactInfoSchema500,
	GetContactInfoSchemaPathParams,
	GetContactInfoSchemaQueryParams,
	GetContactInfoSchemaQueryResponse,
	GetCustomEnvironment400,
	GetCustomEnvironment401,
	GetCustomEnvironment403,
	GetCustomEnvironment404,
	GetCustomEnvironmentPathParams,
	GetCustomEnvironmentQueryParams,
	GetCustomEnvironmentQueryResponse,
	GetDeployment400,
	GetDeployment403,
	GetDeployment404,
	GetDeploymentEvents400,
	GetDeploymentEvents401,
	GetDeploymentEvents403,
	GetDeploymentEvents500,
	GetDeploymentEventsPathParams,
	GetDeploymentEventsQueryParams,
	GetDeploymentEventsQueryResponse,
	GetDeploymentFileContents400,
	GetDeploymentFileContents401,
	GetDeploymentFileContents403,
	GetDeploymentFileContents404,
	GetDeploymentFileContents410,
	GetDeploymentFileContentsPathParams,
	GetDeploymentFileContentsQueryParams,
	GetDeploymentFileContentsQueryResponse,
	GetDeploymentPathParams,
	GetDeploymentQueryParams,
	GetDeploymentQueryResponse,
	GetDeployments400,
	GetDeployments401,
	GetDeployments403,
	GetDeployments404,
	GetDeployments422,
	GetDeploymentsQueryParams,
	GetDeploymentsQueryResponse,
	GetDomain400,
	GetDomain401,
	GetDomain403,
	GetDomain404,
	GetDomainAuthCode400,
	GetDomainAuthCode401,
	GetDomainAuthCode403,
	GetDomainAuthCode404,
	GetDomainAuthCode409,
	GetDomainAuthCode429,
	GetDomainAuthCode500,
	GetDomainAuthCodePathParams,
	GetDomainAuthCodeQueryParams,
	GetDomainAuthCodeQueryResponse,
	GetDomainAvailability400,
	GetDomainAvailability401,
	GetDomainAvailability403,
	GetDomainAvailability404,
	GetDomainAvailability429,
	GetDomainAvailability500,
	GetDomainAvailabilityPathParams,
	GetDomainAvailabilityQueryParams,
	GetDomainAvailabilityQueryResponse,
	GetDomainConfig400,
	GetDomainConfig401,
	GetDomainConfig403,
	GetDomainConfigPathParams,
	GetDomainConfigQueryParams,
	GetDomainConfigQueryResponse,
	GetDomainPathParams,
	GetDomainPrice400,
	GetDomainPrice401,
	GetDomainPrice403,
	GetDomainPrice429,
	GetDomainPrice500,
	GetDomainPricePathParams,
	GetDomainPriceQueryParams,
	GetDomainPriceQueryResponse,
	GetDomainQueryParams,
	GetDomainQueryResponse,
	GetDomains400,
	GetDomains401,
	GetDomains403,
	GetDomains409,
	GetDomainsQueryParams,
	GetDomainsQueryResponse,
	GetDomainTransferIn400,
	GetDomainTransferIn401,
	GetDomainTransferIn403,
	GetDomainTransferIn404,
	GetDomainTransferIn429,
	GetDomainTransferIn500,
	GetDomainTransferInPathParams,
	GetDomainTransferInQueryParams,
	GetDomainTransferInQueryResponse,
	GetDrain400,
	GetDrain401,
	GetDrain403,
	GetDrain404,
	GetDrainPathParams,
	GetDrainQueryParams,
	GetDrainQueryResponse,
	GetDrains400,
	GetDrains401,
	GetDrains403,
	GetDrains404,
	GetDrainsQueryParams,
	GetDrainsQueryResponse,
	GetEdgeConfig400,
	GetEdgeConfig401,
	GetEdgeConfig403,
	GetEdgeConfig404,
	GetEdgeConfigBackup400,
	GetEdgeConfigBackup401,
	GetEdgeConfigBackup403,
	GetEdgeConfigBackup404,
	GetEdgeConfigBackupPathParams,
	GetEdgeConfigBackupQueryParams,
	GetEdgeConfigBackupQueryResponse,
	GetEdgeConfigBackups400,
	GetEdgeConfigBackups401,
	GetEdgeConfigBackups403,
	GetEdgeConfigBackups404,
	GetEdgeConfigBackupsPathParams,
	GetEdgeConfigBackupsQueryParams,
	GetEdgeConfigBackupsQueryResponse,
	GetEdgeConfigItem400,
	GetEdgeConfigItem401,
	GetEdgeConfigItem403,
	GetEdgeConfigItem404,
	GetEdgeConfigItemPathParams,
	GetEdgeConfigItemQueryParams,
	GetEdgeConfigItemQueryResponse,
	GetEdgeConfigItems400,
	GetEdgeConfigItems401,
	GetEdgeConfigItems403,
	GetEdgeConfigItems404,
	GetEdgeConfigItemsPathParams,
	GetEdgeConfigItemsQueryParams,
	GetEdgeConfigItemsQueryResponse,
	GetEdgeConfigPathParams,
	GetEdgeConfigQueryParams,
	GetEdgeConfigQueryResponse,
	GetEdgeConfigSchema400,
	GetEdgeConfigSchema401,
	GetEdgeConfigSchema403,
	GetEdgeConfigSchema404,
	GetEdgeConfigSchemaPathParams,
	GetEdgeConfigSchemaQueryParams,
	GetEdgeConfigSchemaQueryResponse,
	GetEdgeConfigs400,
	GetEdgeConfigs401,
	GetEdgeConfigs403,
	GetEdgeConfigsQueryParams,
	GetEdgeConfigsQueryResponse,
	GetEdgeConfigToken400,
	GetEdgeConfigToken401,
	GetEdgeConfigToken403,
	GetEdgeConfigToken404,
	GetEdgeConfigTokenPathParams,
	GetEdgeConfigTokenQueryParams,
	GetEdgeConfigTokenQueryResponse,
	GetEdgeConfigTokens400,
	GetEdgeConfigTokens401,
	GetEdgeConfigTokens403,
	GetEdgeConfigTokens404,
	GetEdgeConfigTokensPathParams,
	GetEdgeConfigTokensQueryParams,
	GetEdgeConfigTokensQueryResponse,
	GetFirewallConfig400,
	GetFirewallConfig401,
	GetFirewallConfig403,
	GetFirewallConfig404,
	GetFirewallConfigPathParams,
	GetFirewallConfigQueryParams,
	GetFirewallConfigQueryResponse,
	GetIntegrationLogDrains400,
	GetIntegrationLogDrains401,
	GetIntegrationLogDrains403,
	GetIntegrationLogDrainsQueryParams,
	GetIntegrationLogDrainsQueryResponse,
	GetIntegrationResource400,
	GetIntegrationResource401,
	GetIntegrationResource403,
	GetIntegrationResource404,
	GetIntegrationResourcePathParams,
	GetIntegrationResourceQueryResponse,
	GetIntegrationResources400,
	GetIntegrationResources401,
	GetIntegrationResources403,
	GetIntegrationResources404,
	GetIntegrationResourcesPathParams,
	GetIntegrationResourcesQueryResponse,
	GetInvoice400,
	GetInvoice401,
	GetInvoice403,
	GetInvoice404,
	GetInvoicePathParams,
	GetInvoiceQueryResponse,
	GetMember400,
	GetMember401,
	GetMember403,
	GetMember404,
	GetMemberPathParams,
	GetMemberQueryResponse,
	GetOrder400,
	GetOrder401,
	GetOrder403,
	GetOrder404,
	GetOrder429,
	GetOrder500,
	GetOrderPathParams,
	GetOrderQueryParams,
	GetOrderQueryResponse,
	GetProject400,
	GetProject401,
	GetProject403,
	GetProjectDomain400,
	GetProjectDomain401,
	GetProjectDomain403,
	GetProjectDomainPathParams,
	GetProjectDomainQueryParams,
	GetProjectDomainQueryResponse,
	GetProjectDomains400,
	GetProjectDomains401,
	GetProjectDomains403,
	GetProjectDomainsPathParams,
	GetProjectDomainsQueryParams,
	GetProjectDomainsQueryResponse,
	GetProjectEnv400,
	GetProjectEnv401,
	GetProjectEnv403,
	GetProjectEnvPathParams,
	GetProjectEnvQueryParams,
	GetProjectEnvQueryResponse,
	GetProjectMembers400,
	GetProjectMembers401,
	GetProjectMembers403,
	GetProjectMembersPathParams,
	GetProjectMembersQueryParams,
	GetProjectMembersQueryResponse,
	GetProjectPathParams,
	GetProjectQueryParams,
	GetProjectQueryResponse,
	GetProjects400,
	GetProjects401,
	GetProjects403,
	GetProjectsQueryParams,
	GetProjectsQueryResponse,
	GetRecords400,
	GetRecords401,
	GetRecords403,
	GetRecords404,
	GetRecordsPathParams,
	GetRecordsQueryParams,
	GetRecordsQueryResponse,
	GetRedirects400,
	GetRedirects401,
	GetRedirects403,
	GetRedirects404,
	GetRedirectsQueryParams,
	GetRedirectsQueryResponse,
	GetRollingRelease400,
	GetRollingRelease401,
	GetRollingRelease403,
	GetRollingRelease404,
	GetRollingReleaseBillingStatus400,
	GetRollingReleaseBillingStatus401,
	GetRollingReleaseBillingStatus403,
	GetRollingReleaseBillingStatus404,
	GetRollingReleaseBillingStatusPathParams,
	GetRollingReleaseBillingStatusQueryParams,
	GetRollingReleaseBillingStatusQueryResponse,
	GetRollingReleaseConfig400,
	GetRollingReleaseConfig401,
	GetRollingReleaseConfig403,
	GetRollingReleaseConfig404,
	GetRollingReleaseConfigPathParams,
	GetRollingReleaseConfigQueryParams,
	GetRollingReleaseConfigQueryResponse,
	GetRollingReleasePathParams,
	GetRollingReleaseQueryParams,
	GetRollingReleaseQueryResponse,
	GetRuntimeLogs400,
	GetRuntimeLogs401,
	GetRuntimeLogs403,
	GetRuntimeLogsPathParams,
	GetRuntimeLogsQueryParams,
	GetRuntimeLogsQueryResponse,
	GetSharedEnvVar400,
	GetSharedEnvVar401,
	GetSharedEnvVar403,
	GetSharedEnvVarPathParams,
	GetSharedEnvVarQueryParams,
	GetSharedEnvVarQueryResponse,
	GetSupportedTlds400,
	GetSupportedTlds401,
	GetSupportedTlds403,
	GetSupportedTlds429,
	GetSupportedTlds500,
	GetSupportedTldsQueryParams,
	GetSupportedTldsQueryResponse,
	GetTeam400,
	GetTeam401,
	GetTeam403,
	GetTeam404,
	GetTeamAccessRequest400,
	GetTeamAccessRequest401,
	GetTeamAccessRequest403,
	GetTeamAccessRequest404,
	GetTeamAccessRequestPathParams,
	GetTeamAccessRequestQueryResponse,
	GetTeamMembers400,
	GetTeamMembers401,
	GetTeamMembers403,
	GetTeamMembers404,
	GetTeamMembersPathParams,
	GetTeamMembersQueryParams,
	GetTeamMembersQueryResponse,
	GetTeamPathParams,
	GetTeamQueryParams,
	GetTeamQueryResponse,
	GetTeams400,
	GetTeams401,
	GetTeams403,
	GetTeamsQueryParams,
	GetTeamsQueryResponse,
	GetTldPrice400,
	GetTldPrice401,
	GetTldPrice403,
	GetTldPrice429,
	GetTldPrice500,
	GetTldPricePathParams,
	GetTldPriceQueryParams,
	GetTldPriceQueryResponse,
	GetVersions400,
	GetVersions401,
	GetVersions403,
	GetVersions500,
	GetVersionsQueryParams,
	GetVersionsQueryResponse,
	GetWebhook400,
	GetWebhook401,
	GetWebhook403,
	GetWebhookPathParams,
	GetWebhookQueryParams,
	GetWebhookQueryResponse,
	GetWebhooks400,
	GetWebhooks401,
	GetWebhooks403,
	GetWebhooksQueryParams,
	GetWebhooksQueryResponse,
	GitNamespaces400,
	GitNamespaces401,
	GitNamespaces403,
	GitNamespaces404,
	GitNamespaces429,
	GitNamespaces500,
	GitNamespacesQueryParams,
	GitNamespacesQueryResponse,
	ImportResource400,
	ImportResource401,
	ImportResource403,
	ImportResource404,
	ImportResource409,
	ImportResource422,
	ImportResource429,
	ImportResourceMutationResponse,
	ImportResourcePathParams,
	InvalidateBySrcImages400,
	InvalidateBySrcImages401,
	InvalidateBySrcImages402,
	InvalidateBySrcImages403,
	InvalidateBySrcImages404,
	InvalidateBySrcImagesMutationResponse,
	InvalidateBySrcImagesQueryParams,
	InvalidateByTags400,
	InvalidateByTags401,
	InvalidateByTags403,
	InvalidateByTags404,
	InvalidateByTagsMutationResponse,
	InvalidateByTagsQueryParams,
	InviteUserToTeam400,
	InviteUserToTeam401,
	InviteUserToTeam403,
	InviteUserToTeam503,
	InviteUserToTeamMutationResponse,
	InviteUserToTeamPathParams,
	IssueCert400,
	IssueCert401,
	IssueCert402,
	IssueCert403,
	IssueCert404,
	IssueCert449,
	IssueCert500,
	IssueCertMutationResponse,
	IssueCertQueryParams,
	JoinTeam400,
	JoinTeam401,
	JoinTeam402,
	JoinTeam403,
	JoinTeam404,
	JoinTeamMutationResponse,
	JoinTeamPathParams,
	ListAccessGroupMembers400,
	ListAccessGroupMembers401,
	ListAccessGroupMembers403,
	ListAccessGroupMembersPathParams,
	ListAccessGroupMembersQueryParams,
	ListAccessGroupMembersQueryResponse,
	ListAccessGroupProjects400,
	ListAccessGroupProjects401,
	ListAccessGroupProjects403,
	ListAccessGroupProjectsPathParams,
	ListAccessGroupProjectsQueryParams,
	ListAccessGroupProjectsQueryResponse,
	ListAccessGroups400,
	ListAccessGroups401,
	ListAccessGroups403,
	ListAccessGroupsQueryParams,
	ListAccessGroupsQueryResponse,
	ListAliases400,
	ListAliases401,
	ListAliases403,
	ListAliases404,
	ListAliasesQueryParams,
	ListAliasesQueryResponse,
	ListAuthTokens400,
	ListAuthTokens401,
	ListAuthTokens403,
	ListAuthTokensQueryResponse,
	ListCustomEnvironments400,
	ListCustomEnvironments401,
	ListCustomEnvironments403,
	ListCustomEnvironmentsPathParams,
	ListCustomEnvironmentsQueryParams,
	ListCustomEnvironmentsQueryResponse,
	ListDeploymentAliases400,
	ListDeploymentAliases401,
	ListDeploymentAliases403,
	ListDeploymentAliases404,
	ListDeploymentAliasesPathParams,
	ListDeploymentAliasesQueryParams,
	ListDeploymentAliasesQueryResponse,
	ListDeploymentFiles400,
	ListDeploymentFiles401,
	ListDeploymentFiles403,
	ListDeploymentFiles404,
	ListDeploymentFilesPathParams,
	ListDeploymentFilesQueryParams,
	ListDeploymentFilesQueryResponse,
	ListNetworks400,
	ListNetworks401,
	ListNetworks403,
	ListNetworksQueryParams,
	ListNetworksQueryResponse,
	ListPromoteAliases400,
	ListPromoteAliases401,
	ListPromoteAliases403,
	ListPromoteAliases404,
	ListPromoteAliasesPathParams,
	ListPromoteAliasesQueryParams,
	ListPromoteAliasesQueryResponse,
	ListSharedEnvVariable400,
	ListSharedEnvVariable401,
	ListSharedEnvVariable403,
	ListSharedEnvVariable404,
	ListSharedEnvVariableQueryParams,
	ListSharedEnvVariableQueryResponse,
	ListUserEvents400,
	ListUserEvents401,
	ListUserEvents403,
	ListUserEventsQueryParams,
	ListUserEventsQueryResponse,
	MoveProjectDomain400,
	MoveProjectDomain401,
	MoveProjectDomain403,
	MoveProjectDomain409,
	MoveProjectDomainMutationResponse,
	MoveProjectDomainPathParams,
	MoveProjectDomainQueryParams,
	PatchDomain400,
	PatchDomain401,
	PatchDomain403,
	PatchDomain404,
	PatchDomain409,
	PatchDomain500,
	PatchDomainMutationResponse,
	PatchDomainPathParams,
	PatchDomainQueryParams,
	PatchEdgeConfigItems400,
	PatchEdgeConfigItems401,
	PatchEdgeConfigItems402,
	PatchEdgeConfigItems403,
	PatchEdgeConfigItems404,
	PatchEdgeConfigItems409,
	PatchEdgeConfigItems412,
	PatchEdgeConfigItemsMutationResponse,
	PatchEdgeConfigItemsPathParams,
	PatchEdgeConfigItemsQueryParams,
	PatchEdgeConfigSchema400,
	PatchEdgeConfigSchema401,
	PatchEdgeConfigSchema402,
	PatchEdgeConfigSchema403,
	PatchEdgeConfigSchema404,
	PatchEdgeConfigSchema409,
	PatchEdgeConfigSchemaMutationResponse,
	PatchEdgeConfigSchemaPathParams,
	PatchEdgeConfigSchemaQueryParams,
	PatchTeam400,
	PatchTeam401,
	PatchTeam402,
	PatchTeam403,
	PatchTeam428,
	PatchTeamMutationResponse,
	PatchTeamPathParams,
	PatchTeamQueryParams,
	PatchUrlProtectionBypass400,
	PatchUrlProtectionBypass401,
	PatchUrlProtectionBypass403,
	PatchUrlProtectionBypass404,
	PatchUrlProtectionBypass409,
	PatchUrlProtectionBypass428,
	PatchUrlProtectionBypass500,
	PatchUrlProtectionBypassMutationResponse,
	PatchUrlProtectionBypassPathParams,
	PatchUrlProtectionBypassQueryParams,
	PauseProject400,
	PauseProject401,
	PauseProject403,
	PauseProject500,
	PauseProjectMutationResponse,
	PauseProjectPathParams,
	PauseProjectQueryParams,
	PostTeamDsyncRoles400,
	PostTeamDsyncRoles401,
	PostTeamDsyncRoles403,
	PostTeamDsyncRolesMutationResponse,
	PostTeamDsyncRolesPathParams,
	PostTeamDsyncRolesQueryParams,
	PutFirewallConfig400,
	PutFirewallConfig401,
	PutFirewallConfig402,
	PutFirewallConfig403,
	PutFirewallConfig404,
	PutFirewallConfig500,
	PutFirewallConfigMutationResponse,
	PutFirewallConfigQueryParams,
	ReadAccessGroup400,
	ReadAccessGroup401,
	ReadAccessGroup403,
	ReadAccessGroupPathParams,
	ReadAccessGroupProject400,
	ReadAccessGroupProject401,
	ReadAccessGroupProject403,
	ReadAccessGroupProjectPathParams,
	ReadAccessGroupProjectQueryParams,
	ReadAccessGroupProjectQueryResponse,
	ReadAccessGroupQueryParams,
	ReadAccessGroupQueryResponse,
	ReadNetwork400,
	ReadNetwork401,
	ReadNetwork403,
	ReadNetworkPathParams,
	ReadNetworkQueryParams,
	ReadNetworkQueryResponse,
	RecordEvents400,
	RecordEvents401,
	RecordEvents402,
	RecordEvents403,
	RecordEventsHeaderParams,
	RecordEventsMutationResponse,
	RecordEventsQueryParams,
	RemoveBypassIp400,
	RemoveBypassIp401,
	RemoveBypassIp403,
	RemoveBypassIp404,
	RemoveBypassIp500,
	RemoveBypassIpMutationResponse,
	RemoveBypassIpQueryParams,
	RemoveCert400,
	RemoveCert401,
	RemoveCert403,
	RemoveCert404,
	RemoveCertMutationResponse,
	RemoveCertPathParams,
	RemoveCertQueryParams,
	RemoveCustomEnvironment400,
	RemoveCustomEnvironment401,
	RemoveCustomEnvironment403,
	RemoveCustomEnvironmentMutationResponse,
	RemoveCustomEnvironmentPathParams,
	RemoveCustomEnvironmentQueryParams,
	RemoveProjectDomain400,
	RemoveProjectDomain401,
	RemoveProjectDomain403,
	RemoveProjectDomain404,
	RemoveProjectDomain409,
	RemoveProjectDomainMutationResponse,
	RemoveProjectDomainPathParams,
	RemoveProjectDomainQueryParams,
	RemoveProjectEnv400,
	RemoveProjectEnv401,
	RemoveProjectEnv403,
	RemoveProjectEnv404,
	RemoveProjectEnv409,
	RemoveProjectEnvMutationResponse,
	RemoveProjectEnvPathParams,
	RemoveProjectEnvQueryParams,
	RemoveProjectMember400,
	RemoveProjectMember401,
	RemoveProjectMember403,
	RemoveProjectMemberMutationResponse,
	RemoveProjectMemberPathParams,
	RemoveProjectMemberQueryParams,
	RemoveRecord400,
	RemoveRecord401,
	RemoveRecord403,
	RemoveRecord404,
	RemoveRecordMutationResponse,
	RemoveRecordPathParams,
	RemoveRecordQueryParams,
	RemoveTeamMember400,
	RemoveTeamMember401,
	RemoveTeamMember403,
	RemoveTeamMember404,
	RemoveTeamMember503,
	RemoveTeamMemberMutationResponse,
	RemoveTeamMemberPathParams,
	RemoveTeamMemberQueryParams,
	RenewDomain400,
	RenewDomain401,
	RenewDomain403,
	RenewDomain404,
	RenewDomain429,
	RenewDomain500,
	RenewDomainMutationResponse,
	RenewDomainPathParams,
	RenewDomainQueryParams,
	RequestAccessToTeam400,
	RequestAccessToTeam401,
	RequestAccessToTeam403,
	RequestAccessToTeam404,
	RequestAccessToTeam503,
	RequestAccessToTeamMutationResponse,
	RequestAccessToTeamPathParams,
	RequestDelete400,
	RequestDelete401,
	RequestDelete402,
	RequestDelete403,
	RequestDeleteMutationResponse,
	RequestPromote400,
	RequestPromote401,
	RequestPromote403,
	RequestPromote409,
	RequestPromoteMutationResponse,
	RequestPromotePathParams,
	RequestPromoteQueryParams,
	RerequestCheck400,
	RerequestCheck401,
	RerequestCheck403,
	RerequestCheck404,
	RerequestCheckMutationResponse,
	RerequestCheckPathParams,
	RerequestCheckQueryParams,
	RestoreRedirects400,
	RestoreRedirects401,
	RestoreRedirects403,
	RestoreRedirects404,
	RestoreRedirects500,
	RestoreRedirectsMutationResponse,
	RestoreRedirectsQueryParams,
	SearchRepo400,
	SearchRepo401,
	SearchRepo403,
	SearchRepo404,
	SearchRepo429,
	SearchRepo500,
	SearchRepoQueryParams,
	SearchRepoQueryResponse,
	StageRedirects400,
	StageRedirects401,
	StageRedirects403,
	StageRedirects500,
	StageRedirectsMutationResponse,
	StageRedirectsQueryParams,
	Status400,
	Status401,
	Status402,
	Status403,
	StatusQueryParams,
	StatusQueryResponse,
	SubmitBillingData400,
	SubmitBillingData401,
	SubmitBillingData403,
	SubmitBillingData404,
	SubmitBillingDataMutationResponse,
	SubmitBillingDataPathParams,
	SubmitInvoice400,
	SubmitInvoice401,
	SubmitInvoice403,
	SubmitInvoice404,
	SubmitInvoice409,
	SubmitInvoiceMutationResponse,
	SubmitInvoicePathParams,
	SubmitPrepaymentBalances400,
	SubmitPrepaymentBalances401,
	SubmitPrepaymentBalances403,
	SubmitPrepaymentBalances404,
	SubmitPrepaymentBalancesMutationResponse,
	SubmitPrepaymentBalancesPathParams,
	TestDrain400,
	TestDrain401,
	TestDrain403,
	TestDrainMutationResponse,
	TestDrainQueryParams,
	TransferInDomain400,
	TransferInDomain401,
	TransferInDomain403,
	TransferInDomain429,
	TransferInDomain500,
	TransferInDomainMutationResponse,
	TransferInDomainPathParams,
	TransferInDomainQueryParams,
	UnlinkSharedEnvVariable400,
	UnlinkSharedEnvVariable401,
	UnlinkSharedEnvVariable403,
	UnlinkSharedEnvVariableMutationResponse,
	UnlinkSharedEnvVariablePathParams,
	UnlinkSharedEnvVariableQueryParams,
	UnpauseProject400,
	UnpauseProject401,
	UnpauseProject403,
	UnpauseProject500,
	UnpauseProjectMutationResponse,
	UnpauseProjectPathParams,
	UnpauseProjectQueryParams,
	UpdateAccessGroup400,
	UpdateAccessGroup401,
	UpdateAccessGroup403,
	UpdateAccessGroupMutationResponse,
	UpdateAccessGroupPathParams,
	UpdateAccessGroupProject400,
	UpdateAccessGroupProject401,
	UpdateAccessGroupProject403,
	UpdateAccessGroupProjectMutationResponse,
	UpdateAccessGroupProjectPathParams,
	UpdateAccessGroupProjectQueryParams,
	UpdateAccessGroupQueryParams,
	UpdateAttackChallengeMode400,
	UpdateAttackChallengeMode401,
	UpdateAttackChallengeMode403,
	UpdateAttackChallengeMode404,
	UpdateAttackChallengeModeMutationResponse,
	UpdateAttackChallengeModeQueryParams,
	UpdateCheck400,
	UpdateCheck401,
	UpdateCheck403,
	UpdateCheck404,
	UpdateCheck413,
	UpdateCheckMutationResponse,
	UpdateCheckPathParams,
	UpdateCheckQueryParams,
	UpdateCustomEnvironment400,
	UpdateCustomEnvironment401,
	UpdateCustomEnvironment402,
	UpdateCustomEnvironment403,
	UpdateCustomEnvironment500,
	UpdateCustomEnvironmentMutationResponse,
	UpdateCustomEnvironmentPathParams,
	UpdateCustomEnvironmentQueryParams,
	UpdateDomainAutoRenew400,
	UpdateDomainAutoRenew401,
	UpdateDomainAutoRenew403,
	UpdateDomainAutoRenew404,
	UpdateDomainAutoRenew429,
	UpdateDomainAutoRenew500,
	UpdateDomainAutoRenewMutationResponse,
	UpdateDomainAutoRenewPathParams,
	UpdateDomainAutoRenewQueryParams,
	UpdateDomainNameservers400,
	UpdateDomainNameservers401,
	UpdateDomainNameservers403,
	UpdateDomainNameservers404,
	UpdateDomainNameservers429,
	UpdateDomainNameservers500,
	UpdateDomainNameserversMutationResponse,
	UpdateDomainNameserversPathParams,
	UpdateDomainNameserversQueryParams,
	UpdateDrain400,
	UpdateDrain401,
	UpdateDrain403,
	UpdateDrain404,
	UpdateDrainMutationResponse,
	UpdateDrainPathParams,
	UpdateDrainQueryParams,
	UpdateEdgeConfig400,
	UpdateEdgeConfig401,
	UpdateEdgeConfig402,
	UpdateEdgeConfig403,
	UpdateEdgeConfig404,
	UpdateEdgeConfig409,
	UpdateEdgeConfigMutationResponse,
	UpdateEdgeConfigPathParams,
	UpdateEdgeConfigQueryParams,
	UpdateExperimentationEdgeConfig400,
	UpdateExperimentationEdgeConfig401,
	UpdateExperimentationEdgeConfig403,
	UpdateExperimentationEdgeConfig404,
	UpdateExperimentationEdgeConfig409,
	UpdateExperimentationEdgeConfig412,
	UpdateExperimentationEdgeConfigMutationResponse,
	UpdateExperimentationEdgeConfigPathParams,
	UpdateExperimentationItem400,
	UpdateExperimentationItem401,
	UpdateExperimentationItem403,
	UpdateExperimentationItem404,
	UpdateExperimentationItemMutationResponse,
	UpdateExperimentationItemPathParams,
	UpdateFirewallConfig400,
	UpdateFirewallConfig401,
	UpdateFirewallConfig402,
	UpdateFirewallConfig403,
	UpdateFirewallConfig404,
	UpdateFirewallConfig500,
	UpdateFirewallConfigMutationResponse,
	UpdateFirewallConfigQueryParams,
	UpdateInstallation400,
	UpdateInstallation401,
	UpdateInstallation403,
	UpdateInstallation404,
	UpdateInstallationMutationResponse,
	UpdateInstallationPathParams,
	UpdateIntegrationDeploymentAction400,
	UpdateIntegrationDeploymentAction401,
	UpdateIntegrationDeploymentAction403,
	UpdateIntegrationDeploymentActionMutationResponse,
	UpdateIntegrationDeploymentActionPathParams,
	UpdateInvoice400,
	UpdateInvoice401,
	UpdateInvoice403,
	UpdateInvoice404,
	UpdateInvoice409,
	UpdateInvoiceMutationResponse,
	UpdateInvoicePathParams,
	UpdateNetwork400,
	UpdateNetwork401,
	UpdateNetwork403,
	UpdateNetworkMutationResponse,
	UpdateNetworkPathParams,
	UpdateNetworkQueryParams,
	UpdateProject400,
	UpdateProject401,
	UpdateProject402,
	UpdateProject403,
	UpdateProject404,
	UpdateProject409,
	UpdateProject428,
	UpdateProjectDataCache400,
	UpdateProjectDataCache401,
	UpdateProjectDataCache403,
	UpdateProjectDataCache404,
	UpdateProjectDataCacheMutationResponse,
	UpdateProjectDataCachePathParams,
	UpdateProjectDataCacheQueryParams,
	UpdateProjectDomain400,
	UpdateProjectDomain401,
	UpdateProjectDomain403,
	UpdateProjectDomain409,
	UpdateProjectDomainMutationResponse,
	UpdateProjectDomainPathParams,
	UpdateProjectDomainQueryParams,
	UpdateProjectMutationResponse,
	UpdateProjectPathParams,
	UpdateProjectProtectionBypass400,
	UpdateProjectProtectionBypass401,
	UpdateProjectProtectionBypass403,
	UpdateProjectProtectionBypass404,
	UpdateProjectProtectionBypass409,
	UpdateProjectProtectionBypassMutationResponse,
	UpdateProjectProtectionBypassPathParams,
	UpdateProjectProtectionBypassQueryParams,
	UpdateProjectQueryParams,
	UpdateRecord400,
	UpdateRecord401,
	UpdateRecord402,
	UpdateRecord403,
	UpdateRecord404,
	UpdateRecord409,
	UpdateRecordMutationResponse,
	UpdateRecordPathParams,
	UpdateRecordQueryParams,
	UpdateResource400,
	UpdateResource401,
	UpdateResource403,
	UpdateResource404,
	UpdateResource409,
	UpdateResource422,
	UpdateResourceMutationResponse,
	UpdateResourcePathParams,
	UpdateResourceSecrets400,
	UpdateResourceSecrets401,
	UpdateResourceSecrets403,
	UpdateResourceSecrets404,
	UpdateResourceSecrets409,
	UpdateResourceSecrets422,
	UpdateResourceSecretsById400,
	UpdateResourceSecretsById401,
	UpdateResourceSecretsById403,
	UpdateResourceSecretsById404,
	UpdateResourceSecretsById409,
	UpdateResourceSecretsById422,
	UpdateResourceSecretsByIdMutationResponse,
	UpdateResourceSecretsByIdPathParams,
	UpdateResourceSecretsMutationResponse,
	UpdateResourceSecretsPathParams,
	UpdateRollingReleaseConfig400,
	UpdateRollingReleaseConfig401,
	UpdateRollingReleaseConfig403,
	UpdateRollingReleaseConfig404,
	UpdateRollingReleaseConfigMutationResponse,
	UpdateRollingReleaseConfigPathParams,
	UpdateRollingReleaseConfigQueryParams,
	UpdateSharedEnvVariable400,
	UpdateSharedEnvVariable401,
	UpdateSharedEnvVariable402,
	UpdateSharedEnvVariable403,
	UpdateSharedEnvVariableMutationResponse,
	UpdateSharedEnvVariableQueryParams,
	UpdateStaticIps400,
	UpdateStaticIps401,
	UpdateStaticIps402,
	UpdateStaticIps403,
	UpdateStaticIps404,
	UpdateStaticIps409,
	UpdateStaticIps500,
	UpdateStaticIpsMutationResponse,
	UpdateStaticIpsPathParams,
	UpdateStaticIpsQueryParams,
	UpdateTeamMember400,
	UpdateTeamMember401,
	UpdateTeamMember402,
	UpdateTeamMember403,
	UpdateTeamMember404,
	UpdateTeamMember409,
	UpdateTeamMember500,
	UpdateTeamMemberMutationResponse,
	UpdateTeamMemberPathParams,
	UpdateVersion400,
	UpdateVersion401,
	UpdateVersion403,
	UpdateVersion404,
	UpdateVersion500,
	UpdateVersionMutationResponse,
	UpdateVersionQueryParams,
	UploadArtifact400,
	UploadArtifact401,
	UploadArtifact402,
	UploadArtifact403,
	UploadArtifactHeaderParams,
	UploadArtifactMutationResponse,
	UploadArtifactPathParams,
	UploadArtifactQueryParams,
	UploadCert400,
	UploadCert401,
	UploadCert402,
	UploadCert403,
	UploadCertMutationResponse,
	UploadCertQueryParams,
	UploadFile400,
	UploadFile401,
	UploadFile403,
	UploadFileHeaderParams,
	UploadFileMutationResponse,
	UploadFileQueryParams,
	VerifyProjectDomain400,
	VerifyProjectDomain401,
	VerifyProjectDomain403,
	VerifyProjectDomainMutationResponse,
	VerifyProjectDomainPathParams,
	VerifyProjectDomainQueryParams,
} from "./types";

/**
 * @description Allows to read an access group
 * @summary Reads an access group
 * {@link /v1/access-groups/:idOrName}
 */
export function readAccessGroup({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: ReadAccessGroupPathParams;
	queryParams?: ReadAccessGroupQueryParams;
}): Effect.Effect<
	ReadAccessGroupQueryResponse,
	ApiError | ValidationError | ReadAccessGroup400 | ReadAccessGroup401 | ReadAccessGroup403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/access-groups/${idOrName}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ReadAccessGroupQueryResponse;
	});
}

/**
 * @description Allows to update an access group metadata
 * @summary Update an access group
 * {@link /v1/access-groups/:idOrName}
 */
export function updateAccessGroup({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: UpdateAccessGroupPathParams;
	queryParams?: UpdateAccessGroupQueryParams;
}): Effect.Effect<
	UpdateAccessGroupMutationResponse,
	ApiError | ValidationError | UpdateAccessGroup400 | UpdateAccessGroup401 | UpdateAccessGroup403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/access-groups/${idOrName}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateAccessGroupMutationResponse;
	});
}

/**
 * @description Allows to delete an access group
 * @summary Deletes an access group
 * {@link /v1/access-groups/:idOrName}
 */
export function deleteAccessGroup({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: DeleteAccessGroupPathParams;
	queryParams?: DeleteAccessGroupQueryParams;
}): Effect.Effect<
	DeleteAccessGroupMutationResponse,
	ApiError | ValidationError | DeleteAccessGroup400 | DeleteAccessGroup401 | DeleteAccessGroup403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/access-groups/${idOrName}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteAccessGroupMutationResponse;
	});
}

/**
 * @description List members of an access group
 * @summary List members of an access group
 * {@link /v1/access-groups/:idOrName/members}
 */
export function listAccessGroupMembers({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: ListAccessGroupMembersPathParams;
	queryParams?: ListAccessGroupMembersQueryParams;
}): Effect.Effect<
	ListAccessGroupMembersQueryResponse,
	| ApiError
	| ValidationError
	| ListAccessGroupMembers400
	| ListAccessGroupMembers401
	| ListAccessGroupMembers403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/access-groups/${idOrName}/members`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ListAccessGroupMembersQueryResponse;
	});
}

/**
 * @description List access groups
 * @summary List access groups for a team, project or member
 * {@link /v1/access-groups}
 */
export function listAccessGroups({
	queryParams,
}: {
	queryParams?: ListAccessGroupsQueryParams;
}): Effect.Effect<
	ListAccessGroupsQueryResponse,
	ApiError | ValidationError | ListAccessGroups400 | ListAccessGroups401 | ListAccessGroups403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/access-groups";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ListAccessGroupsQueryResponse;
	});
}

/**
 * @description Allows to create an access group
 * @summary Creates an access group
 * {@link /v1/access-groups}
 */
export function createAccessGroup({
	queryParams,
}: {
	queryParams?: CreateAccessGroupQueryParams;
}): Effect.Effect<
	CreateAccessGroupMutationResponse,
	ApiError | ValidationError | CreateAccessGroup400 | CreateAccessGroup401 | CreateAccessGroup403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/access-groups";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateAccessGroupMutationResponse;
	});
}

/**
 * @description List projects of an access group
 * @summary List projects of an access group
 * {@link /v1/access-groups/:idOrName/projects}
 */
export function listAccessGroupProjects({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: ListAccessGroupProjectsPathParams;
	queryParams?: ListAccessGroupProjectsQueryParams;
}): Effect.Effect<
	ListAccessGroupProjectsQueryResponse,
	| ApiError
	| ValidationError
	| ListAccessGroupProjects400
	| ListAccessGroupProjects401
	| ListAccessGroupProjects403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/access-groups/${idOrName}/projects`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ListAccessGroupProjectsQueryResponse;
	});
}

/**
 * @description Allows creation of an access group project
 * @summary Create an access group project
 * {@link /v1/access-groups/:accessGroupIdOrName/projects}
 */
export function createAccessGroupProject({
	pathParams: { accessGroupIdOrName },
	queryParams,
}: {
	pathParams: CreateAccessGroupProjectPathParams;
	queryParams?: CreateAccessGroupProjectQueryParams;
}): Effect.Effect<
	CreateAccessGroupProjectMutationResponse,
	| ApiError
	| ValidationError
	| CreateAccessGroupProject400
	| CreateAccessGroupProject401
	| CreateAccessGroupProject403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (accessGroupIdOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "accessGroupIdOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/access-groups/${accessGroupIdOrName}/projects`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateAccessGroupProjectMutationResponse;
	});
}

/**
 * @description Allows reading an access group project
 * @summary Reads an access group project
 * {@link /v1/access-groups/:accessGroupIdOrName/projects/:projectId}
 */
export function readAccessGroupProject({
	pathParams: { accessGroupIdOrName, projectId },
	queryParams,
}: {
	pathParams: ReadAccessGroupProjectPathParams;
	queryParams?: ReadAccessGroupProjectQueryParams;
}): Effect.Effect<
	ReadAccessGroupProjectQueryResponse,
	| ApiError
	| ValidationError
	| ReadAccessGroupProject400
	| ReadAccessGroupProject401
	| ReadAccessGroupProject403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (accessGroupIdOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "accessGroupIdOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (projectId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "projectId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/access-groups/${accessGroupIdOrName}/projects/${projectId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ReadAccessGroupProjectQueryResponse;
	});
}

/**
 * @description Allows update of an access group project
 * @summary Update an access group project
 * {@link /v1/access-groups/:accessGroupIdOrName/projects/:projectId}
 */
export function updateAccessGroupProject({
	pathParams: { accessGroupIdOrName, projectId },
	queryParams,
}: {
	pathParams: UpdateAccessGroupProjectPathParams;
	queryParams?: UpdateAccessGroupProjectQueryParams;
}): Effect.Effect<
	UpdateAccessGroupProjectMutationResponse,
	| ApiError
	| ValidationError
	| UpdateAccessGroupProject400
	| UpdateAccessGroupProject401
	| UpdateAccessGroupProject403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (accessGroupIdOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "accessGroupIdOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (projectId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "projectId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/access-groups/${accessGroupIdOrName}/projects/${projectId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateAccessGroupProjectMutationResponse;
	});
}

/**
 * @description Allows deletion of an access group project
 * @summary Delete an access group project
 * {@link /v1/access-groups/:accessGroupIdOrName/projects/:projectId}
 */
export function deleteAccessGroupProject({
	pathParams: { accessGroupIdOrName, projectId },
	queryParams,
}: {
	pathParams: DeleteAccessGroupProjectPathParams;
	queryParams?: DeleteAccessGroupProjectQueryParams;
}): Effect.Effect<
	DeleteAccessGroupProjectMutationResponse,
	| ApiError
	| ValidationError
	| DeleteAccessGroupProject400
	| DeleteAccessGroupProject401
	| DeleteAccessGroupProject403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (accessGroupIdOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "accessGroupIdOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (projectId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "projectId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/access-groups/${accessGroupIdOrName}/projects/${projectId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteAccessGroupProjectMutationResponse;
	});
}

/**
 * @description Records an artifacts cache usage event. The body of this request is an array of cache usage events. The supported event types are `HIT` and `MISS`. The source is either `LOCAL` the cache event was on the users filesystem cache or `REMOTE` if the cache event is for a remote cache. When the event is a `HIT` the request also accepts a number `duration` which is the time taken to generate the artifact in the cache.
 * @summary Record an artifacts cache usage event
 * {@link /v8/artifacts/events}
 */
export function recordEvents({
	queryParams,
	headers,
}: {
	queryParams?: RecordEventsQueryParams;
	headers?: RecordEventsHeaderParams;
}): Effect.Effect<
	RecordEventsMutationResponse,
	| ApiError
	| ValidationError
	| RecordEvents400
	| RecordEvents401
	| RecordEvents402
	| RecordEvents403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v8/artifacts/events";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson", ...headers },
		});

		return response as RecordEventsMutationResponse;
	});
}

/**
 * @description Check the status of Remote Caching for this principal. Returns a JSON-encoded status indicating if Remote Caching is enabled, disabled, or disabled due to usage limits.
 * @summary Get status of Remote Caching for this principal
 * {@link /v8/artifacts/status}
 */
export function status({
	queryParams,
}: {
	queryParams?: StatusQueryParams;
}): Effect.Effect<
	StatusQueryResponse,
	ApiError | ValidationError | Status400 | Status401 | Status402 | Status403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v8/artifacts/status";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as StatusQueryResponse;
	});
}

/**
 * @description Uploads a cache artifact identified by the `hash` specified on the path. The cache artifact can then be downloaded with the provided `hash`.
 * @summary Upload a cache artifact
 * {@link /v8/artifacts/:hash}
 */
export function uploadArtifact({
	pathParams: { hash },
	headers,
	queryParams,
}: {
	pathParams: UploadArtifactPathParams;
	headers: UploadArtifactHeaderParams;
	queryParams?: UploadArtifactQueryParams;
}): Effect.Effect<
	UploadArtifactMutationResponse,
	| ApiError
	| ValidationError
	| UploadArtifact400
	| UploadArtifact401
	| UploadArtifact402
	| UploadArtifact403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (hash === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "hash",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v8/artifacts/${hash}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PUT",
			url: fullUrl,

			headers: { "Content-Type": "applicationOctetStream", ...headers },
		});

		return response as UploadArtifactMutationResponse;
	});
}

/**
 * @description Downloads a cache artifact indentified by its `hash` specified on the request path. The artifact is downloaded as an octet-stream. The client should verify the content-length header and response body.
 * @summary Download a cache artifact
 * {@link /v8/artifacts/:hash}
 */
export function downloadArtifact({
	pathParams: { hash },
	queryParams,
	headers,
}: {
	pathParams: DownloadArtifactPathParams;
	queryParams?: DownloadArtifactQueryParams;
	headers?: DownloadArtifactHeaderParams;
}): Effect.Effect<
	DownloadArtifactQueryResponse,
	| ApiError
	| ValidationError
	| DownloadArtifact400
	| DownloadArtifact401
	| DownloadArtifact402
	| DownloadArtifact403
	| DownloadArtifact404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (hash === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "hash",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v8/artifacts/${hash}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: { ...headers },
		});

		return response as DownloadArtifactQueryResponse;
	});
}

/**
 * @description Query information about an array of artifacts.
 * @summary Query information about an artifact
 * {@link /v8/artifacts}
 */
export function artifactQuery({
	queryParams,
}: {
	queryParams?: ArtifactQueryQueryParams;
}): Effect.Effect<
	ArtifactQueryMutationResponse,
	| ApiError
	| ValidationError
	| ArtifactQuery400
	| ArtifactQuery401
	| ArtifactQuery402
	| ArtifactQuery403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v8/artifacts";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as ArtifactQueryMutationResponse;
	});
}

/**
 * @description Stages new redirects for a project and returns the new version.
 * @summary Stages new redirects for a project.
 * {@link /v1/bulk-redirects}
 */
export function stageRedirects({
	queryParams,
}: {
	queryParams?: StageRedirectsQueryParams;
}): Effect.Effect<
	StageRedirectsMutationResponse,
	| ApiError
	| ValidationError
	| StageRedirects400
	| StageRedirects401
	| StageRedirects403
	| StageRedirects500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/bulk-redirects";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PUT",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as StageRedirectsMutationResponse;
	});
}

/**
 * @description Get the version history for a project's bulk redirects
 * @summary Gets project-level redirects.
 * {@link /v1/bulk-redirects}
 */
export function getRedirects({
	queryParams,
}: {
	queryParams: GetRedirectsQueryParams;
}): Effect.Effect<
	GetRedirectsQueryResponse,
	| ApiError
	| ValidationError
	| GetRedirects400
	| GetRedirects401
	| GetRedirects403
	| GetRedirects404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/bulk-redirects";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetRedirectsQueryResponse;
	});
}

/**
 * @description Deletes the provided redirects from the latest version of the projects' bulk redirects. Stages a new change with the new redirects and returns the alias for the new version in the response.
 * @summary Delete project-level redirects.
 * {@link /v1/bulk-redirects}
 */
export function deleteRedirects({
	queryParams,
}: {
	queryParams: DeleteRedirectsQueryParams;
}): Effect.Effect<
	DeleteRedirectsMutationResponse,
	| ApiError
	| ValidationError
	| DeleteRedirects400
	| DeleteRedirects401
	| DeleteRedirects403
	| DeleteRedirects404
	| DeleteRedirects500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/bulk-redirects";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as DeleteRedirectsMutationResponse;
	});
}

/**
 * @description Edits a single redirect identified by its source path. Stages a new change with the modified redirect and returns the alias for the new version in the response.
 * @summary Edit a project-level redirect.
 * {@link /v1/bulk-redirects}
 */
export function editRedirect({
	queryParams,
}: {
	queryParams: EditRedirectQueryParams;
}): Effect.Effect<
	EditRedirectMutationResponse,
	| ApiError
	| ValidationError
	| EditRedirect400
	| EditRedirect401
	| EditRedirect403
	| EditRedirect404
	| EditRedirect500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/bulk-redirects";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as EditRedirectMutationResponse;
	});
}

/**
 * @description Restores the provided redirects in the staging version to the value in the production version. If no production version exists, removes the redirects from staging.
 * @summary Restore staged project-level redirects to their production version.
 * {@link /v1/bulk-redirects/restore}
 */
export function restoreRedirects({
	queryParams,
}: {
	queryParams: RestoreRedirectsQueryParams;
}): Effect.Effect<
	RestoreRedirectsMutationResponse,
	| ApiError
	| ValidationError
	| RestoreRedirects400
	| RestoreRedirects401
	| RestoreRedirects403
	| RestoreRedirects404
	| RestoreRedirects500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/bulk-redirects/restore";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as RestoreRedirectsMutationResponse;
	});
}

/**
 * @description Get the version history for a project's bulk redirects
 * @summary Get the version history for a project's redirects.
 * {@link /v1/bulk-redirects/versions}
 */
export function getVersions({
	queryParams,
}: {
	queryParams: GetVersionsQueryParams;
}): Effect.Effect<
	GetVersionsQueryResponse,
	ApiError | ValidationError | GetVersions400 | GetVersions401 | GetVersions403 | GetVersions500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/bulk-redirects/versions";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetVersionsQueryResponse;
	});
}

/**
 * @description Update a version by promoting staging to production or restoring a previous production version
 * @summary Promote a staging version to production or restore a previous production version.
 * {@link /v1/bulk-redirects/versions}
 */
export function updateVersion({
	queryParams,
}: {
	queryParams: UpdateVersionQueryParams;
}): Effect.Effect<
	UpdateVersionMutationResponse,
	| ApiError
	| ValidationError
	| UpdateVersion400
	| UpdateVersion401
	| UpdateVersion403
	| UpdateVersion404
	| UpdateVersion500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/bulk-redirects/versions";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateVersionMutationResponse;
	});
}

/**
 * @description Creates a new check. This endpoint must be called with an OAuth2 or it will produce a 400 error.
 * @summary Creates a new Check
 * {@link /v1/deployments/:deploymentId/checks}
 */
export function createCheck({
	pathParams: { deploymentId },
	queryParams,
}: {
	pathParams: CreateCheckPathParams;
	queryParams?: CreateCheckQueryParams;
}): Effect.Effect<
	CreateCheckMutationResponse,
	ApiError | ValidationError | CreateCheck400 | CreateCheck401 | CreateCheck403 | CreateCheck404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (deploymentId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "deploymentId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/deployments/${deploymentId}/checks`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateCheckMutationResponse;
	});
}

/**
 * @description List all of the checks created for a deployment.
 * @summary Retrieve a list of all checks
 * {@link /v1/deployments/:deploymentId/checks}
 */
export function getAllChecks({
	pathParams: { deploymentId },
	queryParams,
}: {
	pathParams: GetAllChecksPathParams;
	queryParams?: GetAllChecksQueryParams;
}): Effect.Effect<
	GetAllChecksQueryResponse,
	| ApiError
	| ValidationError
	| GetAllChecks400
	| GetAllChecks401
	| GetAllChecks403
	| GetAllChecks404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (deploymentId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "deploymentId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/deployments/${deploymentId}/checks`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetAllChecksQueryResponse;
	});
}

/**
 * @description Return a detailed response for a single check.
 * @summary Get a single check
 * {@link /v1/deployments/:deploymentId/checks/:checkId}
 */
export function getCheck({
	pathParams: { deploymentId, checkId },
	queryParams,
}: {
	pathParams: GetCheckPathParams;
	queryParams?: GetCheckQueryParams;
}): Effect.Effect<
	GetCheckQueryResponse,
	ApiError | ValidationError | GetCheck400 | GetCheck401 | GetCheck403 | GetCheck404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (deploymentId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "deploymentId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (checkId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "checkId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/deployments/${deploymentId}/checks/${checkId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetCheckQueryResponse;
	});
}

/**
 * @description Update an existing check. This endpoint must be called with an OAuth2 or it will produce a 400 error.
 * @summary Update a check
 * {@link /v1/deployments/:deploymentId/checks/:checkId}
 */
export function updateCheck({
	pathParams: { deploymentId, checkId },
	queryParams,
}: {
	pathParams: UpdateCheckPathParams;
	queryParams?: UpdateCheckQueryParams;
}): Effect.Effect<
	UpdateCheckMutationResponse,
	| ApiError
	| ValidationError
	| UpdateCheck400
	| UpdateCheck401
	| UpdateCheck403
	| UpdateCheck404
	| UpdateCheck413,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (deploymentId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "deploymentId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (checkId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "checkId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/deployments/${deploymentId}/checks/${checkId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateCheckMutationResponse;
	});
}

/**
 * @description Rerequest a selected check that has failed.
 * @summary Rerequest a check
 * {@link /v1/deployments/:deploymentId/checks/:checkId/rerequest}
 */
export function rerequestCheck({
	pathParams: { deploymentId, checkId },
	queryParams,
}: {
	pathParams: RerequestCheckPathParams;
	queryParams?: RerequestCheckQueryParams;
}): Effect.Effect<
	RerequestCheckMutationResponse,
	| ApiError
	| ValidationError
	| RerequestCheck400
	| RerequestCheck401
	| RerequestCheck403
	| RerequestCheck404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (deploymentId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "deploymentId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (checkId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "checkId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/deployments/${deploymentId}/checks/${checkId}/rerequest`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: {},
		});

		return response as RerequestCheckMutationResponse;
	});
}

/**
 * @description Allows to list Secure Compute networks.
 * @summary List Secure Compute networks
 * {@link /v1/connect/networks}
 */
export function listNetworks({
	queryParams,
}: {
	queryParams?: ListNetworksQueryParams;
}): Effect.Effect<
	ListNetworksQueryResponse,
	ApiError | ValidationError | ListNetworks400 | ListNetworks401 | ListNetworks403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/connect/networks";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ListNetworksQueryResponse;
	});
}

/**
 * @description Allows to create a Secure Compute network.
 * @summary Create a Secure Compute network
 * {@link /v1/connect/networks}
 */
export function createNetwork({
	queryParams,
}: {
	queryParams?: CreateNetworkQueryParams;
}): Effect.Effect<
	CreateNetworkMutationResponse,
	| ApiError
	| ValidationError
	| CreateNetwork400
	| CreateNetwork401
	| CreateNetwork402
	| CreateNetwork403
	| CreateNetwork404
	| CreateNetwork409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/connect/networks";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateNetworkMutationResponse;
	});
}

/**
 * @description Allows to delete a Secure Compute network.
 * @summary Delete a Secure Compute network
 * {@link /v1/connect/networks/:networkId}
 */
export function deleteNetwork({
	pathParams: { networkId },
	queryParams,
}: {
	pathParams: DeleteNetworkPathParams;
	queryParams?: DeleteNetworkQueryParams;
}): Effect.Effect<
	DeleteNetworkMutationResponse,
	| ApiError
	| ValidationError
	| DeleteNetwork400
	| DeleteNetwork401
	| DeleteNetwork402
	| DeleteNetwork403
	| DeleteNetwork404
	| DeleteNetwork409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (networkId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "networkId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/connect/networks/${networkId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteNetworkMutationResponse;
	});
}

/**
 * @description Allows to update a Secure Compute network.
 * @summary Update a Secure Compute network
 * {@link /v1/connect/networks/:networkId}
 */
export function updateNetwork({
	pathParams: { networkId },
	queryParams,
}: {
	pathParams: UpdateNetworkPathParams;
	queryParams?: UpdateNetworkQueryParams;
}): Effect.Effect<
	UpdateNetworkMutationResponse,
	ApiError | ValidationError | UpdateNetwork400 | UpdateNetwork401 | UpdateNetwork403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (networkId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "networkId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/connect/networks/${networkId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateNetworkMutationResponse;
	});
}

/**
 * @description Allows to read a Secure Compute network.
 * @summary Read a Secure Compute network
 * {@link /v1/connect/networks/:networkId}
 */
export function readNetwork({
	pathParams: { networkId },
	queryParams,
}: {
	pathParams: ReadNetworkPathParams;
	queryParams?: ReadNetworkQueryParams;
}): Effect.Effect<
	ReadNetworkQueryResponse,
	ApiError | ValidationError | ReadNetwork400 | ReadNetwork401 | ReadNetwork403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (networkId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "networkId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/connect/networks/${networkId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ReadNetworkQueryResponse;
	});
}

/**
 * @description Update the data cache feature on a project.
 * @summary Update the data cache feature
 * {@link /v1/data-cache/projects/:projectId}
 */
export function updateProjectDataCache({
	pathParams: { projectId },
	queryParams,
}: {
	pathParams: UpdateProjectDataCachePathParams;
	queryParams?: UpdateProjectDataCacheQueryParams;
}): Effect.Effect<
	UpdateProjectDataCacheMutationResponse,
	| ApiError
	| ValidationError
	| UpdateProjectDataCache400
	| UpdateProjectDataCache401
	| UpdateProjectDataCache403
	| UpdateProjectDataCache404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (projectId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "projectId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/data-cache/projects/${projectId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateProjectDataCacheMutationResponse;
	});
}

/**
 * @description Get the build logs of a deployment by deployment ID and build ID. It can work as an infinite stream of logs or as a JSON endpoint depending on the input parameters.
 * @summary Get deployment events
 * {@link /v3/deployments/:idOrUrl/events}
 */
export function getDeploymentEvents({
	pathParams: { idOrUrl },
	queryParams,
}: {
	pathParams: GetDeploymentEventsPathParams;
	queryParams?: GetDeploymentEventsQueryParams;
}): Effect.Effect<
	GetDeploymentEventsQueryResponse,
	| ApiError
	| ValidationError
	| GetDeploymentEvents400
	| GetDeploymentEvents401
	| GetDeploymentEvents403
	| GetDeploymentEvents500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrUrl === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrUrl",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v3/deployments/${idOrUrl}/events`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetDeploymentEventsQueryResponse;
	});
}

/**
 * @description Updates the deployment integration action for the specified integration installation
 * @summary Update deployment integration action
 * {@link /v1/deployments/:deploymentId/integrations/:integrationConfigurationId/resources/:resourceId/actions/:action}
 */
export function updateIntegrationDeploymentAction({
	pathParams: { deploymentId, integrationConfigurationId, resourceId, action },
}: {
	pathParams: UpdateIntegrationDeploymentActionPathParams;
}): Effect.Effect<
	UpdateIntegrationDeploymentActionMutationResponse,
	| ApiError
	| ValidationError
	| UpdateIntegrationDeploymentAction400
	| UpdateIntegrationDeploymentAction401
	| UpdateIntegrationDeploymentAction403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (deploymentId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "deploymentId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (resourceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "resourceId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (action === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "action",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/deployments/${deploymentId}/integrations/${integrationConfigurationId}/resources/${resourceId}/actions/${action}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateIntegrationDeploymentActionMutationResponse;
	});
}

/**
 * @description Retrieves information for a deployment either by supplying its ID (`id` property) or Hostname (`url` property). Additional details will be included when the authenticated user or team is an owner of the deployment.
 * @summary Get a deployment by ID or URL
 * {@link /v13/deployments/:idOrUrl}
 */
export function getDeployment({
	pathParams: { idOrUrl },
	queryParams,
}: {
	pathParams: GetDeploymentPathParams;
	queryParams?: GetDeploymentQueryParams;
}): Effect.Effect<
	GetDeploymentQueryResponse,
	ApiError | ValidationError | GetDeployment400 | GetDeployment403 | GetDeployment404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrUrl === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrUrl",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v13/deployments/${idOrUrl}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetDeploymentQueryResponse;
	});
}

/**
 * @description Create a new deployment with all the required and intended data. If the deployment is not a git deployment, all files must be provided with the request, either referenced or inlined. Additionally, a deployment id can be specified to redeploy a previous deployment.
 * @summary Create a new deployment
 * {@link /v13/deployments}
 */
export function createDeployment({
	queryParams,
}: {
	queryParams?: CreateDeploymentQueryParams;
}): Effect.Effect<
	CreateDeploymentMutationResponse,
	| ApiError
	| ValidationError
	| CreateDeployment400
	| CreateDeployment401
	| CreateDeployment402
	| CreateDeployment403
	| CreateDeployment404
	| CreateDeployment409
	| CreateDeployment500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v13/deployments";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateDeploymentMutationResponse;
	});
}

/**
 * @description This endpoint allows you to cancel a deployment which is currently building, by supplying its `id` in the URL.
 * @summary Cancel a deployment
 * {@link /v12/deployments/:id/cancel}
 */
export function cancelDeployment({
	pathParams: { id },
	queryParams,
}: {
	pathParams: CancelDeploymentPathParams;
	queryParams?: CancelDeploymentQueryParams;
}): Effect.Effect<
	CancelDeploymentMutationResponse,
	| ApiError
	| ValidationError
	| CancelDeployment400
	| CancelDeployment401
	| CancelDeployment403
	| CancelDeployment404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v12/deployments/${id}/cancel`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: {},
		});

		return response as CancelDeploymentMutationResponse;
	});
}

/**
 * @description Retrieves a list of DNS records created for a domain name. By default it returns 20 records if no limit is provided. The rest can be retrieved using the pagination options.
 * @summary List existing DNS records
 * {@link /v4/domains/:domain/records}
 */
export function getRecords({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: GetRecordsPathParams;
	queryParams?: GetRecordsQueryParams;
}): Effect.Effect<
	GetRecordsQueryResponse,
	ApiError | ValidationError | GetRecords400 | GetRecords401 | GetRecords403 | GetRecords404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v4/domains/${domain}/records`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetRecordsQueryResponse;
	});
}

/**
 * @description Creates a DNS record for a domain.
 * @summary Create a DNS record
 * {@link /v2/domains/:domain/records}
 */
export function createRecord({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: CreateRecordPathParams;
	queryParams?: CreateRecordQueryParams;
}): Effect.Effect<
	CreateRecordMutationResponse,
	| ApiError
	| ValidationError
	| CreateRecord400
	| CreateRecord401
	| CreateRecord402
	| CreateRecord403
	| CreateRecord404
	| CreateRecord409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v2/domains/${domain}/records`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateRecordMutationResponse;
	});
}

/**
 * @description Updates an existing DNS record for a domain name.
 * @summary Update an existing DNS record
 * {@link /v1/domains/records/:recordId}
 */
export function updateRecord({
	pathParams: { recordId },
	queryParams,
}: {
	pathParams: UpdateRecordPathParams;
	queryParams?: UpdateRecordQueryParams;
}): Effect.Effect<
	UpdateRecordMutationResponse,
	| ApiError
	| ValidationError
	| UpdateRecord400
	| UpdateRecord401
	| UpdateRecord402
	| UpdateRecord403
	| UpdateRecord404
	| UpdateRecord409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (recordId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "recordId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/domains/records/${recordId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateRecordMutationResponse;
	});
}

/**
 * @description Removes an existing DNS record from a domain name.
 * @summary Delete a DNS record
 * {@link /v2/domains/:domain/records/:recordId}
 */
export function removeRecord({
	pathParams: { domain, recordId },
	queryParams,
}: {
	pathParams: RemoveRecordPathParams;
	queryParams?: RemoveRecordQueryParams;
}): Effect.Effect<
	RemoveRecordMutationResponse,
	| ApiError
	| ValidationError
	| RemoveRecord400
	| RemoveRecord401
	| RemoveRecord403
	| RemoveRecord404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}
		if (recordId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "recordId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v2/domains/${domain}/records/${recordId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as RemoveRecordMutationResponse;
	});
}

/**
 * @description Get a list of TLDs supported by Vercel
 * @summary Get supported TLDs
 * {@link /v1/registrar/tlds/supported}
 */
export function getSupportedTlds({
	queryParams,
}: {
	queryParams?: GetSupportedTldsQueryParams;
}): Effect.Effect<
	GetSupportedTldsQueryResponse,
	| ApiError
	| ValidationError
	| GetSupportedTlds400
	| GetSupportedTlds401
	| GetSupportedTlds403
	| GetSupportedTlds429
	| GetSupportedTlds500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/registrar/tlds/supported";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetSupportedTldsQueryResponse;
	});
}

/**
 * @description Get price data for a specific TLD. This only reflects base prices for the given TLD. Premium domains may have different prices. Use the [Get price data for a domain](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/get-price-data-for-a-domain) endpoint to get the price data for a specific domain.
 * @summary Get TLD price data
 * {@link /v1/registrar/tlds/:tld/price}
 */
export function getTldPrice({
	pathParams: { tld },
	queryParams,
}: {
	pathParams: GetTldPricePathParams;
	queryParams?: GetTldPriceQueryParams;
}): Effect.Effect<
	GetTldPriceQueryResponse,
	| ApiError
	| ValidationError
	| GetTldPrice400
	| GetTldPrice401
	| GetTldPrice403
	| GetTldPrice429
	| GetTldPrice500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (tld === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "tld",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/registrar/tlds/${tld}/price`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetTldPriceQueryResponse;
	});
}

/**
 * @description Get availability for a specific domain. If the domain is available, it can be purchased using the [Buy a domain](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/buy-a-domain) endpoint or the [Buy multiple domains](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/buy-multiple-domains) endpoint.
 * @summary Get availability for a domain
 * {@link /v1/registrar/domains/:domain/availability}
 */
export function getDomainAvailability({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: GetDomainAvailabilityPathParams;
	queryParams?: GetDomainAvailabilityQueryParams;
}): Effect.Effect<
	GetDomainAvailabilityQueryResponse,
	| ApiError
	| ValidationError
	| GetDomainAvailability400
	| GetDomainAvailability401
	| GetDomainAvailability403
	| GetDomainAvailability404
	| GetDomainAvailability429
	| GetDomainAvailability500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/registrar/domains/${domain}/availability`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetDomainAvailabilityQueryResponse;
	});
}

/**
 * @description Get price data for a specific domain
 * @summary Get price data for a domain
 * {@link /v1/registrar/domains/:domain/price}
 */
export function getDomainPrice({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: GetDomainPricePathParams;
	queryParams?: GetDomainPriceQueryParams;
}): Effect.Effect<
	GetDomainPriceQueryResponse,
	| ApiError
	| ValidationError
	| GetDomainPrice400
	| GetDomainPrice401
	| GetDomainPrice403
	| GetDomainPrice429
	| GetDomainPrice500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/registrar/domains/${domain}/price`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetDomainPriceQueryResponse;
	});
}

/**
 * @description Get availability for multiple domains. If the domains are available, they can be purchased using the [Buy a domain](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/buy-a-domain) endpoint or the [Buy multiple domains](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/buy-multiple-domains) endpoint.
 * @summary Get availability for multiple domains
 * {@link /v1/registrar/domains/availability}
 */
export function getBulkAvailability({
	queryParams,
}: {
	queryParams?: GetBulkAvailabilityQueryParams;
}): Effect.Effect<
	GetBulkAvailabilityMutationResponse,
	| ApiError
	| ValidationError
	| GetBulkAvailability400
	| GetBulkAvailability401
	| GetBulkAvailability403
	| GetBulkAvailability429
	| GetBulkAvailability500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/registrar/domains/availability";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as GetBulkAvailabilityMutationResponse;
	});
}

/**
 * @description Get the auth code for a domain. This is required to transfer a domain from Vercel to another registrar.
 * @summary Get the auth code for a domain
 * {@link /v1/registrar/domains/:domain/auth-code}
 */
export function getDomainAuthCode({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: GetDomainAuthCodePathParams;
	queryParams?: GetDomainAuthCodeQueryParams;
}): Effect.Effect<
	GetDomainAuthCodeQueryResponse,
	| ApiError
	| ValidationError
	| GetDomainAuthCode400
	| GetDomainAuthCode401
	| GetDomainAuthCode403
	| GetDomainAuthCode404
	| GetDomainAuthCode409
	| GetDomainAuthCode429
	| GetDomainAuthCode500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/registrar/domains/${domain}/auth-code`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetDomainAuthCodeQueryResponse;
	});
}

/**
 * @description Buy a domain
 * @summary Buy a domain
 * {@link /v1/registrar/domains/:domain/buy}
 */
export function buySingleDomain({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: BuySingleDomainPathParams;
	queryParams?: BuySingleDomainQueryParams;
}): Effect.Effect<
	BuySingleDomainMutationResponse,
	| ApiError
	| ValidationError
	| BuySingleDomain400
	| BuySingleDomain401
	| BuySingleDomain403
	| BuySingleDomain429
	| BuySingleDomain500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/registrar/domains/${domain}/buy`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as BuySingleDomainMutationResponse;
	});
}

/**
 * @description Buy multiple domains at once
 * @summary Buy multiple domains
 * {@link /v1/registrar/domains/buy}
 */
export function buyDomains({
	queryParams,
}: {
	queryParams?: BuyDomainsQueryParams;
}): Effect.Effect<
	BuyDomainsMutationResponse,
	| ApiError
	| ValidationError
	| BuyDomains400
	| BuyDomains401
	| BuyDomains403
	| BuyDomains429
	| BuyDomains500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/registrar/domains/buy";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as BuyDomainsMutationResponse;
	});
}

/**
 * @description Transfer a domain in from another registrar
 * @summary Transfer-in a domain
 * {@link /v1/registrar/domains/:domain/transfer}
 */
export function transferInDomain({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: TransferInDomainPathParams;
	queryParams?: TransferInDomainQueryParams;
}): Effect.Effect<
	TransferInDomainMutationResponse,
	| ApiError
	| ValidationError
	| TransferInDomain400
	| TransferInDomain401
	| TransferInDomain403
	| TransferInDomain429
	| TransferInDomain500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/registrar/domains/${domain}/transfer`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as TransferInDomainMutationResponse;
	});
}

/**
 * @description Get the transfer status for a domain
 * @summary Get a domain's transfer status
 * {@link /v1/registrar/domains/:domain/transfer}
 */
export function getDomainTransferIn({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: GetDomainTransferInPathParams;
	queryParams?: GetDomainTransferInQueryParams;
}): Effect.Effect<
	GetDomainTransferInQueryResponse,
	| ApiError
	| ValidationError
	| GetDomainTransferIn400
	| GetDomainTransferIn401
	| GetDomainTransferIn403
	| GetDomainTransferIn404
	| GetDomainTransferIn429
	| GetDomainTransferIn500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/registrar/domains/${domain}/transfer`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetDomainTransferInQueryResponse;
	});
}

/**
 * @description Renew a domain
 * @summary Renew a domain
 * {@link /v1/registrar/domains/:domain/renew}
 */
export function renewDomain({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: RenewDomainPathParams;
	queryParams?: RenewDomainQueryParams;
}): Effect.Effect<
	RenewDomainMutationResponse,
	| ApiError
	| ValidationError
	| RenewDomain400
	| RenewDomain401
	| RenewDomain403
	| RenewDomain404
	| RenewDomain429
	| RenewDomain500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/registrar/domains/${domain}/renew`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as RenewDomainMutationResponse;
	});
}

/**
 * @description Update the auto-renew setting for a domain
 * @summary Update auto-renew for a domain
 * {@link /v1/registrar/domains/:domain/auto-renew}
 */
export function updateDomainAutoRenew({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: UpdateDomainAutoRenewPathParams;
	queryParams?: UpdateDomainAutoRenewQueryParams;
}): Effect.Effect<
	UpdateDomainAutoRenewMutationResponse,
	| ApiError
	| ValidationError
	| UpdateDomainAutoRenew400
	| UpdateDomainAutoRenew401
	| UpdateDomainAutoRenew403
	| UpdateDomainAutoRenew404
	| UpdateDomainAutoRenew429
	| UpdateDomainAutoRenew500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/registrar/domains/${domain}/auto-renew`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateDomainAutoRenewMutationResponse;
	});
}

/**
 * @description Update the nameservers for a domain. Pass an empty array to use Vercel's default nameservers.
 * @summary Update nameservers for a domain
 * {@link /v1/registrar/domains/:domain/nameservers}
 */
export function updateDomainNameservers({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: UpdateDomainNameserversPathParams;
	queryParams?: UpdateDomainNameserversQueryParams;
}): Effect.Effect<
	UpdateDomainNameserversMutationResponse,
	| ApiError
	| ValidationError
	| UpdateDomainNameservers400
	| UpdateDomainNameservers401
	| UpdateDomainNameservers403
	| UpdateDomainNameservers404
	| UpdateDomainNameservers429
	| UpdateDomainNameservers500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/registrar/domains/${domain}/nameservers`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateDomainNameserversMutationResponse;
	});
}

/**
 * @description Some TLDs require additional contact information. Use this endpoint to get the schema for the tld-specific contact information for a domain.
 * @summary Get contact info schema
 * {@link /v1/registrar/domains/:domain/contact-info/schema}
 */
export function getContactInfoSchema({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: GetContactInfoSchemaPathParams;
	queryParams?: GetContactInfoSchemaQueryParams;
}): Effect.Effect<
	GetContactInfoSchemaQueryResponse,
	| ApiError
	| ValidationError
	| GetContactInfoSchema400
	| GetContactInfoSchema401
	| GetContactInfoSchema403
	| GetContactInfoSchema429
	| GetContactInfoSchema500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/registrar/domains/${domain}/contact-info/schema`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetContactInfoSchemaQueryResponse;
	});
}

/**
 * @description Get information about a domain order by its ID
 * @summary Get a domain order
 * {@link /v1/registrar/orders/:orderId}
 */
export function getOrder({
	pathParams: { orderId },
	queryParams,
}: {
	pathParams: GetOrderPathParams;
	queryParams?: GetOrderQueryParams;
}): Effect.Effect<
	GetOrderQueryResponse,
	| ApiError
	| ValidationError
	| GetOrder400
	| GetOrder401
	| GetOrder403
	| GetOrder404
	| GetOrder429
	| GetOrder500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (orderId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "orderId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/registrar/orders/${orderId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetOrderQueryResponse;
	});
}

/**
 * @description Get a Domain's configuration.
 * @summary Get a Domain's configuration
 * {@link /v6/domains/:domain/config}
 */
export function getDomainConfig({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: GetDomainConfigPathParams;
	queryParams?: GetDomainConfigQueryParams;
}): Effect.Effect<
	GetDomainConfigQueryResponse,
	ApiError | ValidationError | GetDomainConfig400 | GetDomainConfig401 | GetDomainConfig403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v6/domains/${domain}/config`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetDomainConfigQueryResponse;
	});
}

/**
 * @description Get information for a single domain in an account or team.
 * @summary Get Information for a Single Domain
 * {@link /v5/domains/:domain}
 */
export function getDomain({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: GetDomainPathParams;
	queryParams?: GetDomainQueryParams;
}): Effect.Effect<
	GetDomainQueryResponse,
	ApiError | ValidationError | GetDomain400 | GetDomain401 | GetDomain403 | GetDomain404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v5/domains/${domain}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetDomainQueryResponse;
	});
}

/**
 * @description Retrieves a list of domains registered for the authenticated user or team. By default it returns the last 20 domains if no limit is provided.
 * @summary List all the domains
 * {@link /v5/domains}
 */
export function getDomains({
	queryParams,
}: {
	queryParams?: GetDomainsQueryParams;
}): Effect.Effect<
	GetDomainsQueryResponse,
	ApiError | ValidationError | GetDomains400 | GetDomains401 | GetDomains403 | GetDomains409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v5/domains";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetDomainsQueryResponse;
	});
}

/**
 * @description This endpoint is used for adding a new apex domain name with Vercel for the authenticating user. Note: This endpoint is no longer used for initiating domain transfers from external registrars to Vercel. For this, please use the endpoint [Transfer-in a domain](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/transfer-in-a-domain).
 * @summary Add an existing domain to the Vercel platform
 * {@link /v7/domains}
 */
export function createOrTransferDomain({
	queryParams,
}: {
	queryParams?: CreateOrTransferDomainQueryParams;
}): Effect.Effect<
	CreateOrTransferDomainMutationResponse,
	| ApiError
	| ValidationError
	| CreateOrTransferDomain400
	| CreateOrTransferDomain401
	| CreateOrTransferDomain402
	| CreateOrTransferDomain403
	| CreateOrTransferDomain404
	| CreateOrTransferDomain409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v7/domains";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateOrTransferDomainMutationResponse;
	});
}

/**
 * @description Update or move apex domain. Note: This endpoint is no longer used for updating auto-renew or nameservers. For this, please use the endpoints [Update auto-renew for a domain](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/update-auto-renew-for-a-domain) and [Update nameservers for a domain](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/update-nameservers-for-a-domain).
 * @summary Update or move apex domain
 * {@link /v3/domains/:domain}
 */
export function patchDomain({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: PatchDomainPathParams;
	queryParams?: PatchDomainQueryParams;
}): Effect.Effect<
	PatchDomainMutationResponse,
	| ApiError
	| ValidationError
	| PatchDomain400
	| PatchDomain401
	| PatchDomain403
	| PatchDomain404
	| PatchDomain409
	| PatchDomain500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v3/domains/${domain}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as PatchDomainMutationResponse;
	});
}

/**
 * @description Delete a previously registered domain name from Vercel. Deleting a domain will automatically remove any associated aliases.
 * @summary Remove a domain by name
 * {@link /v6/domains/:domain}
 */
export function deleteDomain({
	pathParams: { domain },
	queryParams,
}: {
	pathParams: DeleteDomainPathParams;
	queryParams?: DeleteDomainQueryParams;
}): Effect.Effect<
	DeleteDomainMutationResponse,
	| ApiError
	| ValidationError
	| DeleteDomain400
	| DeleteDomain401
	| DeleteDomain403
	| DeleteDomain404
	| DeleteDomain409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v6/domains/${domain}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteDomainMutationResponse;
	});
}

/**
 * @description Retrieves a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be accessed.
 * @summary Retrieves a Configurable Log Drain (deprecated)
 * {@link /v1/log-drains/:id}
 */
export function getConfigurableLogDrain({
	pathParams: { id },
	queryParams,
}: {
	pathParams: GetConfigurableLogDrainPathParams;
	queryParams?: GetConfigurableLogDrainQueryParams;
}): Effect.Effect<
	GetConfigurableLogDrainQueryResponse,
	| ApiError
	| ValidationError
	| GetConfigurableLogDrain400
	| GetConfigurableLogDrain401
	| GetConfigurableLogDrain403
	| GetConfigurableLogDrain404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/log-drains/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetConfigurableLogDrainQueryResponse;
	});
}

/**
 * @description Deletes a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be deleted.
 * @summary Deletes a Configurable Log Drain (deprecated)
 * {@link /v1/log-drains/:id}
 */
export function deleteConfigurableLogDrain({
	pathParams: { id },
	queryParams,
}: {
	pathParams: DeleteConfigurableLogDrainPathParams;
	queryParams?: DeleteConfigurableLogDrainQueryParams;
}): Effect.Effect<
	DeleteConfigurableLogDrainMutationResponse,
	| ApiError
	| ValidationError
	| DeleteConfigurableLogDrain400
	| DeleteConfigurableLogDrain401
	| DeleteConfigurableLogDrain403
	| DeleteConfigurableLogDrain404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/log-drains/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteConfigurableLogDrainMutationResponse;
	});
}

/**
 * @description Retrieves a list of all the Log Drains owned by the account. This endpoint must be called with an account AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated account can be accessed.
 * @summary Retrieves a list of all the Log Drains (deprecated)
 * {@link /v1/log-drains}
 */
export function getAllLogDrains({
	queryParams,
}: {
	queryParams?: GetAllLogDrainsQueryParams;
}): Effect.Effect<
	GetAllLogDrainsQueryResponse,
	| ApiError
	| ValidationError
	| GetAllLogDrains400
	| GetAllLogDrains401
	| GetAllLogDrains403
	| GetAllLogDrains404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/log-drains";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetAllLogDrainsQueryResponse;
	});
}

/**
 * @description Creates a configurable log drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed)
 * @summary Creates a Configurable Log Drain (deprecated)
 * {@link /v1/log-drains}
 */
export function createConfigurableLogDrain({
	queryParams,
}: {
	queryParams?: CreateConfigurableLogDrainQueryParams;
}): Effect.Effect<
	CreateConfigurableLogDrainMutationResponse,
	| ApiError
	| ValidationError
	| CreateConfigurableLogDrain400
	| CreateConfigurableLogDrain401
	| CreateConfigurableLogDrain403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/log-drains";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateConfigurableLogDrainMutationResponse;
	});
}

/**
 * @description Create a new Drain with the provided configuration.
 * @summary Create a new Drain
 * {@link /v1/drains}
 */
export function createDrain({
	queryParams,
}: {
	queryParams?: CreateDrainQueryParams;
}): Effect.Effect<
	CreateDrainMutationResponse,
	ApiError | ValidationError | CreateDrain400 | CreateDrain401 | CreateDrain403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/drains";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateDrainMutationResponse;
	});
}

/**
 * @description Allows to retrieve the list of Drains of the authenticated team.
 * @summary Retrieve a list of all Drains
 * {@link /v1/drains}
 */
export function getDrains({
	queryParams,
}: {
	queryParams?: GetDrainsQueryParams;
}): Effect.Effect<
	GetDrainsQueryResponse,
	ApiError | ValidationError | GetDrains400 | GetDrains401 | GetDrains403 | GetDrains404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/drains";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetDrainsQueryResponse;
	});
}

/**
 * @description Delete a specific Drain by passing the drain id in the URL.
 * @summary Delete a drain
 * {@link /v1/drains/:id}
 */
export function deleteDrain({
	pathParams: { id },
	queryParams,
}: {
	pathParams: DeleteDrainPathParams;
	queryParams?: DeleteDrainQueryParams;
}): Effect.Effect<
	DeleteDrainMutationResponse,
	ApiError | ValidationError | DeleteDrain400 | DeleteDrain401 | DeleteDrain403 | DeleteDrain404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/drains/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteDrainMutationResponse;
	});
}

/**
 * @description Get the information for a specific Drain by passing the drain id in the URL.
 * @summary Find a Drain by id
 * {@link /v1/drains/:id}
 */
export function getDrain({
	pathParams: { id },
	queryParams,
}: {
	pathParams: GetDrainPathParams;
	queryParams?: GetDrainQueryParams;
}): Effect.Effect<
	GetDrainQueryResponse,
	ApiError | ValidationError | GetDrain400 | GetDrain401 | GetDrain403 | GetDrain404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/drains/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetDrainQueryResponse;
	});
}

/**
 * @description Update the configuration of an existing drain.
 * @summary Update an existing Drain
 * {@link /v1/drains/:id}
 */
export function updateDrain({
	pathParams: { id },
	queryParams,
}: {
	pathParams: UpdateDrainPathParams;
	queryParams?: UpdateDrainQueryParams;
}): Effect.Effect<
	UpdateDrainMutationResponse,
	ApiError | ValidationError | UpdateDrain400 | UpdateDrain401 | UpdateDrain403 | UpdateDrain404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/drains/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateDrainMutationResponse;
	});
}

/**
 * @description Validate the delivery configuration of a Drain using sample events.
 * @summary Validate Drain delivery configuration
 * {@link /v1/drains/test}
 */
export function testDrain({
	queryParams,
}: {
	queryParams?: TestDrainQueryParams;
}): Effect.Effect<
	TestDrainMutationResponse,
	ApiError | ValidationError | TestDrain400 | TestDrain401 | TestDrain403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/drains/test";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as TestDrainMutationResponse;
	});
}

/**
 * @description Marks a cache tag as stale, causing cache entries associated with that tag to be revalidated in the background on the next request.
 * @summary Invalidate by tag
 * {@link /v1/edge-cache/invalidate-by-tags}
 */
export function invalidateByTags({
	queryParams,
}: {
	queryParams: InvalidateByTagsQueryParams;
}): Effect.Effect<
	InvalidateByTagsMutationResponse,
	| ApiError
	| ValidationError
	| InvalidateByTags400
	| InvalidateByTags401
	| InvalidateByTags403
	| InvalidateByTags404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/edge-cache/invalidate-by-tags";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as InvalidateByTagsMutationResponse;
	});
}

/**
 * @description Marks a cache tag as deleted, causing cache entries associated with that tag to be revalidated in the foreground on the next request. Use this method with caution because one tag can be associated with many paths and deleting the cache can cause many concurrent requests to the origin leading to cache stampede problem. This method is for advanced use cases and is not recommended; prefer using `invalidateByTag` instead.
 * @summary Dangerously delete by tag
 * {@link /v1/edge-cache/dangerously-delete-by-tags}
 */
export function dangerouslyDeleteByTags({
	queryParams,
}: {
	queryParams: DangerouslyDeleteByTagsQueryParams;
}): Effect.Effect<
	DangerouslyDeleteByTagsMutationResponse,
	| ApiError
	| ValidationError
	| DangerouslyDeleteByTags400
	| DangerouslyDeleteByTags401
	| DangerouslyDeleteByTags403
	| DangerouslyDeleteByTags404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/edge-cache/dangerously-delete-by-tags";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as DangerouslyDeleteByTagsMutationResponse;
	});
}

/**
 * @description Marks a source image as stale, causing its corresponding transformed images to be revalidated in the background on the next request.
 * @summary Invalidate by source image
 * {@link /v1/edge-cache/invalidate-by-src-images}
 */
export function invalidateBySrcImages({
	queryParams,
}: {
	queryParams: InvalidateBySrcImagesQueryParams;
}): Effect.Effect<
	InvalidateBySrcImagesMutationResponse,
	| ApiError
	| ValidationError
	| InvalidateBySrcImages400
	| InvalidateBySrcImages401
	| InvalidateBySrcImages402
	| InvalidateBySrcImages403
	| InvalidateBySrcImages404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/edge-cache/invalidate-by-src-images";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as InvalidateBySrcImagesMutationResponse;
	});
}

/**
 * @description Marks a source image as deleted, causing cache entries associated with that source image to be revalidated in the foreground on the next request. Use this method with caution because one source image can be associated with many paths and deleting the cache can cause many concurrent requests to the origin leading to cache stampede problem. This method is for advanced use cases and is not recommended; prefer using `invalidateBySrcImage` instead.
 * @summary Dangerously delete by source image
 * {@link /v1/edge-cache/dangerously-delete-by-src-images}
 */
export function dangerouslyDeleteBySrcImages({
	queryParams,
}: {
	queryParams: DangerouslyDeleteBySrcImagesQueryParams;
}): Effect.Effect<
	DangerouslyDeleteBySrcImagesMutationResponse,
	| ApiError
	| ValidationError
	| DangerouslyDeleteBySrcImages400
	| DangerouslyDeleteBySrcImages401
	| DangerouslyDeleteBySrcImages402
	| DangerouslyDeleteBySrcImages403
	| DangerouslyDeleteBySrcImages404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/edge-cache/dangerously-delete-by-src-images";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as DangerouslyDeleteBySrcImagesMutationResponse;
	});
}

/**
 * @description Returns all Edge Configs.
 * @summary Get Edge Configs
 * {@link /v1/edge-config}
 */
export function getEdgeConfigs({
	queryParams,
}: {
	queryParams?: GetEdgeConfigsQueryParams;
}): Effect.Effect<
	GetEdgeConfigsQueryResponse,
	ApiError | ValidationError | GetEdgeConfigs400 | GetEdgeConfigs401 | GetEdgeConfigs403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/edge-config";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetEdgeConfigsQueryResponse;
	});
}

/**
 * @description Creates an Edge Config.
 * @summary Create an Edge Config
 * {@link /v1/edge-config}
 */
export function createEdgeConfig({
	queryParams,
}: {
	queryParams?: CreateEdgeConfigQueryParams;
}): Effect.Effect<
	CreateEdgeConfigMutationResponse,
	| ApiError
	| ValidationError
	| CreateEdgeConfig400
	| CreateEdgeConfig401
	| CreateEdgeConfig402
	| CreateEdgeConfig403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/edge-config";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateEdgeConfigMutationResponse;
	});
}

/**
 * @description Returns an Edge Config.
 * @summary Get an Edge Config
 * {@link /v1/edge-config/:edgeConfigId}
 */
export function getEdgeConfig({
	pathParams: { edgeConfigId },
	queryParams,
}: {
	pathParams: GetEdgeConfigPathParams;
	queryParams?: GetEdgeConfigQueryParams;
}): Effect.Effect<
	GetEdgeConfigQueryResponse,
	| ApiError
	| ValidationError
	| GetEdgeConfig400
	| GetEdgeConfig401
	| GetEdgeConfig403
	| GetEdgeConfig404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetEdgeConfigQueryResponse;
	});
}

/**
 * @description Updates an Edge Config.
 * @summary Update an Edge Config
 * {@link /v1/edge-config/:edgeConfigId}
 */
export function updateEdgeConfig({
	pathParams: { edgeConfigId },
	queryParams,
}: {
	pathParams: UpdateEdgeConfigPathParams;
	queryParams?: UpdateEdgeConfigQueryParams;
}): Effect.Effect<
	UpdateEdgeConfigMutationResponse,
	| ApiError
	| ValidationError
	| UpdateEdgeConfig400
	| UpdateEdgeConfig401
	| UpdateEdgeConfig402
	| UpdateEdgeConfig403
	| UpdateEdgeConfig404
	| UpdateEdgeConfig409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PUT",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateEdgeConfigMutationResponse;
	});
}

/**
 * @description Delete an Edge Config by id.
 * @summary Delete an Edge Config
 * {@link /v1/edge-config/:edgeConfigId}
 */
export function deleteEdgeConfig({
	pathParams: { edgeConfigId },
	queryParams,
}: {
	pathParams: DeleteEdgeConfigPathParams;
	queryParams?: DeleteEdgeConfigQueryParams;
}): Effect.Effect<
	DeleteEdgeConfigMutationResponse,
	| ApiError
	| ValidationError
	| DeleteEdgeConfig400
	| DeleteEdgeConfig401
	| DeleteEdgeConfig403
	| DeleteEdgeConfig404
	| DeleteEdgeConfig409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteEdgeConfigMutationResponse;
	});
}

/**
 * @description Returns all items of an Edge Config.
 * @summary Get Edge Config items
 * {@link /v1/edge-config/:edgeConfigId/items}
 */
export function getEdgeConfigItems({
	pathParams: { edgeConfigId },
	queryParams,
}: {
	pathParams: GetEdgeConfigItemsPathParams;
	queryParams?: GetEdgeConfigItemsQueryParams;
}): Effect.Effect<
	GetEdgeConfigItemsQueryResponse,
	| ApiError
	| ValidationError
	| GetEdgeConfigItems400
	| GetEdgeConfigItems401
	| GetEdgeConfigItems403
	| GetEdgeConfigItems404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}/items`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetEdgeConfigItemsQueryResponse;
	});
}

/**
 * @description Update multiple Edge Config Items in batch.
 * @summary Update Edge Config items in batch
 * {@link /v1/edge-config/:edgeConfigId/items}
 */
export function patchEdgeConfigItems({
	pathParams: { edgeConfigId },
	queryParams,
}: {
	pathParams: PatchEdgeConfigItemsPathParams;
	queryParams?: PatchEdgeConfigItemsQueryParams;
}): Effect.Effect<
	PatchEdgeConfigItemsMutationResponse,
	| ApiError
	| ValidationError
	| PatchEdgeConfigItems400
	| PatchEdgeConfigItems401
	| PatchEdgeConfigItems402
	| PatchEdgeConfigItems403
	| PatchEdgeConfigItems404
	| PatchEdgeConfigItems409
	| PatchEdgeConfigItems412,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}/items`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as PatchEdgeConfigItemsMutationResponse;
	});
}

/**
 * @description Returns the schema of an Edge Config.
 * @summary Get Edge Config schema
 * {@link /v1/edge-config/:edgeConfigId/schema}
 */
export function getEdgeConfigSchema({
	pathParams: { edgeConfigId },
	queryParams,
}: {
	pathParams: GetEdgeConfigSchemaPathParams;
	queryParams?: GetEdgeConfigSchemaQueryParams;
}): Effect.Effect<
	GetEdgeConfigSchemaQueryResponse,
	| ApiError
	| ValidationError
	| GetEdgeConfigSchema400
	| GetEdgeConfigSchema401
	| GetEdgeConfigSchema403
	| GetEdgeConfigSchema404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}/schema`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetEdgeConfigSchemaQueryResponse;
	});
}

/**
 * @description Update an Edge Config's schema.
 * @summary Update Edge Config schema
 * {@link /v1/edge-config/:edgeConfigId/schema}
 */
export function patchEdgeConfigSchema({
	pathParams: { edgeConfigId },
	queryParams,
}: {
	pathParams: PatchEdgeConfigSchemaPathParams;
	queryParams?: PatchEdgeConfigSchemaQueryParams;
}): Effect.Effect<
	PatchEdgeConfigSchemaMutationResponse,
	| ApiError
	| ValidationError
	| PatchEdgeConfigSchema400
	| PatchEdgeConfigSchema401
	| PatchEdgeConfigSchema402
	| PatchEdgeConfigSchema403
	| PatchEdgeConfigSchema404
	| PatchEdgeConfigSchema409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}/schema`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as PatchEdgeConfigSchemaMutationResponse;
	});
}

/**
 * @description Deletes the schema of existing Edge Config.
 * @summary Delete an Edge Config's schema
 * {@link /v1/edge-config/:edgeConfigId/schema}
 */
export function deleteEdgeConfigSchema({
	pathParams: { edgeConfigId },
	queryParams,
}: {
	pathParams: DeleteEdgeConfigSchemaPathParams;
	queryParams?: DeleteEdgeConfigSchemaQueryParams;
}): Effect.Effect<
	DeleteEdgeConfigSchemaMutationResponse,
	| ApiError
	| ValidationError
	| DeleteEdgeConfigSchema400
	| DeleteEdgeConfigSchema401
	| DeleteEdgeConfigSchema402
	| DeleteEdgeConfigSchema403
	| DeleteEdgeConfigSchema404
	| DeleteEdgeConfigSchema409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}/schema`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteEdgeConfigSchemaMutationResponse;
	});
}

/**
 * @description Returns a specific Edge Config Item.
 * @summary Get an Edge Config item
 * {@link /v1/edge-config/:edgeConfigId/item/:edgeConfigItemKey}
 */
export function getEdgeConfigItem({
	pathParams: { edgeConfigId, edgeConfigItemKey },
	queryParams,
}: {
	pathParams: GetEdgeConfigItemPathParams;
	queryParams?: GetEdgeConfigItemQueryParams;
}): Effect.Effect<
	GetEdgeConfigItemQueryResponse,
	| ApiError
	| ValidationError
	| GetEdgeConfigItem400
	| GetEdgeConfigItem401
	| GetEdgeConfigItem403
	| GetEdgeConfigItem404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (edgeConfigItemKey === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigItemKey",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}/item/${edgeConfigItemKey}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetEdgeConfigItemQueryResponse;
	});
}

/**
 * @description Returns all tokens of an Edge Config.
 * @summary Get all tokens of an Edge Config
 * {@link /v1/edge-config/:edgeConfigId/tokens}
 */
export function getEdgeConfigTokens({
	pathParams: { edgeConfigId },
	queryParams,
}: {
	pathParams: GetEdgeConfigTokensPathParams;
	queryParams?: GetEdgeConfigTokensQueryParams;
}): Effect.Effect<
	GetEdgeConfigTokensQueryResponse,
	| ApiError
	| ValidationError
	| GetEdgeConfigTokens400
	| GetEdgeConfigTokens401
	| GetEdgeConfigTokens403
	| GetEdgeConfigTokens404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}/tokens`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetEdgeConfigTokensQueryResponse;
	});
}

/**
 * @description Deletes one or more tokens of an existing Edge Config.
 * @summary Delete one or more Edge Config tokens
 * {@link /v1/edge-config/:edgeConfigId/tokens}
 */
export function deleteEdgeConfigTokens({
	pathParams: { edgeConfigId },
	queryParams,
}: {
	pathParams: DeleteEdgeConfigTokensPathParams;
	queryParams?: DeleteEdgeConfigTokensQueryParams;
}): Effect.Effect<
	DeleteEdgeConfigTokensMutationResponse,
	| ApiError
	| ValidationError
	| DeleteEdgeConfigTokens400
	| DeleteEdgeConfigTokens401
	| DeleteEdgeConfigTokens402
	| DeleteEdgeConfigTokens403
	| DeleteEdgeConfigTokens404
	| DeleteEdgeConfigTokens409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}/tokens`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as DeleteEdgeConfigTokensMutationResponse;
	});
}

/**
 * @description Return meta data about an Edge Config token.
 * @summary Get Edge Config token meta data
 * {@link /v1/edge-config/:edgeConfigId/token/:token}
 */
export function getEdgeConfigToken({
	pathParams: { edgeConfigId, token },
	queryParams,
}: {
	pathParams: GetEdgeConfigTokenPathParams;
	queryParams?: GetEdgeConfigTokenQueryParams;
}): Effect.Effect<
	GetEdgeConfigTokenQueryResponse,
	| ApiError
	| ValidationError
	| GetEdgeConfigToken400
	| GetEdgeConfigToken401
	| GetEdgeConfigToken403
	| GetEdgeConfigToken404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (token === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "token",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}/token/${token}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetEdgeConfigTokenQueryResponse;
	});
}

/**
 * @description Adds a token to an existing Edge Config.
 * @summary Create an Edge Config token
 * {@link /v1/edge-config/:edgeConfigId/token}
 */
export function createEdgeConfigToken({
	pathParams: { edgeConfigId },
	queryParams,
}: {
	pathParams: CreateEdgeConfigTokenPathParams;
	queryParams?: CreateEdgeConfigTokenQueryParams;
}): Effect.Effect<
	CreateEdgeConfigTokenMutationResponse,
	| ApiError
	| ValidationError
	| CreateEdgeConfigToken400
	| CreateEdgeConfigToken401
	| CreateEdgeConfigToken402
	| CreateEdgeConfigToken403
	| CreateEdgeConfigToken404
	| CreateEdgeConfigToken409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}/token`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateEdgeConfigTokenMutationResponse;
	});
}

/**
 * @description Retrieves a specific version of an Edge Config from backup storage.
 * @summary Get Edge Config backup
 * {@link /v1/edge-config/:edgeConfigId/backups/:edgeConfigBackupVersionId}
 */
export function getEdgeConfigBackup({
	pathParams: { edgeConfigId, edgeConfigBackupVersionId },
	queryParams,
}: {
	pathParams: GetEdgeConfigBackupPathParams;
	queryParams?: GetEdgeConfigBackupQueryParams;
}): Effect.Effect<
	GetEdgeConfigBackupQueryResponse,
	| ApiError
	| ValidationError
	| GetEdgeConfigBackup400
	| GetEdgeConfigBackup401
	| GetEdgeConfigBackup403
	| GetEdgeConfigBackup404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (edgeConfigBackupVersionId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigBackupVersionId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}/backups/${edgeConfigBackupVersionId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetEdgeConfigBackupQueryResponse;
	});
}

/**
 * @description Returns backups of an Edge Config.
 * @summary Get Edge Config backups
 * {@link /v1/edge-config/:edgeConfigId/backups}
 */
export function getEdgeConfigBackups({
	pathParams: { edgeConfigId },
	queryParams,
}: {
	pathParams: GetEdgeConfigBackupsPathParams;
	queryParams?: GetEdgeConfigBackupsQueryParams;
}): Effect.Effect<
	GetEdgeConfigBackupsQueryResponse,
	| ApiError
	| ValidationError
	| GetEdgeConfigBackups400
	| GetEdgeConfigBackups401
	| GetEdgeConfigBackups403
	| GetEdgeConfigBackups404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (edgeConfigId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "edgeConfigId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/edge-config/${edgeConfigId}/backups`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetEdgeConfigBackupsQueryResponse;
	});
}

/**
 * @description Creates shared environment variable(s) for a team.
 * @summary Create one or more shared environment variables
 * {@link /v1/env}
 */
export function createSharedEnvVariable({
	queryParams,
}: {
	queryParams?: CreateSharedEnvVariableQueryParams;
}): Effect.Effect<
	CreateSharedEnvVariableMutationResponse,
	| ApiError
	| ValidationError
	| CreateSharedEnvVariable400
	| CreateSharedEnvVariable401
	| CreateSharedEnvVariable402
	| CreateSharedEnvVariable403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/env";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateSharedEnvVariableMutationResponse;
	});
}

/**
 * @description Lists all Shared Environment Variables for a team, taking into account optional filters.
 * @summary Lists all Shared Environment Variables for a team
 * {@link /v1/env}
 */
export function listSharedEnvVariable({
	queryParams,
}: {
	queryParams?: ListSharedEnvVariableQueryParams;
}): Effect.Effect<
	ListSharedEnvVariableQueryResponse,
	| ApiError
	| ValidationError
	| ListSharedEnvVariable400
	| ListSharedEnvVariable401
	| ListSharedEnvVariable403
	| ListSharedEnvVariable404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/env";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ListSharedEnvVariableQueryResponse;
	});
}

/**
 * @description Updates a given Shared Environment Variable for a Team.
 * @summary Updates one or more shared environment variables
 * {@link /v1/env}
 */
export function updateSharedEnvVariable({
	queryParams,
}: {
	queryParams?: UpdateSharedEnvVariableQueryParams;
}): Effect.Effect<
	UpdateSharedEnvVariableMutationResponse,
	| ApiError
	| ValidationError
	| UpdateSharedEnvVariable400
	| UpdateSharedEnvVariable401
	| UpdateSharedEnvVariable402
	| UpdateSharedEnvVariable403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/env";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateSharedEnvVariableMutationResponse;
	});
}

/**
 * @description Deletes one or many Shared Environment Variables for a given team.
 * @summary Delete one or more Env Var
 * {@link /v1/env}
 */
export function deleteSharedEnvVariable({
	queryParams,
}: {
	queryParams?: DeleteSharedEnvVariableQueryParams;
}): Effect.Effect<
	DeleteSharedEnvVariableMutationResponse,
	| ApiError
	| ValidationError
	| DeleteSharedEnvVariable400
	| DeleteSharedEnvVariable401
	| DeleteSharedEnvVariable402
	| DeleteSharedEnvVariable403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/env";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as DeleteSharedEnvVariableMutationResponse;
	});
}

/**
 * @description Retrieve the decrypted value of a Shared Environment Variable by id.
 * @summary Retrieve the decrypted value of a Shared Environment Variable by id.
 * {@link /v1/env/:id}
 */
export function getSharedEnvVar({
	pathParams: { id },
	queryParams,
}: {
	pathParams: GetSharedEnvVarPathParams;
	queryParams?: GetSharedEnvVarQueryParams;
}): Effect.Effect<
	GetSharedEnvVarQueryResponse,
	ApiError | ValidationError | GetSharedEnvVar400 | GetSharedEnvVar401 | GetSharedEnvVar403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/env/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetSharedEnvVarQueryResponse;
	});
}

/**
 * @description Disconnects a shared environment variable for a given project
 * @summary Disconnects a shared environment variable for a given project
 * {@link /v1/env/:id/unlink/:projectId}
 */
export function unlinkSharedEnvVariable({
	pathParams: { id, projectId },
	queryParams,
}: {
	pathParams: UnlinkSharedEnvVariablePathParams;
	queryParams?: UnlinkSharedEnvVariableQueryParams;
}): Effect.Effect<
	UnlinkSharedEnvVariableMutationResponse,
	| ApiError
	| ValidationError
	| UnlinkSharedEnvVariable400
	| UnlinkSharedEnvVariable401
	| UnlinkSharedEnvVariable403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}
		if (projectId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "projectId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/env/${id}/unlink/${projectId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: {},
		});

		return response as UnlinkSharedEnvVariableMutationResponse;
	});
}

/**
 * @description Retrieves a list of "events" generated by the User on Vercel. Events are generated when the User performs a particular action, such as logging in, creating a deployment, and joining a Team (just to name a few). When the `teamId` parameter is supplied, then the events that are returned will be in relation to the Team that was specified.
 * @summary List User Events
 * {@link /v3/events}
 */
export function listUserEvents({
	queryParams,
}: {
	queryParams?: ListUserEventsQueryParams;
}): Effect.Effect<
	ListUserEventsQueryResponse,
	ApiError | ValidationError | ListUserEvents400 | ListUserEvents401 | ListUserEvents403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v3/events";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ListUserEventsQueryResponse;
	});
}

/**
 * @description Lists git namespaces for a supported provider. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider is not provided, it will try to obtain it from the user that authenticated the request.
 * @summary List git namespaces by provider
 * {@link /v1/integrations/git-namespaces}
 */
export function gitNamespaces({
	queryParams,
}: {
	queryParams?: GitNamespacesQueryParams;
}): Effect.Effect<
	GitNamespacesQueryResponse,
	| ApiError
	| ValidationError
	| GitNamespaces400
	| GitNamespaces401
	| GitNamespaces403
	| GitNamespaces404
	| GitNamespaces429
	| GitNamespaces500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/integrations/git-namespaces";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GitNamespacesQueryResponse;
	});
}

/**
 * @description Lists git repositories linked to a namespace `id` for a supported provider. A specific namespace `id` can be obtained via the `git-namespaces`  endpoint. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider or namespace is not provided, it will try to obtain it from the user that authenticated the request.
 * @summary List git repositories linked to namespace by provider
 * {@link /v1/integrations/search-repo}
 */
export function searchRepo({
	queryParams,
}: {
	queryParams?: SearchRepoQueryParams;
}): Effect.Effect<
	SearchRepoQueryResponse,
	| ApiError
	| ValidationError
	| SearchRepo400
	| SearchRepo401
	| SearchRepo403
	| SearchRepo404
	| SearchRepo429
	| SearchRepo500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/integrations/search-repo";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as SearchRepoQueryResponse;
	});
}

/**
 * @description Get a list of billing plans for an integration and product.
 * @summary List integration billing plans
 * {@link /v1/integrations/integration/:integrationIdOrSlug/products/:productIdOrSlug/plans}
 */
export function getBillingPlans({
	pathParams: { integrationIdOrSlug, productIdOrSlug },
	queryParams,
}: {
	pathParams: GetBillingPlansPathParams;
	queryParams?: GetBillingPlansQueryParams;
}): Effect.Effect<
	GetBillingPlansQueryResponse,
	| ApiError
	| ValidationError
	| GetBillingPlans400
	| GetBillingPlans401
	| GetBillingPlans403
	| GetBillingPlans404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationIdOrSlug === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationIdOrSlug",
					message: "Missing required path parameter",
				}),
			);
		}
		if (productIdOrSlug === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "productIdOrSlug",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/integrations/integration/${integrationIdOrSlug}/products/${productIdOrSlug}/plans`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetBillingPlansQueryResponse;
	});
}

/**
 * @description Connects an integration resource to a Vercel project. This endpoint establishes a connection between a provisioned integration resource (from storage APIs like `POST /v1/storage/stores/integration/direct`) and a specific Vercel project.
 * @summary Connect integration resource to project
 * {@link /v1/integrations/installations/:integrationConfigurationId/resources/:resourceId/connections}
 */
export function connectIntegrationResourceToProject({
	pathParams: { integrationConfigurationId, resourceId },
	queryParams,
}: {
	pathParams: ConnectIntegrationResourceToProjectPathParams;
	queryParams?: ConnectIntegrationResourceToProjectQueryParams;
}): Effect.Effect<
	ConnectIntegrationResourceToProjectMutationResponse,
	| ApiError
	| ValidationError
	| ConnectIntegrationResourceToProject400
	| ConnectIntegrationResourceToProject401
	| ConnectIntegrationResourceToProject403
	| ConnectIntegrationResourceToProject404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (resourceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "resourceId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/integrations/installations/${integrationConfigurationId}/resources/${resourceId}/connections`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as ConnectIntegrationResourceToProjectMutationResponse;
	});
}

/**
 * @description This endpoint updates an integration installation.
 * @summary Update Installation
 * {@link /v1/installations/:integrationConfigurationId}
 */
export function updateInstallation({
	pathParams: { integrationConfigurationId },
}: {
	pathParams: UpdateInstallationPathParams;
}): Effect.Effect<
	UpdateInstallationMutationResponse,
	| ApiError
	| ValidationError
	| UpdateInstallation400
	| UpdateInstallation401
	| UpdateInstallation403
	| UpdateInstallation404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateInstallationMutationResponse;
	});
}

/**
 * @description Fetches the best account or users contact info
 * @summary Get Account Information
 * {@link /v1/installations/:integrationConfigurationId/account}
 */
export function getAccountInfo({
	pathParams: { integrationConfigurationId },
}: {
	pathParams: GetAccountInfoPathParams;
}): Effect.Effect<
	GetAccountInfoQueryResponse,
	| ApiError
	| ValidationError
	| GetAccountInfo400
	| GetAccountInfo401
	| GetAccountInfo403
	| GetAccountInfo404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/account`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetAccountInfoQueryResponse;
	});
}

/**
 * @description Returns the member role and other information for a given member ID ("user_id" claim in the SSO OIDC token).
 * @summary Get Member Information
 * {@link /v1/installations/:integrationConfigurationId/member/:memberId}
 */
export function getMember({
	pathParams: { integrationConfigurationId, memberId },
}: {
	pathParams: GetMemberPathParams;
}): Effect.Effect<
	GetMemberQueryResponse,
	ApiError | ValidationError | GetMember400 | GetMember401 | GetMember403 | GetMember404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (memberId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "memberId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/member/${memberId}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetMemberQueryResponse;
	});
}

/**
 * @description Partner notifies Vercel of any changes made to an Installation or a Resource. Vercel is expected to use `list-resources` and other read APIs to get the new state.<br/> <br/> `resource.updated` event should be dispatched when any state of a resource linked to Vercel is modified by the partner.<br/> `installation.updated` event should be dispatched when an installation's billing plan is changed via the provider instead of Vercel.<br/> <br/> Resource update use cases: <br/> <br/> - The user renames a database in the partners application. The partner should dispatch a `resource.updated` event to notify Vercel to update the resource in Vercels datastores.<br/> - A resource has been suspended due to a lack of use. The partner should dispatch a `resource.updated` event to notify Vercel to update the resource's status in Vercel's datastores.<br/>
 * @summary Create Event
 * {@link /v1/installations/:integrationConfigurationId/events}
 */
export function createEvent({
	pathParams: { integrationConfigurationId },
}: {
	pathParams: CreateEventPathParams;
}): Effect.Effect<
	CreateEventMutationResponse,
	ApiError | ValidationError | CreateEvent400 | CreateEvent401 | CreateEvent403 | CreateEvent404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/events`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateEventMutationResponse;
	});
}

/**
 * @description Get all resources for a given installation ID.
 * @summary Get Integration Resources
 * {@link /v1/installations/:integrationConfigurationId/resources}
 */
export function getIntegrationResources({
	pathParams: { integrationConfigurationId },
}: {
	pathParams: GetIntegrationResourcesPathParams;
}): Effect.Effect<
	GetIntegrationResourcesQueryResponse,
	| ApiError
	| ValidationError
	| GetIntegrationResources400
	| GetIntegrationResources401
	| GetIntegrationResources403
	| GetIntegrationResources404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/resources`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetIntegrationResourcesQueryResponse;
	});
}

/**
 * @description Get a resource by its partner ID.
 * @summary Get Integration Resource
 * {@link /v1/installations/:integrationConfigurationId/resources/:resourceId}
 */
export function getIntegrationResource({
	pathParams: { integrationConfigurationId, resourceId },
}: {
	pathParams: GetIntegrationResourcePathParams;
}): Effect.Effect<
	GetIntegrationResourceQueryResponse,
	| ApiError
	| ValidationError
	| GetIntegrationResource400
	| GetIntegrationResource401
	| GetIntegrationResource403
	| GetIntegrationResource404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (resourceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "resourceId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/resources/${resourceId}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetIntegrationResourceQueryResponse;
	});
}

/**
 * @description Delete a resource owned by the selected installation ID.
 * @summary Delete Integration Resource
 * {@link /v1/installations/:integrationConfigurationId/resources/:resourceId}
 */
export function deleteIntegrationResource({
	pathParams: { integrationConfigurationId, resourceId },
}: {
	pathParams: DeleteIntegrationResourcePathParams;
}): Effect.Effect<
	DeleteIntegrationResourceMutationResponse,
	| ApiError
	| ValidationError
	| DeleteIntegrationResource400
	| DeleteIntegrationResource401
	| DeleteIntegrationResource403
	| DeleteIntegrationResource404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (resourceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "resourceId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/resources/${resourceId}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteIntegrationResourceMutationResponse;
	});
}

/**
 * @description This endpoint imports (upserts) a resource to Vercel's installation. This may be needed if resources can be independently created on the partner's side and need to be synchronized to Vercel.
 * @summary Import Resource
 * {@link /v1/installations/:integrationConfigurationId/resources/:resourceId}
 */
export function importResource({
	pathParams: { integrationConfigurationId, resourceId },
}: {
	pathParams: ImportResourcePathParams;
}): Effect.Effect<
	ImportResourceMutationResponse,
	| ApiError
	| ValidationError
	| ImportResource400
	| ImportResource401
	| ImportResource403
	| ImportResource404
	| ImportResource409
	| ImportResource422
	| ImportResource429,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (resourceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "resourceId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/resources/${resourceId}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "PUT",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as ImportResourceMutationResponse;
	});
}

/**
 * @description This endpoint updates an existing resource in the installation. All parameters are optional, allowing partial updates.
 * @summary Update Resource
 * {@link /v1/installations/:integrationConfigurationId/resources/:resourceId}
 */
export function updateResource({
	pathParams: { integrationConfigurationId, resourceId },
}: {
	pathParams: UpdateResourcePathParams;
}): Effect.Effect<
	UpdateResourceMutationResponse,
	| ApiError
	| ValidationError
	| UpdateResource400
	| UpdateResource401
	| UpdateResource403
	| UpdateResource404
	| UpdateResource409
	| UpdateResource422,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (resourceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "resourceId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/resources/${resourceId}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateResourceMutationResponse;
	});
}

/**
 * @description Sends the billing and usage data. The partner should do this at least once a day and ideally once per hour. <br/> Use the `credentials.access_token` we provided in the [Upsert Installation](#upsert-installation) body to authorize this request.
 * @summary Submit Billing Data
 * {@link /v1/installations/:integrationConfigurationId/billing}
 */
export function submitBillingData({
	pathParams: { integrationConfigurationId },
}: {
	pathParams: SubmitBillingDataPathParams;
}): Effect.Effect<
	SubmitBillingDataMutationResponse,
	| ApiError
	| ValidationError
	| SubmitBillingData400
	| SubmitBillingData401
	| SubmitBillingData403
	| SubmitBillingData404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/billing`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as SubmitBillingDataMutationResponse;
	});
}

/**
 * @description This endpoint allows the partner to submit an invoice to Vercel. The invoice is created in Vercel's billing system and sent to the customer. Depending on the type of billing plan, the invoice can be sent at a time of signup, at the start of the billing period, or at the end of the billing period.<br/> <br/> Use the `credentials.access_token` we provided in the [Upsert Installation](#upsert-installation) body to authorize this request. <br/> There are several limitations to the invoice submission:<br/> <br/> 1. A resource can only be billed once per the billing period and the billing plan.<br/> 2. The billing plan used to bill the resource must have been active for this resource during the billing period.<br/> 3. The billing plan used must be a subscription plan.<br/> 4. The interim usage data must be sent hourly for all types of subscriptions. See [Send subscription billing and usage data](#send-subscription-billing-and-usage-data) API on how to send interim billing and usage data.<br/>
 * @summary Submit Invoice
 * {@link /v1/installations/:integrationConfigurationId/billing/invoices}
 */
export function submitInvoice({
	pathParams: { integrationConfigurationId },
}: {
	pathParams: SubmitInvoicePathParams;
}): Effect.Effect<
	SubmitInvoiceMutationResponse,
	| ApiError
	| ValidationError
	| SubmitInvoice400
	| SubmitInvoice401
	| SubmitInvoice403
	| SubmitInvoice404
	| SubmitInvoice409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/billing/invoices`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as SubmitInvoiceMutationResponse;
	});
}

/**
 * @description Get Invoice details and status for a given invoice ID.<br/> <br/> See Billing Events with Webhooks documentation on how to receive invoice events. This endpoint is used to retrieve the invoice details.
 * @summary Get Invoice
 * {@link /v1/installations/:integrationConfigurationId/billing/invoices/:invoiceId}
 */
export function getInvoice({
	pathParams: { integrationConfigurationId, invoiceId },
}: {
	pathParams: GetInvoicePathParams;
}): Effect.Effect<
	GetInvoiceQueryResponse,
	ApiError | ValidationError | GetInvoice400 | GetInvoice401 | GetInvoice403 | GetInvoice404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (invoiceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "invoiceId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/billing/invoices/${invoiceId}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetInvoiceQueryResponse;
	});
}

/**
 * @description This endpoint allows the partner to request a refund for an invoice to Vercel. The invoice is created using the [Submit Invoice API](#submit-invoice-api).
 * @summary Invoice Actions
 * {@link /v1/installations/:integrationConfigurationId/billing/invoices/:invoiceId/actions}
 */
export function updateInvoice({
	pathParams: { integrationConfigurationId, invoiceId },
}: {
	pathParams: UpdateInvoicePathParams;
}): Effect.Effect<
	UpdateInvoiceMutationResponse,
	| ApiError
	| ValidationError
	| UpdateInvoice400
	| UpdateInvoice401
	| UpdateInvoice403
	| UpdateInvoice404
	| UpdateInvoice409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (invoiceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "invoiceId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/billing/invoices/${invoiceId}/actions`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateInvoiceMutationResponse;
	});
}

/**
 * @description Sends the prepayment balances. The partner should do this at least once a day and ideally once per hour. <br/> Use the `credentials.access_token` we provided in the [Upsert Installation](#upsert-installation) body to authorize this request.
 * @summary Submit Prepayment Balances
 * {@link /v1/installations/:integrationConfigurationId/billing/balance}
 */
export function submitPrepaymentBalances({
	pathParams: { integrationConfigurationId },
}: {
	pathParams: SubmitPrepaymentBalancesPathParams;
}): Effect.Effect<
	SubmitPrepaymentBalancesMutationResponse,
	| ApiError
	| ValidationError
	| SubmitPrepaymentBalances400
	| SubmitPrepaymentBalances401
	| SubmitPrepaymentBalances403
	| SubmitPrepaymentBalances404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/billing/balance`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as SubmitPrepaymentBalancesMutationResponse;
	});
}

/**
 * @description This endpoint is deprecated and replaced with the endpoint [Update Resource Secrets](#update-resource-secrets). <br/> This endpoint updates the secrets of a resource. If a resource has projects connected, the connected secrets are updated with the new secrets. The old secrets may still be used by existing connected projects because they are not automatically redeployed. Redeployment is a manual action and must be completed by the user. All new project connections will use the new secrets.<br/> <br/> Use cases for this endpoint:<br/> <br/> - Resetting the credentials of a database in the partner. If the user requests the credentials to be updated in the partners application, the partner post the new set of secrets to Vercel, the user should redeploy their application and the expire the old credentials.<br/>
 * @summary Update Resource Secrets (Deprecated)
 * {@link /v1/installations/:integrationConfigurationId/products/:integrationProductIdOrSlug/resources/:resourceId/secrets}
 */
export function updateResourceSecrets({
	pathParams: { integrationConfigurationId, integrationProductIdOrSlug, resourceId },
}: {
	pathParams: UpdateResourceSecretsPathParams;
}): Effect.Effect<
	UpdateResourceSecretsMutationResponse,
	| ApiError
	| ValidationError
	| UpdateResourceSecrets400
	| UpdateResourceSecrets401
	| UpdateResourceSecrets403
	| UpdateResourceSecrets404
	| UpdateResourceSecrets409
	| UpdateResourceSecrets422,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (integrationProductIdOrSlug === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationProductIdOrSlug",
					message: "Missing required path parameter",
				}),
			);
		}
		if (resourceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "resourceId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/products/${integrationProductIdOrSlug}/resources/${resourceId}/secrets`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "PUT",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateResourceSecretsMutationResponse;
	});
}

/**
 * @description This endpoint updates the secrets of a resource. If a resource has projects connected, the connected secrets are updated with the new secrets. The old secrets may still be used by existing connected projects because they are not automatically redeployed. Redeployment is a manual action and must be completed by the user. All new project connections will use the new secrets.<br/> <br/> Use cases for this endpoint:<br/> <br/> - Resetting the credentials of a database in the partner. If the user requests the credentials to be updated in the partners application, the partner post the new set of secrets to Vercel, the user should redeploy their application and the expire the old credentials.<br/>
 * @summary Update Resource Secrets
 * {@link /v1/installations/:integrationConfigurationId/resources/:resourceId/secrets}
 */
export function updateResourceSecretsById({
	pathParams: { integrationConfigurationId, resourceId },
}: {
	pathParams: UpdateResourceSecretsByIdPathParams;
}): Effect.Effect<
	UpdateResourceSecretsByIdMutationResponse,
	| ApiError
	| ValidationError
	| UpdateResourceSecretsById400
	| UpdateResourceSecretsById401
	| UpdateResourceSecretsById403
	| UpdateResourceSecretsById404
	| UpdateResourceSecretsById409
	| UpdateResourceSecretsById422,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (resourceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "resourceId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/resources/${resourceId}/secrets`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "PUT",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateResourceSecretsByIdMutationResponse;
	});
}

/**
 * @description Allows to retrieve all configurations for an authenticated integration. When the `project` view is used, configurations generated for the authorization flow will be filtered out of the results.
 * @summary Get configurations for the authenticated user or team
 * {@link /v1/integrations/configurations}
 */
export function getConfigurations({
	queryParams,
}: {
	queryParams: GetConfigurationsQueryParams;
}): Effect.Effect<
	GetConfigurationsQueryResponse,
	ApiError | ValidationError | GetConfigurations400 | GetConfigurations401 | GetConfigurations403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/integrations/configurations";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetConfigurationsQueryResponse;
	});
}

/**
 * @description Allows to retrieve a the configuration with the provided id in case it exists. The authenticated user or team must be the owner of the config in order to access it.
 * @summary Retrieve an integration configuration
 * {@link /v1/integrations/configuration/:id}
 */
export function getConfiguration({
	pathParams: { id },
	queryParams,
}: {
	pathParams: GetConfigurationPathParams;
	queryParams?: GetConfigurationQueryParams;
}): Effect.Effect<
	GetConfigurationQueryResponse,
	| ApiError
	| ValidationError
	| GetConfiguration400
	| GetConfiguration401
	| GetConfiguration403
	| GetConfiguration404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/integrations/configuration/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetConfigurationQueryResponse;
	});
}

/**
 * @description Allows to remove the configuration with the `id` provided in the parameters. The configuration and all of its resources will be removed. This includes Webhooks, LogDrains and Project Env variables.
 * @summary Delete an integration configuration
 * {@link /v1/integrations/configuration/:id}
 */
export function deleteConfiguration({
	pathParams: { id },
	queryParams,
}: {
	pathParams: DeleteConfigurationPathParams;
	queryParams?: DeleteConfigurationQueryParams;
}): Effect.Effect<
	DeleteConfigurationMutationResponse,
	| ApiError
	| ValidationError
	| DeleteConfiguration400
	| DeleteConfiguration401
	| DeleteConfiguration403
	| DeleteConfiguration404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/integrations/configuration/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteConfigurationMutationResponse;
	});
}

/**
 * @description Lists all products available for an integration configuration. Use this endpoint to discover what integration products are available for your integration configuration. The returned product IDs or slugs can then be used with storage provisioning endpoints like `POST /v1/storage/stores/integration/direct`. ## Workflow 1. Get your integration configurations: `GET /v1/integrations/configurations` 2. **Use this endpoint**: Get products for a configuration: `GET /v1/integrations/configuration/{id}/products` 3. Create storage resource: `POST /v1/storage/stores/integration/direct` ## Response Returns an array of products with their IDs, slugs, names, supported protocols, and metadata requirements. Each product represents a different type of resource you can provision. The `metadataSchema` field contains a JSON Schema that defines: - **Required metadata**: Fields that must be provided during storage creation - **Optional metadata**: Fields that can be provided but are not mandatory - **Field validation**: Data types, allowed values, and constraints Use this schema to validate metadata before calling the storage creation endpoint.
 * @summary List products for integration configuration
 * {@link /v1/integrations/configuration/:id/products}
 */
export function getConfigurationProducts({
	pathParams: { id },
	queryParams,
}: {
	pathParams: GetConfigurationProductsPathParams;
	queryParams?: GetConfigurationProductsQueryParams;
}): Effect.Effect<
	GetConfigurationProductsQueryResponse,
	| ApiError
	| ValidationError
	| GetConfigurationProducts400
	| GetConfigurationProducts401
	| GetConfigurationProducts403
	| GetConfigurationProducts404
	| GetConfigurationProducts500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/integrations/configuration/${id}/products`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetConfigurationProductsQueryResponse;
	});
}

/**
 * @description During the autorization process, Vercel sends the user to the provider [redirectLoginUrl](https://vercel.com/docs/integrations/create-integration/submit-integration#redirect-login-url), that includes the OAuth authorization `code` parameter. The provider then calls the SSO Token Exchange endpoint with the sent code and receives the OIDC token. They log the user in based on this token and redirects the user back to the Vercel account using deep-link parameters included the redirectLoginUrl. Providers should not persist the returned `id_token` in a database since the token will expire. See [**Authentication with SSO**](https://vercel.com/docs/integrations/create-integration/marketplace-api#authentication-with-sso) for more details.
 * @summary SSO Token Exchange
 * {@link /v1/integrations/sso/token}
 */
export function exchangeSsoToken(): Effect.Effect<
	ExchangeSsoTokenMutationResponse,
	ApiError | ValidationError | ExchangeSsoToken400 | ExchangeSsoToken403 | ExchangeSsoToken500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/integrations/sso/token";
		const fullUrl = url;

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as ExchangeSsoTokenMutationResponse;
	});
}

/**
 * @description Retrieves a list of all Integration log drains that are defined for the authenticated user or team. When using an OAuth2 token, the list is limited to log drains created by the authenticated integration.
 * @summary Retrieves a list of Integration log drains (deprecated)
 * {@link /v2/integrations/log-drains}
 */
export function getIntegrationLogDrains({
	queryParams,
}: {
	queryParams?: GetIntegrationLogDrainsQueryParams;
}): Effect.Effect<
	GetIntegrationLogDrainsQueryResponse,
	| ApiError
	| ValidationError
	| GetIntegrationLogDrains400
	| GetIntegrationLogDrains401
	| GetIntegrationLogDrains403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v2/integrations/log-drains";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetIntegrationLogDrainsQueryResponse;
	});
}

/**
 * @description Creates an Integration log drain. This endpoint must be called with an OAuth2 client (integration), since log drains are tied to integrations. If it is called with a different token type it will produce a 400 error.
 * @summary Creates a new Integration Log Drain (deprecated)
 * {@link /v2/integrations/log-drains}
 */
export function createLogDrain({
	queryParams,
}: {
	queryParams?: CreateLogDrainQueryParams;
}): Effect.Effect<
	CreateLogDrainMutationResponse,
	ApiError | ValidationError | CreateLogDrain400 | CreateLogDrain401 | CreateLogDrain403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v2/integrations/log-drains";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateLogDrainMutationResponse;
	});
}

/**
 * @description Deletes the Integration log drain with the provided `id`. When using an OAuth2 Token, the log drain can be deleted only if the integration owns it.
 * @summary Deletes the Integration log drain with the provided `id` (deprecated)
 * {@link /v1/integrations/log-drains/:id}
 */
export function deleteIntegrationLogDrain({
	pathParams: { id },
	queryParams,
}: {
	pathParams: DeleteIntegrationLogDrainPathParams;
	queryParams?: DeleteIntegrationLogDrainQueryParams;
}): Effect.Effect<
	DeleteIntegrationLogDrainMutationResponse,
	| ApiError
	| ValidationError
	| DeleteIntegrationLogDrain400
	| DeleteIntegrationLogDrain401
	| DeleteIntegrationLogDrain403
	| DeleteIntegrationLogDrain404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/integrations/log-drains/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteIntegrationLogDrainMutationResponse;
	});
}

/**
 * @description Returns a stream of logs for a given deployment.
 * @summary Get logs for a deployment
 * {@link /v1/projects/:projectId/deployments/:deploymentId/runtime-logs}
 */
export function getRuntimeLogs({
	pathParams: { projectId, deploymentId },
	queryParams,
}: {
	pathParams: GetRuntimeLogsPathParams;
	queryParams?: GetRuntimeLogsQueryParams;
}): Effect.Effect<
	GetRuntimeLogsQueryResponse,
	ApiError | ValidationError | GetRuntimeLogs400 | GetRuntimeLogs401 | GetRuntimeLogs403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (projectId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "projectId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (deploymentId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "deploymentId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${projectId}/deployments/${deploymentId}/runtime-logs`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetRuntimeLogsQueryResponse;
	});
}

/**
 * @description Create one or multiple experimentation items
 * @summary Create one or multiple experimentation items
 * {@link /v1/installations/:integrationConfigurationId/resources/:resourceId/experimentation/items}
 */
export function createExperimentationItem({
	pathParams: { integrationConfigurationId, resourceId },
}: {
	pathParams: CreateExperimentationItemPathParams;
}): Effect.Effect<
	CreateExperimentationItemMutationResponse,
	| ApiError
	| ValidationError
	| CreateExperimentationItem400
	| CreateExperimentationItem401
	| CreateExperimentationItem403
	| CreateExperimentationItem404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (resourceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "resourceId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/resources/${resourceId}/experimentation/items`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateExperimentationItemMutationResponse;
	});
}

/**
 * @description Patch an existing experimentation item
 * @summary Patch an existing experimentation item
 * {@link /v1/installations/:integrationConfigurationId/resources/:resourceId/experimentation/items/:itemId}
 */
export function updateExperimentationItem({
	pathParams: { integrationConfigurationId, resourceId, itemId },
}: {
	pathParams: UpdateExperimentationItemPathParams;
}): Effect.Effect<
	UpdateExperimentationItemMutationResponse,
	| ApiError
	| ValidationError
	| UpdateExperimentationItem400
	| UpdateExperimentationItem401
	| UpdateExperimentationItem403
	| UpdateExperimentationItem404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (resourceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "resourceId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (itemId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "itemId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/resources/${resourceId}/experimentation/items/${itemId}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateExperimentationItemMutationResponse;
	});
}

/**
 * @description Delete an existing experimentation item
 * @summary Delete an existing experimentation item
 * {@link /v1/installations/:integrationConfigurationId/resources/:resourceId/experimentation/items/:itemId}
 */
export function deleteExperimentationItem({
	pathParams: { integrationConfigurationId, resourceId, itemId },
}: {
	pathParams: DeleteExperimentationItemPathParams;
}): Effect.Effect<
	DeleteExperimentationItemMutationResponse,
	| ApiError
	| ValidationError
	| DeleteExperimentationItem400
	| DeleteExperimentationItem401
	| DeleteExperimentationItem403
	| DeleteExperimentationItem404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (resourceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "resourceId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (itemId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "itemId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/resources/${resourceId}/experimentation/items/${itemId}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteExperimentationItemMutationResponse;
	});
}

/**
 * @description When the user enabled Edge Config syncing, then this endpoint can be used by the partner to push their configuration data into the relevant Edge Config.
 * @summary Push data into a user-provided Edge Config
 * {@link /v1/installations/:integrationConfigurationId/resources/:resourceId/experimentation/edge-config}
 */
export function updateExperimentationEdgeConfig({
	pathParams: { integrationConfigurationId, resourceId },
}: {
	pathParams: UpdateExperimentationEdgeConfigPathParams;
}): Effect.Effect<
	UpdateExperimentationEdgeConfigMutationResponse,
	| ApiError
	| ValidationError
	| UpdateExperimentationEdgeConfig400
	| UpdateExperimentationEdgeConfig401
	| UpdateExperimentationEdgeConfig403
	| UpdateExperimentationEdgeConfig404
	| UpdateExperimentationEdgeConfig409
	| UpdateExperimentationEdgeConfig412,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (integrationConfigurationId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "integrationConfigurationId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (resourceId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "resourceId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/installations/${integrationConfigurationId}/resources/${resourceId}/experimentation/edge-config`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "PUT",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateExperimentationEdgeConfigMutationResponse;
	});
}

/**
 * @description Lists all members of a project.
 * @summary List project members
 * {@link /v1/projects/:idOrName/members}
 */
export function getProjectMembers({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: GetProjectMembersPathParams;
	queryParams?: GetProjectMembersQueryParams;
}): Effect.Effect<
	GetProjectMembersQueryResponse,
	ApiError | ValidationError | GetProjectMembers400 | GetProjectMembers401 | GetProjectMembers403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/members`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetProjectMembersQueryResponse;
	});
}

/**
 * @description Adds a new member to the project.
 * @summary Adds a new member to a project.
 * {@link /v1/projects/:idOrName/members}
 */
export function addProjectMember({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: AddProjectMemberPathParams;
	queryParams?: AddProjectMemberQueryParams;
}): Effect.Effect<
	AddProjectMemberMutationResponse,
	| ApiError
	| ValidationError
	| AddProjectMember400
	| AddProjectMember401
	| AddProjectMember403
	| AddProjectMember500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/members`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as AddProjectMemberMutationResponse;
	});
}

/**
 * @description Remove a member from a specific project
 * @summary Remove a Project Member
 * {@link /v1/projects/:idOrName/members/:uid}
 */
export function removeProjectMember({
	pathParams: { idOrName, uid },
	queryParams,
}: {
	pathParams: RemoveProjectMemberPathParams;
	queryParams?: RemoveProjectMemberQueryParams;
}): Effect.Effect<
	RemoveProjectMemberMutationResponse,
	| ApiError
	| ValidationError
	| RemoveProjectMember400
	| RemoveProjectMember401
	| RemoveProjectMember403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (uid === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "uid",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/members/${uid}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as RemoveProjectMemberMutationResponse;
	});
}

/**
 * @description Allows to retrieve the list of projects of the authenticated user or team. The list will be paginated and the provided query parameters allow filtering the returned projects.
 * @summary Retrieve a list of projects
 * {@link /v10/projects}
 */
export function getProjects({
	queryParams,
}: {
	queryParams?: GetProjectsQueryParams;
}): Effect.Effect<
	GetProjectsQueryResponse,
	ApiError | ValidationError | GetProjects400 | GetProjects401 | GetProjects403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v10/projects";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetProjectsQueryResponse;
	});
}

/**
 * @description Allows to create a new project with the provided configuration. It only requires the project `name` but more configuration can be provided to override the defaults.
 * @summary Create a new project
 * {@link /v11/projects}
 */
export function createProject({
	queryParams,
}: {
	queryParams?: CreateProjectQueryParams;
}): Effect.Effect<
	CreateProjectMutationResponse,
	| ApiError
	| ValidationError
	| CreateProject400
	| CreateProject401
	| CreateProject402
	| CreateProject403
	| CreateProject404
	| CreateProject409
	| CreateProject428
	| CreateProject429
	| CreateProject500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v11/projects";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateProjectMutationResponse;
	});
}

/**
 * @description Get the information for a specific project by passing either the project `id` or `name` in the URL.
 * @summary Find a project by id or name
 * {@link /v9/projects/:idOrName}
 */
export function getProject({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: GetProjectPathParams;
	queryParams?: GetProjectQueryParams;
}): Effect.Effect<
	GetProjectQueryResponse,
	ApiError | ValidationError | GetProject400 | GetProject401 | GetProject403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetProjectQueryResponse;
	});
}

/**
 * @description Update the fields of a project using either its `name` or `id`.
 * @summary Update an existing project
 * {@link /v9/projects/:idOrName}
 */
export function updateProject({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: UpdateProjectPathParams;
	queryParams?: UpdateProjectQueryParams;
}): Effect.Effect<
	UpdateProjectMutationResponse,
	| ApiError
	| ValidationError
	| UpdateProject400
	| UpdateProject401
	| UpdateProject402
	| UpdateProject403
	| UpdateProject404
	| UpdateProject409
	| UpdateProject428,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateProjectMutationResponse;
	});
}

/**
 * @description Delete a specific project by passing either the project `id` or `name` in the URL.
 * @summary Delete a Project
 * {@link /v9/projects/:idOrName}
 */
export function deleteProject({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: DeleteProjectPathParams;
	queryParams?: DeleteProjectQueryParams;
}): Effect.Effect<
	DeleteProjectMutationResponse,
	| ApiError
	| ValidationError
	| DeleteProject400
	| DeleteProject401
	| DeleteProject403
	| DeleteProject409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteProjectMutationResponse;
	});
}

/**
 * @description Allows configuring Static IPs for a project
 * @summary Configures Static IPs for a project
 * {@link /v1/projects/:idOrName/shared-connect-links}
 */
export function updateStaticIps({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: UpdateStaticIpsPathParams;
	queryParams?: UpdateStaticIpsQueryParams;
}): Effect.Effect<
	UpdateStaticIpsMutationResponse,
	| ApiError
	| ValidationError
	| UpdateStaticIps400
	| UpdateStaticIps401
	| UpdateStaticIps402
	| UpdateStaticIps403
	| UpdateStaticIps404
	| UpdateStaticIps409
	| UpdateStaticIps500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/shared-connect-links`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateStaticIpsMutationResponse;
	});
}

/**
 * @description Creates a custom environment for the current project. Cannot be named 'Production' or 'Preview'.
 * @summary Create a custom environment for the current project.
 * {@link /v9/projects/:idOrName/custom-environments}
 */
export function createCustomEnvironment({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: CreateCustomEnvironmentPathParams;
	queryParams?: CreateCustomEnvironmentQueryParams;
}): Effect.Effect<
	CreateCustomEnvironmentMutationResponse,
	| ApiError
	| ValidationError
	| CreateCustomEnvironment400
	| CreateCustomEnvironment401
	| CreateCustomEnvironment402
	| CreateCustomEnvironment403
	| CreateCustomEnvironment500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}/custom-environments`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateCustomEnvironmentMutationResponse;
	});
}

/**
 * @description Retrieve custom environments for the project. Must not be named 'Production' or 'Preview'.
 * @summary Retrieve custom environments
 * {@link /v9/projects/:idOrName/custom-environments}
 */
export function listCustomEnvironments({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: ListCustomEnvironmentsPathParams;
	queryParams?: ListCustomEnvironmentsQueryParams;
}): Effect.Effect<
	ListCustomEnvironmentsQueryResponse,
	| ApiError
	| ValidationError
	| ListCustomEnvironments400
	| ListCustomEnvironments401
	| ListCustomEnvironments403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}/custom-environments`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ListCustomEnvironmentsQueryResponse;
	});
}

/**
 * @description Retrieve a custom environment for the project. Must not be named 'Production' or 'Preview'.
 * @summary Retrieve a custom environment
 * {@link /v9/projects/:idOrName/custom-environments/:environmentSlugOrId}
 */
export function getCustomEnvironment({
	pathParams: { idOrName, environmentSlugOrId },
	queryParams,
}: {
	pathParams: GetCustomEnvironmentPathParams;
	queryParams?: GetCustomEnvironmentQueryParams;
}): Effect.Effect<
	GetCustomEnvironmentQueryResponse,
	| ApiError
	| ValidationError
	| GetCustomEnvironment400
	| GetCustomEnvironment401
	| GetCustomEnvironment403
	| GetCustomEnvironment404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (environmentSlugOrId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "environmentSlugOrId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}/custom-environments/${environmentSlugOrId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetCustomEnvironmentQueryResponse;
	});
}

/**
 * @description Update a custom environment for the project. Must not be named 'Production' or 'Preview'.
 * @summary Update a custom environment
 * {@link /v9/projects/:idOrName/custom-environments/:environmentSlugOrId}
 */
export function updateCustomEnvironment({
	pathParams: { idOrName, environmentSlugOrId },
	queryParams,
}: {
	pathParams: UpdateCustomEnvironmentPathParams;
	queryParams?: UpdateCustomEnvironmentQueryParams;
}): Effect.Effect<
	UpdateCustomEnvironmentMutationResponse,
	| ApiError
	| ValidationError
	| UpdateCustomEnvironment400
	| UpdateCustomEnvironment401
	| UpdateCustomEnvironment402
	| UpdateCustomEnvironment403
	| UpdateCustomEnvironment500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (environmentSlugOrId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "environmentSlugOrId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}/custom-environments/${environmentSlugOrId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateCustomEnvironmentMutationResponse;
	});
}

/**
 * @description Remove a custom environment for the project. Must not be named 'Production' or 'Preview'.
 * @summary Remove a custom environment
 * {@link /v9/projects/:idOrName/custom-environments/:environmentSlugOrId}
 */
export function removeCustomEnvironment({
	pathParams: { idOrName, environmentSlugOrId },
	queryParams,
}: {
	pathParams: RemoveCustomEnvironmentPathParams;
	queryParams?: RemoveCustomEnvironmentQueryParams;
}): Effect.Effect<
	RemoveCustomEnvironmentMutationResponse,
	| ApiError
	| ValidationError
	| RemoveCustomEnvironment400
	| RemoveCustomEnvironment401
	| RemoveCustomEnvironment403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (environmentSlugOrId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "environmentSlugOrId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}/custom-environments/${environmentSlugOrId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as RemoveCustomEnvironmentMutationResponse;
	});
}

/**
 * @description Retrieve the domains associated with a given project by passing either the project `id` or `name` in the URL.
 * @summary Retrieve project domains by project by id or name
 * {@link /v9/projects/:idOrName/domains}
 */
export function getProjectDomains({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: GetProjectDomainsPathParams;
	queryParams?: GetProjectDomainsQueryParams;
}): Effect.Effect<
	GetProjectDomainsQueryResponse,
	ApiError | ValidationError | GetProjectDomains400 | GetProjectDomains401 | GetProjectDomains403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}/domains`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetProjectDomainsQueryResponse;
	});
}

/**
 * @description Get project domain by project id/name and domain name.
 * @summary Get a project domain
 * {@link /v9/projects/:idOrName/domains/:domain}
 */
export function getProjectDomain({
	pathParams: { idOrName, domain },
	queryParams,
}: {
	pathParams: GetProjectDomainPathParams;
	queryParams?: GetProjectDomainQueryParams;
}): Effect.Effect<
	GetProjectDomainQueryResponse,
	ApiError | ValidationError | GetProjectDomain400 | GetProjectDomain401 | GetProjectDomain403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}/domains/${domain}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetProjectDomainQueryResponse;
	});
}

/**
 * @description Update a project domain's configuration, including the name, git branch and redirect of the domain.
 * @summary Update a project domain
 * {@link /v9/projects/:idOrName/domains/:domain}
 */
export function updateProjectDomain({
	pathParams: { idOrName, domain },
	queryParams,
}: {
	pathParams: UpdateProjectDomainPathParams;
	queryParams?: UpdateProjectDomainQueryParams;
}): Effect.Effect<
	UpdateProjectDomainMutationResponse,
	| ApiError
	| ValidationError
	| UpdateProjectDomain400
	| UpdateProjectDomain401
	| UpdateProjectDomain403
	| UpdateProjectDomain409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}/domains/${domain}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateProjectDomainMutationResponse;
	});
}

/**
 * @description Remove a domain from a project by passing the domain name and by specifying the project by either passing the project `id` or `name` in the URL.
 * @summary Remove a domain from a project
 * {@link /v9/projects/:idOrName/domains/:domain}
 */
export function removeProjectDomain({
	pathParams: { idOrName, domain },
	queryParams,
}: {
	pathParams: RemoveProjectDomainPathParams;
	queryParams?: RemoveProjectDomainQueryParams;
}): Effect.Effect<
	RemoveProjectDomainMutationResponse,
	| ApiError
	| ValidationError
	| RemoveProjectDomain400
	| RemoveProjectDomain401
	| RemoveProjectDomain403
	| RemoveProjectDomain404
	| RemoveProjectDomain409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}/domains/${domain}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as RemoveProjectDomainMutationResponse;
	});
}

/**
 * @description Add a domain to the project by passing its domain name and by specifying the project by either passing the project `id` or `name` in the URL. If the domain is not yet verified to be used on this project, the request will return `verified = false`, and the domain will need to be verified according to the `verification` challenge via `POST /projects/:idOrName/domains/:domain/verify`. If the domain already exists on the project, the request will fail with a `400` status code.
 * @summary Add a domain to a project
 * {@link /v10/projects/:idOrName/domains}
 */
export function addProjectDomain({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: AddProjectDomainPathParams;
	queryParams?: AddProjectDomainQueryParams;
}): Effect.Effect<
	AddProjectDomainMutationResponse,
	| ApiError
	| ValidationError
	| AddProjectDomain400
	| AddProjectDomain401
	| AddProjectDomain402
	| AddProjectDomain403
	| AddProjectDomain409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v10/projects/${idOrName}/domains`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as AddProjectDomainMutationResponse;
	});
}

/**
 * @description Move one project's domain to another project. Also allows the move of all redirects pointed to that domain in the same project.
 * @summary Move a project domain
 * {@link /v1/projects/:idOrName/domains/:domain/move}
 */
export function moveProjectDomain({
	pathParams: { idOrName, domain },
	queryParams,
}: {
	pathParams: MoveProjectDomainPathParams;
	queryParams?: MoveProjectDomainQueryParams;
}): Effect.Effect<
	MoveProjectDomainMutationResponse,
	| ApiError
	| ValidationError
	| MoveProjectDomain400
	| MoveProjectDomain401
	| MoveProjectDomain403
	| MoveProjectDomain409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/domains/${domain}/move`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as MoveProjectDomainMutationResponse;
	});
}

/**
 * @description Attempts to verify a project domain with `verified = false` by checking the correctness of the project domain's `verification` challenge.
 * @summary Verify project domain
 * {@link /v9/projects/:idOrName/domains/:domain/verify}
 */
export function verifyProjectDomain({
	pathParams: { idOrName, domain },
	queryParams,
}: {
	pathParams: VerifyProjectDomainPathParams;
	queryParams?: VerifyProjectDomainQueryParams;
}): Effect.Effect<
	VerifyProjectDomainMutationResponse,
	| ApiError
	| ValidationError
	| VerifyProjectDomain400
	| VerifyProjectDomain401
	| VerifyProjectDomain403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (domain === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "domain",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}/domains/${domain}/verify`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: {},
		});

		return response as VerifyProjectDomainMutationResponse;
	});
}

/**
 * @description Retrieve the environment variables for a given project by passing either the project `id` or `name` in the URL.
 * @summary Retrieve the environment variables of a project by id or name
 * {@link /v10/projects/:idOrName/env}
 */
export function filterProjectEnvs({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: FilterProjectEnvsPathParams;
	queryParams?: FilterProjectEnvsQueryParams;
}): Effect.Effect<
	FilterProjectEnvsQueryResponse,
	ApiError | ValidationError | FilterProjectEnvs400 | FilterProjectEnvs401 | FilterProjectEnvs403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v10/projects/${idOrName}/env`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as FilterProjectEnvsQueryResponse;
	});
}

/**
 * @description Create one or more environment variables for a project by passing its `key`, `value`, `type` and `target` and by specifying the project by either passing the project `id` or `name` in the URL. If you include `upsert=true` as a query parameter, a new environment variable will not be created if it already exists but, the existing variable's value will be updated.
 * @summary Create one or more environment variables
 * {@link /v10/projects/:idOrName/env}
 */
export function createProjectEnv({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: CreateProjectEnvPathParams;
	queryParams?: CreateProjectEnvQueryParams;
}): Effect.Effect<
	CreateProjectEnvMutationResponse,
	| ApiError
	| ValidationError
	| CreateProjectEnv400
	| CreateProjectEnv401
	| CreateProjectEnv402
	| CreateProjectEnv403
	| CreateProjectEnv404
	| CreateProjectEnv409
	| CreateProjectEnv429
	| CreateProjectEnv500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v10/projects/${idOrName}/env`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateProjectEnvMutationResponse;
	});
}

/**
 * @description Retrieve the environment variable for a given project.
 * @summary Retrieve the decrypted value of an environment variable of a project by id
 * {@link /v1/projects/:idOrName/env/:id}
 */
export function getProjectEnv({
	pathParams: { idOrName, id },
	queryParams,
}: {
	pathParams: GetProjectEnvPathParams;
	queryParams?: GetProjectEnvQueryParams;
}): Effect.Effect<
	GetProjectEnvQueryResponse,
	ApiError | ValidationError | GetProjectEnv400 | GetProjectEnv401 | GetProjectEnv403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/env/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetProjectEnvQueryResponse;
	});
}

/**
 * @description Delete a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.
 * @summary Remove an environment variable
 * {@link /v9/projects/:idOrName/env/:id}
 */
export function removeProjectEnv({
	pathParams: { idOrName, id },
	queryParams,
}: {
	pathParams: RemoveProjectEnvPathParams;
	queryParams?: RemoveProjectEnvQueryParams;
}): Effect.Effect<
	RemoveProjectEnvMutationResponse,
	| ApiError
	| ValidationError
	| RemoveProjectEnv400
	| RemoveProjectEnv401
	| RemoveProjectEnv403
	| RemoveProjectEnv404
	| RemoveProjectEnv409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}/env/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as RemoveProjectEnvMutationResponse;
	});
}

/**
 * @description Edit a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.
 * @summary Edit an environment variable
 * {@link /v9/projects/:idOrName/env/:id}
 */
export function editProjectEnv({
	pathParams: { idOrName, id },
	queryParams,
}: {
	pathParams: EditProjectEnvPathParams;
	queryParams?: EditProjectEnvQueryParams;
}): Effect.Effect<
	EditProjectEnvMutationResponse,
	| ApiError
	| ValidationError
	| EditProjectEnv400
	| EditProjectEnv401
	| EditProjectEnv403
	| EditProjectEnv404
	| EditProjectEnv409
	| EditProjectEnv429
	| EditProjectEnv500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}
		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v9/projects/${idOrName}/env/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as EditProjectEnvMutationResponse;
	});
}

/**
 * @description Delete multiple environment variables for a given project in a single batch operation.
 * @summary Batch remove environment variables
 * {@link /v1/projects/:idOrName/env}
 */
export function batchRemoveProjectEnv({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: BatchRemoveProjectEnvPathParams;
	queryParams?: BatchRemoveProjectEnvQueryParams;
}): Effect.Effect<
	BatchRemoveProjectEnvMutationResponse,
	| ApiError
	| ValidationError
	| BatchRemoveProjectEnv400
	| BatchRemoveProjectEnv401
	| BatchRemoveProjectEnv403
	| BatchRemoveProjectEnv404
	| BatchRemoveProjectEnv409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/env`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as BatchRemoveProjectEnvMutationResponse;
	});
}

/**
 * @description Get the Rolling Releases billing status for a project. The team level billing status is used to determine if the project can be configured for rolling releases.
 * @summary Get rolling release billing status
 * {@link /v1/projects/:idOrName/rolling-release/billing}
 */
export function getRollingReleaseBillingStatus({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: GetRollingReleaseBillingStatusPathParams;
	queryParams?: GetRollingReleaseBillingStatusQueryParams;
}): Effect.Effect<
	GetRollingReleaseBillingStatusQueryResponse,
	| ApiError
	| ValidationError
	| GetRollingReleaseBillingStatus400
	| GetRollingReleaseBillingStatus401
	| GetRollingReleaseBillingStatus403
	| GetRollingReleaseBillingStatus404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/rolling-release/billing`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetRollingReleaseBillingStatusQueryResponse;
	});
}

/**
 * @description Get the Rolling Releases configuration for a project. The project-level config is simply a template that will be used for any future rolling release, and not the configuration for any active rolling release.
 * @summary Get rolling release configuration
 * {@link /v1/projects/:idOrName/rolling-release/config}
 */
export function getRollingReleaseConfig({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: GetRollingReleaseConfigPathParams;
	queryParams?: GetRollingReleaseConfigQueryParams;
}): Effect.Effect<
	GetRollingReleaseConfigQueryResponse,
	| ApiError
	| ValidationError
	| GetRollingReleaseConfig400
	| GetRollingReleaseConfig401
	| GetRollingReleaseConfig403
	| GetRollingReleaseConfig404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/rolling-release/config`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetRollingReleaseConfigQueryResponse;
	});
}

/**
 * @description Disable Rolling Releases for a project means that future deployments will not undergo a rolling release. Changing the config never alters a rollout that's already in-flightit only affects the next production deployment. If you want to also stop the current rollout, call this endpoint to disable the feature, and then call either the /complete or /abort endpoint.
 * @summary Delete rolling release configuration
 * {@link /v1/projects/:idOrName/rolling-release/config}
 */
export function deleteRollingReleaseConfig({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: DeleteRollingReleaseConfigPathParams;
	queryParams?: DeleteRollingReleaseConfigQueryParams;
}): Effect.Effect<
	DeleteRollingReleaseConfigMutationResponse,
	| ApiError
	| ValidationError
	| DeleteRollingReleaseConfig400
	| DeleteRollingReleaseConfig401
	| DeleteRollingReleaseConfig403
	| DeleteRollingReleaseConfig404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/rolling-release/config`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteRollingReleaseConfigMutationResponse;
	});
}

/**
 * @description Update (or disable) Rolling Releases for a project. Changing the config never alters a rollout that's already in-flight. It only affects the next production deployment. This also applies to disabling Rolling Releases. If you want to also stop the current rollout, call this endpoint to disable the feature, and then call either the /complete or /abort endpoint. Note: Enabling Rolling Releases automatically enables skew protection on the project with the default value if it wasn't configured already.
 * @summary Update the rolling release settings for the project
 * {@link /v1/projects/:idOrName/rolling-release/config}
 */
export function updateRollingReleaseConfig({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: UpdateRollingReleaseConfigPathParams;
	queryParams?: UpdateRollingReleaseConfigQueryParams;
}): Effect.Effect<
	UpdateRollingReleaseConfigMutationResponse,
	| ApiError
	| ValidationError
	| UpdateRollingReleaseConfig400
	| UpdateRollingReleaseConfig401
	| UpdateRollingReleaseConfig403
	| UpdateRollingReleaseConfig404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/rolling-release/config`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: {},
		});

		return response as UpdateRollingReleaseConfigMutationResponse;
	});
}

/**
 * @description Return the Rolling Release for a project, regardless of whether the rollout is active, aborted, or completed. If the feature is enabled but no deployment has occurred yet, null will be returned.
 * @summary Get the active rolling release information for a project
 * {@link /v1/projects/:idOrName/rolling-release}
 */
export function getRollingRelease({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: GetRollingReleasePathParams;
	queryParams?: GetRollingReleaseQueryParams;
}): Effect.Effect<
	GetRollingReleaseQueryResponse,
	| ApiError
	| ValidationError
	| GetRollingRelease400
	| GetRollingRelease401
	| GetRollingRelease403
	| GetRollingRelease404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/rolling-release`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetRollingReleaseQueryResponse;
	});
}

/**
 * @description Advance a rollout to the next stage. This is only needed when rolling releases is configured to require manual approval.
 * @summary Update the active rolling release to the next stage for a project
 * {@link /v1/projects/:idOrName/rolling-release/approve-stage}
 */
export function approveRollingReleaseStage({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: ApproveRollingReleaseStagePathParams;
	queryParams?: ApproveRollingReleaseStageQueryParams;
}): Effect.Effect<
	ApproveRollingReleaseStageMutationResponse,
	| ApiError
	| ValidationError
	| ApproveRollingReleaseStage400
	| ApproveRollingReleaseStage401
	| ApproveRollingReleaseStage403
	| ApproveRollingReleaseStage404
	| ApproveRollingReleaseStage500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/rolling-release/approve-stage`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as ApproveRollingReleaseStageMutationResponse;
	});
}

/**
 * @description Force-complete a Rolling Release. The canary deployment will begin serving 100% of the traffic.
 * @summary Complete the rolling release for the project
 * {@link /v1/projects/:idOrName/rolling-release/complete}
 */
export function completeRollingRelease({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: CompleteRollingReleasePathParams;
	queryParams?: CompleteRollingReleaseQueryParams;
}): Effect.Effect<
	CompleteRollingReleaseMutationResponse,
	| ApiError
	| ValidationError
	| CompleteRollingRelease400
	| CompleteRollingRelease401
	| CompleteRollingRelease403
	| CompleteRollingRelease404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/rolling-release/complete`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CompleteRollingReleaseMutationResponse;
	});
}

/**
 * @description Initiates a project transfer request from one team to another. <br/> Returns a `code` that remains valid for 24 hours and can be used to accept the transfer request by another team using the `PUT /projects/transfer-request/:code` endpoint. <br/> Users can also accept the project transfer request using the claim URL: `https://vercel.com/claim-deployment?code=<code>&returnUrl=<returnUrl>`. <br/> The `code` parameter specifies the project transfer request code generated using this endpoint. <br/> The `returnUrl` parameter redirects users to a specific page of the application if the claim URL is invalid or expired.
 * @summary Create project transfer request
 * {@link /projects/:idOrName/transfer-request}
 */
export function createProjectTransferRequest({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: CreateProjectTransferRequestPathParams;
	queryParams?: CreateProjectTransferRequestQueryParams;
}): Effect.Effect<
	CreateProjectTransferRequestMutationResponse,
	| ApiError
	| ValidationError
	| CreateProjectTransferRequest400
	| CreateProjectTransferRequest401
	| CreateProjectTransferRequest403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/projects/${idOrName}/transfer-request`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateProjectTransferRequestMutationResponse;
	});
}

/**
 * @description Accept a project transfer request initated by another team. <br/> The `code` is generated using the `POST /projects/:idOrName/transfer-request` endpoint.
 * @summary Accept project transfer request
 * {@link /projects/transfer-request/:code}
 */
export function acceptProjectTransferRequest({
	pathParams: { code },
	queryParams,
}: {
	pathParams: AcceptProjectTransferRequestPathParams;
	queryParams?: AcceptProjectTransferRequestQueryParams;
}): Effect.Effect<
	AcceptProjectTransferRequestMutationResponse,
	| ApiError
	| ValidationError
	| AcceptProjectTransferRequest400
	| AcceptProjectTransferRequest401
	| AcceptProjectTransferRequest403
	| AcceptProjectTransferRequest404
	| AcceptProjectTransferRequest422,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (code === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "code",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/projects/transfer-request/${code}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PUT",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as AcceptProjectTransferRequestMutationResponse;
	});
}

/**
 * @description Update the deployment protection automation bypass for a project
 * @summary Update Protection Bypass for Automation
 * {@link /v1/projects/:idOrName/protection-bypass}
 */
export function updateProjectProtectionBypass({
	pathParams: { idOrName },
	queryParams,
}: {
	pathParams: UpdateProjectProtectionBypassPathParams;
	queryParams?: UpdateProjectProtectionBypassQueryParams;
}): Effect.Effect<
	UpdateProjectProtectionBypassMutationResponse,
	| ApiError
	| ValidationError
	| UpdateProjectProtectionBypass400
	| UpdateProjectProtectionBypass401
	| UpdateProjectProtectionBypass403
	| UpdateProjectProtectionBypass404
	| UpdateProjectProtectionBypass409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrName === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrName",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${idOrName}/protection-bypass`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateProjectProtectionBypassMutationResponse;
	});
}

/**
 * @description Allows users to promote a deployment to production. Note: This does NOT rebuild the deployment. If you need that, then call create-deployments endpoint.
 * @summary Points all production domains for a project to the given deploy
 * {@link /v10/projects/:projectId/promote/:deploymentId}
 */
export function requestPromote({
	pathParams: { projectId, deploymentId },
	queryParams,
}: {
	pathParams: RequestPromotePathParams;
	queryParams?: RequestPromoteQueryParams;
}): Effect.Effect<
	RequestPromoteMutationResponse,
	| ApiError
	| ValidationError
	| RequestPromote400
	| RequestPromote401
	| RequestPromote403
	| RequestPromote409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (projectId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "projectId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (deploymentId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "deploymentId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v10/projects/${projectId}/promote/${deploymentId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: {},
		});

		return response as RequestPromoteMutationResponse;
	});
}

/**
 * @description Get a list of aliases related to the last promote request with their mapping status
 * @summary Gets a list of aliases with status for the current promote
 * {@link /v1/projects/:projectId/promote/aliases}
 */
export function listPromoteAliases({
	pathParams: { projectId },
	queryParams,
}: {
	pathParams: ListPromoteAliasesPathParams;
	queryParams?: ListPromoteAliasesQueryParams;
}): Effect.Effect<
	ListPromoteAliasesQueryResponse,
	| ApiError
	| ValidationError
	| ListPromoteAliases400
	| ListPromoteAliases401
	| ListPromoteAliases403
	| ListPromoteAliases404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (projectId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "projectId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${projectId}/promote/aliases`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ListPromoteAliasesQueryResponse;
	});
}

/**
 * @description Pause a project by passing its project `id` in the URL. If the project does not exist given the id then the request will fail with 400 status code. If the project disables auto assigning custom production domains and blocks the active Production Deployment then the request will return with 200 status code.
 * @summary Pause a project
 * {@link /v1/projects/:projectId/pause}
 */
export function pauseProject({
	pathParams: { projectId },
	queryParams,
}: {
	pathParams: PauseProjectPathParams;
	queryParams?: PauseProjectQueryParams;
}): Effect.Effect<
	PauseProjectMutationResponse,
	| ApiError
	| ValidationError
	| PauseProject400
	| PauseProject401
	| PauseProject403
	| PauseProject500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (projectId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "projectId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${projectId}/pause`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: {},
		});

		return response as PauseProjectMutationResponse;
	});
}

/**
 * @description Unpause a project by passing its project `id` in the URL. If the project does not exist given the id then the request will fail with 400 status code. If the project enables auto assigning custom production domains and unblocks the active Production Deployment then the request will return with 200 status code.
 * @summary Unpause a project
 * {@link /v1/projects/:projectId/unpause}
 */
export function unpauseProject({
	pathParams: { projectId },
	queryParams,
}: {
	pathParams: UnpauseProjectPathParams;
	queryParams?: UnpauseProjectQueryParams;
}): Effect.Effect<
	UnpauseProjectMutationResponse,
	| ApiError
	| ValidationError
	| UnpauseProject400
	| UnpauseProject401
	| UnpauseProject403
	| UnpauseProject500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (projectId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "projectId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/projects/${projectId}/unpause`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: {},
		});

		return response as UnpauseProjectMutationResponse;
	});
}

/**
 * @description Update the setting for determining if the project has Attack Challenge mode enabled.
 * @summary Update Attack Challenge mode
 * {@link /v1/security/attack-mode}
 */
export function updateAttackChallengeMode({
	queryParams,
}: {
	queryParams?: UpdateAttackChallengeModeQueryParams;
}): Effect.Effect<
	UpdateAttackChallengeModeMutationResponse,
	| ApiError
	| ValidationError
	| UpdateAttackChallengeMode400
	| UpdateAttackChallengeMode401
	| UpdateAttackChallengeMode403
	| UpdateAttackChallengeMode404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/security/attack-mode";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateAttackChallengeModeMutationResponse;
	});
}

/**
 * @description Set the firewall configuration to provided rules and settings. Creates or overwrite the existing firewall configuration.
 * @summary Put Firewall Configuration
 * {@link /v1/security/firewall/config}
 */
export function putFirewallConfig({
	queryParams,
}: {
	queryParams: PutFirewallConfigQueryParams;
}): Effect.Effect<
	PutFirewallConfigMutationResponse,
	| ApiError
	| ValidationError
	| PutFirewallConfig400
	| PutFirewallConfig401
	| PutFirewallConfig402
	| PutFirewallConfig403
	| PutFirewallConfig404
	| PutFirewallConfig500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/security/firewall/config";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PUT",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as PutFirewallConfigMutationResponse;
	});
}

/**
 * @description Process updates to modify the existing firewall config for a project
 * @summary Update Firewall Configuration
 * {@link /v1/security/firewall/config}
 */
export function updateFirewallConfig({
	queryParams,
}: {
	queryParams: UpdateFirewallConfigQueryParams;
}): Effect.Effect<
	UpdateFirewallConfigMutationResponse,
	| ApiError
	| ValidationError
	| UpdateFirewallConfig400
	| UpdateFirewallConfig401
	| UpdateFirewallConfig402
	| UpdateFirewallConfig403
	| UpdateFirewallConfig404
	| UpdateFirewallConfig500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/security/firewall/config";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateFirewallConfigMutationResponse;
	});
}

/**
 * @description Retrieve the specified firewall configuration for a project. The deployed configVersion will be `active`
 * @summary Read Firewall Configuration
 * {@link /v1/security/firewall/config/:configVersion}
 */
export function getFirewallConfig({
	pathParams: { configVersion },
	queryParams,
}: {
	pathParams: GetFirewallConfigPathParams;
	queryParams: GetFirewallConfigQueryParams;
}): Effect.Effect<
	GetFirewallConfigQueryResponse,
	| ApiError
	| ValidationError
	| GetFirewallConfig400
	| GetFirewallConfig401
	| GetFirewallConfig403
	| GetFirewallConfig404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (configVersion === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "configVersion",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/security/firewall/config/${configVersion}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetFirewallConfigQueryResponse;
	});
}

/**
 * @description Retrieve active attack data within the last N days (default: 1 day)
 * @summary Read active attack data
 * {@link /v1/security/firewall/attack-status}
 */
export function getActiveAttackStatus({
	queryParams,
}: {
	queryParams: GetActiveAttackStatusQueryParams;
}): Effect.Effect<
	GetActiveAttackStatusQueryResponse,
	| ApiError
	| ValidationError
	| GetActiveAttackStatus400
	| GetActiveAttackStatus401
	| GetActiveAttackStatus403
	| GetActiveAttackStatus404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/security/firewall/attack-status";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetActiveAttackStatusQueryResponse;
	});
}

/**
 * @description Retrieve the system bypass rules configured for the specified project
 * @summary Read System Bypass
 * {@link /v1/security/firewall/bypass}
 */
export function getBypassIp({
	queryParams,
}: {
	queryParams: GetBypassIpQueryParams;
}): Effect.Effect<
	GetBypassIpQueryResponse,
	| ApiError
	| ValidationError
	| GetBypassIp400
	| GetBypassIp401
	| GetBypassIp403
	| GetBypassIp404
	| GetBypassIp500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/security/firewall/bypass";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetBypassIpQueryResponse;
	});
}

/**
 * @description Create new system bypass rules
 * @summary Create System Bypass Rule
 * {@link /v1/security/firewall/bypass}
 */
export function addBypassIp({
	queryParams,
}: {
	queryParams: AddBypassIpQueryParams;
}): Effect.Effect<
	AddBypassIpMutationResponse,
	| ApiError
	| ValidationError
	| AddBypassIp400
	| AddBypassIp401
	| AddBypassIp403
	| AddBypassIp404
	| AddBypassIp500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/security/firewall/bypass";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as AddBypassIpMutationResponse;
	});
}

/**
 * @description Remove system bypass rules
 * @summary Remove System Bypass Rule
 * {@link /v1/security/firewall/bypass}
 */
export function removeBypassIp({
	queryParams,
}: {
	queryParams: RemoveBypassIpQueryParams;
}): Effect.Effect<
	RemoveBypassIpMutationResponse,
	| ApiError
	| ValidationError
	| RemoveBypassIp400
	| RemoveBypassIp401
	| RemoveBypassIp403
	| RemoveBypassIp404
	| RemoveBypassIp500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/security/firewall/bypass";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as RemoveBypassIpMutationResponse;
	});
}

/**
 * @description Retrieve firewall actions for a project
 * @summary Read Firewall Actions by Project
 * {@link /v1/security/firewall/events}
 */
export function gETV1SecurityFirewallEvents({
	queryParams,
}: {
	queryParams: GETV1SecurityFirewallEventsQueryParams;
}): Effect.Effect<
	GETV1SecurityFirewallEventsQueryResponse,
	| ApiError
	| ValidationError
	| GETV1SecurityFirewallEvents400
	| GETV1SecurityFirewallEvents401
	| GETV1SecurityFirewallEvents403
	| GETV1SecurityFirewallEvents404
	| GETV1SecurityFirewallEvents500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/security/firewall/events";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GETV1SecurityFirewallEventsQueryResponse;
	});
}

/**
 * @description Creates an integration store for both FREE and PAID billing plans. This simplified endpoint automatically provisions real integration storage resources while handling billing complexity behind the scenes. It supports both free and paid billing plans with automatic authorization creation for paid resources. ## How it works 1. Validates the integration configuration and product 2. For free resources: Auto-discovers available free billing plans 3. For paid resources: Creates billing authorization inline using provided billingPlanId 4. Provisions real resources through the Vercel Marketplace 5. Returns the created store with connection details ## Workflow Before using this endpoint, discover available products and billing plans: 1. List your configurations: `GET /v1/integrations/configurations` 2. Get products for a configuration: `GET /v1/integrations/configuration/{id}/products` 3. Get billing plans for a product: `GET /integrations/integration/{integrationId}/products/{productId}/plans` 4. Review the `metadataSchema` for each product to understand required metadata 5. Create storage with discovered product: `POST /v1/storage/stores/integration/direct` ## Usage Patterns - **Free resources**: Omit `billingPlanId` - endpoint will auto-discover free plans - **Paid resources**: Provide `billingPlanId` from billing plans discovery - **Prepayment plans**: Also provide `prepaymentAmountCents` for variable amount plans ## Limitations - **Admin access required**: Only integration configuration admins can create stores - **Storage limits apply**: Subject to your team's storage quotas - **Payment method required**: For paid plans, ensure valid payment method is configured ## Error Responses - `400 Bad Request`: Invalid input, no plans available, or billing issues - `403 Forbidden`: Insufficient permissions (non-admin users) - `404 Not Found`: Integration configuration or product not found - `429 Too Many Requests`: Rate limit exceeded
 * @summary Create integration store (free and paid plans)
 * {@link /v1/storage/stores/integration/direct}
 */
export function createIntegrationStoreDirect({
	queryParams,
}: {
	queryParams?: CreateIntegrationStoreDirectQueryParams;
}): Effect.Effect<
	CreateIntegrationStoreDirectMutationResponse,
	| ApiError
	| ValidationError
	| CreateIntegrationStoreDirect400
	| CreateIntegrationStoreDirect401
	| CreateIntegrationStoreDirect402
	| CreateIntegrationStoreDirect403
	| CreateIntegrationStoreDirect404
	| CreateIntegrationStoreDirect409
	| CreateIntegrationStoreDirect429
	| CreateIntegrationStoreDirect500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/storage/stores/integration/direct";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateIntegrationStoreDirectMutationResponse;
	});
}

/**
 * @description Get a paginated list of team members for the provided team.
 * @summary List team members
 * {@link /v3/teams/:teamId/members}
 */
export function getTeamMembers({
	pathParams: { teamId },
	queryParams,
}: {
	pathParams: GetTeamMembersPathParams;
	queryParams?: GetTeamMembersQueryParams;
}): Effect.Effect<
	GetTeamMembersQueryResponse,
	| ApiError
	| ValidationError
	| GetTeamMembers400
	| GetTeamMembers401
	| GetTeamMembers403
	| GetTeamMembers404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (teamId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "teamId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v3/teams/${teamId}/members`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetTeamMembersQueryResponse;
	});
}

/**
 * @description Invite a user to join the team specified in the URL. The authenticated user needs to be an `OWNER` in order to successfully invoke this endpoint. The user to be invited must be specified by email.
 * @summary Invite a user
 * {@link /v2/teams/:teamId/members}
 */
export function inviteUserToTeam({
	pathParams: { teamId },
}: {
	pathParams: InviteUserToTeamPathParams;
}): Effect.Effect<
	InviteUserToTeamMutationResponse,
	| ApiError
	| ValidationError
	| InviteUserToTeam400
	| InviteUserToTeam401
	| InviteUserToTeam403
	| InviteUserToTeam503,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (teamId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "teamId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v2/teams/${teamId}/members`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as InviteUserToTeamMutationResponse;
	});
}

/**
 * @description Request access to a team as a member. An owner has to approve the request. Only 10 users can request access to a team at the same time.
 * @summary Request access to a team
 * {@link /v1/teams/:teamId/request}
 */
export function requestAccessToTeam({
	pathParams: { teamId },
}: {
	pathParams: RequestAccessToTeamPathParams;
}): Effect.Effect<
	RequestAccessToTeamMutationResponse,
	| ApiError
	| ValidationError
	| RequestAccessToTeam400
	| RequestAccessToTeam401
	| RequestAccessToTeam403
	| RequestAccessToTeam404
	| RequestAccessToTeam503,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (teamId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "teamId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/teams/${teamId}/request`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as RequestAccessToTeamMutationResponse;
	});
}

/**
 * @description Check the status of a join request. It'll respond with a 404 if the request has been declined. If no `userId` path segment was provided, this endpoint will instead return the status of the authenticated user.
 * @summary Get access request status
 * {@link /v1/teams/:teamId/request/:userId}
 */
export function getTeamAccessRequest({
	pathParams: { userId, teamId },
}: {
	pathParams: GetTeamAccessRequestPathParams;
}): Effect.Effect<
	GetTeamAccessRequestQueryResponse,
	| ApiError
	| ValidationError
	| GetTeamAccessRequest400
	| GetTeamAccessRequest401
	| GetTeamAccessRequest403
	| GetTeamAccessRequest404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (userId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "userId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (teamId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "teamId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/teams/${teamId}/request/${userId}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetTeamAccessRequestQueryResponse;
	});
}

/**
 * @description Join a team with a provided invite code or team ID.
 * @summary Join a team
 * {@link /v1/teams/:teamId/members/teams/join}
 */
export function joinTeam({
	pathParams: { teamId },
}: {
	pathParams: JoinTeamPathParams;
}): Effect.Effect<
	JoinTeamMutationResponse,
	ApiError | ValidationError | JoinTeam400 | JoinTeam401 | JoinTeam402 | JoinTeam403 | JoinTeam404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (teamId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "teamId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/teams/${teamId}/members/teams/join`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as JoinTeamMutationResponse;
	});
}

/**
 * @description Update the membership of a Team Member on the Team specified by `teamId`, such as changing the _role_ of the member, or confirming a request to join the Team for an unconfirmed member. The authenticated user must be an `OWNER` of the Team.
 * @summary Update a Team Member
 * {@link /v1/teams/:teamId/members/:uid}
 */
export function updateTeamMember({
	pathParams: { uid, teamId },
}: {
	pathParams: UpdateTeamMemberPathParams;
}): Effect.Effect<
	UpdateTeamMemberMutationResponse,
	| ApiError
	| ValidationError
	| UpdateTeamMember400
	| UpdateTeamMember401
	| UpdateTeamMember402
	| UpdateTeamMember403
	| UpdateTeamMember404
	| UpdateTeamMember409
	| UpdateTeamMember500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (uid === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "uid",
					message: "Missing required path parameter",
				}),
			);
		}
		if (teamId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "teamId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/teams/${teamId}/members/${uid}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UpdateTeamMemberMutationResponse;
	});
}

/**
 * @description Remove a Team Member from the Team, or dismiss a user that requested access, or leave a team.
 * @summary Remove a Team Member
 * {@link /v1/teams/:teamId/members/:uid}
 */
export function removeTeamMember({
	pathParams: { uid, teamId },
	queryParams,
}: {
	pathParams: RemoveTeamMemberPathParams;
	queryParams?: RemoveTeamMemberQueryParams;
}): Effect.Effect<
	RemoveTeamMemberMutationResponse,
	| ApiError
	| ValidationError
	| RemoveTeamMember400
	| RemoveTeamMember401
	| RemoveTeamMember403
	| RemoveTeamMember404
	| RemoveTeamMember503,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (uid === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "uid",
					message: "Missing required path parameter",
				}),
			);
		}
		if (teamId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "teamId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/teams/${teamId}/members/${uid}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as RemoveTeamMemberMutationResponse;
	});
}

/**
 * @description Get information for the Team specified by the `teamId` parameter.
 * @summary Get a Team
 * {@link /v2/teams/:teamId}
 */
export function getTeam({
	pathParams: { teamId },
	queryParams,
}: {
	pathParams: GetTeamPathParams;
	queryParams?: GetTeamQueryParams;
}): Effect.Effect<
	GetTeamQueryResponse,
	ApiError | ValidationError | GetTeam400 | GetTeam401 | GetTeam403 | GetTeam404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (teamId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "teamId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v2/teams/${teamId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetTeamQueryResponse;
	});
}

/**
 * @description Update the information of a Team specified by the `teamId` parameter. The request body should contain the information that will be updated on the Team.
 * @summary Update a Team
 * {@link /v2/teams/:teamId}
 */
export function patchTeam({
	pathParams: { teamId },
	queryParams,
}: {
	pathParams: PatchTeamPathParams;
	queryParams?: PatchTeamQueryParams;
}): Effect.Effect<
	PatchTeamMutationResponse,
	| ApiError
	| ValidationError
	| PatchTeam400
	| PatchTeam401
	| PatchTeam402
	| PatchTeam403
	| PatchTeam428,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (teamId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "teamId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v2/teams/${teamId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as PatchTeamMutationResponse;
	});
}

/**
 * @description Get a paginated list of all the Teams the authenticated User is a member of.
 * @summary List all teams
 * {@link /v2/teams}
 */
export function getTeams({
	queryParams,
}: {
	queryParams?: GetTeamsQueryParams;
}): Effect.Effect<
	GetTeamsQueryResponse,
	ApiError | ValidationError | GetTeams400 | GetTeams401 | GetTeams403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v2/teams";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetTeamsQueryResponse;
	});
}

/**
 * @description Create a new Team under your account. You need to send a POST request with the desired Team slug, and optionally the Team name.
 * @summary Create a Team
 * {@link /v1/teams}
 */
export function createTeam(): Effect.Effect<
	CreateTeamMutationResponse,
	ApiError | ValidationError | CreateTeam400 | CreateTeam401 | CreateTeam403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/teams";
		const fullUrl = url;

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateTeamMutationResponse;
	});
}

/**
 * @description Update the Directory Sync role mappings for a Team. This endpoint allows updating the mapping between directory groups and team roles or access groups.
 * @summary Update Team Directory Sync Role Mappings
 * {@link /v1/teams/:teamId/dsync-roles}
 */
export function postTeamDsyncRoles({
	pathParams: { teamId },
	queryParams,
}: {
	pathParams: PostTeamDsyncRolesPathParams;
	queryParams?: PostTeamDsyncRolesQueryParams;
}): Effect.Effect<
	PostTeamDsyncRolesMutationResponse,
	| ApiError
	| ValidationError
	| PostTeamDsyncRoles400
	| PostTeamDsyncRoles401
	| PostTeamDsyncRoles403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (teamId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "teamId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/teams/${teamId}/dsync-roles`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as PostTeamDsyncRolesMutationResponse;
	});
}

/**
 * @description Delete a team under your account. You need to send a `DELETE` request with the desired team `id`. An optional array of reasons for deletion may also be sent.
 * @summary Delete a Team
 * {@link /v1/teams/:teamId}
 */
export function deleteTeam({
	pathParams: { teamId },
	queryParams,
}: {
	pathParams: DeleteTeamPathParams;
	queryParams?: DeleteTeamQueryParams;
}): Effect.Effect<
	DeleteTeamMutationResponse,
	| ApiError
	| ValidationError
	| DeleteTeam400
	| DeleteTeam401
	| DeleteTeam402
	| DeleteTeam403
	| DeleteTeam409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (teamId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "teamId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/teams/${teamId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as DeleteTeamMutationResponse;
	});
}

/**
 * @description Delete an active Team invite code.
 * @summary Delete a Team invite code
 * {@link /v1/teams/:teamId/invites/:inviteId}
 */
export function deleteTeamInviteCode({
	pathParams: { inviteId, teamId },
}: {
	pathParams: DeleteTeamInviteCodePathParams;
}): Effect.Effect<
	DeleteTeamInviteCodeMutationResponse,
	| ApiError
	| ValidationError
	| DeleteTeamInviteCode400
	| DeleteTeamInviteCode401
	| DeleteTeamInviteCode403
	| DeleteTeamInviteCode404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (inviteId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "inviteId",
					message: "Missing required path parameter",
				}),
			);
		}
		if (teamId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "teamId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/teams/${teamId}/invites/${inviteId}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteTeamInviteCodeMutationResponse;
	});
}

/**
 * @description Before you create a deployment you need to upload the required files for that deployment. To do it, you need to first upload each file to this endpoint. Once that's completed, you can create a new deployment with the uploaded files. The file content must be placed inside the body of the request. In the case of a successful response you'll receive a status code 200 with an empty body.
 * @summary Upload Deployment Files
 * {@link /v2/files}
 */
export function uploadFile({
	queryParams,
	headers,
}: {
	queryParams?: UploadFileQueryParams;
	headers?: UploadFileHeaderParams;
}): Effect.Effect<
	UploadFileMutationResponse,
	ApiError | ValidationError | UploadFile400 | UploadFile401 | UploadFile403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v2/files";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationOctetStream", ...headers },
		});

		return response as UploadFileMutationResponse;
	});
}

/**
 * @description Retrieve a list of the current User's authentication tokens.
 * @summary List Auth Tokens
 * {@link /v5/user/tokens}
 */
export function listAuthTokens(): Effect.Effect<
	ListAuthTokensQueryResponse,
	ApiError | ValidationError | ListAuthTokens400 | ListAuthTokens401 | ListAuthTokens403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v5/user/tokens";
		const fullUrl = url;

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ListAuthTokensQueryResponse;
	});
}

/**
 * @description Creates and returns a new authentication token for the currently authenticated User. The `bearerToken` property is only provided once, in the response body, so be sure to save it on the client for use with API requests.
 * @summary Create an Auth Token
 * {@link /v3/user/tokens}
 */
export function createAuthToken({
	queryParams,
}: {
	queryParams?: CreateAuthTokenQueryParams;
}): Effect.Effect<
	CreateAuthTokenMutationResponse,
	ApiError | ValidationError | CreateAuthToken400 | CreateAuthToken401 | CreateAuthToken403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v3/user/tokens";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateAuthTokenMutationResponse;
	});
}

/**
 * @description Retrieve metadata about an authentication token belonging to the currently authenticated User.
 * @summary Get Auth Token Metadata
 * {@link /v5/user/tokens/:tokenId}
 */
export function getAuthToken({
	pathParams: { tokenId },
}: {
	pathParams: GetAuthTokenPathParams;
}): Effect.Effect<
	GetAuthTokenQueryResponse,
	| ApiError
	| ValidationError
	| GetAuthToken400
	| GetAuthToken401
	| GetAuthToken403
	| GetAuthToken404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (tokenId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "tokenId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v5/user/tokens/${tokenId}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetAuthTokenQueryResponse;
	});
}

/**
 * @description Invalidate an authentication token, such that it will no longer be valid for future HTTP requests.
 * @summary Delete an authentication token
 * {@link /v3/user/tokens/:tokenId}
 */
export function deleteAuthToken({
	pathParams: { tokenId },
}: {
	pathParams: DeleteAuthTokenPathParams;
}): Effect.Effect<
	DeleteAuthTokenMutationResponse,
	| ApiError
	| ValidationError
	| DeleteAuthToken400
	| DeleteAuthToken401
	| DeleteAuthToken403
	| DeleteAuthToken404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (tokenId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "tokenId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v3/user/tokens/${tokenId}`;
		const fullUrl = url;

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteAuthTokenMutationResponse;
	});
}

/**
 * @description Retrieves information related to the currently authenticated User.
 * @summary Get the User
 * {@link /v2/user}
 */
export function getAuthUser(): Effect.Effect<
	GetAuthUserQueryResponse,
	ApiError | ValidationError | GetAuthUser400 | GetAuthUser401 | GetAuthUser403 | GetAuthUser409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v2/user";
		const fullUrl = url;

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetAuthUserQueryResponse;
	});
}

/**
 * @description Initiates the deletion process for the currently authenticated User, by sending a deletion confirmation email. The email contains a link that the user needs to visit in order to proceed with the deletion process.
 * @summary Delete User Account
 * {@link /v1/user}
 */
export function requestDelete(): Effect.Effect<
	RequestDeleteMutationResponse,
	| ApiError
	| ValidationError
	| RequestDelete400
	| RequestDelete401
	| RequestDelete402
	| RequestDelete403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/user";
		const fullUrl = url;

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as RequestDeleteMutationResponse;
	});
}

/**
 * @description Creates a webhook
 * @summary Creates a webhook
 * {@link /v1/webhooks}
 */
export function createWebhook({
	queryParams,
}: {
	queryParams?: CreateWebhookQueryParams;
}): Effect.Effect<
	CreateWebhookMutationResponse,
	ApiError | ValidationError | CreateWebhook400 | CreateWebhook401 | CreateWebhook403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/webhooks";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as CreateWebhookMutationResponse;
	});
}

/**
 * @description Get a list of webhooks
 * @summary Get a list of webhooks
 * {@link /v1/webhooks}
 */
export function getWebhooks({
	queryParams,
}: {
	queryParams?: GetWebhooksQueryParams;
}): Effect.Effect<
	GetWebhooksQueryResponse,
	ApiError | ValidationError | GetWebhooks400 | GetWebhooks401 | GetWebhooks403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v1/webhooks";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetWebhooksQueryResponse;
	});
}

/**
 * @description Get a webhook
 * @summary Get a webhook
 * {@link /v1/webhooks/:id}
 */
export function getWebhook({
	pathParams: { id },
	queryParams,
}: {
	pathParams: GetWebhookPathParams;
	queryParams?: GetWebhookQueryParams;
}): Effect.Effect<
	GetWebhookQueryResponse,
	ApiError | ValidationError | GetWebhook400 | GetWebhook401 | GetWebhook403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/webhooks/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetWebhookQueryResponse;
	});
}

/**
 * @description Deletes a webhook
 * @summary Deletes a webhook
 * {@link /v1/webhooks/:id}
 */
export function deleteWebhook({
	pathParams: { id },
	queryParams,
}: {
	pathParams: DeleteWebhookPathParams;
	queryParams?: DeleteWebhookQueryParams;
}): Effect.Effect<
	DeleteWebhookMutationResponse,
	ApiError | ValidationError | DeleteWebhook400 | DeleteWebhook401 | DeleteWebhook403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v1/webhooks/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteWebhookMutationResponse;
	});
}

/**
 * @description Retrieves all Aliases for the Deployment with the given ID. The authenticated user or team must own the deployment.
 * @summary List Deployment Aliases
 * {@link /v2/deployments/:id/aliases}
 */
export function listDeploymentAliases({
	pathParams: { id },
	queryParams,
}: {
	pathParams: ListDeploymentAliasesPathParams;
	queryParams?: ListDeploymentAliasesQueryParams;
}): Effect.Effect<
	ListDeploymentAliasesQueryResponse,
	| ApiError
	| ValidationError
	| ListDeploymentAliases400
	| ListDeploymentAliases401
	| ListDeploymentAliases403
	| ListDeploymentAliases404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v2/deployments/${id}/aliases`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ListDeploymentAliasesQueryResponse;
	});
}

/**
 * @description Creates a new alias for the deployment with the given deployment ID. The authenticated user or team must own this deployment. If the desired alias is already assigned to another deployment, then it will be removed from the old deployment and assigned to the new one.
 * @summary Assign an Alias
 * {@link /v2/deployments/:id/aliases}
 */
export function assignAlias({
	pathParams: { id },
	queryParams,
}: {
	pathParams: AssignAliasPathParams;
	queryParams?: AssignAliasQueryParams;
}): Effect.Effect<
	AssignAliasMutationResponse,
	| ApiError
	| ValidationError
	| AssignAlias400
	| AssignAlias401
	| AssignAlias402
	| AssignAlias403
	| AssignAlias404
	| AssignAlias409,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v2/deployments/${id}/aliases`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as AssignAliasMutationResponse;
	});
}

/**
 * @description Retrieves a list of aliases for the authenticated User or Team. When `domain` is provided, only aliases for that domain will be returned. When `projectId` is provided, it will only return the given project aliases.
 * @summary List aliases
 * {@link /v4/aliases}
 */
export function listAliases({
	queryParams,
}: {
	queryParams?: ListAliasesQueryParams;
}): Effect.Effect<
	ListAliasesQueryResponse,
	ApiError | ValidationError | ListAliases400 | ListAliases401 | ListAliases403 | ListAliases404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v4/aliases";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ListAliasesQueryResponse;
	});
}

/**
 * @description Retrieves an Alias for the given host name or alias ID.
 * @summary Get an Alias
 * {@link /v4/aliases/:idOrAlias}
 */
export function getAlias({
	pathParams: { idOrAlias },
	queryParams,
}: {
	pathParams: GetAliasPathParams;
	queryParams?: GetAliasQueryParams;
}): Effect.Effect<
	GetAliasQueryResponse,
	ApiError | ValidationError | GetAlias400 | GetAlias401 | GetAlias403 | GetAlias404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (idOrAlias === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "idOrAlias",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v4/aliases/${idOrAlias}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetAliasQueryResponse;
	});
}

/**
 * @description Delete an Alias with the specified ID.
 * @summary Delete an Alias
 * {@link /v2/aliases/:aliasId}
 */
export function deleteAlias({
	pathParams: { aliasId },
	queryParams,
}: {
	pathParams: DeleteAliasPathParams;
	queryParams?: DeleteAliasQueryParams;
}): Effect.Effect<
	DeleteAliasMutationResponse,
	ApiError | ValidationError | DeleteAlias400 | DeleteAlias401 | DeleteAlias403 | DeleteAlias404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (aliasId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "aliasId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v2/aliases/${aliasId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteAliasMutationResponse;
	});
}

/**
 * @description Update the protection bypass for the alias or deployment URL (used for user access & comment access for deployments). Used as shareable links and user scoped access for Vercel Authentication and also to allow external (logged in) people to comment on previews for Preview Comments (next-live-mode).
 * @summary Update the protection bypass for a URL
 * {@link /aliases/:id/protection-bypass}
 */
export function patchUrlProtectionBypass({
	pathParams: { id },
	queryParams,
}: {
	pathParams: PatchUrlProtectionBypassPathParams;
	queryParams?: PatchUrlProtectionBypassQueryParams;
}): Effect.Effect<
	PatchUrlProtectionBypassMutationResponse,
	| ApiError
	| ValidationError
	| PatchUrlProtectionBypass400
	| PatchUrlProtectionBypass401
	| PatchUrlProtectionBypass403
	| PatchUrlProtectionBypass404
	| PatchUrlProtectionBypass409
	| PatchUrlProtectionBypass428
	| PatchUrlProtectionBypass500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/aliases/${id}/protection-bypass`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PATCH",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as PatchUrlProtectionBypassMutationResponse;
	});
}

/**
 * @description Get cert by id
 * @summary Get cert by id
 * {@link /v8/certs/:id}
 */
export function getCertById({
	pathParams: { id },
	queryParams,
}: {
	pathParams: GetCertByIdPathParams;
	queryParams?: GetCertByIdQueryParams;
}): Effect.Effect<
	GetCertByIdQueryResponse,
	ApiError | ValidationError | GetCertById400 | GetCertById401 | GetCertById403 | GetCertById404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v8/certs/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetCertByIdQueryResponse;
	});
}

/**
 * @description Remove cert
 * @summary Remove cert
 * {@link /v8/certs/:id}
 */
export function removeCert({
	pathParams: { id },
	queryParams,
}: {
	pathParams: RemoveCertPathParams;
	queryParams?: RemoveCertQueryParams;
}): Effect.Effect<
	RemoveCertMutationResponse,
	ApiError | ValidationError | RemoveCert400 | RemoveCert401 | RemoveCert403 | RemoveCert404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v8/certs/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as RemoveCertMutationResponse;
	});
}

/**
 * @description Issue a new cert
 * @summary Issue a new cert
 * {@link /v8/certs}
 */
export function issueCert({
	queryParams,
}: {
	queryParams?: IssueCertQueryParams;
}): Effect.Effect<
	IssueCertMutationResponse,
	| ApiError
	| ValidationError
	| IssueCert400
	| IssueCert401
	| IssueCert402
	| IssueCert403
	| IssueCert404
	| IssueCert449
	| IssueCert500,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v8/certs";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "POST",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as IssueCertMutationResponse;
	});
}

/**
 * @description Upload a cert
 * @summary Upload a cert
 * {@link /v8/certs}
 */
export function uploadCert({
	queryParams,
}: {
	queryParams?: UploadCertQueryParams;
}): Effect.Effect<
	UploadCertMutationResponse,
	ApiError | ValidationError | UploadCert400 | UploadCert401 | UploadCert402 | UploadCert403,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v8/certs";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "PUT",
			url: fullUrl,

			headers: { "Content-Type": "applicationJson" },
		});

		return response as UploadCertMutationResponse;
	});
}

/**
 * @description Allows to retrieve the file structure of the source code of a deployment by supplying the deployment unique identifier. If the deployment was created with the Vercel CLI or the API directly with the `files` key, it will have a file tree that can be retrievable.
 * @summary List Deployment Files
 * {@link /v6/deployments/:id/files}
 */
export function listDeploymentFiles({
	pathParams: { id },
	queryParams,
}: {
	pathParams: ListDeploymentFilesPathParams;
	queryParams?: ListDeploymentFilesQueryParams;
}): Effect.Effect<
	ListDeploymentFilesQueryResponse,
	| ApiError
	| ValidationError
	| ListDeploymentFiles400
	| ListDeploymentFiles401
	| ListDeploymentFiles403
	| ListDeploymentFiles404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v6/deployments/${id}/files`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as ListDeploymentFilesQueryResponse;
	});
}

/**
 * @description Allows to retrieve the content of a file by supplying the file identifier and the deployment unique identifier. The response body will contain a JSON response containing the contents of the file encoded as base64.
 * @summary Get Deployment File Contents
 * {@link /v8/deployments/:id/files/:fileId}
 */
export function getDeploymentFileContents({
	pathParams: { id, fileId },
	queryParams,
}: {
	pathParams: GetDeploymentFileContentsPathParams;
	queryParams?: GetDeploymentFileContentsQueryParams;
}): Effect.Effect<
	GetDeploymentFileContentsQueryResponse,
	| ApiError
	| ValidationError
	| GetDeploymentFileContents400
	| GetDeploymentFileContents401
	| GetDeploymentFileContents403
	| GetDeploymentFileContents404
	| GetDeploymentFileContents410,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}
		if (fileId === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "fileId",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v8/deployments/${id}/files/${fileId}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetDeploymentFileContentsQueryResponse;
	});
}

/**
 * @description List deployments under the authenticated user or team. If a deployment hasn't finished uploading (is incomplete), the `url` property will have a value of `null`.
 * @summary List deployments
 * {@link /v6/deployments}
 */
export function getDeployments({
	queryParams,
}: {
	queryParams?: GetDeploymentsQueryParams;
}): Effect.Effect<
	GetDeploymentsQueryResponse,
	| ApiError
	| ValidationError
	| GetDeployments400
	| GetDeployments401
	| GetDeployments403
	| GetDeployments404
	| GetDeployments422,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		const url = "/v6/deployments";
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "GET",
			url: fullUrl,

			headers: {},
		});

		return response as GetDeploymentsQueryResponse;
	});
}

/**
 * @description This API allows you to delete a deployment, either by supplying its `id` in the URL or the `url` of the deployment as a query parameter. You can obtain the ID, for example, by listing all deployments.
 * @summary Delete a Deployment
 * {@link /v13/deployments/:id}
 */
export function deleteDeployment({
	pathParams: { id },
	queryParams,
}: {
	pathParams: DeleteDeploymentPathParams;
	queryParams?: DeleteDeploymentQueryParams;
}): Effect.Effect<
	DeleteDeploymentMutationResponse,
	| ApiError
	| ValidationError
	| DeleteDeployment400
	| DeleteDeployment401
	| DeleteDeployment403
	| DeleteDeployment404,
	ApiClient
> {
	return Effect.gen(function* () {
		const client = yield* ApiClient;

		if (id === undefined) {
			return yield* Effect.fail(
				new ValidationError({
					field: "id",
					message: "Missing required path parameter",
				}),
			);
		}

		const url = `/v13/deployments/${id}`;
		const searchParams = serializeQueryParams(queryParams);
		const fullUrl = url + (searchParams ? "?" + searchParams : "");

		const response = yield* client.request({
			method: "DELETE",
			url: fullUrl,

			headers: {},
		});

		return response as DeleteDeploymentMutationResponse;
	});
}

export type {
	ApiClientConfig,
	ApiClientRequest,
	ApiClientService,
} from "@sferadev/openapi-utils/effect";
// Re-export core types for convenience
export {
	ApiClient,
	ApiError,
	createClient,
	makeApiClientFromEnv,
	makeApiClientLive,
	NetworkError,
	runWithClient,
	serializeQueryParams,
	ValidationError,
} from "@sferadev/openapi-utils/effect";

// ============================================================================
// Tag-based Services
// ============================================================================

export const AccessGroupsService = {
	readAccessGroup: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: ReadAccessGroupPathParams;
		queryParams?: ReadAccessGroupQueryParams;
	}) => readAccessGroup({ pathParams: { idOrName }, queryParams }),
	updateAccessGroup: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: UpdateAccessGroupPathParams;
		queryParams?: UpdateAccessGroupQueryParams;
	}) => updateAccessGroup({ pathParams: { idOrName }, queryParams }),
	deleteAccessGroup: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: DeleteAccessGroupPathParams;
		queryParams?: DeleteAccessGroupQueryParams;
	}) => deleteAccessGroup({ pathParams: { idOrName }, queryParams }),
	listAccessGroupMembers: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: ListAccessGroupMembersPathParams;
		queryParams?: ListAccessGroupMembersQueryParams;
	}) => listAccessGroupMembers({ pathParams: { idOrName }, queryParams }),
	listAccessGroups: ({ queryParams }: { queryParams?: ListAccessGroupsQueryParams }) =>
		listAccessGroups({ queryParams }),
	createAccessGroup: ({ queryParams }: { queryParams?: CreateAccessGroupQueryParams }) =>
		createAccessGroup({ queryParams }),
	listAccessGroupProjects: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: ListAccessGroupProjectsPathParams;
		queryParams?: ListAccessGroupProjectsQueryParams;
	}) => listAccessGroupProjects({ pathParams: { idOrName }, queryParams }),
	createAccessGroupProject: ({
		pathParams: { accessGroupIdOrName },
		queryParams,
	}: {
		pathParams: CreateAccessGroupProjectPathParams;
		queryParams?: CreateAccessGroupProjectQueryParams;
	}) => createAccessGroupProject({ pathParams: { accessGroupIdOrName }, queryParams }),
	readAccessGroupProject: ({
		pathParams: { accessGroupIdOrName, projectId },
		queryParams,
	}: {
		pathParams: ReadAccessGroupProjectPathParams;
		queryParams?: ReadAccessGroupProjectQueryParams;
	}) => readAccessGroupProject({ pathParams: { accessGroupIdOrName, projectId }, queryParams }),
	updateAccessGroupProject: ({
		pathParams: { accessGroupIdOrName, projectId },
		queryParams,
	}: {
		pathParams: UpdateAccessGroupProjectPathParams;
		queryParams?: UpdateAccessGroupProjectQueryParams;
	}) => updateAccessGroupProject({ pathParams: { accessGroupIdOrName, projectId }, queryParams }),
	deleteAccessGroupProject: ({
		pathParams: { accessGroupIdOrName, projectId },
		queryParams,
	}: {
		pathParams: DeleteAccessGroupProjectPathParams;
		queryParams?: DeleteAccessGroupProjectQueryParams;
	}) => deleteAccessGroupProject({ pathParams: { accessGroupIdOrName, projectId }, queryParams }),
} as const;

export const ArtifactsService = {
	recordEvents: ({
		queryParams,
		headers,
	}: {
		queryParams?: RecordEventsQueryParams;
		headers?: RecordEventsHeaderParams;
	}) => recordEvents({ queryParams, headers }),
	status: ({ queryParams }: { queryParams?: StatusQueryParams }) => status({ queryParams }),
	uploadArtifact: ({
		pathParams: { hash },
		headers,
		queryParams,
	}: {
		pathParams: UploadArtifactPathParams;
		headers: UploadArtifactHeaderParams;
		queryParams?: UploadArtifactQueryParams;
	}) => uploadArtifact({ pathParams: { hash }, headers, queryParams }),
	downloadArtifact: ({
		pathParams: { hash },
		queryParams,
		headers,
	}: {
		pathParams: DownloadArtifactPathParams;
		queryParams?: DownloadArtifactQueryParams;
		headers?: DownloadArtifactHeaderParams;
	}) => downloadArtifact({ pathParams: { hash }, queryParams, headers }),
	artifactQuery: ({ queryParams }: { queryParams?: ArtifactQueryQueryParams }) =>
		artifactQuery({ queryParams }),
} as const;

export const BulkRedirectsService = {
	stageRedirects: ({ queryParams }: { queryParams?: StageRedirectsQueryParams }) =>
		stageRedirects({ queryParams }),
	getRedirects: ({ queryParams }: { queryParams: GetRedirectsQueryParams }) =>
		getRedirects({ queryParams }),
	deleteRedirects: ({ queryParams }: { queryParams: DeleteRedirectsQueryParams }) =>
		deleteRedirects({ queryParams }),
	editRedirect: ({ queryParams }: { queryParams: EditRedirectQueryParams }) =>
		editRedirect({ queryParams }),
	restoreRedirects: ({ queryParams }: { queryParams: RestoreRedirectsQueryParams }) =>
		restoreRedirects({ queryParams }),
	getVersions: ({ queryParams }: { queryParams: GetVersionsQueryParams }) =>
		getVersions({ queryParams }),
	updateVersion: ({ queryParams }: { queryParams: UpdateVersionQueryParams }) =>
		updateVersion({ queryParams }),
} as const;

export const ChecksService = {
	createCheck: ({
		pathParams: { deploymentId },
		queryParams,
	}: {
		pathParams: CreateCheckPathParams;
		queryParams?: CreateCheckQueryParams;
	}) => createCheck({ pathParams: { deploymentId }, queryParams }),
	getAllChecks: ({
		pathParams: { deploymentId },
		queryParams,
	}: {
		pathParams: GetAllChecksPathParams;
		queryParams?: GetAllChecksQueryParams;
	}) => getAllChecks({ pathParams: { deploymentId }, queryParams }),
	getCheck: ({
		pathParams: { deploymentId, checkId },
		queryParams,
	}: {
		pathParams: GetCheckPathParams;
		queryParams?: GetCheckQueryParams;
	}) => getCheck({ pathParams: { deploymentId, checkId }, queryParams }),
	updateCheck: ({
		pathParams: { deploymentId, checkId },
		queryParams,
	}: {
		pathParams: UpdateCheckPathParams;
		queryParams?: UpdateCheckQueryParams;
	}) => updateCheck({ pathParams: { deploymentId, checkId }, queryParams }),
	rerequestCheck: ({
		pathParams: { deploymentId, checkId },
		queryParams,
	}: {
		pathParams: RerequestCheckPathParams;
		queryParams?: RerequestCheckQueryParams;
	}) => rerequestCheck({ pathParams: { deploymentId, checkId }, queryParams }),
} as const;

export const ConnectService = {
	listNetworks: ({ queryParams }: { queryParams?: ListNetworksQueryParams }) =>
		listNetworks({ queryParams }),
	createNetwork: ({ queryParams }: { queryParams?: CreateNetworkQueryParams }) =>
		createNetwork({ queryParams }),
	deleteNetwork: ({
		pathParams: { networkId },
		queryParams,
	}: {
		pathParams: DeleteNetworkPathParams;
		queryParams?: DeleteNetworkQueryParams;
	}) => deleteNetwork({ pathParams: { networkId }, queryParams }),
	updateNetwork: ({
		pathParams: { networkId },
		queryParams,
	}: {
		pathParams: UpdateNetworkPathParams;
		queryParams?: UpdateNetworkQueryParams;
	}) => updateNetwork({ pathParams: { networkId }, queryParams }),
	readNetwork: ({
		pathParams: { networkId },
		queryParams,
	}: {
		pathParams: ReadNetworkPathParams;
		queryParams?: ReadNetworkQueryParams;
	}) => readNetwork({ pathParams: { networkId }, queryParams }),
	updateStaticIps: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: UpdateStaticIpsPathParams;
		queryParams?: UpdateStaticIpsQueryParams;
	}) => updateStaticIps({ pathParams: { idOrName }, queryParams }),
} as const;

export const ProjectsService = {
	updateProjectDataCache: ({
		pathParams: { projectId },
		queryParams,
	}: {
		pathParams: UpdateProjectDataCachePathParams;
		queryParams?: UpdateProjectDataCacheQueryParams;
	}) => updateProjectDataCache({ pathParams: { projectId }, queryParams }),
	getProjects: ({ queryParams }: { queryParams?: GetProjectsQueryParams }) =>
		getProjects({ queryParams }),
	createProject: ({ queryParams }: { queryParams?: CreateProjectQueryParams }) =>
		createProject({ queryParams }),
	getProject: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: GetProjectPathParams;
		queryParams?: GetProjectQueryParams;
	}) => getProject({ pathParams: { idOrName }, queryParams }),
	updateProject: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: UpdateProjectPathParams;
		queryParams?: UpdateProjectQueryParams;
	}) => updateProject({ pathParams: { idOrName }, queryParams }),
	deleteProject: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: DeleteProjectPathParams;
		queryParams?: DeleteProjectQueryParams;
	}) => deleteProject({ pathParams: { idOrName }, queryParams }),
	getProjectDomains: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: GetProjectDomainsPathParams;
		queryParams?: GetProjectDomainsQueryParams;
	}) => getProjectDomains({ pathParams: { idOrName }, queryParams }),
	getProjectDomain: ({
		pathParams: { idOrName, domain },
		queryParams,
	}: {
		pathParams: GetProjectDomainPathParams;
		queryParams?: GetProjectDomainQueryParams;
	}) => getProjectDomain({ pathParams: { idOrName, domain }, queryParams }),
	updateProjectDomain: ({
		pathParams: { idOrName, domain },
		queryParams,
	}: {
		pathParams: UpdateProjectDomainPathParams;
		queryParams?: UpdateProjectDomainQueryParams;
	}) => updateProjectDomain({ pathParams: { idOrName, domain }, queryParams }),
	removeProjectDomain: ({
		pathParams: { idOrName, domain },
		queryParams,
	}: {
		pathParams: RemoveProjectDomainPathParams;
		queryParams?: RemoveProjectDomainQueryParams;
	}) => removeProjectDomain({ pathParams: { idOrName, domain }, queryParams }),
	addProjectDomain: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: AddProjectDomainPathParams;
		queryParams?: AddProjectDomainQueryParams;
	}) => addProjectDomain({ pathParams: { idOrName }, queryParams }),
	moveProjectDomain: ({
		pathParams: { idOrName, domain },
		queryParams,
	}: {
		pathParams: MoveProjectDomainPathParams;
		queryParams?: MoveProjectDomainQueryParams;
	}) => moveProjectDomain({ pathParams: { idOrName, domain }, queryParams }),
	verifyProjectDomain: ({
		pathParams: { idOrName, domain },
		queryParams,
	}: {
		pathParams: VerifyProjectDomainPathParams;
		queryParams?: VerifyProjectDomainQueryParams;
	}) => verifyProjectDomain({ pathParams: { idOrName, domain }, queryParams }),
	filterProjectEnvs: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: FilterProjectEnvsPathParams;
		queryParams?: FilterProjectEnvsQueryParams;
	}) => filterProjectEnvs({ pathParams: { idOrName }, queryParams }),
	createProjectEnv: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: CreateProjectEnvPathParams;
		queryParams?: CreateProjectEnvQueryParams;
	}) => createProjectEnv({ pathParams: { idOrName }, queryParams }),
	getProjectEnv: ({
		pathParams: { idOrName, id },
		queryParams,
	}: {
		pathParams: GetProjectEnvPathParams;
		queryParams?: GetProjectEnvQueryParams;
	}) => getProjectEnv({ pathParams: { idOrName, id }, queryParams }),
	removeProjectEnv: ({
		pathParams: { idOrName, id },
		queryParams,
	}: {
		pathParams: RemoveProjectEnvPathParams;
		queryParams?: RemoveProjectEnvQueryParams;
	}) => removeProjectEnv({ pathParams: { idOrName, id }, queryParams }),
	editProjectEnv: ({
		pathParams: { idOrName, id },
		queryParams,
	}: {
		pathParams: EditProjectEnvPathParams;
		queryParams?: EditProjectEnvQueryParams;
	}) => editProjectEnv({ pathParams: { idOrName, id }, queryParams }),
	batchRemoveProjectEnv: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: BatchRemoveProjectEnvPathParams;
		queryParams?: BatchRemoveProjectEnvQueryParams;
	}) => batchRemoveProjectEnv({ pathParams: { idOrName }, queryParams }),
	createProjectTransferRequest: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: CreateProjectTransferRequestPathParams;
		queryParams?: CreateProjectTransferRequestQueryParams;
	}) => createProjectTransferRequest({ pathParams: { idOrName }, queryParams }),
	acceptProjectTransferRequest: ({
		pathParams: { code },
		queryParams,
	}: {
		pathParams: AcceptProjectTransferRequestPathParams;
		queryParams?: AcceptProjectTransferRequestQueryParams;
	}) => acceptProjectTransferRequest({ pathParams: { code }, queryParams }),
	updateProjectProtectionBypass: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: UpdateProjectProtectionBypassPathParams;
		queryParams?: UpdateProjectProtectionBypassQueryParams;
	}) => updateProjectProtectionBypass({ pathParams: { idOrName }, queryParams }),
	requestPromote: ({
		pathParams: { projectId, deploymentId },
		queryParams,
	}: {
		pathParams: RequestPromotePathParams;
		queryParams?: RequestPromoteQueryParams;
	}) => requestPromote({ pathParams: { projectId, deploymentId }, queryParams }),
	listPromoteAliases: ({
		pathParams: { projectId },
		queryParams,
	}: {
		pathParams: ListPromoteAliasesPathParams;
		queryParams?: ListPromoteAliasesQueryParams;
	}) => listPromoteAliases({ pathParams: { projectId }, queryParams }),
	pauseProject: ({
		pathParams: { projectId },
		queryParams,
	}: {
		pathParams: PauseProjectPathParams;
		queryParams?: PauseProjectQueryParams;
	}) => pauseProject({ pathParams: { projectId }, queryParams }),
	unpauseProject: ({
		pathParams: { projectId },
		queryParams,
	}: {
		pathParams: UnpauseProjectPathParams;
		queryParams?: UnpauseProjectQueryParams;
	}) => unpauseProject({ pathParams: { projectId }, queryParams }),
} as const;

export const DeploymentsService = {
	getDeploymentEvents: ({
		pathParams: { idOrUrl },
		queryParams,
	}: {
		pathParams: GetDeploymentEventsPathParams;
		queryParams?: GetDeploymentEventsQueryParams;
	}) => getDeploymentEvents({ pathParams: { idOrUrl }, queryParams }),
	updateIntegrationDeploymentAction: ({
		pathParams: { deploymentId, integrationConfigurationId, resourceId, action },
	}: {
		pathParams: UpdateIntegrationDeploymentActionPathParams;
	}) =>
		updateIntegrationDeploymentAction({
			pathParams: { deploymentId, integrationConfigurationId, resourceId, action },
		}),
	getDeployment: ({
		pathParams: { idOrUrl },
		queryParams,
	}: {
		pathParams: GetDeploymentPathParams;
		queryParams?: GetDeploymentQueryParams;
	}) => getDeployment({ pathParams: { idOrUrl }, queryParams }),
	createDeployment: ({ queryParams }: { queryParams?: CreateDeploymentQueryParams }) =>
		createDeployment({ queryParams }),
	cancelDeployment: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: CancelDeploymentPathParams;
		queryParams?: CancelDeploymentQueryParams;
	}) => cancelDeployment({ pathParams: { id }, queryParams }),
	uploadFile: ({
		queryParams,
		headers,
	}: {
		queryParams?: UploadFileQueryParams;
		headers?: UploadFileHeaderParams;
	}) => uploadFile({ queryParams, headers }),
	listDeploymentFiles: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: ListDeploymentFilesPathParams;
		queryParams?: ListDeploymentFilesQueryParams;
	}) => listDeploymentFiles({ pathParams: { id }, queryParams }),
	getDeploymentFileContents: ({
		pathParams: { id, fileId },
		queryParams,
	}: {
		pathParams: GetDeploymentFileContentsPathParams;
		queryParams?: GetDeploymentFileContentsQueryParams;
	}) => getDeploymentFileContents({ pathParams: { id, fileId }, queryParams }),
	getDeployments: ({ queryParams }: { queryParams?: GetDeploymentsQueryParams }) =>
		getDeployments({ queryParams }),
	deleteDeployment: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: DeleteDeploymentPathParams;
		queryParams?: DeleteDeploymentQueryParams;
	}) => deleteDeployment({ pathParams: { id }, queryParams }),
} as const;

export const DnsService = {
	getRecords: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: GetRecordsPathParams;
		queryParams?: GetRecordsQueryParams;
	}) => getRecords({ pathParams: { domain }, queryParams }),
	createRecord: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: CreateRecordPathParams;
		queryParams?: CreateRecordQueryParams;
	}) => createRecord({ pathParams: { domain }, queryParams }),
	updateRecord: ({
		pathParams: { recordId },
		queryParams,
	}: {
		pathParams: UpdateRecordPathParams;
		queryParams?: UpdateRecordQueryParams;
	}) => updateRecord({ pathParams: { recordId }, queryParams }),
	removeRecord: ({
		pathParams: { domain, recordId },
		queryParams,
	}: {
		pathParams: RemoveRecordPathParams;
		queryParams?: RemoveRecordQueryParams;
	}) => removeRecord({ pathParams: { domain, recordId }, queryParams }),
} as const;

export const DomainsRegistrarService = {
	getSupportedTlds: ({ queryParams }: { queryParams?: GetSupportedTldsQueryParams }) =>
		getSupportedTlds({ queryParams }),
	getTldPrice: ({
		pathParams: { tld },
		queryParams,
	}: {
		pathParams: GetTldPricePathParams;
		queryParams?: GetTldPriceQueryParams;
	}) => getTldPrice({ pathParams: { tld }, queryParams }),
	getDomainAvailability: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: GetDomainAvailabilityPathParams;
		queryParams?: GetDomainAvailabilityQueryParams;
	}) => getDomainAvailability({ pathParams: { domain }, queryParams }),
	getDomainPrice: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: GetDomainPricePathParams;
		queryParams?: GetDomainPriceQueryParams;
	}) => getDomainPrice({ pathParams: { domain }, queryParams }),
	getBulkAvailability: ({ queryParams }: { queryParams?: GetBulkAvailabilityQueryParams }) =>
		getBulkAvailability({ queryParams }),
	getDomainAuthCode: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: GetDomainAuthCodePathParams;
		queryParams?: GetDomainAuthCodeQueryParams;
	}) => getDomainAuthCode({ pathParams: { domain }, queryParams }),
	buySingleDomain: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: BuySingleDomainPathParams;
		queryParams?: BuySingleDomainQueryParams;
	}) => buySingleDomain({ pathParams: { domain }, queryParams }),
	buyDomains: ({ queryParams }: { queryParams?: BuyDomainsQueryParams }) =>
		buyDomains({ queryParams }),
	transferInDomain: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: TransferInDomainPathParams;
		queryParams?: TransferInDomainQueryParams;
	}) => transferInDomain({ pathParams: { domain }, queryParams }),
	getDomainTransferIn: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: GetDomainTransferInPathParams;
		queryParams?: GetDomainTransferInQueryParams;
	}) => getDomainTransferIn({ pathParams: { domain }, queryParams }),
	renewDomain: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: RenewDomainPathParams;
		queryParams?: RenewDomainQueryParams;
	}) => renewDomain({ pathParams: { domain }, queryParams }),
	updateDomainAutoRenew: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: UpdateDomainAutoRenewPathParams;
		queryParams?: UpdateDomainAutoRenewQueryParams;
	}) => updateDomainAutoRenew({ pathParams: { domain }, queryParams }),
	updateDomainNameservers: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: UpdateDomainNameserversPathParams;
		queryParams?: UpdateDomainNameserversQueryParams;
	}) => updateDomainNameservers({ pathParams: { domain }, queryParams }),
	getContactInfoSchema: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: GetContactInfoSchemaPathParams;
		queryParams?: GetContactInfoSchemaQueryParams;
	}) => getContactInfoSchema({ pathParams: { domain }, queryParams }),
	getOrder: ({
		pathParams: { orderId },
		queryParams,
	}: {
		pathParams: GetOrderPathParams;
		queryParams?: GetOrderQueryParams;
	}) => getOrder({ pathParams: { orderId }, queryParams }),
} as const;

export const DomainsService = {
	getDomainConfig: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: GetDomainConfigPathParams;
		queryParams?: GetDomainConfigQueryParams;
	}) => getDomainConfig({ pathParams: { domain }, queryParams }),
	getDomain: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: GetDomainPathParams;
		queryParams?: GetDomainQueryParams;
	}) => getDomain({ pathParams: { domain }, queryParams }),
	getDomains: ({ queryParams }: { queryParams?: GetDomainsQueryParams }) =>
		getDomains({ queryParams }),
	createOrTransferDomain: ({ queryParams }: { queryParams?: CreateOrTransferDomainQueryParams }) =>
		createOrTransferDomain({ queryParams }),
	patchDomain: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: PatchDomainPathParams;
		queryParams?: PatchDomainQueryParams;
	}) => patchDomain({ pathParams: { domain }, queryParams }),
	deleteDomain: ({
		pathParams: { domain },
		queryParams,
	}: {
		pathParams: DeleteDomainPathParams;
		queryParams?: DeleteDomainQueryParams;
	}) => deleteDomain({ pathParams: { domain }, queryParams }),
} as const;

export const LogDrainsService = {
	getConfigurableLogDrain: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: GetConfigurableLogDrainPathParams;
		queryParams?: GetConfigurableLogDrainQueryParams;
	}) => getConfigurableLogDrain({ pathParams: { id }, queryParams }),
	deleteConfigurableLogDrain: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: DeleteConfigurableLogDrainPathParams;
		queryParams?: DeleteConfigurableLogDrainQueryParams;
	}) => deleteConfigurableLogDrain({ pathParams: { id }, queryParams }),
	getAllLogDrains: ({ queryParams }: { queryParams?: GetAllLogDrainsQueryParams }) =>
		getAllLogDrains({ queryParams }),
	createConfigurableLogDrain: ({
		queryParams,
	}: {
		queryParams?: CreateConfigurableLogDrainQueryParams;
	}) => createConfigurableLogDrain({ queryParams }),
	getIntegrationLogDrains: ({
		queryParams,
	}: {
		queryParams?: GetIntegrationLogDrainsQueryParams;
	}) => getIntegrationLogDrains({ queryParams }),
	createLogDrain: ({ queryParams }: { queryParams?: CreateLogDrainQueryParams }) =>
		createLogDrain({ queryParams }),
	deleteIntegrationLogDrain: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: DeleteIntegrationLogDrainPathParams;
		queryParams?: DeleteIntegrationLogDrainQueryParams;
	}) => deleteIntegrationLogDrain({ pathParams: { id }, queryParams }),
} as const;

export const DrainsService = {
	createDrain: ({ queryParams }: { queryParams?: CreateDrainQueryParams }) =>
		createDrain({ queryParams }),
	getDrains: ({ queryParams }: { queryParams?: GetDrainsQueryParams }) =>
		getDrains({ queryParams }),
	deleteDrain: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: DeleteDrainPathParams;
		queryParams?: DeleteDrainQueryParams;
	}) => deleteDrain({ pathParams: { id }, queryParams }),
	getDrain: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: GetDrainPathParams;
		queryParams?: GetDrainQueryParams;
	}) => getDrain({ pathParams: { id }, queryParams }),
	updateDrain: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: UpdateDrainPathParams;
		queryParams?: UpdateDrainQueryParams;
	}) => updateDrain({ pathParams: { id }, queryParams }),
	testDrain: ({ queryParams }: { queryParams?: TestDrainQueryParams }) =>
		testDrain({ queryParams }),
} as const;

export const EdgeCacheService = {
	invalidateByTags: ({ queryParams }: { queryParams: InvalidateByTagsQueryParams }) =>
		invalidateByTags({ queryParams }),
	dangerouslyDeleteByTags: ({ queryParams }: { queryParams: DangerouslyDeleteByTagsQueryParams }) =>
		dangerouslyDeleteByTags({ queryParams }),
	invalidateBySrcImages: ({ queryParams }: { queryParams: InvalidateBySrcImagesQueryParams }) =>
		invalidateBySrcImages({ queryParams }),
	dangerouslyDeleteBySrcImages: ({
		queryParams,
	}: {
		queryParams: DangerouslyDeleteBySrcImagesQueryParams;
	}) => dangerouslyDeleteBySrcImages({ queryParams }),
} as const;

export const EdgeConfigService = {
	getEdgeConfigs: ({ queryParams }: { queryParams?: GetEdgeConfigsQueryParams }) =>
		getEdgeConfigs({ queryParams }),
	createEdgeConfig: ({ queryParams }: { queryParams?: CreateEdgeConfigQueryParams }) =>
		createEdgeConfig({ queryParams }),
	getEdgeConfig: ({
		pathParams: { edgeConfigId },
		queryParams,
	}: {
		pathParams: GetEdgeConfigPathParams;
		queryParams?: GetEdgeConfigQueryParams;
	}) => getEdgeConfig({ pathParams: { edgeConfigId }, queryParams }),
	updateEdgeConfig: ({
		pathParams: { edgeConfigId },
		queryParams,
	}: {
		pathParams: UpdateEdgeConfigPathParams;
		queryParams?: UpdateEdgeConfigQueryParams;
	}) => updateEdgeConfig({ pathParams: { edgeConfigId }, queryParams }),
	deleteEdgeConfig: ({
		pathParams: { edgeConfigId },
		queryParams,
	}: {
		pathParams: DeleteEdgeConfigPathParams;
		queryParams?: DeleteEdgeConfigQueryParams;
	}) => deleteEdgeConfig({ pathParams: { edgeConfigId }, queryParams }),
	getEdgeConfigItems: ({
		pathParams: { edgeConfigId },
		queryParams,
	}: {
		pathParams: GetEdgeConfigItemsPathParams;
		queryParams?: GetEdgeConfigItemsQueryParams;
	}) => getEdgeConfigItems({ pathParams: { edgeConfigId }, queryParams }),
	patchEdgeConfigItems: ({
		pathParams: { edgeConfigId },
		queryParams,
	}: {
		pathParams: PatchEdgeConfigItemsPathParams;
		queryParams?: PatchEdgeConfigItemsQueryParams;
	}) => patchEdgeConfigItems({ pathParams: { edgeConfigId }, queryParams }),
	getEdgeConfigSchema: ({
		pathParams: { edgeConfigId },
		queryParams,
	}: {
		pathParams: GetEdgeConfigSchemaPathParams;
		queryParams?: GetEdgeConfigSchemaQueryParams;
	}) => getEdgeConfigSchema({ pathParams: { edgeConfigId }, queryParams }),
	patchEdgeConfigSchema: ({
		pathParams: { edgeConfigId },
		queryParams,
	}: {
		pathParams: PatchEdgeConfigSchemaPathParams;
		queryParams?: PatchEdgeConfigSchemaQueryParams;
	}) => patchEdgeConfigSchema({ pathParams: { edgeConfigId }, queryParams }),
	deleteEdgeConfigSchema: ({
		pathParams: { edgeConfigId },
		queryParams,
	}: {
		pathParams: DeleteEdgeConfigSchemaPathParams;
		queryParams?: DeleteEdgeConfigSchemaQueryParams;
	}) => deleteEdgeConfigSchema({ pathParams: { edgeConfigId }, queryParams }),
	getEdgeConfigItem: ({
		pathParams: { edgeConfigId, edgeConfigItemKey },
		queryParams,
	}: {
		pathParams: GetEdgeConfigItemPathParams;
		queryParams?: GetEdgeConfigItemQueryParams;
	}) => getEdgeConfigItem({ pathParams: { edgeConfigId, edgeConfigItemKey }, queryParams }),
	getEdgeConfigTokens: ({
		pathParams: { edgeConfigId },
		queryParams,
	}: {
		pathParams: GetEdgeConfigTokensPathParams;
		queryParams?: GetEdgeConfigTokensQueryParams;
	}) => getEdgeConfigTokens({ pathParams: { edgeConfigId }, queryParams }),
	deleteEdgeConfigTokens: ({
		pathParams: { edgeConfigId },
		queryParams,
	}: {
		pathParams: DeleteEdgeConfigTokensPathParams;
		queryParams?: DeleteEdgeConfigTokensQueryParams;
	}) => deleteEdgeConfigTokens({ pathParams: { edgeConfigId }, queryParams }),
	getEdgeConfigToken: ({
		pathParams: { edgeConfigId, token },
		queryParams,
	}: {
		pathParams: GetEdgeConfigTokenPathParams;
		queryParams?: GetEdgeConfigTokenQueryParams;
	}) => getEdgeConfigToken({ pathParams: { edgeConfigId, token }, queryParams }),
	createEdgeConfigToken: ({
		pathParams: { edgeConfigId },
		queryParams,
	}: {
		pathParams: CreateEdgeConfigTokenPathParams;
		queryParams?: CreateEdgeConfigTokenQueryParams;
	}) => createEdgeConfigToken({ pathParams: { edgeConfigId }, queryParams }),
	getEdgeConfigBackup: ({
		pathParams: { edgeConfigId, edgeConfigBackupVersionId },
		queryParams,
	}: {
		pathParams: GetEdgeConfigBackupPathParams;
		queryParams?: GetEdgeConfigBackupQueryParams;
	}) =>
		getEdgeConfigBackup({ pathParams: { edgeConfigId, edgeConfigBackupVersionId }, queryParams }),
	getEdgeConfigBackups: ({
		pathParams: { edgeConfigId },
		queryParams,
	}: {
		pathParams: GetEdgeConfigBackupsPathParams;
		queryParams?: GetEdgeConfigBackupsQueryParams;
	}) => getEdgeConfigBackups({ pathParams: { edgeConfigId }, queryParams }),
} as const;

export const EnvironmentService = {
	createSharedEnvVariable: ({
		queryParams,
	}: {
		queryParams?: CreateSharedEnvVariableQueryParams;
	}) => createSharedEnvVariable({ queryParams }),
	listSharedEnvVariable: ({ queryParams }: { queryParams?: ListSharedEnvVariableQueryParams }) =>
		listSharedEnvVariable({ queryParams }),
	updateSharedEnvVariable: ({
		queryParams,
	}: {
		queryParams?: UpdateSharedEnvVariableQueryParams;
	}) => updateSharedEnvVariable({ queryParams }),
	deleteSharedEnvVariable: ({
		queryParams,
	}: {
		queryParams?: DeleteSharedEnvVariableQueryParams;
	}) => deleteSharedEnvVariable({ queryParams }),
	getSharedEnvVar: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: GetSharedEnvVarPathParams;
		queryParams?: GetSharedEnvVarQueryParams;
	}) => getSharedEnvVar({ pathParams: { id }, queryParams }),
	unlinkSharedEnvVariable: ({
		pathParams: { id, projectId },
		queryParams,
	}: {
		pathParams: UnlinkSharedEnvVariablePathParams;
		queryParams?: UnlinkSharedEnvVariableQueryParams;
	}) => unlinkSharedEnvVariable({ pathParams: { id, projectId }, queryParams }),
	createCustomEnvironment: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: CreateCustomEnvironmentPathParams;
		queryParams?: CreateCustomEnvironmentQueryParams;
	}) => createCustomEnvironment({ pathParams: { idOrName }, queryParams }),
	listCustomEnvironments: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: ListCustomEnvironmentsPathParams;
		queryParams?: ListCustomEnvironmentsQueryParams;
	}) => listCustomEnvironments({ pathParams: { idOrName }, queryParams }),
	getCustomEnvironment: ({
		pathParams: { idOrName, environmentSlugOrId },
		queryParams,
	}: {
		pathParams: GetCustomEnvironmentPathParams;
		queryParams?: GetCustomEnvironmentQueryParams;
	}) => getCustomEnvironment({ pathParams: { idOrName, environmentSlugOrId }, queryParams }),
	updateCustomEnvironment: ({
		pathParams: { idOrName, environmentSlugOrId },
		queryParams,
	}: {
		pathParams: UpdateCustomEnvironmentPathParams;
		queryParams?: UpdateCustomEnvironmentQueryParams;
	}) => updateCustomEnvironment({ pathParams: { idOrName, environmentSlugOrId }, queryParams }),
	removeCustomEnvironment: ({
		pathParams: { idOrName, environmentSlugOrId },
		queryParams,
	}: {
		pathParams: RemoveCustomEnvironmentPathParams;
		queryParams?: RemoveCustomEnvironmentQueryParams;
	}) => removeCustomEnvironment({ pathParams: { idOrName, environmentSlugOrId }, queryParams }),
} as const;

export const UserService = {
	listUserEvents: ({ queryParams }: { queryParams?: ListUserEventsQueryParams }) =>
		listUserEvents({ queryParams }),
	getAuthUser: () => getAuthUser(),
	requestDelete: () => requestDelete(),
} as const;

export const IntegrationsService = {
	gitNamespaces: ({ queryParams }: { queryParams?: GitNamespacesQueryParams }) =>
		gitNamespaces({ queryParams }),
	searchRepo: ({ queryParams }: { queryParams?: SearchRepoQueryParams }) =>
		searchRepo({ queryParams }),
	getBillingPlans: ({
		pathParams: { integrationIdOrSlug, productIdOrSlug },
		queryParams,
	}: {
		pathParams: GetBillingPlansPathParams;
		queryParams?: GetBillingPlansQueryParams;
	}) => getBillingPlans({ pathParams: { integrationIdOrSlug, productIdOrSlug }, queryParams }),
	connectIntegrationResourceToProject: ({
		pathParams: { integrationConfigurationId, resourceId },
		queryParams,
	}: {
		pathParams: ConnectIntegrationResourceToProjectPathParams;
		queryParams?: ConnectIntegrationResourceToProjectQueryParams;
	}) =>
		connectIntegrationResourceToProject({
			pathParams: { integrationConfigurationId, resourceId },
			queryParams,
		}),
	getConfigurations: ({ queryParams }: { queryParams: GetConfigurationsQueryParams }) =>
		getConfigurations({ queryParams }),
	getConfiguration: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: GetConfigurationPathParams;
		queryParams?: GetConfigurationQueryParams;
	}) => getConfiguration({ pathParams: { id }, queryParams }),
	deleteConfiguration: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: DeleteConfigurationPathParams;
		queryParams?: DeleteConfigurationQueryParams;
	}) => deleteConfiguration({ pathParams: { id }, queryParams }),
	getConfigurationProducts: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: GetConfigurationProductsPathParams;
		queryParams?: GetConfigurationProductsQueryParams;
	}) => getConfigurationProducts({ pathParams: { id }, queryParams }),
	createIntegrationStoreDirect: ({
		queryParams,
	}: {
		queryParams?: CreateIntegrationStoreDirectQueryParams;
	}) => createIntegrationStoreDirect({ queryParams }),
} as const;

export const MarketplaceService = {
	updateInstallation: ({
		pathParams: { integrationConfigurationId },
	}: {
		pathParams: UpdateInstallationPathParams;
	}) => updateInstallation({ pathParams: { integrationConfigurationId } }),
	getAccountInfo: ({
		pathParams: { integrationConfigurationId },
	}: {
		pathParams: GetAccountInfoPathParams;
	}) => getAccountInfo({ pathParams: { integrationConfigurationId } }),
	getMember: ({
		pathParams: { integrationConfigurationId, memberId },
	}: {
		pathParams: GetMemberPathParams;
	}) => getMember({ pathParams: { integrationConfigurationId, memberId } }),
	createEvent: ({
		pathParams: { integrationConfigurationId },
	}: {
		pathParams: CreateEventPathParams;
	}) => createEvent({ pathParams: { integrationConfigurationId } }),
	getIntegrationResources: ({
		pathParams: { integrationConfigurationId },
	}: {
		pathParams: GetIntegrationResourcesPathParams;
	}) => getIntegrationResources({ pathParams: { integrationConfigurationId } }),
	getIntegrationResource: ({
		pathParams: { integrationConfigurationId, resourceId },
	}: {
		pathParams: GetIntegrationResourcePathParams;
	}) => getIntegrationResource({ pathParams: { integrationConfigurationId, resourceId } }),
	deleteIntegrationResource: ({
		pathParams: { integrationConfigurationId, resourceId },
	}: {
		pathParams: DeleteIntegrationResourcePathParams;
	}) => deleteIntegrationResource({ pathParams: { integrationConfigurationId, resourceId } }),
	importResource: ({
		pathParams: { integrationConfigurationId, resourceId },
	}: {
		pathParams: ImportResourcePathParams;
	}) => importResource({ pathParams: { integrationConfigurationId, resourceId } }),
	updateResource: ({
		pathParams: { integrationConfigurationId, resourceId },
	}: {
		pathParams: UpdateResourcePathParams;
	}) => updateResource({ pathParams: { integrationConfigurationId, resourceId } }),
	submitBillingData: ({
		pathParams: { integrationConfigurationId },
	}: {
		pathParams: SubmitBillingDataPathParams;
	}) => submitBillingData({ pathParams: { integrationConfigurationId } }),
	submitInvoice: ({
		pathParams: { integrationConfigurationId },
	}: {
		pathParams: SubmitInvoicePathParams;
	}) => submitInvoice({ pathParams: { integrationConfigurationId } }),
	getInvoice: ({
		pathParams: { integrationConfigurationId, invoiceId },
	}: {
		pathParams: GetInvoicePathParams;
	}) => getInvoice({ pathParams: { integrationConfigurationId, invoiceId } }),
	updateInvoice: ({
		pathParams: { integrationConfigurationId, invoiceId },
	}: {
		pathParams: UpdateInvoicePathParams;
	}) => updateInvoice({ pathParams: { integrationConfigurationId, invoiceId } }),
	submitPrepaymentBalances: ({
		pathParams: { integrationConfigurationId },
	}: {
		pathParams: SubmitPrepaymentBalancesPathParams;
	}) => submitPrepaymentBalances({ pathParams: { integrationConfigurationId } }),
	updateResourceSecrets: ({
		pathParams: { integrationConfigurationId, integrationProductIdOrSlug, resourceId },
	}: {
		pathParams: UpdateResourceSecretsPathParams;
	}) =>
		updateResourceSecrets({
			pathParams: { integrationConfigurationId, integrationProductIdOrSlug, resourceId },
		}),
	updateResourceSecretsById: ({
		pathParams: { integrationConfigurationId, resourceId },
	}: {
		pathParams: UpdateResourceSecretsByIdPathParams;
	}) => updateResourceSecretsById({ pathParams: { integrationConfigurationId, resourceId } }),
	createExperimentationItem: ({
		pathParams: { integrationConfigurationId, resourceId },
	}: {
		pathParams: CreateExperimentationItemPathParams;
	}) => createExperimentationItem({ pathParams: { integrationConfigurationId, resourceId } }),
	updateExperimentationItem: ({
		pathParams: { integrationConfigurationId, resourceId, itemId },
	}: {
		pathParams: UpdateExperimentationItemPathParams;
	}) =>
		updateExperimentationItem({ pathParams: { integrationConfigurationId, resourceId, itemId } }),
	deleteExperimentationItem: ({
		pathParams: { integrationConfigurationId, resourceId, itemId },
	}: {
		pathParams: DeleteExperimentationItemPathParams;
	}) =>
		deleteExperimentationItem({ pathParams: { integrationConfigurationId, resourceId, itemId } }),
	updateExperimentationEdgeConfig: ({
		pathParams: { integrationConfigurationId, resourceId },
	}: {
		pathParams: UpdateExperimentationEdgeConfigPathParams;
	}) => updateExperimentationEdgeConfig({ pathParams: { integrationConfigurationId, resourceId } }),
} as const;

export const AuthenticationService = {
	exchangeSsoToken: () => exchangeSsoToken(),
	listAuthTokens: () => listAuthTokens(),
	createAuthToken: ({ queryParams }: { queryParams?: CreateAuthTokenQueryParams }) =>
		createAuthToken({ queryParams }),
	getAuthToken: ({ pathParams: { tokenId } }: { pathParams: GetAuthTokenPathParams }) =>
		getAuthToken({ pathParams: { tokenId } }),
	deleteAuthToken: ({ pathParams: { tokenId } }: { pathParams: DeleteAuthTokenPathParams }) =>
		deleteAuthToken({ pathParams: { tokenId } }),
} as const;

export const LogsService = {
	getRuntimeLogs: ({
		pathParams: { projectId, deploymentId },
		queryParams,
	}: {
		pathParams: GetRuntimeLogsPathParams;
		queryParams?: GetRuntimeLogsQueryParams;
	}) => getRuntimeLogs({ pathParams: { projectId, deploymentId }, queryParams }),
} as const;

export const ProjectMembersService = {
	getProjectMembers: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: GetProjectMembersPathParams;
		queryParams?: GetProjectMembersQueryParams;
	}) => getProjectMembers({ pathParams: { idOrName }, queryParams }),
	addProjectMember: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: AddProjectMemberPathParams;
		queryParams?: AddProjectMemberQueryParams;
	}) => addProjectMember({ pathParams: { idOrName }, queryParams }),
	removeProjectMember: ({
		pathParams: { idOrName, uid },
		queryParams,
	}: {
		pathParams: RemoveProjectMemberPathParams;
		queryParams?: RemoveProjectMemberQueryParams;
	}) => removeProjectMember({ pathParams: { idOrName, uid }, queryParams }),
} as const;

export const RollingReleaseService = {
	getRollingReleaseBillingStatus: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: GetRollingReleaseBillingStatusPathParams;
		queryParams?: GetRollingReleaseBillingStatusQueryParams;
	}) => getRollingReleaseBillingStatus({ pathParams: { idOrName }, queryParams }),
	getRollingReleaseConfig: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: GetRollingReleaseConfigPathParams;
		queryParams?: GetRollingReleaseConfigQueryParams;
	}) => getRollingReleaseConfig({ pathParams: { idOrName }, queryParams }),
	deleteRollingReleaseConfig: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: DeleteRollingReleaseConfigPathParams;
		queryParams?: DeleteRollingReleaseConfigQueryParams;
	}) => deleteRollingReleaseConfig({ pathParams: { idOrName }, queryParams }),
	updateRollingReleaseConfig: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: UpdateRollingReleaseConfigPathParams;
		queryParams?: UpdateRollingReleaseConfigQueryParams;
	}) => updateRollingReleaseConfig({ pathParams: { idOrName }, queryParams }),
	getRollingRelease: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: GetRollingReleasePathParams;
		queryParams?: GetRollingReleaseQueryParams;
	}) => getRollingRelease({ pathParams: { idOrName }, queryParams }),
	approveRollingReleaseStage: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: ApproveRollingReleaseStagePathParams;
		queryParams?: ApproveRollingReleaseStageQueryParams;
	}) => approveRollingReleaseStage({ pathParams: { idOrName }, queryParams }),
	completeRollingRelease: ({
		pathParams: { idOrName },
		queryParams,
	}: {
		pathParams: CompleteRollingReleasePathParams;
		queryParams?: CompleteRollingReleaseQueryParams;
	}) => completeRollingRelease({ pathParams: { idOrName }, queryParams }),
} as const;

export const SecurityService = {
	updateAttackChallengeMode: ({
		queryParams,
	}: {
		queryParams?: UpdateAttackChallengeModeQueryParams;
	}) => updateAttackChallengeMode({ queryParams }),
	putFirewallConfig: ({ queryParams }: { queryParams: PutFirewallConfigQueryParams }) =>
		putFirewallConfig({ queryParams }),
	updateFirewallConfig: ({ queryParams }: { queryParams: UpdateFirewallConfigQueryParams }) =>
		updateFirewallConfig({ queryParams }),
	getFirewallConfig: ({
		pathParams: { configVersion },
		queryParams,
	}: {
		pathParams: GetFirewallConfigPathParams;
		queryParams: GetFirewallConfigQueryParams;
	}) => getFirewallConfig({ pathParams: { configVersion }, queryParams }),
	getActiveAttackStatus: ({ queryParams }: { queryParams: GetActiveAttackStatusQueryParams }) =>
		getActiveAttackStatus({ queryParams }),
	getBypassIp: ({ queryParams }: { queryParams: GetBypassIpQueryParams }) =>
		getBypassIp({ queryParams }),
	addBypassIp: ({ queryParams }: { queryParams: AddBypassIpQueryParams }) =>
		addBypassIp({ queryParams }),
	removeBypassIp: ({ queryParams }: { queryParams: RemoveBypassIpQueryParams }) =>
		removeBypassIp({ queryParams }),
	gETV1SecurityFirewallEvents: ({
		queryParams,
	}: {
		queryParams: GETV1SecurityFirewallEventsQueryParams;
	}) => gETV1SecurityFirewallEvents({ queryParams }),
} as const;

export const TeamsService = {
	getTeamMembers: ({
		pathParams: { teamId },
		queryParams,
	}: {
		pathParams: GetTeamMembersPathParams;
		queryParams?: GetTeamMembersQueryParams;
	}) => getTeamMembers({ pathParams: { teamId }, queryParams }),
	inviteUserToTeam: ({ pathParams: { teamId } }: { pathParams: InviteUserToTeamPathParams }) =>
		inviteUserToTeam({ pathParams: { teamId } }),
	requestAccessToTeam: ({
		pathParams: { teamId },
	}: {
		pathParams: RequestAccessToTeamPathParams;
	}) => requestAccessToTeam({ pathParams: { teamId } }),
	getTeamAccessRequest: ({
		pathParams: { userId, teamId },
	}: {
		pathParams: GetTeamAccessRequestPathParams;
	}) => getTeamAccessRequest({ pathParams: { userId, teamId } }),
	joinTeam: ({ pathParams: { teamId } }: { pathParams: JoinTeamPathParams }) =>
		joinTeam({ pathParams: { teamId } }),
	updateTeamMember: ({ pathParams: { uid, teamId } }: { pathParams: UpdateTeamMemberPathParams }) =>
		updateTeamMember({ pathParams: { uid, teamId } }),
	removeTeamMember: ({
		pathParams: { uid, teamId },
		queryParams,
	}: {
		pathParams: RemoveTeamMemberPathParams;
		queryParams?: RemoveTeamMemberQueryParams;
	}) => removeTeamMember({ pathParams: { uid, teamId }, queryParams }),
	getTeam: ({
		pathParams: { teamId },
		queryParams,
	}: {
		pathParams: GetTeamPathParams;
		queryParams?: GetTeamQueryParams;
	}) => getTeam({ pathParams: { teamId }, queryParams }),
	patchTeam: ({
		pathParams: { teamId },
		queryParams,
	}: {
		pathParams: PatchTeamPathParams;
		queryParams?: PatchTeamQueryParams;
	}) => patchTeam({ pathParams: { teamId }, queryParams }),
	getTeams: ({ queryParams }: { queryParams?: GetTeamsQueryParams }) => getTeams({ queryParams }),
	createTeam: () => createTeam(),
	postTeamDsyncRoles: ({
		pathParams: { teamId },
		queryParams,
	}: {
		pathParams: PostTeamDsyncRolesPathParams;
		queryParams?: PostTeamDsyncRolesQueryParams;
	}) => postTeamDsyncRoles({ pathParams: { teamId }, queryParams }),
	deleteTeam: ({
		pathParams: { teamId },
		queryParams,
	}: {
		pathParams: DeleteTeamPathParams;
		queryParams?: DeleteTeamQueryParams;
	}) => deleteTeam({ pathParams: { teamId }, queryParams }),
	deleteTeamInviteCode: ({
		pathParams: { inviteId, teamId },
	}: {
		pathParams: DeleteTeamInviteCodePathParams;
	}) => deleteTeamInviteCode({ pathParams: { inviteId, teamId } }),
} as const;

export const WebhooksService = {
	createWebhook: ({ queryParams }: { queryParams?: CreateWebhookQueryParams }) =>
		createWebhook({ queryParams }),
	getWebhooks: ({ queryParams }: { queryParams?: GetWebhooksQueryParams }) =>
		getWebhooks({ queryParams }),
	getWebhook: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: GetWebhookPathParams;
		queryParams?: GetWebhookQueryParams;
	}) => getWebhook({ pathParams: { id }, queryParams }),
	deleteWebhook: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: DeleteWebhookPathParams;
		queryParams?: DeleteWebhookQueryParams;
	}) => deleteWebhook({ pathParams: { id }, queryParams }),
} as const;

export const AliasesService = {
	listDeploymentAliases: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: ListDeploymentAliasesPathParams;
		queryParams?: ListDeploymentAliasesQueryParams;
	}) => listDeploymentAliases({ pathParams: { id }, queryParams }),
	assignAlias: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: AssignAliasPathParams;
		queryParams?: AssignAliasQueryParams;
	}) => assignAlias({ pathParams: { id }, queryParams }),
	listAliases: ({ queryParams }: { queryParams?: ListAliasesQueryParams }) =>
		listAliases({ queryParams }),
	getAlias: ({
		pathParams: { idOrAlias },
		queryParams,
	}: {
		pathParams: GetAliasPathParams;
		queryParams?: GetAliasQueryParams;
	}) => getAlias({ pathParams: { idOrAlias }, queryParams }),
	deleteAlias: ({
		pathParams: { aliasId },
		queryParams,
	}: {
		pathParams: DeleteAliasPathParams;
		queryParams?: DeleteAliasQueryParams;
	}) => deleteAlias({ pathParams: { aliasId }, queryParams }),
	patchUrlProtectionBypass: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: PatchUrlProtectionBypassPathParams;
		queryParams?: PatchUrlProtectionBypassQueryParams;
	}) => patchUrlProtectionBypass({ pathParams: { id }, queryParams }),
} as const;

export const CertsService = {
	getCertById: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: GetCertByIdPathParams;
		queryParams?: GetCertByIdQueryParams;
	}) => getCertById({ pathParams: { id }, queryParams }),
	removeCert: ({
		pathParams: { id },
		queryParams,
	}: {
		pathParams: RemoveCertPathParams;
		queryParams?: RemoveCertQueryParams;
	}) => removeCert({ pathParams: { id }, queryParams }),
	issueCert: ({ queryParams }: { queryParams?: IssueCertQueryParams }) =>
		issueCert({ queryParams }),
	uploadCert: ({ queryParams }: { queryParams?: UploadCertQueryParams }) =>
		uploadCert({ queryParams }),
} as const;

// ============================================================================
// Unified API Service
// ============================================================================

/**
 * Unified API service providing access to all operations organized by tag.
 * Use this for a structured, namespace-based access pattern.
 *
 * @example
 * ```ts
 * import { ApiService, makeApiClientLive } from "your-package/effect";
 * import { Effect } from "effect";
 *
 * const program = Effect.gen(function* () {
 *   const projects = yield* ApiService.projects.listProjects();
 *   return projects;
 * });
 *
 * const result = await program.pipe(
 *   Effect.provide(makeApiClientLive({ baseUrl: "https://api.example.com", token: "your-token" })),
 *   Effect.runPromise
 * );
 * ```
 */
export const ApiService = {
	accessGroups: AccessGroupsService,
	artifacts: ArtifactsService,
	bulkRedirects: BulkRedirectsService,
	checks: ChecksService,
	connect: ConnectService,
	projects: ProjectsService,
	deployments: DeploymentsService,
	dns: DnsService,
	domainsRegistrar: DomainsRegistrarService,
	domains: DomainsService,
	logDrains: LogDrainsService,
	drains: DrainsService,
	edgeCache: EdgeCacheService,
	edgeConfig: EdgeConfigService,
	environment: EnvironmentService,
	user: UserService,
	integrations: IntegrationsService,
	marketplace: MarketplaceService,
	authentication: AuthenticationService,
	logs: LogsService,
	projectMembers: ProjectMembersService,
	rollingRelease: RollingReleaseService,
	security: SecurityService,
	teams: TeamsService,
	webhooks: WebhooksService,
	aliases: AliasesService,
	certs: CertsService,
} as const;

// ============================================================================
// Path-based Operations Map
// ============================================================================

/**
 * Operations indexed by "METHOD /path" for direct endpoint access.
 *
 * @example
 * ```ts
 * import { operationsByPath, makeApiClientLive } from "your-package/effect";
 * import { Effect } from "effect";
 *
 * const program = Effect.gen(function* () {
 *   const result = yield* operationsByPath["GET /v4/projects"]();
 *   return result;
 * });
 *
 * const result = await program.pipe(
 *   Effect.provide(makeApiClientLive({ baseUrl: "https://api.example.com", token: "your-token" })),
 *   Effect.runPromise
 * );
 * ```
 */
export type OperationsByPath = {
	"DELETE /v1/access-groups/{accessGroupIdOrName}/projects/{projectId}": typeof deleteAccessGroupProject;
	"DELETE /v1/access-groups/{idOrName}": typeof deleteAccessGroup;
	"DELETE /v1/bulk-redirects": typeof deleteRedirects;
	"DELETE /v1/connect/networks/{networkId}": typeof deleteNetwork;
	"DELETE /v1/drains/{id}": typeof deleteDrain;
	"DELETE /v1/edge-config/{edgeConfigId}": typeof deleteEdgeConfig;
	"DELETE /v1/edge-config/{edgeConfigId}/schema": typeof deleteEdgeConfigSchema;
	"DELETE /v1/edge-config/{edgeConfigId}/tokens": typeof deleteEdgeConfigTokens;
	"DELETE /v1/env": typeof deleteSharedEnvVariable;
	"DELETE /v1/installations/{integrationConfigurationId}/resources/{resourceId}": typeof deleteIntegrationResource;
	"DELETE /v1/installations/{integrationConfigurationId}/resources/{resourceId}/experimentation/items/{itemId}": typeof deleteExperimentationItem;
	"DELETE /v1/integrations/configuration/{id}": typeof deleteConfiguration;
	"DELETE /v1/integrations/log-drains/{id}": typeof deleteIntegrationLogDrain;
	"DELETE /v1/log-drains/{id}": typeof deleteConfigurableLogDrain;
	"DELETE /v1/projects/{idOrName}/env": typeof batchRemoveProjectEnv;
	"DELETE /v1/projects/{idOrName}/members/{uid}": typeof removeProjectMember;
	"DELETE /v1/projects/{idOrName}/rolling-release/config": typeof deleteRollingReleaseConfig;
	"DELETE /v1/security/firewall/bypass": typeof removeBypassIp;
	"DELETE /v1/teams/{teamId}": typeof deleteTeam;
	"DELETE /v1/teams/{teamId}/invites/{inviteId}": typeof deleteTeamInviteCode;
	"DELETE /v1/teams/{teamId}/members/{uid}": typeof removeTeamMember;
	"DELETE /v1/user": typeof requestDelete;
	"DELETE /v1/webhooks/{id}": typeof deleteWebhook;
	"DELETE /v13/deployments/{id}": typeof deleteDeployment;
	"DELETE /v2/aliases/{aliasId}": typeof deleteAlias;
	"DELETE /v2/domains/{domain}/records/{recordId}": typeof removeRecord;
	"DELETE /v3/user/tokens/{tokenId}": typeof deleteAuthToken;
	"DELETE /v6/domains/{domain}": typeof deleteDomain;
	"DELETE /v8/certs/{id}": typeof removeCert;
	"DELETE /v9/projects/{idOrName}": typeof deleteProject;
	"DELETE /v9/projects/{idOrName}/custom-environments/{environmentSlugOrId}": typeof removeCustomEnvironment;
	"DELETE /v9/projects/{idOrName}/domains/{domain}": typeof removeProjectDomain;
	"DELETE /v9/projects/{idOrName}/env/{id}": typeof removeProjectEnv;
	"GET /v1/access-groups": typeof listAccessGroups;
	"GET /v1/access-groups/{accessGroupIdOrName}/projects/{projectId}": typeof readAccessGroupProject;
	"GET /v1/access-groups/{idOrName}": typeof readAccessGroup;
	"GET /v1/access-groups/{idOrName}/members": typeof listAccessGroupMembers;
	"GET /v1/access-groups/{idOrName}/projects": typeof listAccessGroupProjects;
	"GET /v1/bulk-redirects": typeof getRedirects;
	"GET /v1/bulk-redirects/versions": typeof getVersions;
	"GET /v1/connect/networks": typeof listNetworks;
	"GET /v1/connect/networks/{networkId}": typeof readNetwork;
	"GET /v1/deployments/{deploymentId}/checks": typeof getAllChecks;
	"GET /v1/deployments/{deploymentId}/checks/{checkId}": typeof getCheck;
	"GET /v1/drains": typeof getDrains;
	"GET /v1/drains/{id}": typeof getDrain;
	"GET /v1/edge-config": typeof getEdgeConfigs;
	"GET /v1/edge-config/{edgeConfigId}": typeof getEdgeConfig;
	"GET /v1/edge-config/{edgeConfigId}/backups": typeof getEdgeConfigBackups;
	"GET /v1/edge-config/{edgeConfigId}/backups/{edgeConfigBackupVersionId}": typeof getEdgeConfigBackup;
	"GET /v1/edge-config/{edgeConfigId}/item/{edgeConfigItemKey}": typeof getEdgeConfigItem;
	"GET /v1/edge-config/{edgeConfigId}/items": typeof getEdgeConfigItems;
	"GET /v1/edge-config/{edgeConfigId}/schema": typeof getEdgeConfigSchema;
	"GET /v1/edge-config/{edgeConfigId}/token/{token}": typeof getEdgeConfigToken;
	"GET /v1/edge-config/{edgeConfigId}/tokens": typeof getEdgeConfigTokens;
	"GET /v1/env": typeof listSharedEnvVariable;
	"GET /v1/env/{id}": typeof getSharedEnvVar;
	"GET /v1/installations/{integrationConfigurationId}/account": typeof getAccountInfo;
	"GET /v1/installations/{integrationConfigurationId}/billing/invoices/{invoiceId}": typeof getInvoice;
	"GET /v1/installations/{integrationConfigurationId}/member/{memberId}": typeof getMember;
	"GET /v1/installations/{integrationConfigurationId}/resources": typeof getIntegrationResources;
	"GET /v1/installations/{integrationConfigurationId}/resources/{resourceId}": typeof getIntegrationResource;
	"GET /v1/integrations/configuration/{id}": typeof getConfiguration;
	"GET /v1/integrations/configuration/{id}/products": typeof getConfigurationProducts;
	"GET /v1/integrations/configurations": typeof getConfigurations;
	"GET /v1/integrations/git-namespaces": typeof gitNamespaces;
	"GET /v1/integrations/integration/{integrationIdOrSlug}/products/{productIdOrSlug}/plans": typeof getBillingPlans;
	"GET /v1/integrations/search-repo": typeof searchRepo;
	"GET /v1/log-drains": typeof getAllLogDrains;
	"GET /v1/log-drains/{id}": typeof getConfigurableLogDrain;
	"GET /v1/projects/{idOrName}/env/{id}": typeof getProjectEnv;
	"GET /v1/projects/{idOrName}/members": typeof getProjectMembers;
	"GET /v1/projects/{idOrName}/rolling-release": typeof getRollingRelease;
	"GET /v1/projects/{idOrName}/rolling-release/billing": typeof getRollingReleaseBillingStatus;
	"GET /v1/projects/{idOrName}/rolling-release/config": typeof getRollingReleaseConfig;
	"GET /v1/projects/{projectId}/deployments/{deploymentId}/runtime-logs": typeof getRuntimeLogs;
	"GET /v1/projects/{projectId}/promote/aliases": typeof listPromoteAliases;
	"GET /v1/registrar/domains/{domain}/auth-code": typeof getDomainAuthCode;
	"GET /v1/registrar/domains/{domain}/availability": typeof getDomainAvailability;
	"GET /v1/registrar/domains/{domain}/contact-info/schema": typeof getContactInfoSchema;
	"GET /v1/registrar/domains/{domain}/price": typeof getDomainPrice;
	"GET /v1/registrar/domains/{domain}/transfer": typeof getDomainTransferIn;
	"GET /v1/registrar/orders/{orderId}": typeof getOrder;
	"GET /v1/registrar/tlds/{tld}/price": typeof getTldPrice;
	"GET /v1/registrar/tlds/supported": typeof getSupportedTlds;
	"GET /v1/security/firewall/attack-status": typeof getActiveAttackStatus;
	"GET /v1/security/firewall/bypass": typeof getBypassIp;
	"GET /v1/security/firewall/config/{configVersion}": typeof getFirewallConfig;
	"GET /v1/security/firewall/events": typeof gETV1SecurityFirewallEvents;
	"GET /v1/teams/{teamId}/request/{userId}": typeof getTeamAccessRequest;
	"GET /v1/webhooks": typeof getWebhooks;
	"GET /v1/webhooks/{id}": typeof getWebhook;
	"GET /v10/projects": typeof getProjects;
	"GET /v10/projects/{idOrName}/env": typeof filterProjectEnvs;
	"GET /v13/deployments/{idOrUrl}": typeof getDeployment;
	"GET /v2/deployments/{id}/aliases": typeof listDeploymentAliases;
	"GET /v2/integrations/log-drains": typeof getIntegrationLogDrains;
	"GET /v2/teams": typeof getTeams;
	"GET /v2/teams/{teamId}": typeof getTeam;
	"GET /v2/user": typeof getAuthUser;
	"GET /v3/deployments/{idOrUrl}/events": typeof getDeploymentEvents;
	"GET /v3/events": typeof listUserEvents;
	"GET /v3/teams/{teamId}/members": typeof getTeamMembers;
	"GET /v4/aliases": typeof listAliases;
	"GET /v4/aliases/{idOrAlias}": typeof getAlias;
	"GET /v4/domains/{domain}/records": typeof getRecords;
	"GET /v5/domains": typeof getDomains;
	"GET /v5/domains/{domain}": typeof getDomain;
	"GET /v5/user/tokens": typeof listAuthTokens;
	"GET /v5/user/tokens/{tokenId}": typeof getAuthToken;
	"GET /v6/deployments": typeof getDeployments;
	"GET /v6/deployments/{id}/files": typeof listDeploymentFiles;
	"GET /v6/domains/{domain}/config": typeof getDomainConfig;
	"GET /v8/artifacts/{hash}": typeof downloadArtifact;
	"GET /v8/artifacts/status": typeof status;
	"GET /v8/certs/{id}": typeof getCertById;
	"GET /v8/deployments/{id}/files/{fileId}": typeof getDeploymentFileContents;
	"GET /v9/projects/{idOrName}": typeof getProject;
	"GET /v9/projects/{idOrName}/custom-environments": typeof listCustomEnvironments;
	"GET /v9/projects/{idOrName}/custom-environments/{environmentSlugOrId}": typeof getCustomEnvironment;
	"GET /v9/projects/{idOrName}/domains": typeof getProjectDomains;
	"GET /v9/projects/{idOrName}/domains/{domain}": typeof getProjectDomain;
	"PATCH /aliases/{id}/protection-bypass": typeof patchUrlProtectionBypass;
	"PATCH /v1/access-groups/{accessGroupIdOrName}/projects/{projectId}": typeof updateAccessGroupProject;
	"PATCH /v1/bulk-redirects": typeof editRedirect;
	"PATCH /v1/connect/networks/{networkId}": typeof updateNetwork;
	"PATCH /v1/data-cache/projects/{projectId}": typeof updateProjectDataCache;
	"PATCH /v1/deployments/{deploymentId}/checks/{checkId}": typeof updateCheck;
	"PATCH /v1/deployments/{deploymentId}/integrations/{integrationConfigurationId}/resources/{resourceId}/actions/{action}": typeof updateIntegrationDeploymentAction;
	"PATCH /v1/domains/records/{recordId}": typeof updateRecord;
	"PATCH /v1/drains/{id}": typeof updateDrain;
	"PATCH /v1/edge-config/{edgeConfigId}/items": typeof patchEdgeConfigItems;
	"PATCH /v1/env": typeof updateSharedEnvVariable;
	"PATCH /v1/env/{id}/unlink/{projectId}": typeof unlinkSharedEnvVariable;
	"PATCH /v1/installations/{integrationConfigurationId}": typeof updateInstallation;
	"PATCH /v1/installations/{integrationConfigurationId}/resources/{resourceId}": typeof updateResource;
	"PATCH /v1/installations/{integrationConfigurationId}/resources/{resourceId}/experimentation/items/{itemId}": typeof updateExperimentationItem;
	"PATCH /v1/projects/{idOrName}/protection-bypass": typeof updateProjectProtectionBypass;
	"PATCH /v1/projects/{idOrName}/rolling-release/config": typeof updateRollingReleaseConfig;
	"PATCH /v1/projects/{idOrName}/shared-connect-links": typeof updateStaticIps;
	"PATCH /v1/registrar/domains/{domain}/auto-renew": typeof updateDomainAutoRenew;
	"PATCH /v1/registrar/domains/{domain}/nameservers": typeof updateDomainNameservers;
	"PATCH /v1/security/firewall/config": typeof updateFirewallConfig;
	"PATCH /v1/teams/{teamId}/members/{uid}": typeof updateTeamMember;
	"PATCH /v12/deployments/{id}/cancel": typeof cancelDeployment;
	"PATCH /v2/teams/{teamId}": typeof patchTeam;
	"PATCH /v3/domains/{domain}": typeof patchDomain;
	"PATCH /v9/projects/{idOrName}": typeof updateProject;
	"PATCH /v9/projects/{idOrName}/custom-environments/{environmentSlugOrId}": typeof updateCustomEnvironment;
	"PATCH /v9/projects/{idOrName}/domains/{domain}": typeof updateProjectDomain;
	"PATCH /v9/projects/{idOrName}/env/{id}": typeof editProjectEnv;
	"POST /projects/{idOrName}/transfer-request": typeof createProjectTransferRequest;
	"POST /v1/access-groups": typeof createAccessGroup;
	"POST /v1/access-groups/{accessGroupIdOrName}/projects": typeof createAccessGroupProject;
	"POST /v1/access-groups/{idOrName}": typeof updateAccessGroup;
	"POST /v1/bulk-redirects/restore": typeof restoreRedirects;
	"POST /v1/bulk-redirects/versions": typeof updateVersion;
	"POST /v1/connect/networks": typeof createNetwork;
	"POST /v1/deployments/{deploymentId}/checks": typeof createCheck;
	"POST /v1/deployments/{deploymentId}/checks/{checkId}/rerequest": typeof rerequestCheck;
	"POST /v1/drains": typeof createDrain;
	"POST /v1/drains/test": typeof testDrain;
	"POST /v1/edge-cache/dangerously-delete-by-src-images": typeof dangerouslyDeleteBySrcImages;
	"POST /v1/edge-cache/dangerously-delete-by-tags": typeof dangerouslyDeleteByTags;
	"POST /v1/edge-cache/invalidate-by-src-images": typeof invalidateBySrcImages;
	"POST /v1/edge-cache/invalidate-by-tags": typeof invalidateByTags;
	"POST /v1/edge-config": typeof createEdgeConfig;
	"POST /v1/edge-config/{edgeConfigId}/schema": typeof patchEdgeConfigSchema;
	"POST /v1/edge-config/{edgeConfigId}/token": typeof createEdgeConfigToken;
	"POST /v1/env": typeof createSharedEnvVariable;
	"POST /v1/installations/{integrationConfigurationId}/billing": typeof submitBillingData;
	"POST /v1/installations/{integrationConfigurationId}/billing/balance": typeof submitPrepaymentBalances;
	"POST /v1/installations/{integrationConfigurationId}/billing/invoices": typeof submitInvoice;
	"POST /v1/installations/{integrationConfigurationId}/billing/invoices/{invoiceId}/actions": typeof updateInvoice;
	"POST /v1/installations/{integrationConfigurationId}/events": typeof createEvent;
	"POST /v1/installations/{integrationConfigurationId}/resources/{resourceId}/experimentation/items": typeof createExperimentationItem;
	"POST /v1/integrations/installations/{integrationConfigurationId}/resources/{resourceId}/connections": typeof connectIntegrationResourceToProject;
	"POST /v1/integrations/sso/token": typeof exchangeSsoToken;
	"POST /v1/log-drains": typeof createConfigurableLogDrain;
	"POST /v1/projects/{idOrName}/domains/{domain}/move": typeof moveProjectDomain;
	"POST /v1/projects/{idOrName}/members": typeof addProjectMember;
	"POST /v1/projects/{idOrName}/rolling-release/approve-stage": typeof approveRollingReleaseStage;
	"POST /v1/projects/{idOrName}/rolling-release/complete": typeof completeRollingRelease;
	"POST /v1/projects/{projectId}/pause": typeof pauseProject;
	"POST /v1/projects/{projectId}/unpause": typeof unpauseProject;
	"POST /v1/registrar/domains/{domain}/buy": typeof buySingleDomain;
	"POST /v1/registrar/domains/{domain}/renew": typeof renewDomain;
	"POST /v1/registrar/domains/{domain}/transfer": typeof transferInDomain;
	"POST /v1/registrar/domains/availability": typeof getBulkAvailability;
	"POST /v1/registrar/domains/buy": typeof buyDomains;
	"POST /v1/security/attack-mode": typeof updateAttackChallengeMode;
	"POST /v1/security/firewall/bypass": typeof addBypassIp;
	"POST /v1/storage/stores/integration/direct": typeof createIntegrationStoreDirect;
	"POST /v1/teams": typeof createTeam;
	"POST /v1/teams/{teamId}/dsync-roles": typeof postTeamDsyncRoles;
	"POST /v1/teams/{teamId}/members/teams/join": typeof joinTeam;
	"POST /v1/teams/{teamId}/request": typeof requestAccessToTeam;
	"POST /v1/webhooks": typeof createWebhook;
	"POST /v10/projects/{idOrName}/domains": typeof addProjectDomain;
	"POST /v10/projects/{idOrName}/env": typeof createProjectEnv;
	"POST /v10/projects/{projectId}/promote/{deploymentId}": typeof requestPromote;
	"POST /v11/projects": typeof createProject;
	"POST /v13/deployments": typeof createDeployment;
	"POST /v2/deployments/{id}/aliases": typeof assignAlias;
	"POST /v2/domains/{domain}/records": typeof createRecord;
	"POST /v2/files": typeof uploadFile;
	"POST /v2/integrations/log-drains": typeof createLogDrain;
	"POST /v2/teams/{teamId}/members": typeof inviteUserToTeam;
	"POST /v3/user/tokens": typeof createAuthToken;
	"POST /v7/domains": typeof createOrTransferDomain;
	"POST /v8/artifacts": typeof artifactQuery;
	"POST /v8/artifacts/events": typeof recordEvents;
	"POST /v8/certs": typeof issueCert;
	"POST /v9/projects/{idOrName}/custom-environments": typeof createCustomEnvironment;
	"POST /v9/projects/{idOrName}/domains/{domain}/verify": typeof verifyProjectDomain;
	"PUT /projects/transfer-request/{code}": typeof acceptProjectTransferRequest;
	"PUT /v1/bulk-redirects": typeof stageRedirects;
	"PUT /v1/edge-config/{edgeConfigId}": typeof updateEdgeConfig;
	"PUT /v1/installations/{integrationConfigurationId}/products/{integrationProductIdOrSlug}/resources/{resourceId}/secrets": typeof updateResourceSecrets;
	"PUT /v1/installations/{integrationConfigurationId}/resources/{resourceId}": typeof importResource;
	"PUT /v1/installations/{integrationConfigurationId}/resources/{resourceId}/experimentation/edge-config": typeof updateExperimentationEdgeConfig;
	"PUT /v1/installations/{integrationConfigurationId}/resources/{resourceId}/secrets": typeof updateResourceSecretsById;
	"PUT /v1/security/firewall/config": typeof putFirewallConfig;
	"PUT /v8/artifacts/{hash}": typeof uploadArtifact;
	"PUT /v8/certs": typeof uploadCert;
};

export const operationsByPath: OperationsByPath = {
	"DELETE /v1/access-groups/{accessGroupIdOrName}/projects/{projectId}": deleteAccessGroupProject,
	"DELETE /v1/access-groups/{idOrName}": deleteAccessGroup,
	"DELETE /v1/bulk-redirects": deleteRedirects,
	"DELETE /v1/connect/networks/{networkId}": deleteNetwork,
	"DELETE /v1/drains/{id}": deleteDrain,
	"DELETE /v1/edge-config/{edgeConfigId}": deleteEdgeConfig,
	"DELETE /v1/edge-config/{edgeConfigId}/schema": deleteEdgeConfigSchema,
	"DELETE /v1/edge-config/{edgeConfigId}/tokens": deleteEdgeConfigTokens,
	"DELETE /v1/env": deleteSharedEnvVariable,
	"DELETE /v1/installations/{integrationConfigurationId}/resources/{resourceId}":
		deleteIntegrationResource,
	"DELETE /v1/installations/{integrationConfigurationId}/resources/{resourceId}/experimentation/items/{itemId}":
		deleteExperimentationItem,
	"DELETE /v1/integrations/configuration/{id}": deleteConfiguration,
	"DELETE /v1/integrations/log-drains/{id}": deleteIntegrationLogDrain,
	"DELETE /v1/log-drains/{id}": deleteConfigurableLogDrain,
	"DELETE /v1/projects/{idOrName}/env": batchRemoveProjectEnv,
	"DELETE /v1/projects/{idOrName}/members/{uid}": removeProjectMember,
	"DELETE /v1/projects/{idOrName}/rolling-release/config": deleteRollingReleaseConfig,
	"DELETE /v1/security/firewall/bypass": removeBypassIp,
	"DELETE /v1/teams/{teamId}": deleteTeam,
	"DELETE /v1/teams/{teamId}/invites/{inviteId}": deleteTeamInviteCode,
	"DELETE /v1/teams/{teamId}/members/{uid}": removeTeamMember,
	"DELETE /v1/user": requestDelete,
	"DELETE /v1/webhooks/{id}": deleteWebhook,
	"DELETE /v13/deployments/{id}": deleteDeployment,
	"DELETE /v2/aliases/{aliasId}": deleteAlias,
	"DELETE /v2/domains/{domain}/records/{recordId}": removeRecord,
	"DELETE /v3/user/tokens/{tokenId}": deleteAuthToken,
	"DELETE /v6/domains/{domain}": deleteDomain,
	"DELETE /v8/certs/{id}": removeCert,
	"DELETE /v9/projects/{idOrName}": deleteProject,
	"DELETE /v9/projects/{idOrName}/custom-environments/{environmentSlugOrId}":
		removeCustomEnvironment,
	"DELETE /v9/projects/{idOrName}/domains/{domain}": removeProjectDomain,
	"DELETE /v9/projects/{idOrName}/env/{id}": removeProjectEnv,
	"GET /v1/access-groups": listAccessGroups,
	"GET /v1/access-groups/{accessGroupIdOrName}/projects/{projectId}": readAccessGroupProject,
	"GET /v1/access-groups/{idOrName}": readAccessGroup,
	"GET /v1/access-groups/{idOrName}/members": listAccessGroupMembers,
	"GET /v1/access-groups/{idOrName}/projects": listAccessGroupProjects,
	"GET /v1/bulk-redirects": getRedirects,
	"GET /v1/bulk-redirects/versions": getVersions,
	"GET /v1/connect/networks": listNetworks,
	"GET /v1/connect/networks/{networkId}": readNetwork,
	"GET /v1/deployments/{deploymentId}/checks": getAllChecks,
	"GET /v1/deployments/{deploymentId}/checks/{checkId}": getCheck,
	"GET /v1/drains": getDrains,
	"GET /v1/drains/{id}": getDrain,
	"GET /v1/edge-config": getEdgeConfigs,
	"GET /v1/edge-config/{edgeConfigId}": getEdgeConfig,
	"GET /v1/edge-config/{edgeConfigId}/backups": getEdgeConfigBackups,
	"GET /v1/edge-config/{edgeConfigId}/backups/{edgeConfigBackupVersionId}": getEdgeConfigBackup,
	"GET /v1/edge-config/{edgeConfigId}/item/{edgeConfigItemKey}": getEdgeConfigItem,
	"GET /v1/edge-config/{edgeConfigId}/items": getEdgeConfigItems,
	"GET /v1/edge-config/{edgeConfigId}/schema": getEdgeConfigSchema,
	"GET /v1/edge-config/{edgeConfigId}/token/{token}": getEdgeConfigToken,
	"GET /v1/edge-config/{edgeConfigId}/tokens": getEdgeConfigTokens,
	"GET /v1/env": listSharedEnvVariable,
	"GET /v1/env/{id}": getSharedEnvVar,
	"GET /v1/installations/{integrationConfigurationId}/account": getAccountInfo,
	"GET /v1/installations/{integrationConfigurationId}/billing/invoices/{invoiceId}": getInvoice,
	"GET /v1/installations/{integrationConfigurationId}/member/{memberId}": getMember,
	"GET /v1/installations/{integrationConfigurationId}/resources": getIntegrationResources,
	"GET /v1/installations/{integrationConfigurationId}/resources/{resourceId}":
		getIntegrationResource,
	"GET /v1/integrations/configuration/{id}": getConfiguration,
	"GET /v1/integrations/configuration/{id}/products": getConfigurationProducts,
	"GET /v1/integrations/configurations": getConfigurations,
	"GET /v1/integrations/git-namespaces": gitNamespaces,
	"GET /v1/integrations/integration/{integrationIdOrSlug}/products/{productIdOrSlug}/plans":
		getBillingPlans,
	"GET /v1/integrations/search-repo": searchRepo,
	"GET /v1/log-drains": getAllLogDrains,
	"GET /v1/log-drains/{id}": getConfigurableLogDrain,
	"GET /v1/projects/{idOrName}/env/{id}": getProjectEnv,
	"GET /v1/projects/{idOrName}/members": getProjectMembers,
	"GET /v1/projects/{idOrName}/rolling-release": getRollingRelease,
	"GET /v1/projects/{idOrName}/rolling-release/billing": getRollingReleaseBillingStatus,
	"GET /v1/projects/{idOrName}/rolling-release/config": getRollingReleaseConfig,
	"GET /v1/projects/{projectId}/deployments/{deploymentId}/runtime-logs": getRuntimeLogs,
	"GET /v1/projects/{projectId}/promote/aliases": listPromoteAliases,
	"GET /v1/registrar/domains/{domain}/auth-code": getDomainAuthCode,
	"GET /v1/registrar/domains/{domain}/availability": getDomainAvailability,
	"GET /v1/registrar/domains/{domain}/contact-info/schema": getContactInfoSchema,
	"GET /v1/registrar/domains/{domain}/price": getDomainPrice,
	"GET /v1/registrar/domains/{domain}/transfer": getDomainTransferIn,
	"GET /v1/registrar/orders/{orderId}": getOrder,
	"GET /v1/registrar/tlds/{tld}/price": getTldPrice,
	"GET /v1/registrar/tlds/supported": getSupportedTlds,
	"GET /v1/security/firewall/attack-status": getActiveAttackStatus,
	"GET /v1/security/firewall/bypass": getBypassIp,
	"GET /v1/security/firewall/config/{configVersion}": getFirewallConfig,
	"GET /v1/security/firewall/events": gETV1SecurityFirewallEvents,
	"GET /v1/teams/{teamId}/request/{userId}": getTeamAccessRequest,
	"GET /v1/webhooks": getWebhooks,
	"GET /v1/webhooks/{id}": getWebhook,
	"GET /v10/projects": getProjects,
	"GET /v10/projects/{idOrName}/env": filterProjectEnvs,
	"GET /v13/deployments/{idOrUrl}": getDeployment,
	"GET /v2/deployments/{id}/aliases": listDeploymentAliases,
	"GET /v2/integrations/log-drains": getIntegrationLogDrains,
	"GET /v2/teams": getTeams,
	"GET /v2/teams/{teamId}": getTeam,
	"GET /v2/user": getAuthUser,
	"GET /v3/deployments/{idOrUrl}/events": getDeploymentEvents,
	"GET /v3/events": listUserEvents,
	"GET /v3/teams/{teamId}/members": getTeamMembers,
	"GET /v4/aliases": listAliases,
	"GET /v4/aliases/{idOrAlias}": getAlias,
	"GET /v4/domains/{domain}/records": getRecords,
	"GET /v5/domains": getDomains,
	"GET /v5/domains/{domain}": getDomain,
	"GET /v5/user/tokens": listAuthTokens,
	"GET /v5/user/tokens/{tokenId}": getAuthToken,
	"GET /v6/deployments": getDeployments,
	"GET /v6/deployments/{id}/files": listDeploymentFiles,
	"GET /v6/domains/{domain}/config": getDomainConfig,
	"GET /v8/artifacts/{hash}": downloadArtifact,
	"GET /v8/artifacts/status": status,
	"GET /v8/certs/{id}": getCertById,
	"GET /v8/deployments/{id}/files/{fileId}": getDeploymentFileContents,
	"GET /v9/projects/{idOrName}": getProject,
	"GET /v9/projects/{idOrName}/custom-environments": listCustomEnvironments,
	"GET /v9/projects/{idOrName}/custom-environments/{environmentSlugOrId}": getCustomEnvironment,
	"GET /v9/projects/{idOrName}/domains": getProjectDomains,
	"GET /v9/projects/{idOrName}/domains/{domain}": getProjectDomain,
	"PATCH /aliases/{id}/protection-bypass": patchUrlProtectionBypass,
	"PATCH /v1/access-groups/{accessGroupIdOrName}/projects/{projectId}": updateAccessGroupProject,
	"PATCH /v1/bulk-redirects": editRedirect,
	"PATCH /v1/connect/networks/{networkId}": updateNetwork,
	"PATCH /v1/data-cache/projects/{projectId}": updateProjectDataCache,
	"PATCH /v1/deployments/{deploymentId}/checks/{checkId}": updateCheck,
	"PATCH /v1/deployments/{deploymentId}/integrations/{integrationConfigurationId}/resources/{resourceId}/actions/{action}":
		updateIntegrationDeploymentAction,
	"PATCH /v1/domains/records/{recordId}": updateRecord,
	"PATCH /v1/drains/{id}": updateDrain,
	"PATCH /v1/edge-config/{edgeConfigId}/items": patchEdgeConfigItems,
	"PATCH /v1/env": updateSharedEnvVariable,
	"PATCH /v1/env/{id}/unlink/{projectId}": unlinkSharedEnvVariable,
	"PATCH /v1/installations/{integrationConfigurationId}": updateInstallation,
	"PATCH /v1/installations/{integrationConfigurationId}/resources/{resourceId}": updateResource,
	"PATCH /v1/installations/{integrationConfigurationId}/resources/{resourceId}/experimentation/items/{itemId}":
		updateExperimentationItem,
	"PATCH /v1/projects/{idOrName}/protection-bypass": updateProjectProtectionBypass,
	"PATCH /v1/projects/{idOrName}/rolling-release/config": updateRollingReleaseConfig,
	"PATCH /v1/projects/{idOrName}/shared-connect-links": updateStaticIps,
	"PATCH /v1/registrar/domains/{domain}/auto-renew": updateDomainAutoRenew,
	"PATCH /v1/registrar/domains/{domain}/nameservers": updateDomainNameservers,
	"PATCH /v1/security/firewall/config": updateFirewallConfig,
	"PATCH /v1/teams/{teamId}/members/{uid}": updateTeamMember,
	"PATCH /v12/deployments/{id}/cancel": cancelDeployment,
	"PATCH /v2/teams/{teamId}": patchTeam,
	"PATCH /v3/domains/{domain}": patchDomain,
	"PATCH /v9/projects/{idOrName}": updateProject,
	"PATCH /v9/projects/{idOrName}/custom-environments/{environmentSlugOrId}":
		updateCustomEnvironment,
	"PATCH /v9/projects/{idOrName}/domains/{domain}": updateProjectDomain,
	"PATCH /v9/projects/{idOrName}/env/{id}": editProjectEnv,
	"POST /projects/{idOrName}/transfer-request": createProjectTransferRequest,
	"POST /v1/access-groups": createAccessGroup,
	"POST /v1/access-groups/{accessGroupIdOrName}/projects": createAccessGroupProject,
	"POST /v1/access-groups/{idOrName}": updateAccessGroup,
	"POST /v1/bulk-redirects/restore": restoreRedirects,
	"POST /v1/bulk-redirects/versions": updateVersion,
	"POST /v1/connect/networks": createNetwork,
	"POST /v1/deployments/{deploymentId}/checks": createCheck,
	"POST /v1/deployments/{deploymentId}/checks/{checkId}/rerequest": rerequestCheck,
	"POST /v1/drains": createDrain,
	"POST /v1/drains/test": testDrain,
	"POST /v1/edge-cache/dangerously-delete-by-src-images": dangerouslyDeleteBySrcImages,
	"POST /v1/edge-cache/dangerously-delete-by-tags": dangerouslyDeleteByTags,
	"POST /v1/edge-cache/invalidate-by-src-images": invalidateBySrcImages,
	"POST /v1/edge-cache/invalidate-by-tags": invalidateByTags,
	"POST /v1/edge-config": createEdgeConfig,
	"POST /v1/edge-config/{edgeConfigId}/schema": patchEdgeConfigSchema,
	"POST /v1/edge-config/{edgeConfigId}/token": createEdgeConfigToken,
	"POST /v1/env": createSharedEnvVariable,
	"POST /v1/installations/{integrationConfigurationId}/billing": submitBillingData,
	"POST /v1/installations/{integrationConfigurationId}/billing/balance": submitPrepaymentBalances,
	"POST /v1/installations/{integrationConfigurationId}/billing/invoices": submitInvoice,
	"POST /v1/installations/{integrationConfigurationId}/billing/invoices/{invoiceId}/actions":
		updateInvoice,
	"POST /v1/installations/{integrationConfigurationId}/events": createEvent,
	"POST /v1/installations/{integrationConfigurationId}/resources/{resourceId}/experimentation/items":
		createExperimentationItem,
	"POST /v1/integrations/installations/{integrationConfigurationId}/resources/{resourceId}/connections":
		connectIntegrationResourceToProject,
	"POST /v1/integrations/sso/token": exchangeSsoToken,
	"POST /v1/log-drains": createConfigurableLogDrain,
	"POST /v1/projects/{idOrName}/domains/{domain}/move": moveProjectDomain,
	"POST /v1/projects/{idOrName}/members": addProjectMember,
	"POST /v1/projects/{idOrName}/rolling-release/approve-stage": approveRollingReleaseStage,
	"POST /v1/projects/{idOrName}/rolling-release/complete": completeRollingRelease,
	"POST /v1/projects/{projectId}/pause": pauseProject,
	"POST /v1/projects/{projectId}/unpause": unpauseProject,
	"POST /v1/registrar/domains/{domain}/buy": buySingleDomain,
	"POST /v1/registrar/domains/{domain}/renew": renewDomain,
	"POST /v1/registrar/domains/{domain}/transfer": transferInDomain,
	"POST /v1/registrar/domains/availability": getBulkAvailability,
	"POST /v1/registrar/domains/buy": buyDomains,
	"POST /v1/security/attack-mode": updateAttackChallengeMode,
	"POST /v1/security/firewall/bypass": addBypassIp,
	"POST /v1/storage/stores/integration/direct": createIntegrationStoreDirect,
	"POST /v1/teams": createTeam,
	"POST /v1/teams/{teamId}/dsync-roles": postTeamDsyncRoles,
	"POST /v1/teams/{teamId}/members/teams/join": joinTeam,
	"POST /v1/teams/{teamId}/request": requestAccessToTeam,
	"POST /v1/webhooks": createWebhook,
	"POST /v10/projects/{idOrName}/domains": addProjectDomain,
	"POST /v10/projects/{idOrName}/env": createProjectEnv,
	"POST /v10/projects/{projectId}/promote/{deploymentId}": requestPromote,
	"POST /v11/projects": createProject,
	"POST /v13/deployments": createDeployment,
	"POST /v2/deployments/{id}/aliases": assignAlias,
	"POST /v2/domains/{domain}/records": createRecord,
	"POST /v2/files": uploadFile,
	"POST /v2/integrations/log-drains": createLogDrain,
	"POST /v2/teams/{teamId}/members": inviteUserToTeam,
	"POST /v3/user/tokens": createAuthToken,
	"POST /v7/domains": createOrTransferDomain,
	"POST /v8/artifacts": artifactQuery,
	"POST /v8/artifacts/events": recordEvents,
	"POST /v8/certs": issueCert,
	"POST /v9/projects/{idOrName}/custom-environments": createCustomEnvironment,
	"POST /v9/projects/{idOrName}/domains/{domain}/verify": verifyProjectDomain,
	"PUT /projects/transfer-request/{code}": acceptProjectTransferRequest,
	"PUT /v1/bulk-redirects": stageRedirects,
	"PUT /v1/edge-config/{edgeConfigId}": updateEdgeConfig,
	"PUT /v1/installations/{integrationConfigurationId}/products/{integrationProductIdOrSlug}/resources/{resourceId}/secrets":
		updateResourceSecrets,
	"PUT /v1/installations/{integrationConfigurationId}/resources/{resourceId}": importResource,
	"PUT /v1/installations/{integrationConfigurationId}/resources/{resourceId}/experimentation/edge-config":
		updateExperimentationEdgeConfig,
	"PUT /v1/installations/{integrationConfigurationId}/resources/{resourceId}/secrets":
		updateResourceSecretsById,
	"PUT /v1/security/firewall/config": putFirewallConfig,
	"PUT /v8/artifacts/{hash}": uploadArtifact,
	"PUT /v8/certs": uploadCert,
};

// ============================================================================
// Type-safe Request Helper
// ============================================================================

/**
 * Type-safe request helper for making API calls by endpoint.
 *
 * @example
 * ```ts
 * import { request, makeApiClientLive } from "your-package/effect";
 * import { Effect } from "effect";
 *
 * const program = Effect.gen(function* () {
 *   const result = yield* request("GET /v4/projects", {});
 *   return result;
 * });
 *
 * const result = await program.pipe(
 *   Effect.provide(makeApiClientLive({ baseUrl: "https://api.example.com", token: "your-token" })),
 *   Effect.runPromise
 * );
 * ```
 */
export function request<K extends keyof OperationsByPath>(
	endpoint: K,
	params: Parameters<OperationsByPath[K]>[0],
): ReturnType<OperationsByPath[K]> {
	const operation = operationsByPath[endpoint] as (
		params: unknown,
	) => ReturnType<OperationsByPath[K]>;
	return operation(params);
}
