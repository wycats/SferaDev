/**
 * Generated by Kubb (https://kubb.dev/).
 * Do not edit manually.
 */

import { z } from "zod";

export const accountConfigSchema = z.object({
	alexaPin: z.string().describe("The alexa pin - used by alexa for unlock actions"),
	gactionsHomePin: z.string().describe("The google smart home pin - used for unlock actions"),
	otpEnabledDate: z.optional(z.string().datetime().describe("The opt enabled date")),
});

export const accountProfileSchema = z.object({
	firstName: z.string().describe("The first name"),
	lastName: z.string().describe("The last name"),
	address: z.string().describe("The address"),
	zip: z.string().describe("The postal code"),
	city: z.string().describe("The city"),
	country: z.string().describe("The 2-letter country code"),
});

export const accountDescentSchema = z.object({
	origin: z.enum(["GOOGLE", "APPLE"]).describe("The account origin source"),
});

export const termsOfUseSchema = z.object({
	state: z.optional(z.enum(["Accepted", "Inactive"])),
	publishDate: z.optional(z.string().datetime()),
	acceptanceDate: z.optional(z.string().datetime()),
});

export const accountSchema = z.object({
	accountId: z.int().describe("The account id"),
	type: z.int().min(0).max(2).describe("The type: 0 .. user, 1 .. company, 2 .. caretaker"),
	email: z.string().describe("The email address"),
	emailVerified: z.optional(z.boolean().describe("true, if the email is verified")),
	name: z.string().describe("The name"),
	masterAccountId: z.optional(z.int().describe("The master account id if it's a sub account")),
	rights: z.optional(
		z
			.int()
			.min(0)
			.max(127)
			.describe(
				"The rights bitmask if it's a sub account: 1 .. manage smartlock, 2 .. operate smartlock, 4 .. manage smartlock config, 8 .. manage smartlock authorizations, 16 .. view smartlock logs, 32 .. manage sub accounts, 64 .. create smartlocks",
			),
	),
	language: z.optional(z.string().describe("The language code")),
	get config() {
		return accountConfigSchema.optional();
	},
	get profile() {
		return accountProfileSchema.optional();
	},
	creationDate: z.string().datetime().describe("The creation date"),
	updateDate: z.string().datetime().describe("The update date"),
	get descent() {
		return accountDescentSchema.optional();
	},
	shsSubscriptionType: z.optional(
		z
			.enum(["BUSINESS", "STANDARD", "BUSINESS_PLUS", "API_ONLY"])
			.describe("subscription type of the account (b2b)"),
	),
	b2bActive: z.optional(z.boolean()),
	get apiTermsOfUse() {
		return termsOfUseSchema.optional();
	},
});

export const accountEmailChangeSchema = z.object({
	email: z.string().describe("The new email for the account"),
});

export const accountIntegrationSchema = z.object({
	version: z
		.enum(["LEGACY", "HYDRA"])
		.describe("If the integration/device is an legacy or from the new oauth implementation"),
	vendorKey: z
		.string()
		.describe(
			"Enum key identifying the integration/device, values are e.g. ALEXA, IOS, NUKI_WEB, API_TOKEN etc",
		),
	subAccountName: z.optional(
		z
			.string()
			.describe(
				"Name of the sub-account or null if there is none, which is associated with this token",
			),
	),
	subAccountId: z.optional(
		z
			.int()
			.describe(
				"Id of the sub-account or null if there is none, which is associated with this token",
			),
	),
	subAccount: z.optional(z.boolean().describe("True if the integration is done via a sub-account")),
	name: z.string().describe("Name of the token"),
	description: z.optional(
		z.string().describe("Description given by the user, usually only set for api tokens"),
	),
	createdAt: z.optional(z.string().datetime().describe("First creation date of the token")),
	lastActiveAt: z.optional(z.string().datetime().describe("Last refresh date of the token")),
	scopes: z.optional(
		z.array(z.string()).describe("The scopes which have been granted to the token"),
	),
	warning: z.optional(
		z.boolean().describe("If this is from a legacy integration this is set to true"),
	),
	tokenId: z.optional(z.string().describe("The tokenId if this a manual generated api token")),
	advancedType: z.optional(
		z
			.string()
			.describe("The enum advanced type (HEALTHCARE e.g.) if this integration is a advanced one"),
	),
	advancedState: z.optional(
		z
			.string()
			.describe("The enum advanced state (TESTING e.g.) if this integration is a advanced one"),
	),
	clientId: z
		.string()
		.describe("The clientId of this integration/device used for deleting the integration"),
	sortOrder: z.optional(
		z
			.int()
			.describe(
				"Sort order by which the entry should be sorted, is being set by the vendor key enum",
			),
	),
	device: z.optional(
		z.boolean().describe("True this is a device and false this is an integration"),
	),
});

export const accountOtpEnableSchema = z.object({
	otp: z.string().describe("The one time password (otp)"),
});

export const accountPasswordResetSchema = z.object({
	email: z.string(),
	deleteApiTokens: z.optional(z.boolean()),
});

export const staleDeviceSchema = z.object({
	smartlockId: z.optional(z.int()),
	name: z.optional(z.string()),
	read: z.optional(z.boolean()),
});

export const accountSettingWebSchema = z.object({
	deviceViewType: z.optional(
		z.enum(["LIST", "TILE"]).describe("The initial view type of the device page"),
	),
	deviceSortType: z.optional(
		z
			.enum(["FAVOURITES_FIRST", "NAME_ASC", "NAME_DESC", "LAST_ADDED_DESC"])
			.describe("The initial sort type of the device page"),
	),
	nukiClubDismissed: z.optional(
		z.boolean().describe("If true, Nuki Club info is dismissed and no banner is shown"),
	),
	get removedStaledDevices() {
		return z.array(staleDeviceSchema).describe("List of removed staled devices").optional();
	},
	get markedStaledDevices() {
		return z.array(staleDeviceSchema).describe("List of marked staled devices").optional();
	},
});

export const accountSettingSchema = z.object({
	get web() {
		return accountSettingWebSchema.optional();
	},
});

export const accountSubCreateSchema = z.object({
	email: z.string().describe("The email address"),
	password: z.string().describe("The password (must be at least 7 chars long)"),
	name: z.string().describe("The name of the sub account"),
	rights: z
		.int()
		.min(0)
		.max(31)
		.describe(
			"The right bitmask of the sub account: 1 .. operate smartlock, 2 .. change smartlock config, 4 .. manage smartlock users, 8 .. view smartlock logs, 16 .. manage sub accounts",
		),
	language: z.string().describe("The language code"),
	get profile() {
		return accountProfileSchema.optional();
	},
});

export const accountSubUpdateSchema = z.object({
	email: z.optional(z.string().describe("The new email address")),
	password: z.optional(z.string().describe("The new password (must be at least 7 chars long)")),
	name: z.optional(z.string().describe("The new name of the sub account")),
	rights: z.optional(
		z
			.int()
			.min(0)
			.max(127)
			.describe(
				"The new right bitmask of the sub account: 1 .. operate smartlock, 2 .. change smartlock config, 4 .. manage smartlock users, 8 .. view smartlock logs, 16 .. manage sub accounts, 32 .. manage sub accounts, 64 .. create smartlocks",
			),
	),
	language: z.string().describe("The language code"),
	get config() {
		return accountConfigSchema.optional();
	},
	get profile() {
		return accountProfileSchema.optional();
	},
});

export const accountUpdateSchema = z.object({
	email: z.optional(z.string().describe("The new email address")),
	password: z.optional(z.string().describe("The password (must be at least 7 chars long)")),
	name: z.optional(z.string().describe("The name of the account")),
	language: z.string().describe("The language code"),
	get config() {
		return accountConfigSchema.optional();
	},
	get profile() {
		return accountProfileSchema.optional();
	},
});

export const accountUserSchema = z.object({
	accountUserId: z.int().describe("The account user id"),
	accountId: z.int().describe("The account id"),
	type: z.optional(z.int().min(0).max(1).describe("The optional type: 0 .. user, 1 .. company")),
	email: z.string().describe("The email address"),
	name: z.string().describe("The name"),
	language: z.optional(z.string().describe("The language code")),
	operationId: z.optional(
		z.string().describe("The operation id - if set it's locked for another operation"),
	),
	creationDate: z.string().datetime().describe("The creation date"),
	updateDate: z.string().datetime().describe("The update date"),
});

export const accountUserCreateSchema = z.object({
	type: z.optional(
		z
			.int()
			.min(0)
			.max(1)
			.describe("The optional type - only allowed for caretakers: 0 .. user, 1 .. company"),
	),
	email: z.string().describe("The email address"),
	name: z.string().describe("The name"),
	language: z.optional(
		z.enum(["en", "de", "es", "fr", "it", "nl", "cs", "sk"]).describe("The language code"),
	),
});

export const accountUserUpdateSchema = z.object({
	email: z.optional(z.string().describe("The new email address")),
	name: z.optional(z.string().describe("The new name of the sub account")),
	language: z.optional(
		z.enum(["en", "de", "es", "fr", "it", "nl", "cs", "sk"]).describe("The new language code"),
	),
});

export const addressSchema = z.object({
	addressId: z.int().describe("The address id"),
	accountId: z.int().describe("The account id"),
	name: z.string().describe("The name of the address"),
	smartlockIds: z.array(z.int()).describe("The smartlocks for this address"),
	serviceId: z.optional(
		z
			.enum(["airbnb", "bookingsync"])
			.describe("The optional service id if the address is from an partner service"),
	),
	timeZone: z.optional(z.string().describe("The timezone")),
	checkInTime: z.optional(z.int().describe("The optional check in time (minutes of the day)")),
	checkOutTime: z.optional(z.int().describe("The optional check out time (minutes of the day)")),
	settings: z.optional(
		z.object({}).catchall(z.object({})).describe("The optional settings object"),
	),
	creationDate: z.string().datetime().describe("The creation date"),
	updateDate: z.string().datetime().describe("The update date"),
});

export const addressCreateSchema = z.object({
	name: z.string().describe("The name of the address"),
	smartlockIds: z.array(z.int()).describe("The smartlocks for this address"),
});

export const addressReservationSchema = z.object({
	id: z.string().describe("The id"),
	addressId: z.int().describe("The address id"),
	accountId: z.int().describe("The account id"),
	email: z.string().describe("The email of the guest"),
	name: z.string().describe("The name of the guest"),
	guests: z.int().describe("The number of guests"),
	guestsIssued: z.int().describe("The number of guests issued"),
	keypadIssued: z.boolean().describe("True if a keypad authorization was issued"),
	state: z.enum(["canceled", "accepted"]).describe("The state"),
	serviceId: z.optional(
		z
			.enum(["airbnb", "bookingsync"])
			.describe("The optional service id if the address is from an partner service"),
	),
	reference: z.optional(z.string().describe("The reference (booking code)")),
	automation: z.int().describe("The automation state"),
	checkedIn: z.optional(
		z
			.boolean()
			.describe(
				"True if the user has checked in, false if the check in is pending, null if it isn't monitored",
			),
	),
	startDate: z.string().datetime().describe("The start date"),
	endDate: z.string().datetime().describe("The end date"),
	updateDate: z.string().datetime().describe("The update date"),
	isCurrentlyIssuingAuth: z.boolean(),
	isCurrentlyRevokingAuth: z.boolean(),
	hasCustomAccessTimes: z.boolean(),
	currentlyRevokingAuth: z.optional(z.boolean()),
	currentlyIssuingAuth: z.optional(z.boolean()),
});

export const addressTokenSchema = z.object({
	id: z.string().describe("The id"),
	addressId: z.int().describe("The address id"),
	creationDate: z.string().datetime().describe("The creation date"),
	redeemDate: z.string().datetime().describe("The redeem date"),
	redeemAccountId: z.int().describe("The redeem account id"),
	inviteKeys: z.optional(z.array(z.string()).describe("The list of invite keys")),
	redeemResult: z.optional(z.enum(["ok", "failed"]).describe("The redeem result")),
});

export const addressTokenInfoSchema = z.object({
	id: z.string().describe("The id"),
	addressName: z.string().describe("The address name"),
	smartlockNames: z.array(z.string()).describe("The associated smartlock names"),
});

export const addressUnitSchema = z.object({
	id: z.optional(z.string().describe("The id")),
	name: z.string().describe("The name of the address unit"),
	addressId: z.optional(z.int().describe("The address id")),
	addressTokenId: z.optional(z.string().describe("The address token id")),
	operationId: z.optional(
		z.string().describe("The operation id - if set it's locked for another operation"),
	),
});

export const addressUnitResponseSchema = z.object({
	id: z.optional(z.string().describe("The id")),
	name: z.string().describe("The name of the address unit"),
	addressId: z.optional(z.int().describe("The address id")),
	addressTokenId: z.optional(z.string().describe("The address token id")),
	operationId: z.optional(
		z.string().describe("The operation id - if set it's locked for another operation"),
	),
	creationDate: z.string().datetime().describe("The creation date"),
	redeemDate: z.string().datetime().describe("The redeem date"),
	redeemResult: z.optional(z.enum(["ok", "failed"]).describe("The redeem result")),
});

export const addressUpdateSchema = z.object({
	name: z.optional(z.string().describe("The name of the address")),
	smartlockIds: z.optional(z.array(z.int()).describe("The smartlocks for this address")),
	settings: z.optional(z.object({}).catchall(z.object({})).describe("The optional settings")),
});

export const advancedApiKeySchema = z.object({
	name: z.string().describe("The name of the company for which you apply for access"),
	country: z
		.string()
		.describe(
			"The country of the headquarter or the country where you are mainly doing business in",
		),
	description: z
		.string()
		.describe(
			"Describe the services and/or products you offer to your customers and how your customers would use Nuki devices in their processes",
		),
	type: z
		.enum(["ONLY_SECRET", "SHORT_RENTAL", "HEALTHCARE", "SMART_HOME", "OTHER"])
		.describe("The application type"),
	webhookStatus: z.optional(
		z.enum(["ACTIVE", "DEACTIVATED"]).describe("The status of the webhook posting automation"),
	),
	url: z
		.string()
		.describe("A website where we can find more information on the company and its business model"),
	email: z
		.string()
		.describe("An email address where we can contact you for checks on your application"),
	webhookUrl: z.string().describe("The URL where our webhooks should point to"),
	webhookFeatures: z
		.array(
			z.enum([
				"DEVICE_STATUS",
				"DEVICE_MASTERDATA",
				"DEVICE_CONFIG",
				"DEVICE_LOGS",
				"DEVICE_AUTHS",
				"ACCOUNT_USER",
			]),
		)
		.refine((items) => new Set(items).size === items.length, {
			message: "Array entries must be unique",
		})
		.describe("The features to trigger webhooks, for all types except 'ONLY_SECRET'"),
	restricted: z.boolean().describe("Whether the advanced API key is restricted"),
	secret: z
		.string()
		.describe("The client secret, visible if application is approved (status >= 'TESTING')"),
	status: z.enum(["INACTIVE", "APPLIED", "TESTING", "ACTIVE"]).describe("The application status"),
	creationDate: z.string().datetime().describe("The creation date"),
	updateDate: z.string().datetime().describe("The update date"),
});

export const advancedApiKeyCreateSchema = z.object({
	name: z.string().describe("The name of the company for which you apply for access"),
	country: z
		.string()
		.describe(
			"The country of the headquarter or the country where you are mainly doing business in",
		),
	description: z
		.string()
		.describe(
			"Describe the services and/or products you offer to your customers and how your customers would use Nuki devices in their processes",
		),
	type: z
		.enum(["ONLY_SECRET", "SHORT_RENTAL", "HEALTHCARE", "SMART_HOME", "OTHER"])
		.describe("The application type"),
	webhookStatus: z.optional(
		z.enum(["ACTIVE", "DEACTIVATED"]).describe("The status of the webhook posting automation"),
	),
	url: z
		.string()
		.describe("A website where we can find more information on the company and its business model"),
	email: z
		.string()
		.describe("An email address where we can contact you for checks on your application"),
	webhookUrl: z.string().describe("The URL where our webhooks should point to"),
	webhookFeatures: z
		.array(
			z.enum([
				"DEVICE_STATUS",
				"DEVICE_MASTERDATA",
				"DEVICE_CONFIG",
				"DEVICE_LOGS",
				"DEVICE_AUTHS",
				"ACCOUNT_USER",
			]),
		)
		.refine((items) => new Set(items).size === items.length, {
			message: "Array entries must be unique",
		})
		.describe("The features to trigger webhooks, for all types except 'ONLY_SECRET'"),
	restricted: z.boolean().describe("Whether the advanced API key is restricted"),
});

export const advancedApiKeyUpdateSchema = z.object({
	webhookUrl: z.string().describe("The URL where our webhooks should point to"),
	webhookFeatures: z
		.array(
			z.enum([
				"DEVICE_STATUS",
				"DEVICE_MASTERDATA",
				"DEVICE_CONFIG",
				"DEVICE_LOGS",
				"DEVICE_AUTHS",
				"ACCOUNT_USER",
			]),
		)
		.refine((items) => new Set(items).size === items.length, {
			message: "Array entries must be unique",
		})
		.describe("The features to trigger webhooks, for all types except 'ONLY_SECRET'"),
});

export const advancedConfirmationResponseSchema = z.object({
	requestId: z
		.string()
		.describe("A UUID to identify the upcoming asynchronously web hook response"),
	error: z.optional(
		z
			.string()
			.describe(
				"Contains error message and smartlock IDs, if auths can not be created because they need subscription.",
			),
	),
});

export const apiKeySchema = z.object({
	apiKeyId: z.int().describe("The id"),
	accountId: z.int().describe("The account id"),
	description: z.optional(z.string().describe("The description")),
	redirectUris: z.optional(z.array(z.string()).describe("The redirect uris")),
	creationDate: z.string().datetime().describe("The creation date"),
	apiKey: z.optional(z.string().describe("The api key")),
});

export const apiKeyAdvancedSchema = z.object({
	name: z.optional(z.string()),
	country: z.optional(z.string()),
	description: z.optional(z.string()),
	type: z.optional(z.enum(["ONLY_SECRET", "SHORT_RENTAL", "HEALTHCARE", "SMART_HOME", "OTHER"])),
	url: z.optional(z.string()),
	email: z.optional(z.string()),
	webhookFeatures: z.optional(
		z
			.array(
				z.enum([
					"DEVICE_STATUS",
					"DEVICE_MASTERDATA",
					"DEVICE_CONFIG",
					"DEVICE_LOGS",
					"DEVICE_AUTHS",
					"ACCOUNT_USER",
				]),
			)
			.refine((items) => new Set(items).size === items.length, {
				message: "Array entries must be unique",
			}),
	),
	webhookUrl: z.optional(z.string()),
	webhookSentSuccessfully: z.optional(z.int()),
	webhookSentErroneous: z.optional(z.int()),
	lastSuccessfulPost: z.optional(z.string().datetime()),
	lastPostDuration: z.optional(z.int()),
	lastPostSuccesful: z.optional(z.boolean()),
	status: z.optional(z.enum(["INACTIVE", "APPLIED", "TESTING", "ACTIVE"])),
	webhookStatus: z.optional(z.enum(["ACTIVE", "DEACTIVATED"])),
	creationDate: z.optional(z.string().datetime()),
	updateDate: z.optional(z.string().datetime()),
	restricted: z.optional(z.boolean()),
});

export const apiKeyCreateSchema = z.object({
	description: z.optional(z.string().describe("The description")),
	redirectUris: z.optional(z.array(z.string()).describe("The list of redirect uris")),
});

export const completableFutureListApiKeySchema = z.object({
	completedExceptionally: z.optional(z.boolean()),
	numberOfDependents: z.optional(z.int()),
	done: z.optional(z.boolean()),
	cancelled: z.optional(z.boolean()),
});

export const apiKeyServiceSchema = z.object({
	get byActiveWebhook() {
		return completableFutureListApiKeySchema.optional();
	},
});

export const apiKeyTokenSchema = z.object({
	id: z.string().describe("The id"),
	accountId: z.int().describe("The account id"),
	description: z.optional(z.string().describe("The description")),
	accessToken: z.optional(z.string().describe("The access token")),
	scopes: z.array(z.string()).describe("The list of scopes"),
	creationDate: z.string().datetime().describe("The creation date"),
});

export const apiKeyTokenCreateSchema = z.object({
	description: z.optional(z.string().describe("The description")),
	scopes: z.optional(z.array(z.string()).describe("The list of scopes")),
});

export const apiKeyTokenUpdateSchema = z.object({
	description: z.optional(z.string().describe("The description")),
	scopes: z.optional(z.array(z.string()).describe("The list of scopes")),
});

export const apiKeyUpdateSchema = z.object({
	description: z.optional(z.string().describe("The description")),
	redirectUris: z.optional(z.array(z.string()).describe("The list of redirect uris")),
});

export const filterSchema = z.object({});

export const levelSchema = z.object({
	name: z.optional(z.string()),
	resourceBundleName: z.optional(z.string()),
	localizedName: z.optional(z.string()),
});

export const formatterSchema = z.object({});

export const errorManagerSchema = z.object({});

export const handlerSchema = z.object({
	get filter() {
		return filterSchema.optional();
	},
	get formatter() {
		return formatterSchema.optional();
	},
	get errorManager() {
		return errorManagerSchema.optional();
	},
	encoding: z.optional(z.string()),
	get level() {
		return levelSchema.optional();
	},
});

export const localeSchema = z.object({
	language: z.optional(z.string()),
	displayName: z.optional(z.string()),
	country: z.optional(z.string()),
	variant: z.optional(z.string()),
	script: z.optional(z.string()),
	unicodeLocaleAttributes: z.optional(
		z.array(z.string()).refine((items) => new Set(items).size === items.length, {
			message: "Array entries must be unique",
		}),
	),
	unicodeLocaleKeys: z.optional(
		z.array(z.string()).refine((items) => new Set(items).size === items.length, {
			message: "Array entries must be unique",
		}),
	),
	displayLanguage: z.optional(z.string()),
	displayScript: z.optional(z.string()),
	displayCountry: z.optional(z.string()),
	displayVariant: z.optional(z.string()),
	extensionKeys: z.optional(
		z.array(z.string()).refine((items) => new Set(items).size === items.length, {
			message: "Array entries must be unique",
		}),
	),
	iso3Language: z.optional(z.string()),
	iso3Country: z.optional(z.string()),
});

export const enumerationStringSchema = z.object({});

export const resourceBundleSchema = z.object({
	get locale() {
		return localeSchema.optional();
	},
	get keys() {
		return enumerationStringSchema.optional();
	},
	baseBundleName: z.optional(z.string()),
});

export const loggerSchema = z.object({
	name: z.optional(z.string()),
	get parent() {
		return loggerSchema.optional();
	},
	get filter() {
		return filterSchema.optional();
	},
	get level() {
		return levelSchema.optional();
	},
	resourceBundleName: z.optional(z.string()),
	get handlers() {
		return z.array(handlerSchema).optional();
	},
	useParentHandlers: z.optional(z.boolean()),
	get resourceBundle() {
		return resourceBundleSchema.optional();
	},
});

export const restletSchema = z.object({
	author: z.optional(z.string()),
	get context() {
		return contextSchema.optional();
	},
	description: z.optional(z.string()),
	name: z.optional(z.string()),
	owner: z.optional(z.string()),
	started: z.optional(z.boolean()),
	get logger() {
		return loggerSchema.optional();
	},
	get application() {
		return applicationSchema.optional();
	},
	stopped: z.optional(z.boolean()),
});

export const parameterSchema = z.object({
	name: z.optional(z.string()),
	value: z.optional(z.string()),
});

export const enrolerSchema = z.object({});

export const verifierSchema = z.object({});

export const scheduledExecutorServiceSchema = z.object({
	terminated: z.optional(z.boolean()),
	shutdown: z.optional(z.boolean()),
});

export const contextSchema = z.object({
	get clientDispatcher() {
		return restletSchema.optional();
	},
	get serverDispatcher() {
		return restletSchema.optional();
	},
	attributes: z.optional(z.object({}).catchall(z.object({}))),
	get logger() {
		return loggerSchema.optional();
	},
	get parameters() {
		return z.array(parameterSchema).optional();
	},
	get defaultEnroler() {
		return enrolerSchema.optional();
	},
	get defaultVerifier() {
		return verifierSchema.optional();
	},
	get executorService() {
		return scheduledExecutorServiceSchema.optional();
	},
});

export const roleSchema = z.object({
	get application() {
		return applicationSchema.optional();
	},
	get childRoles() {
		return z.array(roleSchema).optional();
	},
	description: z.optional(z.string()),
	name: z.optional(z.string()),
});

export const serviceSchema = z.object({
	get context() {
		return contextSchema.optional();
	},
	enabled: z.optional(z.boolean()),
	started: z.optional(z.boolean()),
	stopped: z.optional(z.boolean()),
});

export const connegServiceSchema = z.object({
	get context() {
		return contextSchema.optional();
	},
	enabled: z.optional(z.boolean()),
	started: z.optional(z.boolean()),
	strict: z.optional(z.boolean()),
	stopped: z.optional(z.boolean()),
});

export const converterServiceSchema = z.object({
	get context() {
		return contextSchema.optional();
	},
	enabled: z.optional(z.boolean()),
	started: z.optional(z.boolean()),
	stopped: z.optional(z.boolean()),
});

export const protocolSchema = z.object({
	confidential: z.optional(z.boolean()),
	defaultPort: z.optional(z.int()),
	description: z.optional(z.string()),
	name: z.optional(z.string()),
	schemeName: z.optional(z.string()),
	technicalName: z.optional(z.string()),
	version: z.optional(z.string()),
});

export const referenceSchema = z.object({
	get baseRef() {
		return referenceSchema.optional();
	},
	absolute: z.optional(z.boolean()),
	scheme: z.optional(z.string()),
	opaque: z.optional(z.boolean()),
	authority: z.optional(z.string()),
	relative: z.optional(z.boolean()),
	query: z.optional(z.string()),
	path: z.optional(z.string()),
	userInfo: z.optional(z.string()),
	schemeSpecificPart: z.optional(z.string()),
	fragment: z.optional(z.string()),
	extensions: z.optional(z.string()),
	matrix: z.optional(z.string()),
	get matrixAsForm() {
		return z.array(parameterSchema).optional();
	},
	get queryAsForm() {
		return z.array(parameterSchema).optional();
	},
	extensionsAsArray: z.optional(z.array(z.string())),
	hierarchicalPart: z.optional(z.string()),
	hostDomain: z.optional(z.string()),
	hostIdentifier: z.optional(z.string()),
	hostPort: z.optional(z.int()),
	lastSegment: z.optional(z.string()),
	get parentRef() {
		return referenceSchema.optional();
	},
	relativePart: z.optional(z.string()),
	get relativeRef() {
		return referenceSchema.optional();
	},
	remainingPart: z.optional(z.string()),
	get schemeProtocol() {
		return protocolSchema.optional();
	},
	segments: z.optional(z.array(z.string())),
	get targetRef() {
		return referenceSchema.optional();
	},
	hierarchical: z.optional(z.boolean()),
	identifier: z.optional(z.string()),
});

export const metadataSchema = z.object({
	description: z.optional(z.string()),
	name: z.optional(z.string()),
	get parent() {
		return metadataSchema.optional();
	},
});

export const characterSetSchema = z.object({
	description: z.optional(z.string()),
	name: z.optional(z.string()),
	get parent() {
		return metadataSchema.optional();
	},
});

export const encodingSchema = z.object({
	description: z.optional(z.string()),
	name: z.optional(z.string()),
	get parent() {
		return metadataSchema.optional();
	},
});

export const languageSchema = z.object({
	description: z.optional(z.string()),
	name: z.optional(z.string()),
	subTags: z.optional(z.array(z.string())),
	get parent() {
		return languageSchema.optional();
	},
	primaryTag: z.optional(z.string()),
});

export const mediaTypeSchema = z.object({
	description: z.optional(z.string()),
	name: z.optional(z.string()),
	get parameters() {
		return z.array(parameterSchema).optional();
	},
	get parent() {
		return mediaTypeSchema.optional();
	},
	mainType: z.optional(z.string()),
	concrete: z.optional(z.boolean()),
	subType: z.optional(z.string()),
});

export const metadataServiceSchema = z.object({
	get context() {
		return contextSchema.optional();
	},
	enabled: z.optional(z.boolean()),
	started: z.optional(z.boolean()),
	get defaultCharacterSet() {
		return characterSetSchema.optional();
	},
	get defaultEncoding() {
		return encodingSchema.optional();
	},
	get defaultLanguage() {
		return languageSchema.optional();
	},
	get defaultMediaType() {
		return mediaTypeSchema.optional();
	},
	allEncodingExtensionNames: z.optional(z.array(z.string())),
	allCharacterSetExtensionNames: z.optional(z.array(z.string())),
	allExtensionNames: z.optional(z.array(z.string())),
	allLanguageExtensionNames: z.optional(z.array(z.string())),
	allMediaTypeExtensionNames: z.optional(z.array(z.string())),
	stopped: z.optional(z.boolean()),
});

export const statusServiceSchema = z.object({
	get context() {
		return contextSchema.optional();
	},
	enabled: z.optional(z.boolean()),
	started: z.optional(z.boolean()),
	get connegService() {
		return connegServiceSchema.optional();
	},
	contactEmail: z.optional(z.string()),
	get converterService() {
		return converterServiceSchema.optional();
	},
	get homeRef() {
		return referenceSchema.optional();
	},
	get metadataService() {
		return metadataServiceSchema.optional();
	},
	overwriting: z.optional(z.boolean()),
	stopped: z.optional(z.boolean()),
});

export const rangeServiceSchema = z.object({
	get context() {
		return contextSchema.optional();
	},
	enabled: z.optional(z.boolean()),
	started: z.optional(z.boolean()),
	stopped: z.optional(z.boolean()),
});

export const taskServiceSchema = z.object({
	get context() {
		return contextSchema.optional();
	},
	enabled: z.optional(z.boolean()),
	started: z.optional(z.boolean()),
	corePoolSize: z.optional(z.int()),
	daemon: z.optional(z.boolean()),
	shutdownAllowed: z.optional(z.boolean()),
	terminated: z.optional(z.boolean()),
	shutdown: z.optional(z.boolean()),
	stopped: z.optional(z.boolean()),
});

export const tunnelServiceSchema = z.object({
	get context() {
		return contextSchema.optional();
	},
	enabled: z.optional(z.boolean()),
	started: z.optional(z.boolean()),
	characterSetParameter: z.optional(z.string()),
	encodingParameter: z.optional(z.string()),
	extensionsTunnel: z.optional(z.boolean()),
	headersTunnel: z.optional(z.boolean()),
	languageParameter: z.optional(z.string()),
	mediaTypeParameter: z.optional(z.string()),
	methodHeader: z.optional(z.string()),
	methodParameter: z.optional(z.string()),
	methodTunnel: z.optional(z.boolean()),
	preferencesTunnel: z.optional(z.boolean()),
	queryTunnel: z.optional(z.boolean()),
	userAgentTunnel: z.optional(z.boolean()),
	stopped: z.optional(z.boolean()),
});

export const connectorServiceSchema = z.object({
	get context() {
		return contextSchema.optional();
	},
	enabled: z.optional(z.boolean()),
	started: z.optional(z.boolean()),
	get clientProtocols() {
		return z.array(protocolSchema).optional();
	},
	get serverProtocols() {
		return z.array(protocolSchema).optional();
	},
	stopped: z.optional(z.boolean()),
});

export const decoderServiceSchema = z.object({
	get context() {
		return contextSchema.optional();
	},
	enabled: z.optional(z.boolean()),
	started: z.optional(z.boolean()),
	stopped: z.optional(z.boolean()),
});

export const encoderServiceSchema = z.object({
	get context() {
		return contextSchema.optional();
	},
	enabled: z.optional(z.boolean()),
	started: z.optional(z.boolean()),
	get acceptedMediaTypes() {
		return z.array(mediaTypeSchema).optional();
	},
	get ignoredMediaTypes() {
		return z.array(mediaTypeSchema).optional();
	},
	minimumSize: z.optional(z.int()),
	stopped: z.optional(z.boolean()),
});

export const applicationSchema = z.object({
	author: z.optional(z.string()),
	get context() {
		return contextSchema.optional();
	},
	description: z.optional(z.string()),
	name: z.optional(z.string()),
	owner: z.optional(z.string()),
	started: z.optional(z.boolean()),
	debugging: z.optional(z.boolean()),
	get inboundRoot() {
		return restletSchema.optional();
	},
	get outboundRoot() {
		return restletSchema.optional();
	},
	get roles() {
		return z.array(roleSchema).optional();
	},
	get services() {
		return z.array(serviceSchema).optional();
	},
	get statusService() {
		return statusServiceSchema.optional();
	},
	get connegService() {
		return connegServiceSchema.optional();
	},
	get metadataService() {
		return metadataServiceSchema.optional();
	},
	get converterService() {
		return converterServiceSchema.optional();
	},
	get rangeService() {
		return rangeServiceSchema.optional();
	},
	get taskService() {
		return taskServiceSchema.optional();
	},
	get tunnelService() {
		return tunnelServiceSchema.optional();
	},
	get connectorService() {
		return connectorServiceSchema.optional();
	},
	get decoderService() {
		return decoderServiceSchema.optional();
	},
	get encoderService() {
		return encoderServiceSchema.optional();
	},
	get logger() {
		return loggerSchema.optional();
	},
	get application() {
		return applicationSchema.optional();
	},
	stopped: z.optional(z.boolean()),
});

export const authenticationInfoSchema = z.object({
	nextServerNonce: z.optional(z.string()),
	nonceCount: z.optional(z.int()),
	clientNonce: z.optional(z.string()),
	quality: z.optional(z.string()),
	responseDigest: z.optional(z.string()),
});

export const smartlockWebConfigSchema = z.object({
	batteryWarningPerMailEnabled: z.optional(
		z
			.boolean()
			.describe(
				"True if a battery warning is send via email, if null/not send, the value is not being updated",
			),
	),
	dismissedLiftUpHandleWarning: z.optional(
		z
			.array(z.int())
			.describe(
				"Contains the account ids which have dismissed the lift up handle warning, if null/not send, the value is not being updated. To clear send a empty array []",
			),
	),
});

export const webConfigRequestSchema = z.object({
	smartlockId: z.optional(z.int()),
	get webConfig() {
		return smartlockWebConfigSchema.optional();
	},
});

export const bulkWebConfigRequestSchema = z.object({
	get webConfigRequests() {
		return z.array(webConfigRequestSchema).optional();
	},
});

export const cacheDirectiveSchema = z.object({
	digit: z.optional(z.boolean()),
	name: z.optional(z.string()),
	value: z.optional(z.string()),
});

export const publicKeySchema = z.object({
	encoded: z.optional(z.array(z.string())),
	format: z.optional(z.string()),
	algorithm: z.optional(z.string()),
});

export const certificateSchema = z.object({
	type: z.optional(z.string()),
	encoded: z.optional(z.array(z.string())),
	get publicKey() {
		return publicKeySchema.optional();
	},
});

export const challengeSchemeSchema = z.object({
	description: z.optional(z.string()),
	name: z.optional(z.string()),
	technicalName: z.optional(z.string()),
});

export const challengeRequestSchema = z.object({
	rawValue: z.optional(z.string()),
	get parameters() {
		return z.array(parameterSchema).optional();
	},
	get scheme() {
		return challengeSchemeSchema.optional();
	},
	serverNonce: z.optional(z.string()),
	realm: z.optional(z.string()),
	opaque: z.optional(z.string()),
	digestAlgorithm: z.optional(z.string()),
	qualityOptions: z.optional(z.array(z.string())),
	get domainRefs() {
		return z.array(referenceSchema).optional();
	},
	stale: z.optional(z.boolean()),
});

export const principalSchema = z.object({
	name: z.optional(z.string()),
});

export const challengeResponseSchema = z.object({
	rawValue: z.optional(z.string()),
	get parameters() {
		return z.array(parameterSchema).optional();
	},
	get scheme() {
		return challengeSchemeSchema.optional();
	},
	serverNonce: z.optional(z.string()),
	realm: z.optional(z.string()),
	opaque: z.optional(z.string()),
	digestAlgorithm: z.optional(z.string()),
	clientNonce: z.optional(z.string()),
	get digestRef() {
		return referenceSchema.optional();
	},
	identifier: z.optional(z.string()),
	quality: z.optional(z.string()),
	secret: z.optional(z.array(z.string())),
	secretAlgorithm: z.optional(z.string()),
	serverNounceCount: z.optional(z.int()),
	timeIssued: z.optional(z.int()),
	get principal() {
		return principalSchema.optional();
	},
	serverNounceCountAsHex: z.optional(z.string()),
});

export const preferenceCharacterSetSchema = z.object({
	get metadata() {
		return characterSetSchema.optional();
	},
	get parameters() {
		return z.array(parameterSchema).optional();
	},
	quality: z.optional(z.number()),
});

export const preferenceEncodingSchema = z.object({
	get metadata() {
		return encodingSchema.optional();
	},
	get parameters() {
		return z.array(parameterSchema).optional();
	},
	quality: z.optional(z.number()),
});

export const preferenceLanguageSchema = z.object({
	get metadata() {
		return languageSchema.optional();
	},
	get parameters() {
		return z.array(parameterSchema).optional();
	},
	quality: z.optional(z.number()),
});

export const preferenceMediaTypeSchema = z.object({
	get metadata() {
		return mediaTypeSchema.optional();
	},
	get parameters() {
		return z.array(parameterSchema).optional();
	},
	quality: z.optional(z.number()),
});

export const productSchema = z.object({
	comment: z.optional(z.string()),
	name: z.optional(z.string()),
	version: z.optional(z.string()),
});

export const expectationSchema = z.object({
	name: z.optional(z.string()),
	get parameters() {
		return z.array(parameterSchema).optional();
	},
	value: z.optional(z.string()),
});

export const userSchema = z.object({
	email: z.optional(z.string()),
	firstName: z.optional(z.string()),
	identifier: z.optional(z.string()),
	lastName: z.optional(z.string()),
	secret: z.optional(z.array(z.string())),
	name: z.optional(z.string()),
});

export const clientInfoSchema = z.object({
	get acceptedCharacterSets() {
		return z.array(preferenceCharacterSetSchema).optional();
	},
	get acceptedEncodings() {
		return z.array(preferenceEncodingSchema).optional();
	},
	get acceptedLanguages() {
		return z.array(preferenceLanguageSchema).optional();
	},
	get acceptedMediaTypes() {
		return z.array(preferenceMediaTypeSchema).optional();
	},
	get acceptedPatches() {
		return z.array(preferenceMediaTypeSchema).optional();
	},
	address: z.optional(z.string()),
	agent: z.optional(z.string()),
	agentAttributes: z.optional(z.object({}).catchall(z.string())),
	get agentProducts() {
		return z.array(productSchema).optional();
	},
	authenticated: z.optional(z.boolean()),
	get certificates() {
		return z.array(certificateSchema).optional();
	},
	cipherSuite: z.optional(z.string()),
	get expectations() {
		return z.array(expectationSchema).optional();
	},
	forwardedAddresses: z.optional(z.array(z.string())),
	from: z.optional(z.string()),
	port: z.optional(z.int()),
	get principals() {
		return z.array(principalSchema).optional();
	},
	get roles() {
		return z.array(roleSchema).optional();
	},
	get user() {
		return userSchema.optional();
	},
	upstreamAddress: z.optional(z.string()),
	agentName: z.optional(z.string()),
	agentVersion: z.optional(z.string()),
	get mainAgentProduct() {
		return productSchema.optional();
	},
});

export const companySchema = z.object({
	name: z.optional(z.string()),
	email: z.optional(z.string()),
});

export const completableFutureSchema = z.object({
	completedExceptionally: z.optional(z.boolean()),
	numberOfDependents: z.optional(z.int()),
	done: z.optional(z.boolean()),
	cancelled: z.optional(z.boolean()),
});

export const tagSchema = z.object({
	name: z.optional(z.string()),
	weak: z.optional(z.boolean()),
});

export const conditionsSchema = z.object({
	get match() {
		return z.array(tagSchema).optional();
	},
	modifiedSince: z.optional(z.string().datetime()),
	get noneMatch() {
		return z.array(tagSchema).optional();
	},
	rangeDate: z.optional(z.string().datetime()),
	get rangeTag() {
		return tagSchema.optional();
	},
	unmodifiedSince: z.optional(z.string().datetime()),
});

export const cookieSchema = z.object({
	domain: z.optional(z.string()),
	name: z.optional(z.string()),
	path: z.optional(z.string()),
	value: z.optional(z.string()),
	version: z.optional(z.int()),
});

export const cookieSettingSchema = z.object({
	domain: z.optional(z.string()),
	name: z.optional(z.string()),
	path: z.optional(z.string()),
	value: z.optional(z.string()),
	version: z.optional(z.int()),
	accessRestricted: z.optional(z.boolean()),
	comment: z.optional(z.string()),
	maxAge: z.optional(z.int()),
	secure: z.optional(z.boolean()),
	description: z.optional(z.string()),
});

export const decentralWebhookSchema = z.object({
	id: z.optional(z.int().describe("The identifier")),
	secret: z.optional(z.string().describe("The secret to sign the webhook's payload")),
	webhookUrl: z
		.string()
		.describe("The URL where our webhooks (POST requests) should point to (needs to be https)"),
	webhookFeatures: z
		.array(
			z.enum([
				"DEVICE_STATUS",
				"DEVICE_MASTERDATA",
				"DEVICE_CONFIG",
				"DEVICE_LOGS",
				"DEVICE_AUTHS",
				"ACCOUNT_USER",
			]),
		)
		.refine((items) => new Set(items).size === items.length, {
			message: "Array entries must be unique",
		})
		.describe(
			"The features to trigger webhooks, set values: DEVICE_STATUS, DEVICE_MASTERDATA, DEVICE_CONFIG, DEVICE_LOGS, DEVICE_AUTHS, ACCOUNT_USER",
		),
});

export const digestSchema = z.object({
	algorithm: z.optional(z.string()),
	value: z.optional(z.array(z.string())),
});

export const dispositionSchema = z.object({
	get parameters() {
		return z.array(parameterSchema).optional();
	},
	type: z.optional(z.string()),
	filename: z.optional(z.string()),
});

export const enumerationSchema = z.object({});

export const headerSchema = z.object({
	name: z.optional(z.string()),
	value: z.optional(z.string()),
});

export const inputStreamSchema = z.object({});

export const methodSchema = z.object({
	description: z.optional(z.string()),
	idempotent: z.optional(z.boolean()),
	name: z.optional(z.string()),
	replying: z.optional(z.boolean()),
	safe: z.optional(z.boolean()),
	uri: z.optional(z.string()),
});

export const myAccountSchema = z.object({
	accountId: z.int().describe("The account id"),
	type: z.int().min(0).max(2).describe("The type: 0 .. user, 1 .. company, 2 .. caretaker"),
	email: z.string().describe("The email address"),
	emailVerified: z.optional(z.boolean().describe("true, if the email is verified")),
	name: z.string().describe("The name"),
	masterAccountId: z.optional(z.int().describe("The master account id if it's a sub account")),
	rights: z.optional(
		z
			.int()
			.min(0)
			.max(127)
			.describe(
				"The rights bitmask if it's a sub account: 1 .. manage smartlock, 2 .. operate smartlock, 4 .. manage smartlock config, 8 .. manage smartlock authorizations, 16 .. view smartlock logs, 32 .. manage sub accounts, 64 .. create smartlocks",
			),
	),
	language: z.optional(z.string().describe("The language code")),
	get config() {
		return accountConfigSchema.optional();
	},
	get profile() {
		return accountProfileSchema.optional();
	},
	secret: z.optional(z.array(z.string()).describe("The secret base64 encoded")),
	creationDate: z.string().datetime().describe("The creation date"),
	updateDate: z.string().datetime().describe("The update date"),
	get descent() {
		return accountDescentSchema.optional();
	},
	shsSubscriptionType: z.optional(
		z
			.enum(["BUSINESS", "STANDARD", "BUSINESS_PLUS", "API_ONLY"])
			.describe("subscription type of the account (b2b)"),
	),
	b2bActive: z.optional(z.boolean()),
	get apiTermsOfUse() {
		return termsOfUseSchema.optional();
	},
});

export const namedValueSchema = z.object({
	name: z.optional(z.string()),
	value: z.optional(z.object({})),
});

export const namedValueStringSchema = z.object({
	name: z.optional(z.string()),
	value: z.optional(z.string()),
});

export const notificationSettingSchema = z.object({
	smartlockId: z.optional(
		z
			.int()
			.describe(
				"The smartlock ID, if not set all Smart Locks of the account  are enabled for push notifications",
			),
	),
	triggerEvents: z
		.array(z.string())
		.refine((items) => new Set(items).size === items.length, {
			message: "Array entries must be unique",
		})
		.describe(
			"A set on which push notifications should be triggered: lock, unlock, unlatch, lockngo, open, ring, doorsensor, warnings, smartlock",
		),
	authIds: z.optional(
		z
			.array(z.string())
			.refine((items) => new Set(items).size === items.length, {
				message: "Array entries must be unique",
			})
			.describe(
				"A set of auth IDs to filter push notifications to certain  users or keypads. If no entry push notifications are triggered for all users and keypads",
			),
	),
});

export const notificationSchema = z.object({
	notificationId: z.optional(z.string().describe("The unique notificationId for the notification")),
	referenceId: z.optional(
		z.string().describe("The reference ID, an ID to identify a foreign system"),
	),
	pushId: z.string().describe("The push ID or the POST URL for a webhook"),
	secret: z.optional(
		z
			.string()
			.describe(
				"The 40 byte hex string to sign the checksumof the POST payload if the notification is webhook (os=2)",
			),
	),
	os: z.int().describe("The operating system: 0 .. Android, 1 .. iOS, 2 .. web hook"),
	language: z.optional(
		z.string().describe("The language of push messages: cs, de, en (default), es, fr, it, nl, sk"),
	),
	status: z.optional(z.int().describe("Current state: 0 .. init, 1 .. active, 2 .. failed")),
	lastActiveDate: z.optional(z.string().datetime().describe("The last active date")),
	get settings() {
		return z.array(notificationSettingSchema).describe("Settings per Smart Lock");
	},
});

export const objectIdSchema = z.object({
	timestamp: z.optional(z.int()),
	counter: z.optional(z.int()),
	time: z.optional(z.int()),
	date: z.optional(z.string().datetime()),
	machineIdentifier: z.optional(z.int()),
	processIdentifier: z.optional(z.int()),
	timeSecond: z.optional(z.int()),
});

export const openerIntercomBrandSchema = z.object({
	brandId: z.int().describe("The brand ID"),
	brand: z.string().describe("The brand name"),
});

export const openerIntercomModelSchema = z.object({
	intercomId: z.int().describe("The intercom ID"),
	brandId: z.int().describe("The related brand ID"),
	type: z.int().describe("The type of the model"),
	model: z.string().describe("The model name"),
	verified: z
		.int()
		.describe(
			"Verified Nuki intercom: 1 .. verified to work, 2 .. may be compatible, but not verified, 3 .. not compatible",
		),
	conGndBus: z.string().describe("Connection for ground BUS"),
	conBusAudio: z.string().describe("Connection for audio BUS"),
	conAudioout: z.string().describe("Connection for audio out"),
	conDoorbellPlus: z.string().describe("Connection for doorbell plus"),
	conDoorbellMinus: z.string().describe("Connection for doorbell minus"),
	conOpendoor: z.string().describe("Connection for open the door"),
	conGndAnalogue: z.string().describe("Connection for ground analogue"),
	busModeSwitch: z.int().describe("Settings value for BUS mode switch"),
	busModeSwitchShortCircuitDuration: z
		.int()
		.describe("Settings value for BUS mode switch short cicuit duration"),
	creationDate: z.optional(z.string().datetime().describe("The creation date")),
	updateDate: z.optional(z.string().datetime().describe("The update date")),
});

export const paginationSchema = z.object({
	totalItems: z.optional(z.int()),
	totalPages: z.optional(z.int()),
	currentPage: z.optional(z.int()),
	nextPage: z.optional(z.string()),
	prevPage: z.optional(z.string()),
	pageSize: z.optional(z.int()),
});

export const paginatedResponseSchema = z.object({
	results: z.optional(z.array(z.object({}))),
	get pagination() {
		return paginationSchema.optional();
	},
});

export const preferenceSchema = z.object({
	get metadata() {
		return metadataSchema.optional();
	},
	get parameters() {
		return z.array(parameterSchema).optional();
	},
	quality: z.optional(z.number()),
});

export const rangeSchema = z.object({
	index: z.optional(z.int()),
	instanceSize: z.optional(z.int()),
	size: z.optional(z.int()),
	unitName: z.optional(z.string()),
});

export const readableByteChannelSchema = z.object({
	open: z.optional(z.boolean()),
});

export const readerSchema = z.object({});

export const recipientInfoSchema = z.object({
	get protocol() {
		return protocolSchema.optional();
	},
	comment: z.optional(z.string()),
	name: z.optional(z.string()),
});

export const selectionListenerSchema = z.object({});

export const selectableChannelSchema = z.object({
	registered: z.optional(z.boolean()),
	blocking: z.optional(z.boolean()),
	open: z.optional(z.boolean()),
});

export const wakeupListenerSchema = z.object({});

export const selectionRegistrationSchema = z.object({
	canceling: z.optional(z.boolean()),
	interestOperations: z.optional(z.int()),
	get selectionListener() {
		return selectionListenerSchema.optional();
	},
	readyOperations: z.optional(z.int()),
	get selectableChannel() {
		return selectableChannelSchema.optional();
	},
	get wakeupListener() {
		return wakeupListenerSchema.optional();
	},
	readable: z.optional(z.boolean()),
	writable: z.optional(z.boolean()),
	connectable: z.optional(z.boolean()),
	interestReady: z.optional(z.boolean()),
});

export const representationSchema = z.object({
	get characterSet() {
		return characterSetSchema.optional();
	},
	get encodings() {
		return z.array(encodingSchema).optional();
	},
	get locationRef() {
		return referenceSchema.optional();
	},
	get languages() {
		return z.array(languageSchema).optional();
	},
	get mediaType() {
		return mediaTypeSchema.optional();
	},
	modificationDate: z.optional(z.string().datetime()),
	get tag() {
		return tagSchema.optional();
	},
	available: z.optional(z.boolean()),
	get digest() {
		return digestSchema.optional();
	},
	get disposition() {
		return dispositionSchema.optional();
	},
	expirationDate: z.optional(z.string().datetime()),
	get range() {
		return rangeSchema.optional();
	},
	size: z.optional(z.int()),
	empty: z.optional(z.boolean()),
	get channel() {
		return readableByteChannelSchema.optional();
	},
	transient: z.optional(z.boolean()),
	text: z.optional(z.string()),
	get reader() {
		return readerSchema.optional();
	},
	availableSize: z.optional(z.int()),
	get registration() {
		return selectionRegistrationSchema.optional();
	},
	get stream() {
		return inputStreamSchema.optional();
	},
	selectable: z.optional(z.boolean()),
});

export const uniformSchema = z.object({});

export const stackTraceElementSchema = z.object({
	classLoaderName: z.optional(z.string()),
	moduleName: z.optional(z.string()),
	moduleVersion: z.optional(z.string()),
	methodName: z.optional(z.string()),
	fileName: z.optional(z.string()),
	lineNumber: z.optional(z.int()),
	className: z.optional(z.string()),
	nativeMethod: z.optional(z.boolean()),
});

export const throwableSchema = z.object({
	get cause() {
		return throwableSchema.optional();
	},
	get stackTrace() {
		return z.array(stackTraceElementSchema).optional();
	},
	message: z.optional(z.string()),
	get suppressed() {
		return z.array(throwableSchema).optional();
	},
	localizedMessage: z.optional(z.string()),
});

export const statusSchema = z.object({
	code: z.optional(z.int()),
	description: z.optional(z.string()),
	reasonPhrase: z.optional(z.string()),
	get throwable() {
		return throwableSchema.optional();
	},
	uri: z.optional(z.string()),
	error: z.optional(z.boolean()),
	success: z.optional(z.boolean()),
	serverError: z.optional(z.boolean()),
	connectorError: z.optional(z.boolean()),
	clientError: z.optional(z.boolean()),
	globalError: z.optional(z.boolean()),
	informational: z.optional(z.boolean()),
	redirection: z.optional(z.boolean()),
	recoverableError: z.optional(z.boolean()),
});

export const warningSchema = z.object({
	agent: z.optional(z.string()),
	date: z.optional(z.string().datetime()),
	get status() {
		return statusSchema.optional();
	},
	text: z.optional(z.string()),
});

export const requestSchema = z.object({
	attributes: z.optional(z.object({}).catchall(z.object({}))),
	get cacheDirectives() {
		return z.array(cacheDirectiveSchema).optional();
	},
	date: z.optional(z.string().datetime()),
	get entity() {
		return representationSchema.optional();
	},
	get onError() {
		return uniformSchema.optional();
	},
	get onSent() {
		return uniformSchema.optional();
	},
	get recipientsInfo() {
		return z.array(recipientInfoSchema).optional();
	},
	get warnings() {
		return z.array(warningSchema).optional();
	},
	accessControlRequestHeaders: z.optional(
		z.array(z.string()).refine((items) => new Set(items).size === items.length, {
			message: "Array entries must be unique",
		}),
	),
	get accessControlRequestMethod() {
		return methodSchema.optional();
	},
	get challengeResponse() {
		return challengeResponseSchema.optional();
	},
	get clientInfo() {
		return clientInfoSchema.optional();
	},
	get conditions() {
		return conditionsSchema.optional();
	},
	get cookies() {
		return z.array(cookieSchema).optional();
	},
	get hostRef() {
		return referenceSchema.optional();
	},
	loggable: z.optional(z.boolean()),
	maxForwards: z.optional(z.int()),
	get method() {
		return methodSchema.optional();
	},
	get onResponse() {
		return uniformSchema.optional();
	},
	get originalRef() {
		return referenceSchema.optional();
	},
	get protocol() {
		return protocolSchema.optional();
	},
	get proxyChallengeResponse() {
		return challengeResponseSchema.optional();
	},
	get ranges() {
		return z.array(rangeSchema).optional();
	},
	get referrerRef() {
		return referenceSchema.optional();
	},
	get resourceRef() {
		return referenceSchema.optional();
	},
	get rootRef() {
		return referenceSchema.optional();
	},
	confidential: z.optional(z.boolean()),
	asynchronous: z.optional(z.boolean()),
	entityAvailable: z.optional(z.boolean()),
	expectingResponse: z.optional(z.boolean()),
	synchronous: z.optional(z.boolean()),
	entityAsText: z.optional(z.string()),
	get headers() {
		return z.array(headerSchema).optional();
	},
});

export const reservationAccessTimesUpdateSchema = z.object({
	checkInTime: z.optional(z.int().describe("Custom check in time in minutes from midnight")),
	checkOutTime: z.optional(z.int().describe("Custom check out time in minutes from midnight")),
});

export const serverInfoSchema = z.object({
	acceptingRanges: z.optional(z.boolean()),
	address: z.optional(z.string()),
	agent: z.optional(z.string()),
	port: z.optional(z.int()),
});

export const responseSchema = z.object({
	attributes: z.optional(z.object({}).catchall(z.object({}))),
	get cacheDirectives() {
		return z.array(cacheDirectiveSchema).optional();
	},
	date: z.optional(z.string().datetime()),
	get entity() {
		return representationSchema.optional();
	},
	get onError() {
		return uniformSchema.optional();
	},
	get onSent() {
		return uniformSchema.optional();
	},
	get recipientsInfo() {
		return z.array(recipientInfoSchema).optional();
	},
	get warnings() {
		return z.array(warningSchema).optional();
	},
	accessControlAllowCredentials: z.optional(z.boolean()),
	accessControlAllowHeaders: z.optional(
		z.array(z.string()).refine((items) => new Set(items).size === items.length, {
			message: "Array entries must be unique",
		}),
	),
	get accessControlAllowMethods() {
		return z
			.array(methodSchema)
			.refine((items) => new Set(items).size === items.length, {
				message: "Array entries must be unique",
			})
			.optional();
	},
	accessControlAllowOrigin: z.optional(z.string()),
	accessControlExposeHeaders: z.optional(
		z.array(z.string()).refine((items) => new Set(items).size === items.length, {
			message: "Array entries must be unique",
		}),
	),
	accessControlMaxAge: z.optional(z.int()),
	age: z.optional(z.int()),
	get allowedMethods() {
		return z
			.array(methodSchema)
			.refine((items) => new Set(items).size === items.length, {
				message: "Array entries must be unique",
			})
			.optional();
	},
	get authenticationInfo() {
		return authenticationInfoSchema.optional();
	},
	autoCommitting: z.optional(z.boolean()),
	get challengeRequests() {
		return z.array(challengeRequestSchema).optional();
	},
	committed: z.optional(z.boolean()),
	get cookieSettings() {
		return z.array(cookieSettingSchema).optional();
	},
	dimensions: z.optional(
		z
			.array(
				z.enum([
					"AUTHORIZATION",
					"CHARACTER_SET",
					"CLIENT_ADDRESS",
					"CLIENT_AGENT",
					"UNSPECIFIED",
					"ENCODING",
					"LANGUAGE",
					"MEDIA_TYPE",
					"TIME",
					"ORIGIN",
				]),
			)
			.refine((items) => new Set(items).size === items.length, {
				message: "Array entries must be unique",
			}),
	),
	get locationRef() {
		return referenceSchema.optional();
	},
	get proxyChallengeRequests() {
		return z.array(challengeRequestSchema).optional();
	},
	get request() {
		return requestSchema.optional();
	},
	retryAfter: z.optional(z.string().datetime()),
	get serverInfo() {
		return serverInfoSchema.optional();
	},
	get status() {
		return statusSchema.optional();
	},
	final: z.optional(z.boolean()),
	confidential: z.optional(z.boolean()),
	provisional: z.optional(z.boolean()),
	entityAvailable: z.optional(z.boolean()),
	entityAsText: z.optional(z.string()),
	get headers() {
		return z.array(headerSchema).optional();
	},
});

export const shsSubscriptionSchema = z.object({
	type: z.optional(z.enum(["B2C", "B2B"])),
	state: z.optional(
		z.enum(["ACTIVE", "INACTIVE", "CANCELLED", "EXPIRED", "ON_HOLD", "PENDING", "PENDING_CANCEL"]),
	),
	shsSubscriptionType: z.optional(z.enum(["BUSINESS", "STANDARD", "BUSINESS_PLUS", "API_ONLY"])),
	updateDate: z.optional(z.string().datetime()),
	creationDate: z.optional(z.string().datetime()),
	expirationDate: z.optional(z.string().datetime()),
	isInGracePeriod: z.optional(z.boolean()),
	isGracePeriodWarningDismissed: z.optional(z.boolean()),
	gracePeriodWarningEmailSent: z.optional(z.boolean()),
	contractId: z.optional(z.uuid()),
});

export const smartlockConfigSchema = z.object({
	name: z.string().describe("The name of the smartlock for new users"),
	latitude: z.number().describe("The latitude of the smartlock position"),
	longitude: z.number().describe("The longitude of the smartlock position"),
	capabilities: z.optional(
		z
			.int()
			.min(0)
			.max(2)
			.describe(
				"The capabilities indicate whether door opening via app is possible, RTO is possible or both: 0 .. only door opening possible, 1 .. both possible, 2 .. only RTO possible (only for type=2)",
			),
	),
	autoUnlatch: z.optional(
		z
			.boolean()
			.describe(
				"True if the door should be unlatched on unlocking (knob) (only for type=1 and type=3)",
			),
	),
	liftUpHandle: z.optional(
		z
			.boolean()
			.describe(
				"True if the door has a lift up handle, which is required to be lifted up to lock the door",
			),
	),
	pairingEnabled: z.optional(
		z.boolean().describe("True if the pairing is allowed via the smartlock button"),
	),
	buttonEnabled: z.optional(z.boolean().describe("True if the button on the smartlock is enabled")),
	ledEnabled: z.optional(z.boolean().describe("True if the LED on the smartlock is enabled")),
	ledBrightness: z.optional(
		z.int().describe("The brightness of the LED: 0 .. off, 5 .. max (only for type=1 and type=3)"),
	),
	timezoneOffset: z.int().describe("[deprecated] The timezone offset (in minutes)"),
	daylightSavingMode: z.optional(
		z.int().describe("[deprecated] The daylight saving mode: 0 .. off, 1 .. european"),
	),
	fobPaired: z.optional(z.boolean().describe("True if a fob is paired with the smartlock")),
	fobAction1: z.optional(
		z
			.int()
			.min(0)
			.max(8)
			.describe(
				"The fob action if button is pressed once: type=0/3/4: 0 .. none, 1 .. unlock, 2 .. lock, 3 .. lock 'n' go, 4 .. intelligent (lock/unlocked based on the current state); type=2: 0 .. none, 1 .. toggle ring to open, 2 .. activate ring to open, 3 .. deactivate ring to open, 7 .. open (electric strike actuation), 8 .. ring",
			),
	),
	fobAction2: z.optional(
		z
			.int()
			.min(0)
			.max(8)
			.describe(
				"The fob action if button is pressed twice: type=0/3/4: 0 .. none, 1 .. unlock, 2 .. lock, 3 .. lock 'n' go, 4 .. intelligent (lock/unlocked based on the current state); type=2: 0 .. none, 1 .. toggle ring to open, 2 .. activate ring to open, 3 .. deactivate ring to open, 7 .. open (electric strike actuation), 8 .. ring",
			),
	),
	fobAction3: z.optional(
		z
			.int()
			.min(0)
			.max(8)
			.describe(
				"The fob action if button is pressed 3 times: type=0/3/4: 0 .. none, 1 .. unlock, 2 .. lock, 3 .. lock 'n' go, 4 .. intelligent (lock/unlocked based on the current state); type=2: 0 .. none, 1 .. toggle ring to open, 2 .. activate ring to open, 3 .. deactivate ring to open, 7 .. open (electric strike actuation), 8 .. ring",
			),
	),
	singleLock: z
		.boolean()
		.describe("True if the smartlock should only lock once (instead of twice) (only for type=1)"),
	operatingMode: z.optional(
		z
			.int()
			.describe(
				"The operating mode of the opener (only for type=2): 0x00 .. generic door opener, 0x01 .. analogue intercom, 0x02 .. digital intercom, 0x03 .. digital intercom Siedle, 0x04 .. digital intercom TCS, 0x05 .. digital intercom Bticino, 0x06 .. analog intercom Siedle HTS, 0x07 .. digital intercom STR, 0x08 .. digital intercom Ritto, 0x09 .. digital intercom Fermax, 0x0A .. digital intercom Comelit, 0x0B .. digital intercom Urmet BiBus, 0x0C .. digital intercom Urmet 2Voice, 0x0D .. digital intercom Golmar, 0x0E .. digital intercom SKS, 0x0F .. digital intercom Spare",
			),
	),
	advertisingMode: z
		.int()
		.min(0)
		.max(3)
		.describe(
			"The advertising mode (battery saving): 0 .. automatic, 1 .. normal, 2 .. slow, 3 .. slowest",
		),
	keypadPaired: z.optional(z.boolean().describe("True if a keypad is paired with the smartlock")),
	keypad2Paired: z.optional(
		z.boolean().describe("True if a keypad 2 is paired with the smartlock"),
	),
	homekitState: z.optional(
		z
			.int()
			.min(0)
			.max(3)
			.describe(
				"The homekit state: 0 .. unavailable, 1 .. disabled, 2 .. enabled, 3 .. enabled & paired",
			),
	),
	matterState: z.optional(
		z
			.int()
			.min(0)
			.max(4)
			.describe(
				"The matter state: 0 .. not available, 1 .. disabled and no certificate available, 2 .. disabled, 3 .. enabled, 4 .. enabled & paired",
			),
	),
	timezoneId: z
		.int()
		.min(0)
		.max(45)
		.describe("The timezone id (check https://developer.nuki.io for ids)"),
	deviceType: z.optional(z.int().describe("The device type of a Nuki device")),
	wifiEnabled: z.optional(
		z.boolean().describe("Flag that indicates if the devices internal WIFI module can be used"),
	),
	operationId: z.optional(
		z.string().describe("The operation id - if set it's locked for another operation"),
	),
	productVariant: z.optional(
		z
			.int()
			.min(1)
			.max(3)
			.describe("The product variant for Smartlock 5: 1 .. Go, 2 .. Pro, 3 .. Ultra"),
	),
});

export const smartlockAdvancedConfigSchema = z.object({
	lngTimeout: z.optional(
		z
			.union([
				z.literal(5),
				z.literal(10),
				z.literal(15),
				z.literal(20),
				z.literal(30),
				z.literal(45),
				z.literal(60),
			])
			.describe("Timeout in seconds for lock n go"),
	),
	singleButtonPressAction: z.optional(
		z
			.int()
			.describe(
				"The desired action, if the button is pressed once: 0 .. no action, 1 .. intelligent, 2 .. unlock, 3 .. lock, 4 .. unlatch, 5 .. lock 'n' go, 6 .. show status",
			),
	),
	doubleButtonPressAction: z.optional(
		z
			.int()
			.describe(
				"The desired action, if the button is pressed twice: 0 .. no action, 1 .. intelligent, 2 .. unlock, 3 .. lock, 4 .. unlatch, 5 .. lock 'n' go, 6 .. show status",
			),
	),
	automaticBatteryTypeDetection: z.optional(
		z
			.boolean()
			.describe("Flag that indicates if the automatic detection of the battery type is enabled"),
	),
	unlatchDuration: z.optional(
		z
			.union([
				z.literal(1),
				z.literal(3),
				z.literal(5),
				z.literal(7),
				z.literal(10),
				z.literal(15),
				z.literal(20),
				z.literal(30),
			])
			.describe("Duration in seconds for holding the latch in unlatched position"),
	),
	operationId: z.optional(
		z.string().describe("The operation id - if set it's locked for another operation"),
	),
	totalDegrees: z
		.int()
		.describe("The absolute total position in degrees that has been reached during calibration"),
	singleLockedPositionOffsetDegrees: z
		.int()
		.describe("Offset that alters the single locked position"),
	unlockedToLockedTransitionOffsetDegrees: z.optional(
		z
			.int()
			.describe("Offset that alters the position where transition from unlocked to locked happens"),
	),
	unlockedPositionOffsetDegrees: z.int().describe("Offset that alters the unlocked position"),
	lockedPositionOffsetDegrees: z.int().describe("Offset that alters the locked position"),
	detachedCylinder: z.optional(
		z
			.boolean()
			.describe(
				"Flag that indicates that the inner side of the used cylinder is detached from the outer side",
			),
	),
	batteryType: z
		.int()
		.describe(
			"The type of the batteries present in the smart lock: 0 .. alkali, 1 .. accumulator, 2 .. lithium",
		),
	autoLock: z.optional(
		z
			.boolean()
			.describe(
				"New separate flag with FW >= 2.7.8/1.9.1: The Auto Lock feature automatically locks your door when it has been unlocked for a certain period of time",
			),
	),
	autoLockTimeout: z.optional(
		z
			.int()
			.describe(
				"Seconds until the smart lock relocks itself after it has been unlocked. FW < 2.7.8/1.9.1: No auto relock if value is 0, FW >= 2.7.8/1.9.1: has to be >=2 (defaults to 2 for values <2 if autoLock is set to true)",
			),
	),
	autoUpdateEnabled: z.optional(
		z
			.boolean()
			.describe(
				"Flag that indicates if available firmware updates for the deviceshould be installed automatically",
			),
	),
	motorSpeed: z.optional(
		z
			.int()
			.describe(
				"Field used for setting the motor speed. 0x00 ... standard, 0x01 ... fast, 0x02 ... slow",
			),
	),
	enableSlowSpeedDuringNightmode: z.optional(
		z.boolean().describe("Flag indicating if the slow speed shall be applied during NightMode"),
	),
});

export const smartlockOpenerAdvancedConfigSchema = z.object({
	intercomId: z.int().describe("The database ID of the connected intercom"),
	busModeSwitch: z
		.union([z.literal(0), z.literal(1)])
		.describe("Method to switch between data and analogue mode"),
	shortCircuitDuration: z
		.int()
		.describe("Duration of the short circuit for BUS mode switching in ms"),
	electricStrikeDelay: z
		.int()
		.describe(
			"Delay of electric strike activation in ms after lock action 3 'electric strike actuation'",
		),
	randomElectricStrikeDelay: z
		.boolean()
		.describe(
			"Random electricStrikeDelay (range 3000 - 7000 ms) in order to simulate a person inside actuating the electric strike",
		),
	electricStrikeDuration: z
		.int()
		.describe(
			"Duration in ms of electric strike actuation lock action 3 'electric strike actuation'",
		),
	disableRtoAfterRing: z.boolean().describe("Flag to disable RTO after ring"),
	rtoTimeout: z
		.int()
		.describe("After this period of time in minutes, RTO gets deactivated automatically"),
	doorbellSuppression: z
		.int()
		.describe(
			"The doorbell supression bitmask: first bit (least significant) .. whenever the doorbell rings and CM and RTO are inactive, second bit .. RTO is active, third bit .. CM is active",
		),
	doorbellSuppressionDuration: z
		.int()
		.describe(
			"Duration in ms of doorbell suppression (only in Operating mode 2 'digital Intercom')",
		),
	soundRing: z
		.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3)])
		.describe("The sound for ring: 0 .. no sound, 1 .. Sound1, 2 .. Sound2, 3 .. Sound3"),
	soundOpen: z
		.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3)])
		.describe("The sound for open: 0 .. no sound, 1 .. Sound1, 2 .. Sound2, 3 .. Sound3"),
	soundRto: z
		.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3)])
		.describe("The sound for RTO: 0 .. no sound, 1 .. Sound1, 2 .. Sound2, 3 .. Sound3"),
	soundCm: z
		.union([z.literal(0), z.literal(1), z.literal(2), z.literal(3)])
		.describe("The sound for CM: 0 .. no sound, 1 .. Sound1, 2 .. Sound2, 3 .. Sound3"),
	soundConfirmation: z
		.union([z.literal(0), z.literal(1)])
		.describe("The sound confirmation: 0 .. no sound, 1 .. sound"),
	soundLevel: z.int().describe("The sound level"),
	singleButtonPressAction: z
		.int()
		.describe(
			"The desired action, if the button is pressed once: 0 .. no action, 1 .. toggle RTO, 2 .. activate RTO, 3 .. deactivate RTO, 4 .. toggle CM, 5 .. activate CM, 6 .. deactivate CM, 7 .. open",
		),
	doubleButtonPressAction: z
		.int()
		.describe(
			"The desired action, if the button is pressed twice: 0 .. no action, 1 .. toggle RTO, 2 .. activate RTO, 3 .. deactivate RTO, 4 .. toggle CM, 5 .. activate CM, 6 .. deactivate CM, 7 .. open",
		),
	batteryType: z
		.int()
		.describe(
			"The type of the batteries present in the smart lock: 0 .. alkali, 1 .. accumulator, 2 .. lithium, 3 .. fixed",
		),
	automaticBatteryTypeDetection: z.optional(
		z
			.boolean()
			.describe("Flag that indicates if the automatic detection of the battery type is enabled"),
	),
	autoUpdateEnabled: z.optional(
		z
			.boolean()
			.describe(
				"Flag that indicates if available firmware updates for the deviceshould be installed automatically",
			),
	),
	operationId: z.optional(
		z.string().describe("The operation id - if set it's locked for another operation"),
	),
});

export const smartlockSmartdoorAdvancedConfigSchema = z.object({
	lngTimeout: z.optional(
		z
			.union([
				z.literal(5),
				z.literal(10),
				z.literal(15),
				z.literal(20),
				z.literal(30),
				z.literal(45),
				z.literal(60),
			])
			.describe("Timeout in seconds for lock n go"),
	),
	singleButtonPressAction: z.optional(
		z
			.int()
			.describe(
				"The desired action, if the button is pressed once: 0 .. no action, 1 .. intelligent, 2 .. unlock, 3 .. lock, 4 .. unlatch, 5 .. lock 'n' go, 6 .. show status",
			),
	),
	doubleButtonPressAction: z.optional(
		z
			.int()
			.describe(
				"The desired action, if the button is pressed twice: 0 .. no action, 1 .. intelligent, 2 .. unlock, 3 .. lock, 4 .. unlatch, 5 .. lock 'n' go, 6 .. show status",
			),
	),
	automaticBatteryTypeDetection: z.optional(
		z
			.boolean()
			.describe("Flag that indicates if the automatic detection of the battery type is enabled"),
	),
	unlatchDuration: z.optional(
		z
			.union([
				z.literal(1),
				z.literal(3),
				z.literal(5),
				z.literal(7),
				z.literal(10),
				z.literal(15),
				z.literal(20),
				z.literal(30),
			])
			.describe("Duration in seconds for holding the latch in unlatched position"),
	),
	operationId: z.optional(
		z.string().describe("The operation id - if set it's locked for another operation"),
	),
	buzzerVolume: z.optional(
		z
			.union([z.literal(0), z.literal(1), z.literal(2)])
			.describe("The volume of the buzzer: 0 .. off, 1 .. low, 2 .. normal"),
	),
	supportedBatteryTypes: z.optional(
		z
			.array(z.int())
			.refine((items) => new Set(items).size === items.length, {
				message: "Array entries must be unique",
			})
			.describe(
				"Set of supported battery types: 0 .. alkali, 1 .. accumulator, 2 .. lithium, 3 .. fixed, 254 .. automatic, 255 .. unknown",
			),
	),
	batteryType: z
		.int()
		.describe(
			"The type of the batteries present in the smart lock: 0 .. alkali, 1 .. accumulator, 2 .. lithium, 3 .. fixed, 255 .. unknown",
		),
	autoLockTimeout: z.optional(
		z
			.int()
			.describe(
				"Seconds until the smart lock relocks itself after it has been unlocked. No auto relock if value is 0",
			),
	),
	autoLock: z
		.boolean()
		.describe(
			"The Auto Lock feature automatically locks your door when it has been unlocked for a certain period of time",
		),
});

export const smartlockStateSchema = z.object({
	mode: z
		.int()
		.min(0)
		.max(4)
		.describe(
			"The smartlock mode: 0 .. uninitialized, 1 .. pairing, 2 .. door (default), 3 .. continuous (type=2 only), 4 .. maintenance, 5 .. off-door charging",
		),
	state: z
		.int()
		.min(0)
		.max(255)
		.describe(
			"The smartlock state: type=0/3/4: 0 .. uncalibrated, 1 .. locked, 2 .. unlocking, 3 .. unlocked, 4 .. locking, 5 .. unlatched, 6 .. unlocked (lock 'n' go), 7 .. unlatching, 224 .. Error wrong entry code, 225 .. Error wrong Fingerprint, 254 .. motor blocked, 255 .. undefined; type=2: 0 .. untrained, 1 .. online, 3 .. ring to open active, 5 .. open, 7 .. opening, 253 .. boot run, 255 .. undefined",
		),
	trigger: z
		.int()
		.min(0)
		.max(6)
		.describe(
			" The state trigger: 0 .. system, 1 .. manual, 2 .. button, 3 .. automatic, 4 .. web (type=1 only), 5 .. app (type=1 only), 6 .. continuous mode (type=2 only), 7 .. accessory (type=3 only)",
		),
	lastAction: z
		.int()
		.min(0)
		.max(5)
		.describe(
			"The action: type=0/3/4: 1 .. unlock, 2 .. lock, 3 .. unlatch, 4 .. lock 'n' go, 5 .. lock 'n' go with unlatch; type=1: 1 .. unlock; type=2: 1 .. activate ring to open, 2 .. deactivate ring to open, 3 .. open (electric strike actuation)",
		),
	batteryCritical: z.boolean().describe("True if the battery state of the device is critical"),
	batteryCharging: z.optional(
		z.boolean().describe("True if a Nuki battery pack in a Smart Lock is currently charging"),
	),
	batteryCharge: z.optional(
		z.int().min(0).max(100).describe("Remaining capacity of a Nuki battery pack in %"),
	),
	keypadBatteryCritical: z.optional(
		z
			.boolean()
			.describe(
				"True if the battery of a paired Keypad is critical (only available for supported devices)",
			),
	),
	doorsensorBatteryCritical: z.optional(
		z
			.boolean()
			.describe(
				"True if the battery of a paired doorsensor is critical (only available for supported devices)",
			),
	),
	doorState: z
		.int()
		.min(0)
		.max(255)
		.describe(
			"The door state: 0 .. unavailable/not paired, 1 .. deactivated, 2 .. door closed, 3 .. door opened, 4 .. door state unknown, 5 .. calibrating, 16 .. uncalibrated, 240 .. removed, 255 .. unknown",
		),
	ringToOpenTimer: z
		.int()
		.min(0)
		.max(65535)
		.describe(
			"[deprecated] Remaining ring to open time; 0 if ring to open is not active (type=2 only)",
		),
	ringToOpenEnd: z.optional(
		z
			.string()
			.datetime()
			.describe(
				"End date of ring to open timeout; null if ring to open is not active (type=2 only)",
			),
	),
	nightMode: z.boolean().describe("True if night mode currently active"),
	operationId: z.optional(
		z.string().describe("The operation id - if set it's locked for another operation"),
	),
});

export const smartlockSchema = z.object({
	smartlockId: z.int().describe("The smartlock id"),
	accountId: z.int().describe("The account id"),
	type: z
		.int()
		.describe(
			"The type: 0 .. keyturner, 1 .. box, 2 .. opener, 3 .. smartdoor, 4 .. smartlock 3.0/4. Gen",
		),
	lmType: z.optional(
		z
			.int()
			.describe(
				"The lock mechanism used in the smart door lock: 1 .. MyEVO, 2 .. KFV Genius (only for type = 3)",
			),
	),
	authId: z.int().describe("The authorization id"),
	name: z.string().describe("The name of the smartlock"),
	favorite: z.boolean().describe("The favorite flag"),
	get config() {
		return smartlockConfigSchema.optional();
	},
	get advancedConfig() {
		return smartlockAdvancedConfigSchema.optional();
	},
	get openerAdvancedConfig() {
		return smartlockOpenerAdvancedConfigSchema.optional();
	},
	get smartdoorAdvancedConfig() {
		return smartlockSmartdoorAdvancedConfigSchema.optional();
	},
	get webConfig() {
		return smartlockWebConfigSchema.optional();
	},
	get state() {
		return smartlockStateSchema.optional();
	},
	firmwareVersion: z.optional(z.int().describe("The firmware version")),
	hardwareVersion: z.optional(z.int().describe("The hardware version")),
	operationId: z.optional(
		z.string().describe("The operation id - if set it's locked for another operation"),
	),
	serverState: z
		.int()
		.min(0)
		.max(4)
		.describe(
			"The server state: 0 .. ok, 1 .. unregistered, 2 .. auth uuid invalid, 3 .. auth invalid, 4 .. offline",
		),
	adminPinState: z
		.int()
		.min(0)
		.max(2)
		.describe("The admin pin state: 0 .. ok, 1 .. missing, 2 .. invalid"),
	virtualDevice: z.optional(z.boolean().describe("The flag indicating a virtual Smart Lock")),
	creationDate: z.optional(z.string().datetime().describe("The creation date")),
	updateDate: z.optional(z.string().datetime().describe("The update date")),
	error: z.optional(z.string().describe("In case of any error, it contains the error message")),
	get previousSubscriptions() {
		return z.array(shsSubscriptionSchema).describe("Previous Subscriptions").optional();
	},
	get currentSubscription() {
		return shsSubscriptionSchema.optional();
	},
	region: z.optional(z.int().describe("The region")),
	mountingVariant: z.optional(z.int().describe("The mounting variant")),
	opener: z.optional(z.boolean()),
	box: z.optional(z.boolean()),
	smartDoor: z.optional(z.boolean()),
	keyturner: z.optional(z.boolean()),
});

export const smartlockActionSchema = z.object({
	action: z
		.int()
		.min(0)
		.max(7)
		.describe(
			"The action: type=0/3/4: 1 .. unlock, 2 .. lock, 3 .. unlatch, 4 .. lock 'n' go, 5 .. lock 'n' go with unlatch; type=1: 1 .. unlock; type=2: 1 activate ring to open, 2 .. deactivate ring to open, 3 .. open (electric strike actuation), 6 ... activate continuous mode, 7 ... deactivate continuous mode",
		),
	option: z.optional(
		z.int().min(0).max(7).describe("The option mask: 0 .. none, 2 .. force, 4 .. full lock"),
	),
});

export const smartlockAdminPinUpdateSchema = z.object({
	adminPin: z.int().min(0).max(9999).describe("The admin pin"),
});

export const smartlockAuthSchema = z.object({
	id: z.string().describe("The unique id for the smartlock authorization"),
	smartlockId: z.int().describe("The smartlock id"),
	accountUserId: z.optional(z.int().describe("The id of the linked account user")),
	authId: z.optional(z.int().describe("The smartlock authorization id")),
	code: z.optional(z.int().describe("The keypad code (only for type keypad)")),
	fingerprints: z.optional(z.object({}).catchall(z.string())),
	type: z
		.int()
		.min(0)
		.max(2)
		.describe(
			"The type of the authorization: 0 .. app, 1 .. bridge, 2 .. fob, 3 .. keypad, 13 .. keypad code, 14 .. z-key, 15 .. virtual",
		),
	name: z.string().describe("The name of the authorization (max 32 chars)"),
	enabled: z.boolean().describe("True if the auth is enabled"),
	remoteAllowed: z.boolean().describe("True if the auth has remote access"),
	lockCount: z.int().describe("The lock count"),
	allowedFromDate: z.optional(z.string().datetime().describe("The allowed from date")),
	allowedUntilDate: z.optional(z.string().datetime().describe("The allowed until date")),
	allowedWeekDays: z.optional(
		z
			.int()
			.min(0)
			.max(127)
			.describe(
				"The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday",
			),
	),
	allowedFromTime: z.optional(z.int().describe("The allowed from time (in minutes from midnight)")),
	allowedUntilTime: z.optional(
		z.int().describe("The allowed until time (in minutes from midnight)"),
	),
	lastActiveDate: z.optional(z.string().datetime().describe("The last active date")),
	creationDate: z.optional(z.string().datetime().describe("The creation date")),
	updateDate: z.optional(z.string().datetime().describe("The update date")),
	get operationId() {
		return objectIdSchema.optional();
	},
	error: z.optional(z.string().describe("In case of any error, it contains the error message")),
	appId: z.optional(z.int().describe("The ID of the Nuki App")),
	authTypeAsString: z.optional(z.string()),
});

export const smartlockAuthCreateSchema = z.object({
	name: z.string().describe("The name of the authorization (max 32 chars)"),
	allowedFromDate: z.optional(z.string().datetime().describe("The allowed from date")),
	allowedUntilDate: z.optional(z.string().datetime().describe("The allowed until date")),
	allowedWeekDays: z.optional(
		z
			.int()
			.min(0)
			.max(127)
			.describe(
				"The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday",
			),
	),
	allowedFromTime: z.optional(z.int().describe("The allowed from time (in minutes from midnight)")),
	allowedUntilTime: z.optional(
		z.int().describe("The allowed until time (in minutes from midnight)"),
	),
	accountUserId: z.optional(
		z.int().describe("The id of the linked account user (required if type is NOT 13 .. keypad)"),
	),
	remoteAllowed: z.boolean().describe("True if the auth has remote access"),
	smartActionsEnabled: z.optional(z.boolean().describe("The smart actions enabled flag")),
	type: z.optional(
		z.int().describe("The optional type of the auth 0 .. app (default), 2 .. fob, 13 .. keypad"),
	),
	code: z.optional(z.int().describe("The code of the keypad authorization (only for keypad)")),
});

export const smartlockAuthMultiUpdateSchema = z.object({
	name: z.string().describe("The name of the authorization (max 32 chars)"),
	allowedFromDate: z.optional(z.string().datetime().describe("The allowed from date")),
	allowedUntilDate: z.optional(z.string().datetime().describe("The allowed until date")),
	allowedWeekDays: z.optional(
		z
			.int()
			.min(0)
			.max(127)
			.describe(
				"The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday",
			),
	),
	allowedFromTime: z.optional(z.int().describe("The allowed from time (in minutes from midnight)")),
	allowedUntilTime: z.optional(
		z.int().describe("The allowed until time (in minutes from midnight)"),
	),
	accountUserId: z.optional(z.int().describe("The id of the linked account user")),
	enabled: z.optional(z.boolean().describe("True if the auth is enabled")),
	remoteAllowed: z.optional(z.boolean().describe("True if the auth has remote access")),
	code: z.optional(z.int().describe("The code of the keypad authorization (only for keypad)")),
	id: z.string().describe("The unique id for the smartlock authorization"),
});

export const smartlockAuthUpdateSchema = z.object({
	name: z.string().describe("The name of the authorization (max 32 chars)"),
	allowedFromDate: z.optional(z.string().datetime().describe("The allowed from date")),
	allowedUntilDate: z.optional(z.string().datetime().describe("The allowed until date")),
	allowedWeekDays: z.optional(
		z
			.int()
			.min(0)
			.max(127)
			.describe(
				"The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday",
			),
	),
	allowedFromTime: z.optional(z.int().describe("The allowed from time (in minutes from midnight)")),
	allowedUntilTime: z.optional(
		z.int().describe("The allowed until time (in minutes from midnight)"),
	),
	accountUserId: z.optional(z.int().describe("The id of the linked account user")),
	enabled: z.optional(z.boolean().describe("True if the auth is enabled")),
	remoteAllowed: z.optional(z.boolean().describe("True if the auth has remote access")),
	code: z.optional(z.int().describe("The code of the keypad authorization (only for keypad)")),
});

export const smartlockAuthWithSharedKeyCreateSchema = z.object({
	name: z.string().describe("The name of the authorization (max 32 chars)"),
	allowedFromDate: z.optional(z.string().datetime().describe("The allowed from date")),
	allowedUntilDate: z.optional(z.string().datetime().describe("The allowed until date")),
	allowedWeekDays: z.optional(
		z
			.int()
			.min(0)
			.max(127)
			.describe(
				"The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday",
			),
	),
	allowedFromTime: z.optional(z.int().describe("The allowed from time (in minutes from midnight)")),
	allowedUntilTime: z.optional(
		z.int().describe("The allowed until time (in minutes from midnight)"),
	),
	accountUserId: z.optional(z.int().describe("The id of the linked account user")),
});

export const smartlockLogOpenerLogSchema = z.object({
	activeCm: z.boolean().describe("Flag indicating if continuous mode was active"),
	activeRto: z.boolean().describe("Flag indicating if ring to open was active"),
	source: z
		.int()
		.min(0)
		.max(6)
		.describe(
			"The cause of the activation of ring to open or continuous mode: 0 .. doorbell, 1 .. timecontrol, 2 .. app, 3 .. button, 4 .. fob, 5 .. bridge, 6 .. keypad",
		),
	flagGeoFence: z.boolean().describe("Flag indicating a geo fence induced action"),
	flagForce: z.boolean().describe("Flag indicating a force induced action"),
	flagDoorbellSuppression: z
		.boolean()
		.describe("Flag indicating if doorbell suppression was active"),
});

export const smartlockLogSchema = z.object({
	id: z.string().describe("The unique id for the smartlock log"),
	smartlockId: z.int().describe("The smartlock id"),
	deviceType: z
		.union([z.literal(0), z.literal(2), z.literal(3)])
		.describe("The device type: 0 .. smartlock and box, 2 .. opener, 3 .. smartdoor"),
	accountUserId: z.optional(z.int().describe("The id of the linked account user")),
	authId: z.optional(z.string().describe("The id of the linked smartlock auth")),
	name: z.string().describe("The name"),
	action: z
		.int()
		.min(1)
		.max(255)
		.describe(
			"The action: 1 .. unlock, 2 .. lock, 3 .. unlatch, 4 .. lock'n'go, 5 .. lock'n'go with unlatch, 11 .. Restore reset to default setting, 208 .. door warning ajar, 209 door warning status mismatch, 224 .. doorbell recognition (only Opener), 240 .. door opened, 241 .. door closed, 242 .. door sensor jammed, 243 .. firmware update, 250 .. door log enabled, 251 .. door log disabled, 252 .. initialization, 253 .. calibration, 254 .. log enabled, 255 .. log disabled",
		),
	trigger: z
		.int()
		.min(0)
		.max(255)
		.describe(
			"The trigger: 0 .. system, 1 .. manual, 2 .. button, 3 .. automatic, 4 .. web, 5 .. app, 6 .. auto lock, 7 .. accessory, 255 .. keypad",
		),
	state: z
		.int()
		.min(1)
		.max(255)
		.describe(
			"The completion state: 0 .. Success, 1 .. Motor blocked, 2 .. Canceled, 3 .. Too recent, 4 .. Busy, 5 .. Low motor voltage, 6 .. Clutch failure, 7 .. Motor power failure, 8 .. Incomplete, 9 .. Rejected, 10 .. Rejected night mode, 224 .. Invalid Code, 225 .. Invalid Fingerprint, 226 .. Invalid NFC Tag, 254 .. Other error, 255 .. Unknown error",
		),
	autoUnlock: z.boolean().describe("True if it was an auto unlock"),
	date: z.string().datetime().describe("The log date"),
	get openerLog() {
		return smartlockLogOpenerLogSchema.optional();
	},
	ajarTimeout: z.optional(
		z.int().describe("The door sensor warning ajar timeout (in minutes, only for action = 208)"),
	),
	source: z.optional(
		z
			.int()
			.describe(
				"The source of action: 1 .. Keypad code, 2 .. Fingerprint, 3 .. Tap to Unlock, 0 .. Default",
			),
	),
	error: z.optional(z.string().describe("In case of any error, it contains the error message")),
});

export const smartlockUpdateSchema = z.object({
	name: z.optional(z.string().describe("The new name of the smartlock")),
	favorite: z.optional(z.boolean().describe("True if the smartlock is favorite")),
});

export const smartlocksAuthAdvancedCreateSchema = z.object({
	name: z.string().describe("The name of the authorization (max 32 chars)"),
	allowedFromDate: z.optional(z.string().datetime().describe("The allowed from date")),
	allowedUntilDate: z.optional(z.string().datetime().describe("The allowed until date")),
	allowedWeekDays: z.optional(
		z
			.int()
			.min(0)
			.max(127)
			.describe(
				"The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday",
			),
	),
	allowedFromTime: z.optional(z.int().describe("The allowed from time (in minutes from midnight)")),
	allowedUntilTime: z.optional(
		z.int().describe("The allowed until time (in minutes from midnight)"),
	),
	accountUserId: z.int().describe("The id of the linked account user"),
	smartlockIds: z.array(z.int()).describe("The list of smartlock ids"),
	remoteAllowed: z.boolean().describe("True if the auth has remote access"),
	smartActionsEnabled: z.optional(z.boolean().describe("The smart actions enabled flag")),
});

export const smartlocksAuthCreateSchema = z.object({
	name: z.string().describe("The name of the authorization (max 32 chars)"),
	allowedFromDate: z.optional(z.string().datetime().describe("The allowed from date")),
	allowedUntilDate: z.optional(z.string().datetime().describe("The allowed until date")),
	allowedWeekDays: z.optional(
		z
			.int()
			.min(0)
			.max(127)
			.describe(
				"The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday",
			),
	),
	allowedFromTime: z.optional(z.int().describe("The allowed from time (in minutes from midnight)")),
	allowedUntilTime: z.optional(
		z.int().describe("The allowed until time (in minutes from midnight)"),
	),
	accountUserId: z.optional(
		z.int().describe("The id of the linked account user (required if type is NOT 13 .. keypad)"),
	),
	smartlockIds: z.optional(z.array(z.int()).describe("The list of smartlock ids")),
	remoteAllowed: z.boolean().describe("True if the auth has remote access"),
	smartActionsEnabled: z.optional(z.boolean().describe("The smart actions enabled flag")),
	type: z.optional(
		z.int().describe("The optional type of the auth 0 .. app (default), 2 .. fob, 13 .. keypad"),
	),
	code: z.optional(z.int().describe("The code of the keypad authorization (only for keypad)")),
});

export const variantSchema = z.object({
	get characterSet() {
		return characterSetSchema.optional();
	},
	get encodings() {
		return z.array(encodingSchema).optional();
	},
	get locationRef() {
		return referenceSchema.optional();
	},
	get languages() {
		return z.array(languageSchema).optional();
	},
	get mediaType() {
		return mediaTypeSchema.optional();
	},
});

export const webhookMessageSchema = z.object({
	headers: z.object({}).catchall(z.string()).describe("Http Headers as key value pairs"),
	body: z.optional(z.object({}).catchall(z.object({})).describe("Http Body as Json")),
	timestamp: z.optional(
		z.string().datetime().describe("The timestamp when the message was created"),
	),
	path: z.string().describe("Path of the message"),
});

export const webhookLogSchema = z.object({
	id: z.string().describe("The WebhookLog id"),
	requestId: z.optional(
		z.string().describe("Request id, set when api-triggered request otherwise empty"),
	),
	succeeded: z.optional(z.boolean().describe("If the webhooks sends the data successfully")),
	responseStatus: z.optional(z.int().describe("Http Status code of the webhook response")),
	duration: z.optional(z.int().describe("The duration of the webhook in milli seconds")),
	accountId: z.int().describe("The account id"),
	get request() {
		return webhookMessageSchema.optional();
	},
	get response() {
		return webhookMessageSchema.optional();
	},
	apiKeyId: z.int().describe("Used Api Key for the webhook"),
	updated: z.string().datetime().describe("last updated time"),
	created: z.string().datetime().describe("Creation Date"),
});

/**
 * @description successful operation
 */
export const getAccountsResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getAccountsResource401Schema = z.unknown();

export const getAccountsResourceQueryResponseSchema = z.lazy(() => getAccountsResource200Schema);

export const postAccountsResourceQueryParamsSchema = z.object({
	deleteApiTokens: z
		.boolean()
		.default(true)
		.describe("If false existing API tokens are not deleted if the password is changed"),
});

/**
 * @description Ok
 */
export const postAccountsResource204Schema = z.unknown();

/**
 * @description Invalid E-Mail address or name supplied
 */
export const postAccountsResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postAccountsResource401Schema = z.unknown();

/**
 * @description E-Mail address already exists
 */
export const postAccountsResource409Schema = z.unknown();

/**
 * @description Account update representation
 */
export const postAccountsResourceMutationRequestSchema = z.lazy(() => accountUpdateSchema);

export const postAccountsResourceMutationResponseSchema = z.lazy(
	() => postAccountsResource204Schema,
);

/**
 * @description Ok
 */
export const deleteAccountsResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteAccountsResource401Schema = z.unknown();

export const deleteAccountsResourceMutationResponseSchema = z.lazy(
	() => deleteAccountsResource204Schema,
);

/**
 * @description Ok
 */
export const postAccountEmailChangeResource204Schema = z.unknown();

/**
 * @description Email not in valid format
 */
export const postAccountEmailChangeResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postAccountEmailChangeResource401Schema = z.unknown();

/**
 * @description Other account is already using the email
 */
export const postAccountEmailChangeResource409Schema = z.unknown();

/**
 * @description Account email change representation
 */
export const postAccountEmailChangeResourceMutationRequestSchema = z.lazy(
	() => accountEmailChangeSchema,
);

export const postAccountEmailChangeResourceMutationResponseSchema = z.lazy(
	() => postAccountEmailChangeResource204Schema,
);

/**
 * @description Ok
 */
export const postAccountEmailVerifyResource204Schema = z.unknown();

/**
 * @description Email not in valid format
 */
export const postAccountEmailVerifyResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postAccountEmailVerifyResource401Schema = z.unknown();

/**
 * @description Other account is already using the email
 */
export const postAccountEmailVerifyResource409Schema = z.unknown();

export const postAccountEmailVerifyResourceMutationResponseSchema = z.lazy(
	() => postAccountEmailVerifyResource204Schema,
);

/**
 * @description successful operation
 */
export const getAccountIntegrationsResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getAccountIntegrationsResource401Schema = z.unknown();

export const getAccountIntegrationsResourceQueryResponseSchema = z.lazy(
	() => getAccountIntegrationsResource200Schema,
);

export const deleteAccountIntegrationsResourceQueryParamsSchema = z
	.object({
		apiKeyId: z.optional(
			z.coerce
				.number()
				.int()
				.describe(
					"The api key id to delete (this also removes all tokens if no specific tokenId is given)",
				),
		),
		tokenId: z.optional(
			z.coerce
				.number()
				.int()
				.describe("The token id if a specific token has to be deleted but not the full api key"),
		),
	})
	.optional();

/**
 * @description Ok
 */
export const deleteAccountIntegrationsResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteAccountIntegrationsResource401Schema = z.unknown();

export const deleteAccountIntegrationsResourceMutationResponseSchema = z.lazy(
	() => deleteAccountIntegrationsResource204Schema,
);

/**
 * @description Ok
 */
export const postAccountOtpResource204Schema = z.unknown();

/**
 * @description One time password empty
 */
export const postAccountOtpResource400Schema = z.unknown();

/**
 * @description Not authorized or one time password wrong
 */
export const postAccountOtpResource401Schema = z.unknown();

/**
 * @description Too many failed attempts
 */
export const postAccountOtpResource429Schema = z.unknown();

/**
 * @description Account one time password enable representation
 */
export const postAccountOtpResourceMutationRequestSchema = z.lazy(() => accountOtpEnableSchema);

export const postAccountOtpResourceMutationResponseSchema = z.lazy(
	() => postAccountOtpResource204Schema,
);

/**
 * @description Ok
 */
export const putAccountOtpResource200Schema = z.unknown();

/**
 * @description One time password is already enabled
 */
export const putAccountOtpResource405Schema = z.unknown();

export const putAccountOtpResourceMutationResponseSchema = z.lazy(
	() => putAccountOtpResource200Schema,
);

/**
 * @description Ok
 */
export const deleteAccountOtpResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteAccountOtpResource401Schema = z.unknown();

export const deleteAccountOtpResourceMutationResponseSchema = z.lazy(
	() => deleteAccountOtpResource204Schema,
);

/**
 * @description Ok
 */
export const postAccountPasswordResetResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postAccountPasswordResetResource401Schema = z.unknown();

/**
 * @description Account password reset representation
 */
export const postAccountPasswordResetResourceMutationRequestSchema = z.lazy(
	() => accountPasswordResetSchema,
);

export const postAccountPasswordResetResourceMutationResponseSchema = z.lazy(
	() => postAccountPasswordResetResource204Schema,
);

/**
 * @description successful operation
 */
export const getAccountSettingResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getAccountSettingResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const getAccountSettingResource403Schema = z.unknown();

/**
 * @description Not found
 */
export const getAccountSettingResource404Schema = z.unknown();

export const getAccountSettingResourceQueryResponseSchema = z.lazy(
	() => getAccountSettingResource200Schema,
);

/**
 * @description successful operation
 */
export const putAccountSettingResource200Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const putAccountSettingResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const putAccountSettingResource401Schema = z.unknown();

/**
 * @description Account setting representation
 */
export const putAccountSettingResourceMutationRequestSchema = z.lazy(() => accountSettingSchema);

export const putAccountSettingResourceMutationResponseSchema = z.lazy(
	() => putAccountSettingResource200Schema,
);

/**
 * @description Ok
 */
export const deleteAccountSettingResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteAccountSettingResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const deleteAccountSettingResource403Schema = z.unknown();

export const deleteAccountSettingResourceMutationResponseSchema = z.lazy(
	() => deleteAccountSettingResource204Schema,
);

export const getAccountSubsResourceQueryParamsSchema = z
	.object({
		email: z.optional(z.string().describe("The optional email (regex)")),
	})
	.optional();

/**
 * @description successful operation
 */
export const getAccountSubsResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getAccountSubsResource401Schema = z.unknown();

export const getAccountSubsResourceQueryResponseSchema = z.lazy(
	() => getAccountSubsResource200Schema,
);

/**
 * @description Ok
 */
export const putAccountSubsResource200Schema = z.unknown();

/**
 * @description Invalid parameter supplied
 */
export const putAccountSubsResource400Schema = z.unknown();

/**
 * @description Account sub create representation
 */
export const putAccountSubsResourceMutationRequestSchema = z.lazy(() => accountSubCreateSchema);

export const putAccountSubsResourceMutationResponseSchema = z.lazy(
	() => putAccountSubsResource200Schema,
);

export const getAccountSubResourcePathParamsSchema = z.object({
	accountId: z.coerce.number().int().describe("The account id"),
});

/**
 * @description successful operation
 */
export const getAccountSubResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getAccountSubResource401Schema = z.unknown();

export const getAccountSubResourceQueryResponseSchema = z.lazy(
	() => getAccountSubResource200Schema,
);

export const postAccountSubResourcePathParamsSchema = z.object({
	accountId: z.coerce.number().int().describe("The account id"),
});

/**
 * @description Ok
 */
export const postAccountSubResource204Schema = z.unknown();

/**
 * @description Invalid parameter supplied
 */
export const postAccountSubResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postAccountSubResource401Schema = z.unknown();

/**
 * @description E-Mail address already exists
 */
export const postAccountSubResource409Schema = z.unknown();

/**
 * @description Account update representation
 */
export const postAccountSubResourceMutationRequestSchema = z.lazy(() => accountSubUpdateSchema);

export const postAccountSubResourceMutationResponseSchema = z.lazy(
	() => postAccountSubResource204Schema,
);

export const deleteAccountSubResourcePathParamsSchema = z.object({
	accountId: z.coerce.number().int().describe("The account id"),
});

/**
 * @description Ok
 */
export const deleteAccountSubResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteAccountSubResource401Schema = z.unknown();

export const deleteAccountSubResourceMutationResponseSchema = z.lazy(
	() => deleteAccountSubResource204Schema,
);

export const getAccountUsersResourceQueryParamsSchema = z
	.object({
		email: z.optional(z.string().describe("Filter for email")),
		offset: z.optional(
			z.coerce.number().int().describe("The offset of the first user in the collection to return"),
		),
		limit: z.optional(
			z.coerce
				.number()
				.int()
				.describe(
					"The maximum number of users to return. If the value exceeds the maximum, then the maximum value will be used.",
				),
		),
	})
	.optional();

/**
 * @description successful operation
 */
export const getAccountUsersResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getAccountUsersResource401Schema = z.unknown();

export const getAccountUsersResourceQueryResponseSchema = z.lazy(
	() => getAccountUsersResource200Schema,
);

/**
 * @description Ok
 */
export const putAccountUsersResource200Schema = z.unknown();

/**
 * @description Invalid E-Mail address or name supplied
 */
export const putAccountUsersResource400Schema = z.unknown();

/**
 * @description Account sub create representation
 */
export const putAccountUsersResourceMutationRequestSchema = z.lazy(() => accountUserCreateSchema);

export const putAccountUsersResourceMutationResponseSchema = z.lazy(
	() => putAccountUsersResource200Schema,
);

export const getAccountUserResourcePathParamsSchema = z.object({
	accountUserId: z.coerce.number().int().describe("The account user id"),
});

/**
 * @description successful operation
 */
export const getAccountUserResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getAccountUserResource401Schema = z.unknown();

export const getAccountUserResourceQueryResponseSchema = z.lazy(
	() => getAccountUserResource200Schema,
);

export const postAccountUserResourcePathParamsSchema = z.object({
	accountUserId: z.coerce.number().int().describe("The account user id"),
});

/**
 * @description successful operation
 */
export const postAccountUserResource200Schema = z.unknown();

/**
 * @description Ok
 */
export const postAccountUserResource204Schema = z.unknown();

/**
 * @description Invalid E-Mail address or name supplied
 */
export const postAccountUserResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postAccountUserResource401Schema = z.unknown();

/**
 * @description E-Mail address already exists
 */
export const postAccountUserResource409Schema = z.unknown();

/**
 * @description Account update representation
 */
export const postAccountUserResourceMutationRequestSchema = z.lazy(() => accountUserUpdateSchema);

export const postAccountUserResourceMutationResponseSchema = z.union([
	z.lazy(() => postAccountUserResource200Schema),
	z.lazy(() => postAccountUserResource204Schema),
]);

export const deleteAccountUserResourcePathParamsSchema = z.object({
	accountUserId: z.coerce.number().int().describe("The account user id"),
});

/**
 * @description Ok
 */
export const deleteAccountUserResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteAccountUserResource401Schema = z.unknown();

/**
 * @description Locked
 */
export const deleteAccountUserResource423Schema = z.unknown();

export const deleteAccountUserResourceMutationResponseSchema = z.lazy(
	() => deleteAccountUserResource204Schema,
);

/**
 * @description successful operation
 */
export const getAddressesResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getAddressesResource401Schema = z.unknown();

export const getAddressesResourceQueryResponseSchema = z.lazy(() => getAddressesResource200Schema);

/**
 * @description Ok
 */
export const putAddressesResource200Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const putAddressesResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const putAddressesResource401Schema = z.unknown();

/**
 * @description Address create representation
 */
export const putAddressesResourceMutationRequestSchema = z.lazy(() => addressCreateSchema);

export const putAddressesResourceMutationResponseSchema = z.lazy(
	() => putAddressesResource200Schema,
);

export const getAddressTokenResourcePathParamsSchema = z.object({
	id: z.string().describe("The token id"),
});

/**
 * @description successful operation
 */
export const getAddressTokenResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getAddressTokenResource401Schema = z.unknown();

/**
 * @description Token not found
 */
export const getAddressTokenResource404Schema = z.unknown();

export const getAddressTokenResourceQueryResponseSchema = z.lazy(
	() => getAddressTokenResource200Schema,
);

export const getAddressTokenRedeemResourcePathParamsSchema = z.object({
	id: z.string().describe("The token id"),
});

/**
 * @description successful operation
 */
export const getAddressTokenRedeemResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getAddressTokenRedeemResource401Schema = z.unknown();

/**
 * @description Token not found
 */
export const getAddressTokenRedeemResource404Schema = z.unknown();

export const getAddressTokenRedeemResourceQueryResponseSchema = z.lazy(
	() => getAddressTokenRedeemResource200Schema,
);

export const postAddressTokenRedeemResourcePathParamsSchema = z.object({
	id: z.string().describe("The token id"),
});

export const postAddressTokenRedeemResourceQueryParamsSchema = z
	.object({
		email: z.optional(z.boolean().describe("If false no email will be send")),
	})
	.optional();

/**
 * @description Ok
 */
export const postAddressTokenRedeemResource204Schema = z.unknown();

/**
 * @description Invalid parameter given
 */
export const postAddressTokenRedeemResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postAddressTokenRedeemResource401Schema = z.unknown();

/**
 * @description Token not found
 */
export const postAddressTokenRedeemResource404Schema = z.unknown();

export const postAddressTokenRedeemResourceMutationResponseSchema = z.lazy(
	() => postAddressTokenRedeemResource204Schema,
);

export const postAddressResourcePathParamsSchema = z.object({
	addressId: z.coerce.number().int().describe("The address id"),
});

/**
 * @description Ok
 */
export const postAddressResource204Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postAddressResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postAddressResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const postAddressResource403Schema = z.unknown();

/**
 * @description Address update representation
 */
export const postAddressResourceMutationRequestSchema = z.lazy(() => addressUpdateSchema);

export const postAddressResourceMutationResponseSchema = z.lazy(() => postAddressResource204Schema);

export const deleteAddressResourcePathParamsSchema = z.object({
	addressId: z.coerce.number().int().describe("The address id"),
});

/**
 * @description Ok
 */
export const deleteAddressResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteAddressResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const deleteAddressResource403Schema = z.unknown();

export const deleteAddressResourceMutationResponseSchema = z.lazy(
	() => deleteAddressResource204Schema,
);

export const getAddressReservationsResourcePathParamsSchema = z.object({
	addressId: z.coerce.number().int().describe("The address id"),
});

/**
 * @description successful operation
 */
export const getAddressReservationsResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getAddressReservationsResource401Schema = z.unknown();

export const getAddressReservationsResourceQueryResponseSchema = z.lazy(
	() => getAddressReservationsResource200Schema,
);

export const postAddressReservationIssueResourcePathParamsSchema = z.object({
	addressId: z.coerce.number().int().describe("The address id"),
	id: z.string().describe("The address reservation id"),
});

/**
 * @description Ok
 */
export const postAddressReservationIssueResource204Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postAddressReservationIssueResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postAddressReservationIssueResource401Schema = z.unknown();

export const postAddressReservationIssueResourceMutationResponseSchema = z.lazy(
	() => postAddressReservationIssueResource204Schema,
);

export const postAddressReservationRevokeResourcePathParamsSchema = z.object({
	addressId: z.coerce.number().int().describe("The address id"),
	id: z.string().describe("The address reservation id"),
});

/**
 * @description Ok
 */
export const postAddressReservationRevokeResource204Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postAddressReservationRevokeResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postAddressReservationRevokeResource401Schema = z.unknown();

export const postAddressReservationRevokeResourceMutationResponseSchema = z.lazy(
	() => postAddressReservationRevokeResource204Schema,
);

export const postReservationAccessTimesUpdateResourcePathParamsSchema = z.object({
	addressId: z.coerce.number().int().describe("The address id"),
	id: z.string().describe("The reservation id"),
});

/**
 * @description Ok
 */
export const postReservationAccessTimesUpdateResource204Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postReservationAccessTimesUpdateResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postReservationAccessTimesUpdateResource401Schema = z.unknown();

/**
 * @description Reservation access times update representation
 */
export const postReservationAccessTimesUpdateResourceMutationRequestSchema = z.lazy(
	() => reservationAccessTimesUpdateSchema,
);

export const postReservationAccessTimesUpdateResourceMutationResponseSchema = z.lazy(
	() => postReservationAccessTimesUpdateResource204Schema,
);

export const getAddressTokensResourcePathParamsSchema = z.object({
	addressId: z.coerce.number().int().describe("The address id"),
});

/**
 * @description successful operation
 */
export const getAddressTokensResource200Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const getAddressTokensResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getAddressTokensResource401Schema = z.unknown();

export const getAddressTokensResourceQueryResponseSchema = z.lazy(
	() => getAddressTokensResource200Schema,
);

export const getAddressUnitsResourcePathParamsSchema = z.object({
	addressId: z.coerce.number().int().describe("The address id"),
});

/**
 * @description successful operation
 */
export const getAddressUnitsResource200Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const getAddressUnitsResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getAddressUnitsResource401Schema = z.unknown();

export const getAddressUnitsResourceQueryResponseSchema = z.lazy(
	() => getAddressUnitsResource200Schema,
);

export const putAddressUnitsResourcePathParamsSchema = z.object({
	addressId: z.coerce.number().int().describe("The address id"),
});

/**
 * @description Ok
 */
export const putAddressUnitsResource200Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const putAddressUnitsResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const putAddressUnitsResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const putAddressUnitsResource403Schema = z.unknown();

/**
 * @description Address unit representation
 */
export const putAddressUnitsResourceMutationRequestSchema = z
	.lazy(() => addressUnitSchema)
	.unwrap()
	.omit({ id: true, addressId: true, addressTokenId: true, operationId: true });

export const putAddressUnitsResourceMutationResponseSchema = z.lazy(
	() => putAddressUnitsResource200Schema,
);

export const deleteAddressUnitsResourcePathParamsSchema = z.object({
	addressId: z.coerce.number().int().describe("The address id"),
});

/**
 * @description Ok
 */
export const deleteAddressUnitsResource200Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const deleteAddressUnitsResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteAddressUnitsResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const deleteAddressUnitsResource403Schema = z.unknown();

/**
 * @description Locked
 */
export const deleteAddressUnitsResource423Schema = z.unknown();

/**
 * @description Address unit IDs to delete
 */
export const deleteAddressUnitsResourceMutationRequestSchema = z.array(z.string());

export const deleteAddressUnitsResourceMutationResponseSchema = z.lazy(
	() => deleteAddressUnitsResource200Schema,
);

export const deleteAddressUnitResourcePathParamsSchema = z.object({
	addressId: z.coerce.number().int().describe("The address id"),
	id: z.string().describe("The address unit id"),
});

/**
 * @description Ok
 */
export const deleteAddressUnitResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteAddressUnitResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const deleteAddressUnitResource403Schema = z.unknown();

/**
 * @description Locked
 */
export const deleteAddressUnitResource423Schema = z.unknown();

export const deleteAddressUnitResourceMutationResponseSchema = z.lazy(
	() => deleteAddressUnitResource200Schema,
);

/**
 * @description successful operation
 */
export const getDecentralWebhooksResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getDecentralWebhooksResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const getDecentralWebhooksResource403Schema = z.unknown();

export const getDecentralWebhooksResourceQueryResponseSchema = z.lazy(
	() => getDecentralWebhooksResource200Schema,
);

/**
 * @description successful operation
 */
export const putDecentralWebhooksResource200Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const putDecentralWebhooksResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const putDecentralWebhooksResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const putDecentralWebhooksResource403Schema = z.unknown();

/**
 * @description Decentral webhook representation
 */
export const putDecentralWebhooksResourceMutationRequestSchema = z
	.lazy(() => decentralWebhookSchema)
	.unwrap()
	.omit({ id: true, secret: true });

export const putDecentralWebhooksResourceMutationResponseSchema = z.lazy(
	() => putDecentralWebhooksResource200Schema,
);

export const deleteDecentralWebhookResourcePathParamsSchema = z.object({
	id: z.coerce.number().int().describe("The ID of the decentral webhook"),
});

/**
 * @description Ok
 */
export const deleteDecentralWebhookResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteDecentralWebhookResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const deleteDecentralWebhookResource403Schema = z.unknown();

export const deleteDecentralWebhookResourceMutationResponseSchema = z.lazy(
	() => deleteDecentralWebhookResource204Schema,
);

/**
 * @description successful operation
 */
export const getApiKeysResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getApiKeysResource401Schema = z.unknown();

export const getApiKeysResourceQueryResponseSchema = z.lazy(() => getApiKeysResource200Schema);

/**
 * @description Ok
 */
export const putApiKeysResource200Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const putApiKeysResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const putApiKeysResource401Schema = z.unknown();

/**
 * @description Api key create representation
 */
export const putApiKeysResourceMutationRequestSchema = z.lazy(() => apiKeyCreateSchema);

export const putApiKeysResourceMutationResponseSchema = z.lazy(() => putApiKeysResource200Schema);

export const postApiKeyResourcePathParamsSchema = z.object({
	apiKeyId: z.coerce.number().int().describe("The api key id"),
});

/**
 * @description Ok
 */
export const postApiKeyResource204Schema = z.unknown();

/**
 * @description Invalid parameter given
 */
export const postApiKeyResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postApiKeyResource401Schema = z.unknown();

/**
 * @description Api key update representation
 */
export const postApiKeyResourceMutationRequestSchema = z.lazy(() => apiKeyUpdateSchema);

export const postApiKeyResourceMutationResponseSchema = z.lazy(() => postApiKeyResource204Schema);

export const deleteApiKeyResourcePathParamsSchema = z.object({
	apiKeyId: z.coerce.number().int().describe("The api key id"),
});

/**
 * @description Ok
 */
export const deleteApiKeyResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteApiKeyResource401Schema = z.unknown();

export const deleteApiKeyResourceMutationResponseSchema = z.lazy(
	() => deleteApiKeyResource204Schema,
);

export const getApiKeyAdvancedResourcePathParamsSchema = z.object({
	apiKeyId: z.coerce.number().int().describe("The api key id"),
});

/**
 * @description successful operation
 */
export const getApiKeyAdvancedResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getApiKeyAdvancedResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const getApiKeyAdvancedResource403Schema = z.unknown();

/**
 * @description Not found
 */
export const getApiKeyAdvancedResource404Schema = z.unknown();

export const getApiKeyAdvancedResourceQueryResponseSchema = z.lazy(
	() => getApiKeyAdvancedResource200Schema,
);

export const postApiKeyAdvancedResourcePathParamsSchema = z.object({
	apiKeyId: z.coerce.number().int().describe("The api key id"),
});

/**
 * @description Ok
 */
export const postApiKeyAdvancedResource204Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postApiKeyAdvancedResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postApiKeyAdvancedResource401Schema = z.unknown();

/**
 * @description Update for advaced api key representation
 */
export const postApiKeyAdvancedResourceMutationRequestSchema = z.lazy(
	() => advancedApiKeyUpdateSchema,
);

export const postApiKeyAdvancedResourceMutationResponseSchema = z.lazy(
	() => postApiKeyAdvancedResource204Schema,
);

export const putApiKeyAdvancedResourcePathParamsSchema = z.object({
	apiKeyId: z.coerce.number().int().describe("The api key id"),
});

/**
 * @description Ok
 */
export const putApiKeyAdvancedResource204Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const putApiKeyAdvancedResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const putApiKeyAdvancedResource401Schema = z.unknown();

/**
 * @description Apply for advaced api key representation
 */
export const putApiKeyAdvancedResourceMutationRequestSchema = z
	.lazy(() => advancedApiKeyCreateSchema)
	.unwrap()
	.omit({ webhookStatus: true });

export const putApiKeyAdvancedResourceMutationResponseSchema = z.lazy(
	() => putApiKeyAdvancedResource204Schema,
);

export const deleteApiKeyAdvancedResourcePathParamsSchema = z.object({
	apiKeyId: z.coerce.number().int().describe("The api key id"),
});

/**
 * @description Ok
 */
export const deleteApiKeyAdvancedResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteApiKeyAdvancedResource401Schema = z.unknown();

export const deleteApiKeyAdvancedResourceMutationResponseSchema = z.lazy(
	() => deleteApiKeyAdvancedResource204Schema,
);

export const postApiKeyAdvancedReactivateResourcePathParamsSchema = z.object({
	apiKeyId: z.coerce.number().int().describe("The api key id"),
});

/**
 * @description Ok
 */
export const postApiKeyAdvancedReactivateResource204Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postApiKeyAdvancedReactivateResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postApiKeyAdvancedReactivateResource401Schema = z.unknown();

export const postApiKeyAdvancedReactivateResourceMutationResponseSchema = z.lazy(
	() => postApiKeyAdvancedReactivateResource204Schema,
);

export const getApiKeyTokensResourcePathParamsSchema = z.object({
	apiKeyId: z.coerce.number().int().describe("The api key id"),
});

/**
 * @description successful operation
 */
export const getApiKeyTokensResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getApiKeyTokensResource401Schema = z.unknown();

export const getApiKeyTokensResourceQueryResponseSchema = z.lazy(
	() => getApiKeyTokensResource200Schema,
);

export const putApiKeyTokensResourcePathParamsSchema = z.object({
	apiKeyId: z.coerce.number().int().describe("The api key id"),
});

/**
 * @description Ok
 */
export const putApiKeyTokensResource200Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const putApiKeyTokensResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const putApiKeyTokensResource401Schema = z.unknown();

/**
 * @description Api key token create representation
 */
export const putApiKeyTokensResourceMutationRequestSchema = z.lazy(() => apiKeyTokenCreateSchema);

export const putApiKeyTokensResourceMutationResponseSchema = z.lazy(
	() => putApiKeyTokensResource200Schema,
);

export const postApiKeyTokenResourcePathParamsSchema = z.object({
	apiKeyId: z.coerce.number().int().describe("The api key id"),
	id: z.string().describe("The api key token id"),
});

/**
 * @description Ok
 */
export const postApiKeyTokenResource204Schema = z.unknown();

/**
 * @description Invalid parameter given
 */
export const postApiKeyTokenResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postApiKeyTokenResource401Schema = z.unknown();

/**
 * @description Api key token update representation
 */
export const postApiKeyTokenResourceMutationRequestSchema = z.lazy(() => apiKeyTokenUpdateSchema);

export const postApiKeyTokenResourceMutationResponseSchema = z.lazy(
	() => postApiKeyTokenResource204Schema,
);

export const deleteApiKeyTokenResourcePathParamsSchema = z.object({
	apiKeyId: z.coerce.number().int().describe("The api key id"),
	id: z.string().describe("The api key token id"),
});

/**
 * @description Ok
 */
export const deleteApiKeyTokenResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteApiKeyTokenResource401Schema = z.unknown();

export const deleteApiKeyTokenResourceMutationResponseSchema = z.lazy(
	() => deleteApiKeyTokenResource204Schema,
);

export const getWebhookLogsResourcePathParamsSchema = z.object({
	apiKeyId: z.coerce.number().int().describe("The api key id"),
});

export const getWebhookLogsResourceQueryParamsSchema = z.object({
	id: z.optional(z.string().describe("Optionally filter for older logs")),
	limit: z.coerce.number().int().default(50).describe("Amount of logs (max: 100)"),
});

/**
 * @description successful operation
 */
export const getWebhookLogsResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getWebhookLogsResource401Schema = z.unknown();

export const getWebhookLogsResourceQueryResponseSchema = z.lazy(
	() => getWebhookLogsResource200Schema,
);

/**
 * @description Ok
 */
export const postSmartlockBulkWebConfigResource204Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const postSmartlockBulkWebConfigResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockBulkWebConfigResource401Schema = z.unknown();

/**
 * @description Smartlocks web config update representation
 */
export const postSmartlockBulkWebConfigResourceMutationRequestSchema = z.lazy(
	() => bulkWebConfigRequestSchema,
);

export const postSmartlockBulkWebConfigResourceMutationResponseSchema = z.lazy(
	() => postSmartlockBulkWebConfigResource204Schema,
);

/**
 * @description successful operation
 */
export const getCompaniesResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getCompaniesResource401Schema = z.unknown();

/**
 * @description Not allowed
 */
export const getCompaniesResource403Schema = z.unknown();

export const getCompaniesResourceQueryResponseSchema = z.lazy(() => getCompaniesResource200Schema);

export const getNotificationsResourceQueryParamsSchema = z
	.object({
		referenceId: z.optional(z.string().describe("The reference ID to the third party system")),
	})
	.optional();

/**
 * @description successful operation
 */
export const getNotificationsResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getNotificationsResource401Schema = z.unknown();

export const getNotificationsResourceQueryResponseSchema = z.lazy(
	() => getNotificationsResource200Schema,
);

/**
 * @description successful operation
 */
export const putNotificationsResource200Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const putNotificationsResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const putNotificationsResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const putNotificationsResource403Schema = z.unknown();

/**
 * @description Notification representation
 */
export const putNotificationsResourceMutationRequestSchema = z.lazy(() => notificationSchema);

export const putNotificationsResourceMutationResponseSchema = z.lazy(
	() => putNotificationsResource200Schema,
);

export const getNotificationResourcePathParamsSchema = z.object({
	notificationId: z.string().describe("The unique notification ID"),
});

/**
 * @description successful operation
 */
export const getNotificationResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getNotificationResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const getNotificationResource403Schema = z.unknown();

/**
 * @description Not found
 */
export const getNotificationResource404Schema = z.unknown();

export const getNotificationResourceQueryResponseSchema = z.lazy(
	() => getNotificationResource200Schema,
);

export const postNotificationResourcePathParamsSchema = z.object({
	notificationId: z.string().describe("The unique notification ID"),
});

/**
 * @description successful operation
 */
export const postNotificationResource200Schema = z.unknown();

/**
 * @description Invalid parameter given
 */
export const postNotificationResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postNotificationResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const postNotificationResource403Schema = z.unknown();

/**
 * @description Notification update representation
 */
export const postNotificationResourceMutationRequestSchema = z.lazy(() => notificationSchema);

export const postNotificationResourceMutationResponseSchema = z.lazy(
	() => postNotificationResource200Schema,
);

export const deleteNotificationResourcePathParamsSchema = z.object({
	notificationId: z.string().describe("The unique notification ID"),
});

/**
 * @description Ok
 */
export const deleteNotificationResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteNotificationResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const deleteNotificationResource403Schema = z.unknown();

/**
 * @description Not allowed
 */
export const deleteNotificationResource405Schema = z.unknown();

export const deleteNotificationResourceMutationResponseSchema = z.lazy(
	() => deleteNotificationResource204Schema,
);

/**
 * @description successful operation
 */
export const getOpenerBrandsResource200Schema = z.unknown();

export const getOpenerBrandsResourceQueryResponseSchema = z.lazy(
	() => getOpenerBrandsResource200Schema,
);

export const getOpenerBrandResourcePathParamsSchema = z.object({
	brandId: z.coerce.number().int().describe("The brand ID"),
});

/**
 * @description successful operation
 */
export const getOpenerBrandResource200Schema = z.unknown();

export const getOpenerBrandResourceQueryResponseSchema = z.lazy(
	() => getOpenerBrandResource200Schema,
);

export const getOpenerIntercomsResourceQueryParamsSchema = z
	.object({
		brandId: z.optional(
			z.coerce
				.number()
				.int()
				.describe("Filter for brandId. Required if 'recentlyChanged' is not set"),
		),
		ignoreVerified: z.optional(
			z.boolean().describe("If true, return intercoms ignoring their verified value"),
		),
		recentlyChanged: z.optional(
			z.boolean().describe("If true, return all intercoms which recently were updated"),
		),
	})
	.optional();

/**
 * @description successful operation
 */
export const getOpenerIntercomsResource200Schema = z.unknown();

export const getOpenerIntercomsResourceQueryResponseSchema = z.lazy(
	() => getOpenerIntercomsResource200Schema,
);

export const getOpenerIntercomResourcePathParamsSchema = z.object({
	intercomId: z.coerce.number().int().describe("The intercom ID"),
});

/**
 * @description successful operation
 */
export const getOpenerIntercomResource200Schema = z.unknown();

export const getOpenerIntercomResourceQueryResponseSchema = z.lazy(
	() => getOpenerIntercomResource200Schema,
);

export const getServicesResourceQueryParamsSchema = z
	.object({
		serviceIds: z.optional(
			z.string().describe("Filter for service IDs (comma-separated eg: airbnb,guesty,smoobu)"),
		),
	})
	.optional();

/**
 * @description successful operation
 */
export const getServicesResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getServicesResource401Schema = z.unknown();

export const getServicesResourceQueryResponseSchema = z.lazy(() => getServicesResource200Schema);

export const getServiceResourcePathParamsSchema = z.object({
	serviceId: z.string().describe("The service id"),
});

/**
 * @description successful operation
 */
export const getServiceResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getServiceResource401Schema = z.unknown();

export const getServiceResourceQueryResponseSchema = z.lazy(() => getServiceResource200Schema);

export const postServiceLinkResourcePathParamsSchema = z.object({
	serviceId: z.string().describe("The service id"),
});

/**
 * @description Ok
 */
export const postServiceLinkResource200Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postServiceLinkResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postServiceLinkResource401Schema = z.unknown();

export const postServiceLinkResourceMutationResponseSchema = z.lazy(
	() => postServiceLinkResource200Schema,
);

export const postServiceSyncResourcePathParamsSchema = z.object({
	serviceId: z.string().describe("The service id"),
});

/**
 * @description Ok
 */
export const postServiceSyncResource204Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postServiceSyncResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postServiceSyncResource401Schema = z.unknown();

export const postServiceSyncResourceMutationResponseSchema = z.lazy(
	() => postServiceSyncResource204Schema,
);

export const postServiceUnlinkResourcePathParamsSchema = z.object({
	serviceId: z.string().describe("The service id"),
});

/**
 * @description Ok
 */
export const postServiceUnlinkResource204Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postServiceUnlinkResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postServiceUnlinkResource401Schema = z.unknown();

export const postServiceUnlinkResourceMutationResponseSchema = z.lazy(
	() => postServiceUnlinkResource204Schema,
);

export const getSmartlocksResourceQueryParamsSchema = z
	.object({
		authId: z.optional(z.coerce.number().int().describe("Filter for authId")),
		type: z.optional(z.coerce.number().int().describe("Filter for type")),
	})
	.optional();

/**
 * @description successful operation
 */
export const getSmartlocksResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getSmartlocksResource401Schema = z.unknown();

export const getSmartlocksResourceQueryResponseSchema = z.lazy(
	() => getSmartlocksResource200Schema,
);

export const getSmartlocksAuthsResourceQueryParamsSchema = z
	.object({
		accountUserId: z.optional(
			z.coerce
				.number()
				.int()
				.describe(
					"Filter for account users:  set to a positive number will filter for authorizations with this specific accountUserId, set to a negative number will filter without set accountUserId",
				),
		),
		types: z.optional(
			z.string().describe("Filter for authorization's types (comma-separated eg: 0,2,3)"),
		),
	})
	.optional();

/**
 * @description successful operation
 */
export const getSmartlocksAuthsResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getSmartlocksAuthsResource401Schema = z.unknown();

export const getSmartlocksAuthsResourceQueryResponseSchema = z.lazy(
	() => getSmartlocksAuthsResource200Schema,
);

/**
 * @description Ok
 */
export const postSmartlocksAuthsResource204Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const postSmartlocksAuthsResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlocksAuthsResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const postSmartlocksAuthsResource403Schema = z.unknown();

/**
 * @description Parameter conflicts
 */
export const postSmartlocksAuthsResource409Schema = z.unknown();

/**
 * @description Locked
 */
export const postSmartlocksAuthsResource423Schema = z.unknown();

/**
 * @description Smartlock authorization update representations
 */
export const postSmartlocksAuthsResourceMutationRequestSchema = z.array(
	z.lazy(() => smartlockAuthMultiUpdateSchema),
);

export const postSmartlocksAuthsResourceMutationResponseSchema = z.lazy(
	() => postSmartlocksAuthsResource204Schema,
);

/**
 * @description Ok
 */
export const putSmartlocksAuthsResource204Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const putSmartlocksAuthsResource400Schema = z.unknown();

/**
 * @description Account not payed
 */
export const putSmartlocksAuthsResource402Schema = z.unknown();

/**
 * @description Parameter conflicts
 */
export const putSmartlocksAuthsResource409Schema = z.unknown();

/**
 * @description Account upgrade required
 */
export const putSmartlocksAuthsResource426Schema = z.unknown();

/**
 * @description Smartlock authorization create representation
 */
export const putSmartlocksAuthsResourceMutationRequestSchema = z.lazy(
	() => smartlocksAuthCreateSchema,
);

export const putSmartlocksAuthsResourceMutationResponseSchema = z.lazy(
	() => putSmartlocksAuthsResource204Schema,
);

/**
 * @description Ok
 */
export const deleteSmartlocksAuthsResource204Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const deleteSmartlocksAuthsResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteSmartlocksAuthsResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const deleteSmartlocksAuthsResource403Schema = z.unknown();

/**
 * @description Locked
 */
export const deleteSmartlocksAuthsResource423Schema = z.unknown();

/**
 * @description Smartlock authorization IDs to delete
 */
export const deleteSmartlocksAuthsResourceMutationRequestSchema = z.array(z.string());

export const deleteSmartlocksAuthsResourceMutationResponseSchema = z.lazy(
	() => deleteSmartlocksAuthsResource204Schema,
);

/**
 * @description Ok
 */
export const putSmartlockAuthsAdvancedResource200Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const putSmartlockAuthsAdvancedResource400Schema = z.unknown();

/**
 * @description Account not payed
 */
export const putSmartlockAuthsAdvancedResource402Schema = z.unknown();

/**
 * @description Parameter conflicts
 */
export const putSmartlockAuthsAdvancedResource409Schema = z.unknown();

/**
 * @description Account upgrade required
 */
export const putSmartlockAuthsAdvancedResource426Schema = z.unknown();

/**
 * @description Smartlock authorization create representation
 */
export const putSmartlockAuthsAdvancedResourceMutationRequestSchema = z.lazy(
	() => smartlocksAuthAdvancedCreateSchema,
);

export const putSmartlockAuthsAdvancedResourceMutationResponseSchema = z.lazy(
	() => putSmartlockAuthsAdvancedResource200Schema,
);

export const getSmartlocksAuthsPaginatedResourceQueryParamsSchema = z.object({
	page: z.coerce.number().int().default(0).describe("The page number, starting from 0"),
	size: z.coerce.number().int().default(100).describe("The number of items in one page"),
	accountUserId: z.optional(
		z.coerce
			.number()
			.int()
			.describe(
				"Filter for account users:  set to a positive number will filter for authorizations with this specific accountUserId, set to a negative number will filter without set accountUserId",
			),
	),
	types: z.optional(
		z.string().describe("Filter for authorization's types (comma-separated eg: 0,2,3)"),
	),
});

/**
 * @description successful operation
 */
export const getSmartlocksAuthsPaginatedResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getSmartlocksAuthsPaginatedResource401Schema = z.unknown();

export const getSmartlocksAuthsPaginatedResourceQueryResponseSchema = z.lazy(
	() => getSmartlocksAuthsPaginatedResource200Schema,
);

export const getSmartlocksLogsResourceQueryParamsSchema = z.object({
	accountUserId: z.optional(z.coerce.number().int().describe("Filter for account users")),
	fromDate: z.optional(z.string().describe("Filter for date (RFC3339)")),
	toDate: z.optional(z.string().describe("Filter for date (RFC3339)")),
	action: z.optional(z.coerce.number().int().describe("Filter for action")),
	id: z.optional(z.string().describe("Filter for older logs")),
	limit: z.coerce.number().int().default(20).describe("Amount of logs (max: 50)"),
});

/**
 * @description successful operation
 */
export const getSmartlocksLogsResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getSmartlocksLogsResource401Schema = z.unknown();

export const getSmartlocksLogsResourceQueryResponseSchema = z.lazy(
	() => getSmartlocksLogsResource200Schema,
);

export const getSmartlockResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
});

/**
 * @description successful operation
 */
export const getSmartlockResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getSmartlockResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const getSmartlockResource403Schema = z.unknown();

/**
 * @description Not found
 */
export const getSmartlockResource404Schema = z.unknown();

export const getSmartlockResourceQueryResponseSchema = z.lazy(() => getSmartlockResource200Schema);

export const postSmartlockResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const postSmartlockResource204Schema = z.unknown();

/**
 * @description Invalid parameter given
 */
export const postSmartlockResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const postSmartlockResource403Schema = z.unknown();

/**
 * @description Smartlock update representation
 */
export const postSmartlockResourceMutationRequestSchema = z.lazy(() => smartlockUpdateSchema);

export const postSmartlockResourceMutationResponseSchema = z.lazy(
	() => postSmartlockResource204Schema,
);

export const deleteSmartlockResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const deleteSmartlockResource204Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const deleteSmartlockResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteSmartlockResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const deleteSmartlockResource403Schema = z.unknown();

export const deleteSmartlockResourceMutationResponseSchema = z.lazy(
	() => deleteSmartlockResource204Schema,
);

export const postSmartlockActionResourcePathParamsSchema = z.object({
	smartlockId: z.string().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const postSmartlockActionResource204Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postSmartlockActionResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockActionResource401Schema = z.unknown();

/**
 * @description Account not payed
 */
export const postSmartlockActionResource402Schema = z.unknown();

/**
 * @description Smartlock action representation
 */
export const postSmartlockActionResourceMutationRequestSchema = z.lazy(() => smartlockActionSchema);

export const postSmartlockActionResourceMutationResponseSchema = z.lazy(
	() => postSmartlockActionResource204Schema,
);

export const postSmartlockActionAdvancedResourcePathParamsSchema = z.object({
	smartlockId: z.string().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const postSmartlockActionAdvancedResource200Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const postSmartlockActionAdvancedResource400Schema = z.unknown();

/**
 * @description Account not payed
 */
export const postSmartlockActionAdvancedResource402Schema = z.unknown();

/**
 * @description Parameter conflicts
 */
export const postSmartlockActionAdvancedResource409Schema = z.unknown();

/**
 * @description Account upgrade required
 */
export const postSmartlockActionAdvancedResource426Schema = z.unknown();

/**
 * @description Smartlock action representation
 */
export const postSmartlockActionAdvancedResourceMutationRequestSchema = z.lazy(
	() => smartlockActionSchema,
);

export const postSmartlockActionAdvancedResourceMutationResponseSchema = z.lazy(
	() => postSmartlockActionAdvancedResource200Schema,
);

export const postSmartlockLockActionResourcePathParamsSchema = z.object({
	smartlockId: z.string().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const postSmartlockLockActionResource204Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postSmartlockLockActionResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockLockActionResource401Schema = z.unknown();

/**
 * @description Not allowed
 */
export const postSmartlockLockActionResource405Schema = z.unknown();

export const postSmartlockLockActionResourceMutationResponseSchema = z.lazy(
	() => postSmartlockLockActionResource204Schema,
);

export const postSmartlockLockActionAdvancedResourcePathParamsSchema = z.object({
	smartlockId: z.string().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const postSmartlockLockActionAdvancedResource200Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postSmartlockLockActionAdvancedResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockLockActionAdvancedResource401Schema = z.unknown();

/**
 * @description Not allowed
 */
export const postSmartlockLockActionAdvancedResource405Schema = z.unknown();

export const postSmartlockLockActionAdvancedResourceMutationResponseSchema = z.lazy(
	() => postSmartlockLockActionAdvancedResource200Schema,
);

export const postSmartlockUnlockActionResourcePathParamsSchema = z.object({
	smartlockId: z.string().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const postSmartlockUnlockActionResource204Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postSmartlockUnlockActionResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockUnlockActionResource401Schema = z.unknown();

/**
 * @description Not allowed
 */
export const postSmartlockUnlockActionResource405Schema = z.unknown();

export const postSmartlockUnlockActionResourceMutationResponseSchema = z.lazy(
	() => postSmartlockUnlockActionResource204Schema,
);

export const postSmartlockUnlockActionAdvancedResourcePathParamsSchema = z.object({
	smartlockId: z.string().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const postSmartlockUnlockActionAdvancedResource200Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postSmartlockUnlockActionAdvancedResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockUnlockActionAdvancedResource401Schema = z.unknown();

/**
 * @description Not allowed
 */
export const postSmartlockUnlockActionAdvancedResource405Schema = z.unknown();

export const postSmartlockUnlockActionAdvancedResourceMutationResponseSchema = z.lazy(
	() => postSmartlockUnlockActionAdvancedResource200Schema,
);

export const postSmartlockAdminPinResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const postSmartlockAdminPinResource204Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const postSmartlockAdminPinResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockAdminPinResource401Schema = z.unknown();

/**
 * @description Smartlock admin pin update representation
 */
export const postSmartlockAdminPinResourceMutationRequestSchema = z.lazy(
	() => smartlockAdminPinUpdateSchema,
);

export const postSmartlockAdminPinResourceMutationResponseSchema = z.lazy(
	() => postSmartlockAdminPinResource204Schema,
);

export const postSmartlockAdvancedConfigResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const postSmartlockAdvancedConfigResource204Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const postSmartlockAdvancedConfigResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockAdvancedConfigResource401Schema = z.unknown();

/**
 * @description Smartlock config update representation
 */
export const postSmartlockAdvancedConfigResourceMutationRequestSchema = z
	.lazy(() => smartlockAdvancedConfigSchema)
	.unwrap()
	.omit({ operationId: true, totalDegrees: true });

export const postSmartlockAdvancedConfigResourceMutationResponseSchema = z.lazy(
	() => postSmartlockAdvancedConfigResource204Schema,
);

export const postSmartlockOpenerAdvancedConfigResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock (opener) id"),
});

/**
 * @description Ok
 */
export const postSmartlockOpenerAdvancedConfigResource204Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const postSmartlockOpenerAdvancedConfigResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockOpenerAdvancedConfigResource401Schema = z.unknown();

/**
 * @description Opener advanced config update representation
 */
export const postSmartlockOpenerAdvancedConfigResourceMutationRequestSchema = z
	.lazy(() => smartlockOpenerAdvancedConfigSchema)
	.unwrap()
	.omit({ intercomId: true, busModeSwitch: true, operationId: true });

export const postSmartlockOpenerAdvancedConfigResourceMutationResponseSchema = z.lazy(
	() => postSmartlockOpenerAdvancedConfigResource204Schema,
);

export const postSmartdoorAdvancedConfigResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartdoor id"),
});

/**
 * @description Ok
 */
export const postSmartdoorAdvancedConfigResource204Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const postSmartdoorAdvancedConfigResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartdoorAdvancedConfigResource401Schema = z.unknown();

/**
 * @description Smartdoor advanced config update representation
 */
export const postSmartdoorAdvancedConfigResourceMutationRequestSchema = z
	.lazy(() => smartlockSmartdoorAdvancedConfigSchema)
	.unwrap()
	.omit({ operationId: true, supportedBatteryTypes: true });

export const postSmartdoorAdvancedConfigResourceMutationResponseSchema = z.lazy(
	() => postSmartdoorAdvancedConfigResource204Schema,
);

export const getSmartlockAuthsResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
});

export const getSmartlockAuthsResourceQueryParamsSchema = z
	.object({
		types: z.optional(
			z.string().describe("Filter for smartlock authorization's types (comma-separated eg: 0,2,3)"),
		),
	})
	.optional();

/**
 * @description successful operation
 */
export const getSmartlockAuthsResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getSmartlockAuthsResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const getSmartlockAuthsResource403Schema = z.unknown();

export const getSmartlockAuthsResourceQueryResponseSchema = z.lazy(
	() => getSmartlockAuthsResource200Schema,
);

export const putSmartlockAuthsResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const putSmartlockAuthsResource204Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const putSmartlockAuthsResource400Schema = z.unknown();

/**
 * @description Account not payed
 */
export const putSmartlockAuthsResource402Schema = z.unknown();

/**
 * @description Parameter conflicts
 */
export const putSmartlockAuthsResource409Schema = z.unknown();

/**
 * @description Account upgrade required
 */
export const putSmartlockAuthsResource426Schema = z.unknown();

/**
 * @description Smartlock authorization create representation
 */
export const putSmartlockAuthsResourceMutationRequestSchema = z.lazy(
	() => smartlockAuthCreateSchema,
);

export const putSmartlockAuthsResourceMutationResponseSchema = z.lazy(
	() => putSmartlockAuthsResource204Schema,
);

export const postSmartlockAuthWithSharedKeyResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
});

/**
 * @description successful operation
 */
export const postSmartlockAuthWithSharedKeyResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockAuthWithSharedKeyResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const postSmartlockAuthWithSharedKeyResource403Schema = z.unknown();

/**
 * @description Id not found
 */
export const postSmartlockAuthWithSharedKeyResource404Schema = z.unknown();

/**
 * @description Smartlock auth create with shared key
 */
export const postSmartlockAuthWithSharedKeyResourceMutationRequestSchema = z.lazy(
	() => smartlockAuthWithSharedKeyCreateSchema,
);

export const postSmartlockAuthWithSharedKeyResourceMutationResponseSchema = z.lazy(
	() => postSmartlockAuthWithSharedKeyResource200Schema,
);

export const getSmartlockAuthResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
	id: z.string().describe("The smartlock auth unique id"),
});

/**
 * @description successful operation
 */
export const getSmartlockAuthResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getSmartlockAuthResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const getSmartlockAuthResource403Schema = z.unknown();

export const getSmartlockAuthResourceQueryResponseSchema = z.lazy(
	() => getSmartlockAuthResource200Schema,
);

export const postSmartlockAuthResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
	id: z.string().describe("The smartlock authorization unique id"),
});

/**
 * @description Ok
 */
export const postSmartlockAuthResource204Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const postSmartlockAuthResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockAuthResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const postSmartlockAuthResource403Schema = z.unknown();

/**
 * @description Parameter conflicts
 */
export const postSmartlockAuthResource409Schema = z.unknown();

/**
 * @description Locked
 */
export const postSmartlockAuthResource423Schema = z.unknown();

/**
 * @description Smartlock authorization update representation
 */
export const postSmartlockAuthResourceMutationRequestSchema = z.lazy(
	() => smartlockAuthUpdateSchema,
);

export const postSmartlockAuthResourceMutationResponseSchema = z.lazy(
	() => postSmartlockAuthResource204Schema,
);

export const deleteSmartlockAuthResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
	id: z.string().describe("The smartlock authorization unique id"),
});

/**
 * @description Ok
 */
export const deleteSmartlockAuthResource204Schema = z.unknown();

/**
 * @description Not authorized
 */
export const deleteSmartlockAuthResource401Schema = z.unknown();

/**
 * @description Forbidden
 */
export const deleteSmartlockAuthResource403Schema = z.unknown();

/**
 * @description Locked
 */
export const deleteSmartlockAuthResource423Schema = z.unknown();

export const deleteSmartlockAuthResourceMutationResponseSchema = z.lazy(
	() => deleteSmartlockAuthResource204Schema,
);

export const postSmartlockConfigResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const postSmartlockConfigResource204Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const postSmartlockConfigResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockConfigResource401Schema = z.unknown();

/**
 * @description Smartlock config update representation
 */
export const postSmartlockConfigResourceMutationRequestSchema = z
	.lazy(() => smartlockConfigSchema)
	.unwrap()
	.omit({
		capabilities: true,
		fobPaired: true,
		fobAction1: true,
		fobAction2: true,
		fobAction3: true,
		operatingMode: true,
		keypadPaired: true,
		keypad2Paired: true,
		homekitState: true,
		matterState: true,
		deviceType: true,
		wifiEnabled: true,
		operationId: true,
		productVariant: true,
	});

export const postSmartlockConfigResourceMutationResponseSchema = z.lazy(
	() => postSmartlockConfigResource204Schema,
);

export const getSmartlockLogsResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
});

export const getSmartlockLogsResourceQueryParamsSchema = z.object({
	authId: z.optional(z.string().describe("Filter for auths")),
	accountUserId: z.optional(z.coerce.number().int().describe("Filter for account users")),
	fromDate: z.optional(z.string().describe("Filter for date (RFC3339)")),
	toDate: z.optional(z.string().describe("Filter for date (RFC3339)")),
	action: z.optional(z.coerce.number().int().describe("Filter for action")),
	id: z.optional(z.string().describe("Filter for older logs")),
	limit: z.coerce.number().int().default(20).describe("Amount of logs (max: 50)"),
});

/**
 * @description successful operation
 */
export const getSmartlockLogsResource200Schema = z.unknown();

/**
 * @description Not authorized
 */
export const getSmartlockLogsResource401Schema = z.unknown();

export const getSmartlockLogsResourceQueryResponseSchema = z.lazy(
	() => getSmartlockLogsResource200Schema,
);

export const postSmartlockSyncResourcePathParamsSchema = z.object({
	smartlockId: z.string().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const postSmartlockSyncResource204Schema = z.unknown();

/**
 * @description Bad Parameter
 */
export const postSmartlockSyncResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockSyncResource401Schema = z.unknown();

export const postSmartlockSyncResourceMutationResponseSchema = z.lazy(
	() => postSmartlockSyncResource204Schema,
);

export const postSmartlockWebConfigResourcePathParamsSchema = z.object({
	smartlockId: z.coerce.number().int().describe("The smartlock id"),
});

/**
 * @description Ok
 */
export const postSmartlockWebConfigResource204Schema = z.unknown();

/**
 * @description Bad parameter
 */
export const postSmartlockWebConfigResource400Schema = z.unknown();

/**
 * @description Not authorized
 */
export const postSmartlockWebConfigResource401Schema = z.unknown();

/**
 * @description Smartlock web config update representation
 */
export const postSmartlockWebConfigResourceMutationRequestSchema = z.lazy(
	() => smartlockWebConfigSchema,
);

export const postSmartlockWebConfigResourceMutationResponseSchema = z.lazy(
	() => postSmartlockWebConfigResource204Schema,
);
