/**
 * Generated by Kubb (https://kubb.dev/).
 * Do not edit manually.
 */

import { z } from "zod";

/**
 * @description An internal identifier for an item to reference.
 */
export const itemReferenceParamSchema = z
	.object({
		type: z.optional(z.union([z.enum(["item_reference"]), z.null()])),
		id: z.string().describe("The ID of the item to reference."),
	})
	.describe("An internal identifier for an item to reference.");

export const reasoningSummaryContentParamSchema = z.object({
	type: z
		.enum(["summary_text"])
		.default("summary_text")
		.describe("The content type. Always `summary_text`."),
	text: z.string().max(10485760).describe("The reasoning summary text."),
});

export const reasoningItemParamSchema = z.object({
	id: z.optional(z.union([z.string(), z.null()])),
	type: z.enum(["reasoning"]).default("reasoning").describe("The item type. Always `reasoning`."),
	get summary() {
		return z
			.array(reasoningSummaryContentParamSchema)
			.describe("Reasoning summary content associated with this item.");
	},
	content: z.optional(z.null()),
	encrypted_content: z.optional(z.union([z.string(), z.null()])),
});

/**
 * @description A text input to the model.
 */
export const inputTextContentParamSchema = z
	.object({
		type: z
			.enum(["input_text"])
			.default("input_text")
			.describe("The type of the input item. Always `input_text`."),
		text: z.string().max(10485760).describe("The text input to the model."),
	})
	.describe("A text input to the model.");

export const detailEnumSchema = z.enum(["low", "high", "auto"]);

export const imageDetailSchema = z.enum(["low", "high", "auto"]);

/**
 * @description An image input to the model. Learn about [image inputs](/docs/guides/vision)
 */
export const inputImageContentParamAutoParamSchema = z
	.object({
		type: z
			.enum(["input_image"])
			.default("input_image")
			.describe("The type of the input item. Always `input_image`."),
		image_url: z.optional(z.union([z.string(), z.null()])),
		get detail() {
			return z.union([imageDetailSchema.and(z.unknown()), z.null()]).optional();
		},
	})
	.describe("An image input to the model. Learn about [image inputs](/docs/guides/vision)");

/**
 * @description A file input to the model.
 */
export const inputFileContentParamSchema = z
	.object({
		type: z
			.enum(["input_file"])
			.default("input_file")
			.describe("The type of the input item. Always `input_file`."),
		filename: z.optional(z.union([z.string(), z.null()])),
		file_data: z.optional(z.union([z.string(), z.null()])),
		file_url: z.optional(z.union([z.string(), z.null()])),
	})
	.describe("A file input to the model.");

export const userMessageItemParamSchema = z.object({
	id: z.optional(z.union([z.string(), z.null()])),
	type: z.enum(["message"]).default("message").describe("The item type. Always `message`."),
	role: z.enum(["user"]).default("user").describe("The message role. Always `user`."),
	get content() {
		return z
			.union([
				z.array(
					z
						.union([
							inputTextContentParamSchema,
							inputImageContentParamAutoParamSchema,
							inputFileContentParamSchema,
						])
						.describe("A piece of message content, such as text, an image, or a file."),
				),
				z.string(),
			])
			.describe("The message content, as an array of content parts.");
	},
	status: z.optional(z.union([z.string(), z.null()])),
});

export const systemMessageItemParamSchema = z.object({
	id: z.optional(z.union([z.string(), z.null()])),
	type: z.enum(["message"]).default("message").describe("The item type. Always `message`."),
	role: z.enum(["system"]).default("system").describe("The message role. Always `system`."),
	get content() {
		return z
			.union([z.array(inputTextContentParamSchema), z.string()])
			.describe("The message content, as an array of content parts.");
	},
	status: z.optional(z.union([z.string(), z.null()])),
});

export const developerMessageItemParamSchema = z.object({
	id: z.optional(z.union([z.string(), z.null()])),
	type: z.enum(["message"]).default("message").describe("The item type. Always `message`."),
	role: z
		.enum(["developer"])
		.default("developer")
		.describe("The message role. Always `developer`."),
	get content() {
		return z
			.union([z.array(inputTextContentParamSchema), z.string()])
			.describe("The message content, as an array of content parts.");
	},
	status: z.optional(z.union([z.string(), z.null()])),
});

export const urlCitationParamSchema = z.object({
	type: z
		.enum(["url_citation"])
		.default("url_citation")
		.describe("The citation type. Always `url_citation`."),
	start_index: z
		.int()
		.min(0)
		.describe("The index of the first character of the citation in the message."),
	end_index: z
		.int()
		.min(0)
		.describe("The index of the last character of the citation in the message."),
	url: z.string().describe("The URL of the cited resource."),
	title: z.string().describe("The title of the cited resource."),
});

export const outputTextContentParamSchema = z.object({
	type: z
		.enum(["output_text"])
		.default("output_text")
		.describe("The content type. Always `output_text`."),
	text: z.string().max(10485760).describe("The text content."),
	get annotations() {
		return z
			.array(urlCitationParamSchema)
			.describe("Citations associated with the text content.")
			.optional();
	},
});

export const refusalContentParamSchema = z.object({
	type: z.enum(["refusal"]).default("refusal").describe("The content type. Always `refusal`."),
	refusal: z.string().max(10485760).describe("The refusal text."),
});

export const assistantMessageItemParamSchema = z.object({
	id: z.optional(z.union([z.string(), z.null()])),
	type: z.enum(["message"]).default("message").describe("The item type. Always `message`."),
	role: z
		.enum(["assistant"])
		.default("assistant")
		.describe("The role of the message author. Always `assistant`."),
	get content() {
		return z
			.union([
				z.array(
					z
						.union([outputTextContentParamSchema, refusalContentParamSchema])
						.describe("A piece of assistant message content, such as text or a refusal."),
				),
				z.string(),
			])
			.describe("The message content, as an array of content parts.");
	},
	status: z.optional(z.union([z.string(), z.null()])),
});

export const functionCallItemStatusSchema = z.enum(["in_progress", "completed", "incomplete"]);

export const functionCallStatusSchema = z.enum(["in_progress", "completed", "incomplete"]);

export const functionCallItemParamSchema = z.object({
	id: z.optional(z.union([z.string(), z.null()])),
	call_id: z
		.string()
		.min(1)
		.max(64)
		.describe("The unique ID of the function tool call generated by the model."),
	type: z
		.enum(["function_call"])
		.default("function_call")
		.describe("The item type. Always `function_call`."),
	name: z
		.string()
		.min(1)
		.max(64)
		.regex(/^[a-zA-Z0-9_-]+$/)
		.describe("The name of the function to call."),
	arguments: z.string().describe("The function arguments as a JSON string."),
	get status() {
		return z.union([functionCallStatusSchema.and(z.unknown()), z.null()]).optional();
	},
});

/**
 * @description A content block representing a video input to the model.
 */
export const inputVideoContentSchema = z
	.object({
		type: z.enum(["input_video"]).describe("The type of the input content. Always `input_video`."),
		video_url: z.string().describe("A base64 or remote url that resolves to a video file."),
	})
	.describe("A content block representing a video input to the model.");

/**
 * @description The output of a function tool call.
 */
export const functionCallOutputItemParamSchema = z
	.object({
		id: z.optional(z.union([z.string(), z.null()])),
		call_id: z
			.string()
			.min(1)
			.max(64)
			.describe("The unique ID of the function tool call generated by the model."),
		type: z
			.enum(["function_call_output"])
			.default("function_call_output")
			.describe("The type of the function tool call output. Always `function_call_output`."),
		get output() {
			return z
				.union([
					z.array(
						z
							.union([
								inputTextContentParamSchema,
								inputImageContentParamAutoParamSchema,
								inputFileContentParamSchema,
								inputVideoContentSchema,
							])
							.describe("A piece of message content, such as text, an image, or a file."),
					),
					z.string(),
				])
				.describe("Text, image, or file output of the function tool call.");
		},
		get status() {
			return z.union([functionCallStatusSchema.and(z.unknown()), z.null()]).optional();
		},
	})
	.describe("The output of a function tool call.");

export const itemParamSchema = z.union([
	z.lazy(() => itemReferenceParamSchema),
	z.lazy(() => reasoningItemParamSchema),
	z.lazy(() => userMessageItemParamSchema),
	z.lazy(() => systemMessageItemParamSchema),
	z.lazy(() => developerMessageItemParamSchema),
	z.lazy(() => assistantMessageItemParamSchema),
	z.lazy(() => functionCallItemParamSchema),
	z.lazy(() => functionCallOutputItemParamSchema),
]);

export const includeEnumSchema = z.enum([
	"reasoning.encrypted_content",
	"message.output_text.logprobs",
]);

export const emptyModelParamSchema = z.object({});

export const functionToolParamSchema = z.object({
	name: z
		.string()
		.min(1)
		.max(64)
		.regex(/^[a-zA-Z0-9_-]+$/),
	description: z.optional(z.union([z.string(), z.null()])),
	get parameters() {
		return z.union([emptyModelParamSchema, z.null()]).optional();
	},
	strict: z.optional(z.boolean()),
	type: z.enum(["function"]).default("function"),
});

export const responsesToolParamSchema = z.lazy(() => functionToolParamSchema);

export const specificFunctionParamSchema = z.object({
	type: z.enum(["function"]).default("function").describe("The tool to call. Always `function`."),
	name: z.string().describe("The name of the function tool to call."),
});

export const specificToolChoiceParamSchema = z.lazy(() => specificFunctionParamSchema);

export const toolChoiceValueEnumSchema = z.enum(["none", "auto", "required"]);

export const allowedToolsParamSchema = z.object({
	type: z
		.enum(["allowed_tools"])
		.default("allowed_tools")
		.describe("The tool choice type. Always `allowed_tools`."),
	get tools() {
		return z
			.array(specificToolChoiceParamSchema)
			.min(1)
			.max(128)
			.describe("The list of tools that are permitted for this request.");
	},
	get mode() {
		return toolChoiceValueEnumSchema.and(z.unknown()).optional();
	},
});

/**
 * @description Controls which tool the model should use, if any.
 */
export const toolChoiceParamSchema = z
	.union([
		z.lazy(() => specificToolChoiceParamSchema),
		z.lazy(() => toolChoiceValueEnumSchema),
		z.lazy(() => allowedToolsParamSchema),
	])
	.describe("Controls which tool the model should use, if any.");

/**
 * @description Set of 16 key-value pairs that can be attached to an object. This can be         useful for storing additional information about the object in a structured         format, and querying for objects via API or the dashboard.\n        Keys are strings with a maximum length of 64 characters. Values are strings         with a maximum length of 512 characters.
 */
export const metadataParamSchema = z
	.object({})
	.catchall(z.string().max(512))
	.describe(
		"Set of 16 key-value pairs that can be attached to an object. This can be         useful for storing additional information about the object in a structured         format, and querying for objects via API or the dashboard.\n        Keys are strings with a maximum length of 64 characters. Values are strings         with a maximum length of 512 characters.",
	);

export const verbosityEnumSchema = z.enum(["low", "medium", "high"]);

export const textResponseFormatSchema = z.object({
	type: z.enum(["text"]).default("text"),
});

export const jsonSchemaResponseFormatParamSchema = z.object({
	type: z.optional(
		z
			.enum(["json_schema"])
			.describe("The type of response format being defined. Always `json_schema`."),
	),
	description: z.optional(
		z
			.string()
			.describe(
				"A description of what the response format is for, used by the model to\ndetermine how to respond in the format.\n",
			),
	),
	name: z.optional(
		z
			.string()
			.describe(
				"The name of the response format. Must be a-z, A-Z, 0-9, or contain\nunderscores and dashes, with a maximum length of 64.\n",
			),
	),
	schema: z.optional(
		z
			.object({})
			.catchall(z.unknown())
			.describe("The schema for the response format, described as a JSON Schema object.\n"),
	),
	strict: z.optional(z.union([z.boolean(), z.null()])),
});

export const textFormatParamSchema = z.union([
	z.lazy(() => textResponseFormatSchema),
	z.lazy(() => jsonSchemaResponseFormatParamSchema),
]);

export const textParamSchema = z.object({
	get format() {
		return z
			.union([textFormatParamSchema, z.null()])
			.describe("The format configuration for text output.")
			.optional();
	},
	get verbosity() {
		return verbosityEnumSchema.and(z.unknown()).optional();
	},
});

/**
 * @description Options that control streamed response behavior.
 */
export const streamOptionsParamSchema = z
	.object({
		include_obfuscation: z.optional(
			z
				.boolean()
				.describe(
					"Whether to obfuscate sensitive information in streamed output. Defaults to `true`.",
				),
		),
	})
	.describe("Options that control streamed response behavior.");

export const reasoningEffortEnumSchema = z.enum(["none", "low", "medium", "high", "xhigh"]);

export const reasoningSummaryEnumSchema = z.enum(["concise", "detailed", "auto"]);

/**
 * @description **gpt-5 and o-series models only** Configuration options for [reasoning models](https://platform.openai.com/docs/guides/reasoning).
 */
export const reasoningParamSchema = z
	.object({
		get effort() {
			return z.union([reasoningEffortEnumSchema, z.null()]).optional();
		},
		get summary() {
			return z.union([reasoningSummaryEnumSchema.and(z.unknown()), z.null()]).optional();
		},
	})
	.describe(
		"**gpt-5 and o-series models only** Configuration options for [reasoning models](https://platform.openai.com/docs/guides/reasoning).",
	);

export const truncationEnumSchema = z.enum(["auto", "disabled"]);

export const serviceTierEnumSchema = z.enum(["auto", "default", "flex", "priority"]);

export const createResponseBodySchema = z.object({
	model: z.optional(z.union([z.string(), z.null()])),
	get input() {
		return z.union([z.union([z.array(itemParamSchema), z.string()]), z.null()]).optional();
	},
	previous_response_id: z.optional(z.union([z.string(), z.null()])),
	get include() {
		return z.array(includeEnumSchema).optional();
	},
	get tools() {
		return z.union([z.array(responsesToolParamSchema), z.null()]).optional();
	},
	get tool_choice() {
		return z.union([toolChoiceParamSchema.and(z.unknown()), z.null()]).optional();
	},
	get metadata() {
		return z.union([metadataParamSchema.and(z.unknown()), z.null()]).optional();
	},
	get text() {
		return z.union([textParamSchema.and(z.unknown()), z.null()]).optional();
	},
	temperature: z.optional(z.union([z.number(), z.null()])),
	top_p: z.optional(z.union([z.number(), z.null()])),
	presence_penalty: z.optional(z.union([z.number(), z.null()])),
	frequency_penalty: z.optional(z.union([z.number(), z.null()])),
	parallel_tool_calls: z.optional(z.union([z.boolean(), z.null()])),
	stream: z.optional(
		z.boolean().describe("Whether to stream response events as server-sent events."),
	),
	get stream_options() {
		return z.union([streamOptionsParamSchema.and(z.unknown()), z.null()]).optional();
	},
	background: z.optional(
		z.boolean().describe("Whether to run the request in the background and return immediately."),
	),
	max_output_tokens: z.optional(z.union([z.int(), z.null()])),
	max_tool_calls: z.optional(z.union([z.int(), z.null()])),
	get reasoning() {
		return z.union([reasoningParamSchema.and(z.unknown()), z.null()]).optional();
	},
	safety_identifier: z.optional(z.union([z.string(), z.null()])),
	prompt_cache_key: z.optional(z.union([z.string(), z.null()])),
	get truncation() {
		return truncationEnumSchema.and(z.unknown()).optional();
	},
	instructions: z.optional(z.union([z.string(), z.null()])),
	store: z.optional(
		z.boolean().describe("Whether to store the response so it can be retrieved later."),
	),
	get service_tier() {
		return serviceTierEnumSchema.and(z.unknown()).optional();
	},
	top_logprobs: z.optional(z.union([z.int(), z.null()])),
});

/**
 * @description Details about why the response was incomplete.
 */
export const incompleteDetailsSchema = z
	.object({
		reason: z.string().describe("The reason the response could not be completed."),
	})
	.describe("Details about why the response was incomplete.");

export const messageRoleSchema = z.enum(["user", "assistant", "system", "developer"]);

/**
 * @description A text input to the model.
 */
export const inputTextContentSchema = z
	.object({
		type: z
			.enum(["input_text"])
			.default("input_text")
			.describe("The type of the input item. Always `input_text`."),
		text: z.string().describe("The text input to the model."),
	})
	.describe("A text input to the model.");

/**
 * @description A citation for a web resource used to generate a model response.
 */
export const urlCitationBodySchema = z
	.object({
		type: z
			.enum(["url_citation"])
			.default("url_citation")
			.describe("The type of the URL citation. Always `url_citation`."),
		url: z.string().describe("The URL of the web resource."),
		start_index: z
			.int()
			.describe("The index of the first character of the URL citation in the message."),
		end_index: z
			.int()
			.describe("The index of the last character of the URL citation in the message."),
		title: z.string().describe("The title of the web resource."),
	})
	.describe("A citation for a web resource used to generate a model response.");

/**
 * @description An annotation that applies to a span of output text.
 */
export const annotationSchema = z
	.lazy(() => urlCitationBodySchema)
	.describe("An annotation that applies to a span of output text.");

/**
 * @description The top log probability of a token.
 */
export const topLogProbSchema = z
	.object({
		token: z.string(),
		logprob: z.number(),
		bytes: z.array(z.int()),
	})
	.describe("The top log probability of a token.");

/**
 * @description The log probability of a token.
 */
export const logProbSchema = z
	.object({
		token: z.string(),
		logprob: z.number(),
		bytes: z.array(z.int()),
		get top_logprobs() {
			return z.array(topLogProbSchema.describe("The top log probability of a token."));
		},
	})
	.describe("The log probability of a token.");

/**
 * @description A text output from the model.
 */
export const outputTextContentSchema = z
	.object({
		type: z
			.enum(["output_text"])
			.default("output_text")
			.describe("The type of the output text. Always `output_text`."),
		text: z.string().describe("The text output from the model."),
		get annotations() {
			return z
				.array(annotationSchema.describe("An annotation that applies to a span of output text."))
				.describe("The annotations of the text output.");
		},
		get logprobs() {
			return z.array(logProbSchema.describe("The log probability of a token."));
		},
	})
	.describe("A text output from the model.");

/**
 * @description A text content.
 */
export const textContentSchema = z
	.object({
		type: z.enum(["text"]).default("text"),
		text: z.string(),
	})
	.describe("A text content.");

/**
 * @description A summary text from the model.
 */
export const summaryTextContentSchema = z
	.object({
		type: z
			.enum(["summary_text"])
			.default("summary_text")
			.describe("The type of the object. Always `summary_text`."),
		text: z.string().describe("A summary of the reasoning output from the model so far."),
	})
	.describe("A summary text from the model.");

/**
 * @description Reasoning text from the model.
 */
export const reasoningTextContentSchema = z
	.object({
		type: z
			.enum(["reasoning_text"])
			.default("reasoning_text")
			.describe("The type of the reasoning text. Always `reasoning_text`."),
		text: z.string().describe("The reasoning text from the model."),
	})
	.describe("Reasoning text from the model.");

/**
 * @description A refusal from the model.
 */
export const refusalContentSchema = z
	.object({
		type: z
			.enum(["refusal"])
			.default("refusal")
			.describe("The type of the refusal. Always `refusal`."),
		refusal: z.string().describe("The refusal explanation from the model."),
	})
	.describe("A refusal from the model.");

/**
 * @description An image input to the model. Learn about [image inputs](/docs/guides/vision).
 */
export const inputImageContentSchema = z
	.object({
		type: z
			.enum(["input_image"])
			.default("input_image")
			.describe("The type of the input item. Always `input_image`."),
		image_url: z.union([z.string(), z.null()]),
		get detail() {
			return imageDetailSchema.and(z.unknown());
		},
	})
	.describe("An image input to the model. Learn about [image inputs](/docs/guides/vision).");

/**
 * @description A file input to the model.
 */
export const inputFileContentSchema = z
	.object({
		type: z
			.enum(["input_file"])
			.default("input_file")
			.describe("The type of the input item. Always `input_file`."),
		filename: z.optional(z.string().describe("The name of the file to be sent to the model.")),
		file_url: z.optional(z.string().describe("The URL of the file to be sent to the model.")),
	})
	.describe("A file input to the model.");

export const messageStatusSchema = z.enum(["in_progress", "completed", "incomplete"]);

/**
 * @description A message to or from the model.
 */
export const messageSchema = z
	.object({
		type: z
			.enum(["message"])
			.default("message")
			.describe("The type of the message. Always set to `message`."),
		id: z.string().describe("The unique ID of the message."),
		get status() {
			return messageStatusSchema.and(z.unknown());
		},
		get role() {
			return messageRoleSchema.and(z.unknown());
		},
		get content() {
			return z
				.array(
					z
						.union([
							inputTextContentSchema,
							outputTextContentSchema,
							textContentSchema,
							summaryTextContentSchema,
							reasoningTextContentSchema,
							refusalContentSchema,
							inputImageContentSchema,
							inputFileContentSchema,
							inputVideoContentSchema,
						])
						.describe("A content part that makes up an input or output item."),
				)
				.describe("The content of the message");
		},
	})
	.describe("A message to or from the model.");

/**
 * @description A function tool call that was generated by the model.
 */
export const functionCallSchema = z
	.object({
		type: z
			.enum(["function_call"])
			.default("function_call")
			.describe("The type of the item. Always `function_call`."),
		id: z.string().describe("The unique ID of the function call item."),
		call_id: z.string().describe("The unique ID of the function tool call that was generated."),
		name: z.string().describe("The name of the function that was called."),
		arguments: z.string().describe("The arguments JSON string that was generated."),
		get status() {
			return functionCallStatusSchema.and(z.unknown());
		},
	})
	.describe("A function tool call that was generated by the model.");

/**
 * @description Similar to `FunctionCallStatus`. All three options are allowed here for compatibility, but because in practice these items will be provided by developers, only `completed` should be used.
 */
export const functionCallOutputStatusEnumSchema = z
	.enum(["in_progress", "completed", "incomplete"])
	.describe(
		"Similar to `FunctionCallStatus`. All three options are allowed here for compatibility, but because in practice these items will be provided by developers, only `completed` should be used.",
	);

/**
 * @description A function tool call output that was returned by the tool.
 */
export const functionCallOutputSchema = z
	.object({
		type: z
			.enum(["function_call_output"])
			.default("function_call_output")
			.describe("The type of the function tool call output. Always `function_call_output`."),
		id: z
			.string()
			.describe(
				"The unique ID of the function tool call output. Populated when this item is returned via API.",
			),
		call_id: z.string().describe("The unique ID of the function tool call generated by the model."),
		get output() {
			return z.union([
				z.array(
					z
						.union([inputTextContentSchema, inputImageContentSchema, inputFileContentSchema])
						.describe("A content part that makes up an input or output item."),
				),
				z.string(),
			]);
		},
		get status() {
			return functionCallOutputStatusEnumSchema.and(z.unknown());
		},
	})
	.describe("A function tool call output that was returned by the tool.");

/**
 * @description A reasoning item that was generated by the model.
 */
export const reasoningBodySchema = z
	.object({
		type: z
			.enum(["reasoning"])
			.default("reasoning")
			.describe("The type of the item. Always `reasoning`."),
		id: z.string().describe("The unique ID of the reasoning item."),
		get content() {
			return z
				.array(
					z
						.union([
							inputTextContentSchema,
							outputTextContentSchema,
							textContentSchema,
							summaryTextContentSchema,
							reasoningTextContentSchema,
							refusalContentSchema,
							inputImageContentSchema,
							inputFileContentSchema,
						])
						.describe("A content part that makes up an input or output item."),
				)
				.describe("The reasoning content that was generated.")
				.optional();
		},
		get summary() {
			return z
				.array(
					z
						.union([
							inputTextContentSchema,
							outputTextContentSchema,
							textContentSchema,
							summaryTextContentSchema,
							reasoningTextContentSchema,
							refusalContentSchema,
							inputImageContentSchema,
							inputFileContentSchema,
						])
						.describe("A content part that makes up an input or output item."),
				)
				.describe("The reasoning summary content that was generated.");
		},
		encrypted_content: z.optional(
			z.string().describe("The encrypted reasoning content that was generated."),
		),
	})
	.describe("A reasoning item that was generated by the model.");

/**
 * @description An item representing a message, tool call, tool output, reasoning, or other response element.
 */
export const itemFieldSchema = z
	.union([
		z.lazy(() => messageSchema),
		z.lazy(() => functionCallSchema),
		z.lazy(() => functionCallOutputSchema),
		z.lazy(() => reasoningBodySchema),
	])
	.describe(
		"An item representing a message, tool call, tool output, reasoning, or other response element.",
	);

/**
 * @description An error that occurred while generating the response.
 */
export const errorSchema = z
	.object({
		code: z.string().describe("A machine-readable error code that was returned."),
		message: z.string().describe("A human-readable description of the error that was returned."),
	})
	.describe("An error that occurred while generating the response.");

/**
 * @description Defines a function in your own code the model can choose to call. Learn more about [function calling](https://platform.openai.com/docs/guides/function-calling).
 */
export const functionToolSchema = z
	.object({
		type: z
			.enum(["function"])
			.default("function")
			.describe("The type of the function tool. Always `function`."),
		name: z.string().describe("The name of the function to call."),
		description: z.union([z.string(), z.null()]),
		parameters: z.union([z.object({}).catchall(z.unknown()), z.null()]),
		strict: z.union([z.boolean(), z.null()]),
	})
	.describe(
		"Defines a function in your own code the model can choose to call. Learn more about [function calling](https://platform.openai.com/docs/guides/function-calling).",
	);

/**
 * @description A tool that can be used to generate a response.
 */
export const toolSchema = z
	.lazy(() => functionToolSchema)
	.describe("A tool that can be used to generate a response.");

export const functionToolChoiceSchema = z.object({
	type: z.enum(["function"]).default("function"),
	name: z.optional(z.string()),
});

export const allowedToolChoiceSchema = z.object({
	type: z.enum(["allowed_tools"]).default("allowed_tools"),
	get tools() {
		return z.array(functionToolChoiceSchema);
	},
	get mode() {
		return toolChoiceValueEnumSchema;
	},
});

export const jsonObjectResponseFormatSchema = z.object({
	type: z.enum(["json_object"]).default("json_object"),
});

export const jsonSchemaResponseFormatSchema = z.object({
	type: z.enum(["json_schema"]).default("json_schema"),
	name: z.string(),
	description: z.union([z.string(), z.null()]),
	schema: z.null(),
	strict: z.boolean(),
});

export const textFieldSchema = z.object({
	get format() {
		return z.union([
			textResponseFormatSchema,
			jsonObjectResponseFormatSchema,
			jsonSchemaResponseFormatSchema,
		]);
	},
	get verbosity() {
		return verbosityEnumSchema.optional();
	},
});

/**
 * @description Reasoning configuration and metadata that were used for the response.
 */
export const reasoningSchema = z
	.object({
		get effort() {
			return z.union([reasoningEffortEnumSchema, z.null()]);
		},
		get summary() {
			return z.union([reasoningSummaryEnumSchema.and(z.unknown()), z.null()]);
		},
	})
	.describe("Reasoning configuration and metadata that were used for the response.");

/**
 * @description A breakdown of input token usage that was recorded.
 */
export const inputTokensDetailsSchema = z
	.object({
		cached_tokens: z.int().describe("The number of input tokens that were served from cache."),
	})
	.describe("A breakdown of input token usage that was recorded.");

/**
 * @description A breakdown of output token usage that was recorded.
 */
export const outputTokensDetailsSchema = z
	.object({
		reasoning_tokens: z
			.int()
			.describe("The number of output tokens that were attributed to reasoning."),
	})
	.describe("A breakdown of output token usage that was recorded.");

/**
 * @description Token usage statistics that were recorded for the response.
 */
export const usageSchema = z
	.object({
		input_tokens: z
			.int()
			.describe("The number of input tokens that were used to generate the response."),
		output_tokens: z
			.int()
			.describe("The number of output tokens that were generated by the model."),
		total_tokens: z.int().describe("The total number of tokens that were used."),
		get input_tokens_details() {
			return inputTokensDetailsSchema.and(z.unknown());
		},
		get output_tokens_details() {
			return outputTokensDetailsSchema.and(z.unknown());
		},
	})
	.describe("Token usage statistics that were recorded for the response.");

/**
 * @description The complete response object that was returned by the Responses API.
 */
export const responseResourceSchema = z
	.object({
		id: z.string().describe("The unique ID of the response that was created."),
		object: z
			.enum(["response"])
			.default("response")
			.describe("The object type, which was always `response`."),
		created_at: z
			.int()
			.describe("The Unix timestamp (in seconds) for when the response was created."),
		completed_at: z.union([z.int(), z.null()]),
		status: z.string().describe("The status that was set for the response."),
		get incomplete_details() {
			return z.union([incompleteDetailsSchema.and(z.unknown()), z.null()]);
		},
		model: z.string().describe("The model that generated this response."),
		previous_response_id: z.union([z.string(), z.null()]),
		instructions: z.union([z.string(), z.null()]),
		get output() {
			return z
				.array(
					itemFieldSchema.describe(
						"An item representing a message, tool call, tool output, reasoning, or other response element.",
					),
				)
				.describe("The output items that were generated by the model.");
		},
		get error() {
			return z.union([errorSchema.and(z.unknown()), z.null()]);
		},
		get tools() {
			return z
				.array(toolSchema.describe("A tool that can be used to generate a response."))
				.describe("The tools that were available to the model during response generation.");
		},
		get tool_choice() {
			return z.union([
				functionToolChoiceSchema,
				toolChoiceValueEnumSchema,
				allowedToolChoiceSchema,
			]);
		},
		get truncation() {
			return truncationEnumSchema.and(z.unknown());
		},
		parallel_tool_calls: z
			.boolean()
			.describe("Whether the model was allowed to call multiple tools in parallel."),
		get text() {
			return textFieldSchema.and(z.unknown());
		},
		top_p: z.number().describe("The nucleus sampling parameter that was used for this response."),
		presence_penalty: z
			.number()
			.describe(
				"The presence penalty that was used to penalize new tokens based on whether they appear in the text so far.",
			),
		frequency_penalty: z
			.number()
			.describe(
				"The frequency penalty that was used to penalize new tokens based on their frequency in the text so far.",
			),
		top_logprobs: z
			.int()
			.describe(
				"The number of most likely tokens that were returned at each position, along with their log probabilities.",
			),
		temperature: z.number().describe("The sampling temperature that was used for this response."),
		get reasoning() {
			return z.union([reasoningSchema.and(z.unknown()), z.null()]);
		},
		get usage() {
			return z.union([usageSchema.and(z.unknown()), z.null()]);
		},
		max_output_tokens: z.union([z.int(), z.null()]),
		max_tool_calls: z.union([z.int(), z.null()]),
		store: z.boolean().describe("Whether this response was stored so it can be retrieved later."),
		background: z.boolean().describe("Whether this request was run in the background."),
		service_tier: z.string().describe("The service tier that was used for this response."),
		metadata: z
			.unknown()
			.describe("Developer-defined metadata that was associated with the response."),
		safety_identifier: z.union([z.string(), z.null()]),
		prompt_cache_key: z.union([z.string(), z.null()]),
	})
	.describe("The complete response object that was returned by the Responses API.");

/**
 * @description A streaming event that indicated the response was created.
 */
export const responseCreatedStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.created"])
			.default("response.created")
			.describe("The type of the event, always `response.created`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		get response() {
			return responseResourceSchema.and(z.unknown());
		},
	})
	.describe("A streaming event that indicated the response was created.");

/**
 * @description A streaming event that indicated the response was queued.
 */
export const responseQueuedStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.queued"])
			.default("response.queued")
			.describe("The type of the event, always `response.queued`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		get response() {
			return responseResourceSchema.and(z.unknown());
		},
	})
	.describe("A streaming event that indicated the response was queued.");

/**
 * @description A streaming event that indicated the response was in progress.
 */
export const responseInProgressStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.in_progress"])
			.default("response.in_progress")
			.describe("The type of the event, always `response.in_progress`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		get response() {
			return responseResourceSchema.and(z.unknown());
		},
	})
	.describe("A streaming event that indicated the response was in progress.");

/**
 * @description A streaming event that indicated the response was completed.
 */
export const responseCompletedStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.completed"])
			.default("response.completed")
			.describe("The type of the event, always `response.completed`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		get response() {
			return responseResourceSchema.and(z.unknown());
		},
	})
	.describe("A streaming event that indicated the response was completed.");

/**
 * @description A streaming event that indicated the response had failed.
 */
export const responseFailedStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.failed"])
			.default("response.failed")
			.describe("The type of the event, always `response.failed`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		get response() {
			return responseResourceSchema.and(z.unknown());
		},
	})
	.describe("A streaming event that indicated the response had failed.");

/**
 * @description A streaming event that indicated the response was incomplete.
 */
export const responseIncompleteStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.incomplete"])
			.default("response.incomplete")
			.describe("The type of the event, always `response.incomplete`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		get response() {
			return responseResourceSchema.and(z.unknown());
		},
	})
	.describe("A streaming event that indicated the response was incomplete.");

/**
 * @description A streaming event that indicated an output item was added to the response.
 */
export const responseOutputItemAddedStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.output_item.added"])
			.default("response.output_item.added")
			.describe("The type of the event, always `response.output_item.added`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		output_index: z.int().describe("The index of the output item that was added."),
		get item() {
			return z.union([itemFieldSchema.and(z.unknown()), z.null()]);
		},
	})
	.describe("A streaming event that indicated an output item was added to the response.");

/**
 * @description A streaming event that indicated an output item was completed.
 */
export const responseOutputItemDoneStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.output_item.done"])
			.default("response.output_item.done")
			.describe("The type of the event, always `response.output_item.done`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		output_index: z.int().describe("The index of the output item that was completed."),
		get item() {
			return z.union([itemFieldSchema.and(z.unknown()), z.null()]);
		},
	})
	.describe("A streaming event that indicated an output item was completed.");

/**
 * @description A streaming event that indicated a reasoning summary part was added.
 */
export const responseReasoningSummaryPartAddedStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.reasoning_summary_part.added"])
			.default("response.reasoning_summary_part.added")
			.describe("The type of the event, always `response.reasoning_summary_part.added`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		summary_index: z.int().describe("The index of the summary part that was added."),
		get part() {
			return z
				.union([
					inputTextContentSchema,
					outputTextContentSchema,
					textContentSchema,
					summaryTextContentSchema,
					reasoningTextContentSchema,
					refusalContentSchema,
					inputImageContentSchema,
					inputFileContentSchema,
				])
				.describe("A content part that makes up an input or output item.");
		},
	})
	.describe("A streaming event that indicated a reasoning summary part was added.");

/**
 * @description A streaming event that indicated a reasoning summary part was completed.
 */
export const responseReasoningSummaryPartDoneStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.reasoning_summary_part.done"])
			.default("response.reasoning_summary_part.done")
			.describe("The type of the event, always `response.reasoning_summary_part.done`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		summary_index: z.int().describe("The index of the summary part that was completed."),
		get part() {
			return z
				.union([
					inputTextContentSchema,
					outputTextContentSchema,
					textContentSchema,
					summaryTextContentSchema,
					reasoningTextContentSchema,
					refusalContentSchema,
					inputImageContentSchema,
					inputFileContentSchema,
				])
				.describe("A content part that makes up an input or output item.");
		},
	})
	.describe("A streaming event that indicated a reasoning summary part was completed.");

/**
 * @description A streaming event that indicated a content part was added.
 */
export const responseContentPartAddedStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.content_part.added"])
			.default("response.content_part.added")
			.describe("The type of the event, always `response.content_part.added`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		content_index: z.int().describe("The index of the content part that was added."),
		get part() {
			return z
				.union([
					inputTextContentSchema,
					outputTextContentSchema,
					textContentSchema,
					summaryTextContentSchema,
					reasoningTextContentSchema,
					refusalContentSchema,
					inputImageContentSchema,
					inputFileContentSchema,
				])
				.describe("A content part that makes up an input or output item.");
		},
	})
	.describe("A streaming event that indicated a content part was added.");

/**
 * @description A streaming event that indicated a content part was completed.
 */
export const responseContentPartDoneStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.content_part.done"])
			.default("response.content_part.done")
			.describe("The type of the event, always `response.content_part.done`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		content_index: z.int().describe("The index of the content part that was completed."),
		get part() {
			return z
				.union([
					inputTextContentSchema,
					outputTextContentSchema,
					textContentSchema,
					summaryTextContentSchema,
					reasoningTextContentSchema,
					refusalContentSchema,
					inputImageContentSchema,
					inputFileContentSchema,
				])
				.describe("A content part that makes up an input or output item.");
		},
	})
	.describe("A streaming event that indicated a content part was completed.");

/**
 * @description A streaming event that indicated output text was incrementally added.
 */
export const responseOutputTextDeltaStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.output_text.delta"])
			.default("response.output_text.delta")
			.describe("The type of the event, always `response.output_text.delta`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		content_index: z.int().describe("The index of the content part that was updated."),
		delta: z.string().describe("The text delta that was appended."),
		get logprobs() {
			return z
				.array(logProbSchema.describe("The log probability of a token."))
				.describe("The token log probabilities that were emitted with the delta, if any.");
		},
		obfuscation: z.optional(
			z.string().describe("An obfuscation string that was added to pad the event payload."),
		),
	})
	.describe("A streaming event that indicated output text was incrementally added.");

/**
 * @description A streaming event that indicated output text was completed.
 */
export const responseOutputTextDoneStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.output_text.done"])
			.default("response.output_text.done")
			.describe("The type of the event, always `response.output_text.done`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		content_index: z.int().describe("The index of the content part that was completed."),
		text: z.string().describe("The final text that was emitted."),
		get logprobs() {
			return z
				.array(logProbSchema.describe("The log probability of a token."))
				.describe("The token log probabilities that were emitted with the final text, if any.");
		},
	})
	.describe("A streaming event that indicated output text was completed.");

/**
 * @description A streaming event that indicated refusal text was incrementally added.
 */
export const responseRefusalDeltaStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.refusal.delta"])
			.default("response.refusal.delta")
			.describe("The type of the event, always `response.refusal.delta`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		content_index: z.int().describe("The index of the refusal content that was updated."),
		delta: z.string().describe("The refusal text delta that was appended."),
	})
	.describe("A streaming event that indicated refusal text was incrementally added.");

/**
 * @description A streaming event that indicated refusal text was completed.
 */
export const responseRefusalDoneStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.refusal.done"])
			.default("response.refusal.done")
			.describe("The type of the event, always `response.refusal.done`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		content_index: z.int().describe("The index of the refusal content that was completed."),
		refusal: z.string().describe("The final refusal text that was emitted."),
	})
	.describe("A streaming event that indicated refusal text was completed.");

/**
 * @description A streaming event that indicated reasoning text was incrementally added.
 */
export const responseReasoningDeltaStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.reasoning.delta"])
			.default("response.reasoning.delta")
			.describe("The type of the event, always `response.reasoning.delta`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		content_index: z.int().describe("The index of the reasoning content that was updated."),
		delta: z.string().describe("The reasoning text delta that was appended."),
		obfuscation: z.optional(
			z.string().describe("An obfuscation string that was added to pad the event payload."),
		),
	})
	.describe("A streaming event that indicated reasoning text was incrementally added.");

/**
 * @description A streaming event that indicated reasoning text was completed.
 */
export const responseReasoningDoneStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.reasoning.done"])
			.default("response.reasoning.done")
			.describe("The type of the event, always `response.reasoning.done`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		content_index: z.int().describe("The index of the reasoning content that was completed."),
		text: z.string().describe("The final reasoning text that was emitted."),
	})
	.describe("A streaming event that indicated reasoning text was completed.");

/**
 * @description A streaming event that indicated a reasoning summary was incrementally added.
 */
export const responseReasoningSummaryDeltaStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.reasoning_summary_text.delta"])
			.default("response.reasoning_summary_text.delta")
			.describe("The type of the event, always `response.reasoning_summary.delta`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		summary_index: z.int().describe("The index of the summary content that was updated."),
		delta: z.string().describe("The summary text delta that was appended."),
		obfuscation: z.optional(
			z.string().describe("An obfuscation string that was added to pad the event payload."),
		),
	})
	.describe("A streaming event that indicated a reasoning summary was incrementally added.");

/**
 * @description A streaming event that indicated a reasoning summary was completed.
 */
export const responseReasoningSummaryDoneStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.reasoning_summary_text.done"])
			.default("response.reasoning_summary_text.done")
			.describe("The type of the event, always `response.reasoning_summary.done`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		summary_index: z.int().describe("The index of the summary content that was completed."),
		text: z.string().describe("The final summary text that was emitted."),
	})
	.describe("A streaming event that indicated a reasoning summary was completed.");

/**
 * @description A streaming event that indicated an output text annotation was added.
 */
export const responseOutputTextAnnotationAddedStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.output_text.annotation.added"])
			.default("response.output_text.annotation.added")
			.describe("The type of the event, always `response.output_text.annotation.added`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		content_index: z.int().describe("The index of the output text content that was updated."),
		annotation_index: z.int().describe("The index of the annotation that was added."),
		get annotation() {
			return z.union([annotationSchema.and(z.unknown()), z.null()]);
		},
	})
	.describe("A streaming event that indicated an output text annotation was added.");

/**
 * @description A streaming event that indicated function call arguments were incrementally added.
 */
export const responseFunctionCallArgumentsDeltaStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.function_call_arguments.delta"])
			.default("response.function_call_arguments.delta")
			.describe("The type of the event, always `response.function_call_arguments.delta`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the tool call item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		delta: z.string().describe("The arguments delta that was appended."),
		obfuscation: z.optional(
			z.string().describe("An obfuscation string that was added to pad the event payload."),
		),
	})
	.describe("A streaming event that indicated function call arguments were incrementally added.");

/**
 * @description A streaming event that indicated function call arguments were completed.
 */
export const responseFunctionCallArgumentsDoneStreamingEventSchema = z
	.object({
		type: z
			.enum(["response.function_call_arguments.done"])
			.default("response.function_call_arguments.done")
			.describe("The type of the event, always `response.function_call_arguments.done`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		item_id: z.string().describe("The ID of the tool call item that was updated."),
		output_index: z.int().describe("The index of the output item that was updated."),
		arguments: z.string().describe("The final arguments string that was emitted."),
	})
	.describe("A streaming event that indicated function call arguments were completed.");

/**
 * @description An error payload that was emitted for a streaming error event.
 */
export const errorPayloadSchema = z
	.object({
		type: z.string().describe("The error type that was emitted."),
		code: z.union([z.string(), z.null()]),
		message: z.string().describe("The human-readable error message that was emitted."),
		param: z.union([z.string(), z.null()]),
		headers: z.optional(
			z
				.object({})
				.catchall(z.string().describe("The header value that was emitted."))
				.describe("The response headers that were emitted with the error, if any."),
		),
	})
	.describe("An error payload that was emitted for a streaming error event.");

/**
 * @description A streaming event that indicated an error was emitted.
 */
export const errorStreamingEventSchema = z
	.object({
		type: z.enum(["error"]).default("error").describe("The type of the event, always `error`."),
		sequence_number: z.int().describe("The sequence number of the event that was emitted."),
		get error() {
			return errorPayloadSchema.and(z.unknown());
		},
	})
	.describe("A streaming event that indicated an error was emitted.");

/**
 * @description Success
 */
export const createresponse200Schema = z
	.lazy(() => responseResourceSchema)
	.describe("The complete response object that was returned by the Responses API.");

export const createresponseMutationRequestSchema = z.lazy(() => createResponseBodySchema);

export const createresponseMutationResponseSchema = z.lazy(() => createresponse200Schema);
