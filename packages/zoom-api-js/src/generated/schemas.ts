/**
 * Generated by Kubb (https://kubb.dev/).
 * Do not edit manually.
 */

import { z } from "zod";

export const listArchivedFilesQueryParamsSchema = z.object({
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	from: z.optional(
		z
			.string()
			.datetime()
			.describe(
				"The query start date, in `yyyy-MM-dd'T'HH:mm:ssZ` format. This value and the `to` query parameter value cannot exceed seven days.",
			),
	),
	to: z.optional(
		z
			.string()
			.datetime()
			.describe(
				"The query end date, in `yyyy-MM-dd'T'HH:mm:ssZ` format. This value and the `from` query parameter value cannot exceed seven days.",
			),
	),
	query_date_type: z
		.enum(["meeting_start_time", "archive_complete_time"])
		.default("meeting_start_time")
		.describe(
			"The type of query date.\n* `meeting_start_time` \n* `archive_complete_time` \n\n This value defaults to `meeting_start_time`.",
		),
	group_id: z.optional(z.string().describe("Deprecated. Please use 'group_ids' for querying.")),
	group_ids: z.optional(
		z
			.string()
			.describe(
				"The group IDs. To get a group ID, use the [List groups](/docs/api/rest/reference/scim-api/methods/#operation/groupSCIM2List) API.\n(The maximum number of supported groups for filtering is 7.)",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`   \n \n Archived files returned.
 */
export const listArchivedFiles200Schema = z.object({
	from: z.optional(z.string().datetime().describe("The queried start date.")),
	meetings: z.optional(
		z
			.array(
				z.object({
					account_name: z.string().describe("The user's account name."),
					archive_files: z
						.array(
							z.object({
								download_url: z
									.string()
									.describe(
										"The URL to download the the archive file. \n\n **OAuth apps** \n\n If a user has authorized and installed your OAuth app that contains recording scopes, use the user's [OAuth access token](/docs/integrations/oauth/) to download the file. For example, `https://{{base-domain}}/rec/archive/download/xxx--header 'Authorization: Bearer {{OAuth-access-token}}'` \n\n **Note:** This field does **not** return for [Zoom on-premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). Instead, this API will return the `file_path` field.",
									),
								file_extension: z.string().describe("The archived file's extension."),
								file_path: z.optional(
									z
										.string()
										.describe(
											"The file path to the on-premise account archive file. \n\n **Note:** The API only returns this field for [Zoom on-premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). It does **not** return the `download_url` field.",
										),
								),
								file_size: z.int().describe("The archived file's size, in bytes."),
								file_type: z
									.enum([
										"MP4",
										"M4A",
										"CHAT",
										"CC",
										"CHAT_MESSAGE",
										"TRANSCRIPT",
										"SUB_GROUP_MEMBER_LOG",
										"AIC_COVERSATION",
									])
									.describe(
										"The archive file's type. \n* `MP4` - Video file. \n* `M4A` - Audio-only file. \n* `CHAT` - A TXT file containing in-meeting chat messages. \n* `CC` - A file containing the closed captions of the recording, in VTT file format. \n*  `CHAT_MESSAGE` - A JSON file encoded in base64 format containing chat messages. The file also includes waiting room chats, deleted messages, meeting emojis and non-verbal feedback. \n*  `TRANSCRIPT` - A JSON file include audio transcript wording. \n* `SUB_GROUP_MEMBER_LOG` - A json file containing records of members entering and leaving the subgroup. \n* `AIC_COVERSATION` - A json file include internal user archive aic content.",
									),
								id: z.string().describe("The archive file's unique ID."),
								individual: z
									.boolean()
									.describe(
										"Whether the archive file is an individual recording file. \n* `true` - An individual recording file. \n * `false` - An entire meeting file.",
									),
								participant_email: z.optional(
									z
										.email()
										.describe(
											"The individual recording file's participant email address. This value is returned when the `individual` value is `true`. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](/docs/api/using-zoom-apis/#email-address-display-rules) for details.",
										),
								),
								participant_join_time: z
									.string()
									.datetime()
									.describe(
										"The join time for the generated recording file. If this value is returned when the individual value is `true`, it is the recording file's participant join time. When the individual value is `false`, it returns the join time for the archiving gateway.",
									),
								participant_leave_time: z
									.string()
									.datetime()
									.describe(
										"The leave time for the generated recording file. If this value is returned when the individual value is `true`, it is the recording file's participant leave time. When the individual value is `false`, it returns the leave time for the archiving gateway.",
									),
								recording_type: z
									.enum([
										"shared_screen_with_speaker_view",
										"audio_only",
										"chat_file",
										"closed_caption",
										"chat_message",
										"audio_transcript",
										"aic_conversation",
									])
									.describe(
										"The archive file's recording type. \n* `shared_screen_with_speaker_view` \n* `audio_only` \n* `chat_file` \n* `closed_caption` \n* `chat_message` \n* `audio_transcript` \n* `aic_conversation` \n\n For more information, read our [Managing and sharing cloud recordings](https://support.zoom.us/hc/en-us/articles/205347605-Managing-and-sharing-cloud-recordings#h_9898497b-e736-4980-a749-d55608f10773) documentation.",
									),
								status: z
									.enum(["completed", "processing", "failed"])
									.describe(
										"The archived file's processing status. \n* `completed` - The processing of the file is complete. \n* `processing` - The file is processing. \n* `failed` - The processing of the file failed.",
									),
								encryption_fingerprint: z
									.string()
									.describe(
										"The archived file's encryption fingerprint, using the SHA256 hash algorithm.",
									),
								number_of_messages: z.optional(
									z
										.int()
										.describe(
											"The number of `TXT` or `JSON` file messages. This field returns only when the `file_extension` is `JSON` or `TXT`.",
										),
								),
								storage_location: z.optional(
									z
										.enum(["US", "AU", "BR", "CA", "EU", "IN", "JP", "SG", "CH"])
										.describe(
											"The region where the file is stored. This field returns only `Enable Distributed Compliance Archiving` op feature is enabled.",
										),
								),
								auto_delete: z.optional(
									z
										.boolean()
										.describe(
											'Whether to auto delete the archived file.\n\n**Prerequisites:** \n\nEnable the "Tag Archiving Files for Deletion" feature in OP. Contact [Zoom Support](https://support.zoom.us/hc/en-us/articles/201362003) to open.',
										),
								),
							}),
						)
						.describe("Information about the archive files."),
					complete_time: z
						.union([z.string().datetime(), z.enum([""])])
						.describe("The meeting or webinar's archive completion time."),
					duration: z.int().describe("The meeting or webinar's scheduled duration."),
					duration_in_second: z.int().describe("The meeting or webinar's duration, in seconds."),
					host_id: z
						.string()
						.describe("The ID of the user set as the host of the archived meeting or webinar."),
					id: z.int().describe("The meeting or webinar ID, either `meetingId` or `webinarId`."),
					is_breakout_room: z
						.boolean()
						.describe(
							"Whether the room is a [breakout room](https://support.zoom.us/hc/en-us/articles/115005769646-Participating-in-breakout-rooms).",
						),
					meeting_type: z
						.enum(["internal", "external"])
						.describe(
							"Whether the meeting or webinar is internal or external. \n* `internal` - An internal meeting or webinar. \n* `external` - An external meeting or webinar. \n\n The `id`, `host_id`, and `topic` PII (Personal Identifiable Information) values in this response are removed when this value is `external`.",
						),
					parent_meeting_id: z.optional(
						z
							.string()
							.describe(
								"The parent meeting's universally unique ID (UUID). Each meeting or webinar instance generates a UUID. If the `is_breakout_room` value is `true`, the API returns this value.",
							),
					),
					recording_count: z
						.int()
						.describe("The number of archived files returned in the API call response."),
					start_time: z.string().datetime().describe("The meeting or webinar's start time."),
					timezone: z
						.string()
						.describe(
							"The meeting or webinar's [timezone](/docs/api/references/abbreviations/#timezones).",
						),
					topic: z.string().describe("The meeting or webinar topic."),
					total_size: z.int().describe("The total size of the archive file, in bytes."),
					type: z
						.union([
							z.literal(1),
							z.literal(2),
							z.literal(3),
							z.literal(4),
							z.literal(5),
							z.literal(6),
							z.literal(7),
							z.literal(8),
							z.literal(9),
							z.literal(100),
						])
						.describe(
							"The type of archived meeting or webinar. \n\n Meeting recordings use these archive types. \n* `1` - Instant meeting. \n* `2` - Scheduled meeting. \n* `3` - A recurring meeting with no fixed time. \n* `4` - A meeting created via PMI (Personal Meeting ID). \n* `7` - A [Personal Audio Conference](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference) (PAC). \n* `8` - Recurring meeting with a fixed time. \n\n Webinar recordings use these archive types. \n* `5` - A webinar. \n* `6` - A recurring webinar without a fixed time. \n* `9` - A recurring webinar with a fixed time. \n\n If the recording is **not** from a meeting or webinar: \n\n* `100` - A [breakout room](https://support.zoom.us/hc/en-us/articles/115005769646-Participating-in-breakout-rooms).",
						),
					uuid: z
						.string()
						.describe(
							"The recorded meeting or webinar instance's universally unique identifier (UUID). Each meeting or webinar instance generates a UUID.",
						),
					status: z
						.enum(["completed", "processing"])
						.describe(
							"The archive's processing status. \n* `completed` - The archive's processing is complete. \n* `processing` - The archive is processing.",
						),
					group_id: z.optional(
						z
							.string()
							.describe(
								"Primary group IDs of participants who belong to your account. Each group ID is separated by a comma.",
							),
					),
					physical_files: z.optional(
						z
							.array(
								z.object({
									file_id: z.optional(z.string().describe("The physical file's unique ID.")),
									file_name: z.optional(z.string().describe("The physical file's name.")),
									file_size: z.optional(z.int().describe("The physical file's size, in bytes.")),
									download_url: z.optional(
										z
											.string()
											.describe(
												"The URL to download the the archive file. \n\n **OAuth apps** \n\n If a user has authorized and installed your OAuth app that contains recording scopes, use the user's [OAuth access token](/docs/integrations/oauth/) to download the file. \n\n Example: \n\n `https://{{base-domain}}/rec/archive/attached/download/xxx--header 'Authorization: Bearer {{OAuth-access-token}}'` ",
											),
									),
								}),
							)
							.describe("Information about the physical files."),
					),
				}),
			)
			.describe("Information about the meeting or webinar."),
	),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.\n\n **Note:** if you use `next_page_token` as a parameter, your other request parameters should be changeless to make sure that the large result set is what you want. For example, if your `to` parameter is for a future time, Zoom resets this value to the current time and returns this value in the response body, along with the `next_page_token` value. Use these same `to` and `next_page_token` values in requests for the remaining results set; otherwise you will get an invalid token error.",
			),
	),
	page_size: z.optional(
		z.int().describe("The number of records returned within a single API call."),
	),
	to: z.optional(z.string().datetime().describe("The queried end date.")),
	total_records: z.optional(z.int().describe("The total number of returned meeting records.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `2001` <br>\n Account does not exist: {accountId} <br>\n
 */
export const listArchivedFiles400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const listArchivedFiles429Schema = z.unknown();

export const listArchivedFilesQueryResponseSchema = z.lazy(() => listArchivedFiles200Schema);

export const getArchivedFileStatisticsQueryParamsSchema = z
	.object({
		from: z.optional(
			z
				.string()
				.datetime()
				.describe(
					"The query start date, in `yyyy-MM-dd'T'HH:mm:ssZ` format. This value and the `to` query parameter value cannot exceed seven days.",
				),
		),
		to: z.optional(
			z
				.string()
				.datetime()
				.describe(
					"The query end date, in `yyyy-MM-dd'T'HH:mm:ssZ` format. This value and the `from` query parameter value cannot exceed seven days.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `200`   \n \n The statistics of Archived files returned.
 */
export const getArchivedFileStatistics200Schema = z.object({
	from: z.optional(z.string().datetime().describe("The queried start date.")),
	to: z.optional(z.string().datetime().describe("The queried end date.")),
	total_records: z.optional(z.int().describe("The total number of returned meeting records.")),
	statistic_by_file_extension: z.optional(
		z
			.object({
				mp4_file_count: z.optional(z.int().describe("The number of mp4 files.")),
				m4a_file_count: z.optional(z.int().describe("The number of m4a files.")),
				txt_file_count: z.optional(z.int().describe("The number of txt files.")),
				json_file_count: z.optional(z.int().describe("The number of json files.")),
				vtt_file_count: z.optional(z.int().describe("The number of vtt files.")),
			})
			.describe("Statistics about archive files, by file extension."),
	),
	statistic_by_file_status: z.optional(
		z
			.object({
				processing_file_count: z.optional(z.int().describe("The number of processing files.")),
				completed_file_count: z.optional(z.int().describe("The number of completed files.")),
				failed_file_count: z.optional(z.int().describe("The number of failed files.")),
			})
			.describe("Statistics about archive files, by file status."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `2001` <br>\n Account does not exist: {accountId}. <br>\n
 */
export const getArchivedFileStatistics400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const getArchivedFileStatistics429Schema = z.unknown();

export const getArchivedFileStatisticsQueryResponseSchema = z.lazy(
	() => getArchivedFileStatistics200Schema,
);

export const updateArchivedFilePathParamsSchema = z.object({
	fileId: z.string().describe("Archived file ID."),
});

/**
 * @description **HTTP Status Code:** `204` <br>\n auto-delete status updated  \n\n
 */
export const updateArchivedFile204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n
 */
export const updateArchivedFile400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n
 */
export const updateArchivedFile404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const updateArchivedFile429Schema = z.unknown();

export const updateArchivedFileMutationRequestSchema = z.object({
	auto_delete: z.boolean().describe("Whether to auto-delete the archived file."),
});

export const updateArchivedFileMutationResponseSchema = z.lazy(() => updateArchivedFile204Schema);

export const meetingLocalArchivingArchiveTokenPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `200`   \n \nMeeting local archiving token returned.
 */
export const meetingLocalArchivingArchiveToken200Schema = z
	.object({
		expire_in: z.optional(
			z
				.literal(120)
				.describe(
					"The number of seconds the archive token is valid for before it expires. This value always returns `120`.",
				),
		),
		token: z.optional(z.string().describe("The archive token.")),
	})
	.describe("Information about the meeting's local archive token.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `3000` <br>\n Cannot access webinar information. <br>\n**Error Code:** `124` <br>\n This API only supports OAuth2 authorization. <br>\n**Error Code:** `3000` <br>\n Not allowed to start local archiving. To use this feature, enable the \"Archive meetings and webinars\" setting in the \"Settings\" page of the Zoom web portal. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingLocalArchivingArchiveToken400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `300` <br>\n Meeting ID does not exist. <br>\n**Error Code:** `3001` <br>\n Meeting does not exist: {meetingId} <br>\n
 */
export const meetingLocalArchivingArchiveToken404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingLocalArchivingArchiveToken429Schema = z.unknown();

export const meetingLocalArchivingArchiveTokenQueryResponseSchema = z.lazy(
	() => meetingLocalArchivingArchiveToken200Schema,
);

export const getArchivedFilesPathParamsSchema = z.object({
	meetingUUID: z
		.string()
		.describe(
			"The meeting's universally unique identifier (UUID). Each meeting instance generates a UUID. After a meeting ends, a new UUID is generated for the next meeting instance.\n\nIf the meeting UUID begins with a `/` character or contains a `//` character, you **must** [double encode](/docs/api/using-zoom-apis/#meeting-id-and-uuid) the meeting UUID when using the meeting UUID for other API calls.",
		),
});

/**
 * @description **HTTP Status Code:** `200`   \n\n Meeting archived files returned.
 */
export const getArchivedFiles200Schema = z.object({
	account_name: z.string().describe("The user's account name."),
	archive_files: z
		.array(
			z.object({
				download_url: z
					.string()
					.describe(
						"The URL to download the the archive file. \n\n **OAuth apps** \n\n If a user has authorized and installed your OAuth app that contains recording scopes, use the user's [OAuth access token](/docs/integrations/oauth/) to download the file. For example: \n\n `https://{{base-domain}}/rec/archive/download/xxx--header 'Authorization: Bearer {{OAuth-access-token}}'` \n\n **Note:** This field does **not** return for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). Instead, this API will return the `file_path` field.",
					),
				file_extension: z.string().describe("The archived file's extension."),
				file_path: z.optional(
					z
						.string()
						.describe(
							"The file path to the on-premise account archive file. \n\n **Note:** The API only returns this field for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). It does **not** return the `download_url` field.",
						),
				),
				file_size: z.int().describe("The archived file's size, in bytes."),
				file_type: z
					.enum([
						"MP4",
						"M4A",
						"CHAT",
						"CC",
						"CHAT_MESSAGE",
						"TRANSCRIPT",
						"SUB_GROUP_MEMBER_LOG",
						"AIC_COVERSATION",
					])
					.describe(
						"The archive file's type. \n* `MP4` - Video file. \n* `M4A` - Audio-only file. \n* `CHAT` - A TXT file containing in-meeting chat messages. \n* `CC` - A file containing the closed captions of the recording, in VTT file format. \n* `CHAT_MESSAGE` - A JSON file encoded in base64 format containing chat messages. The file also includes waiting room chats, deleted messages, meeting emojis and non-verbal feedback.  \n*  `TRANSCRIPT` - A JSON file include audio transcript wording. \n* `SUB_GROUP_MEMBER_LOG` - A JSON file containing records of members entering and leaving the subgroup. \n* `AIC_COVERSATION` - A json file include internal user archive aic content.",
					),
				id: z.string().describe("The archive file's unique ID."),
				individual: z
					.boolean()
					.describe(
						"Whether the archive file is an individual recording file. \n* `true` - An individual recording file. \n * `false` - An entire meeting file.",
					),
				participant_email: z.optional(
					z
						.email()
						.describe(
							"The individual recording file's participant email address. This value is returned when the `individual` value is `true`. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](/docs/api/using-zoom-apis/#email-address-display-rules) for details.",
						),
				),
				participant_join_time: z
					.string()
					.datetime()
					.describe(
						"The join time for the generated recording file. If this value is returned when the individual value is true, then it is the recording file's participant join time. When the individual value is false, it returns the join time for the archiving gateway.",
					),
				participant_leave_time: z
					.string()
					.datetime()
					.describe(
						"The leave time for the generated recording file. If this value is returned when the individual value is true, then it is the recording file's participant leave time. When the individual value is false, it returns the leave time for the archiving gateway.",
					),
				recording_type: z
					.enum([
						"shared_screen_with_speaker_view",
						"audio_only",
						"chat_file",
						"closed_caption",
						"chat_message",
						"audio_transcript",
						"aic_conversation",
					])
					.describe(
						"The archive file's recording type. \n* `shared_screen_with_speaker_view` \n* `audio_only` \n* `chat_file` \n* `closed_caption` \n* `chat_message` \n* `audio_transcript` \n* `aic_conversation` \n\n For more information, read our [Managing and sharing cloud recordings](https://support.zoom.us/hc/en-us/articles/205347605-Managing-and-sharing-cloud-recordings#h_9898497b-e736-4980-a749-d55608f10773) documentation.",
					),
				status: z
					.enum(["completed", "processing", "failed"])
					.describe(
						"The archived file's processing status. \n* `completed` - The processing of the file is complete. \n* `processing` - The file is processing. \n* `failed` - The processing of the file failed.",
					),
				encryption_fingerprint: z
					.string()
					.describe("The archived file's encryption fingerprint, using the SHA256 hash algorithm."),
				number_of_messages: z.optional(
					z
						.int()
						.describe(
							"The number of `TXT` or `JSON` file messages. This field returns only when the `file_extension` is `JSON` or `TXT`",
						),
				),
				storage_location: z.optional(
					z
						.enum(["US", "AU", "BR", "CA", "EU", "IN", "JP", "SG", "CH"])
						.describe(
							"The region where the file is stored. This field returns only `Enable Distributed Compliance Archiving` op feature is enabled.",
						),
				),
				auto_delete: z.optional(
					z
						.boolean()
						.describe(
							'Whether to auto delete the archived file.\n\n **Prerequisites:** \n\n* The "Tag Archiving Files for Deletion" feature must be enabled in OP. Contact [Zoom Support](https://support.zoom.us/hc/en-us/articles/201362003) to open.\n',
						),
				),
			}),
		)
		.describe("Information about the archive files."),
	complete_time: z
		.union([z.string().datetime(), z.enum([""])])
		.describe("The meeting or webinar's archive completion time."),
	duration: z.int().describe("The meeting or webinar's scheduled duration."),
	duration_in_second: z.int().describe("The meeting or webinar's duration, in seconds."),
	host_id: z.string().describe("The host's user ID for the archived meeting or webinar."),
	id: z.int().describe("The meeting or webinar ID, either `meetingId` or `webinarId`."),
	is_breakout_room: z
		.boolean()
		.describe(
			"Whether the room is a [breakout room](https://support.zoom.us/hc/en-us/articles/115005769646-Participating-in-breakout-rooms).",
		),
	meeting_type: z
		.enum(["internal", "external"])
		.describe(
			"Whether the meeting or webinar is internal or external. \n* `internal` - An internal meeting or webinar. \n* `external` - An external meeting or webinar. \n\n The `id`, `host_id`, and `topic` PII (Personal Identifiable Information) values in this response are removed when this value is `external`.",
		),
	parent_meeting_id: z.optional(
		z
			.string()
			.describe(
				"The parent meeting's universally unique ID (UUID). Each meeting or webinar instance generates a UUID. If the `is_breakout_room` value is `true`, the API returns this value.",
			),
	),
	recording_count: z
		.int()
		.describe("The number of archived files returned in the API call response."),
	start_time: z.string().datetime().describe("The meeting or webinar's start time."),
	timezone: z
		.string()
		.describe(
			"The meeting or webinar's [timezone](/docs/api/references/abbreviations/#timezones).",
		),
	topic: z.string().describe("The meeting or webinar topic."),
	total_size: z.int().describe("The total size of the archive file, in bytes."),
	type: z
		.union([
			z.literal(1),
			z.literal(2),
			z.literal(3),
			z.literal(4),
			z.literal(5),
			z.literal(6),
			z.literal(7),
			z.literal(8),
			z.literal(9),
			z.literal(100),
		])
		.describe(
			"The type of archived meeting or webinar. \n\n If the recording is of a meeting: \n* `1` - Instant meeting. \n* `2` - Scheduled meeting. \n* `3` - A recurring meeting with no fixed time. \n* `4` - A meeting created via PMI (Personal Meeting ID). \n* `7` - A [Personal Audio Conference](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference) (PAC). \n* `8` - Recurring meeting with a fixed time. \n\n If the recording is of a webinar: \n* `5` - A webinar. \n* `6` - A recurring webinar without a fixed time. \n* `9` - A recurring webinar with a fixed time. \n\n If the recording is **not** from a meeting or webinar: \n\n* `100` - A [breakout room](https://support.zoom.us/hc/en-us/articles/115005769646-Participating-in-breakout-rooms).",
		),
	uuid: z
		.string()
		.describe(
			"The universally unique identifier (UUID) of the recorded meeting or webinar instance. Each meeting or webinar instance generates a UUID.",
		),
	status: z
		.enum(["completed", "processing"])
		.describe(
			"The archive's processing status. \n* `completed` - The archive's processing is complete. \n* `processing` - The archive is processing.",
		),
	group_id: z.optional(
		z
			.string()
			.describe(
				"Primary group IDs of participants who belong to your account. Each group ID is separated by a comma.",
			),
	),
	physical_files: z.optional(
		z
			.array(
				z.object({
					file_id: z.optional(z.string().describe("The physical file's unique ID.")),
					file_name: z.optional(z.string().describe("The physical file's name.")),
					file_size: z.optional(z.int().describe("The physical file's size, in bytes.")),
					download_url: z.optional(
						z
							.string()
							.describe(
								"The URL to download the the archive file. \n\n **OAuth apps** \n\n If a user has authorized and installed your OAuth app that contains recording scopes, use the user's [OAuth access token](/docs/integrations/oauth/) to download the file. For example: \n\n `https://{{base-domain}}/rec/archive/attached/download/xxx--header 'Authorization: Bearer {{OAuth-access-token}}'` ",
							),
					),
				}),
			)
			.describe("Information about the physical files."),
	),
});

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting {meetingUUId} does not exist. <br> <br>\n
 */
export const getArchivedFiles404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const getArchivedFiles429Schema = z.unknown();

export const getArchivedFilesQueryResponseSchema = z.lazy(() => getArchivedFiles200Schema);

export const deleteArchivedFilesPathParamsSchema = z.object({
	meetingUUID: z
		.string()
		.describe(
			"The meeting's universally unique identifier (UUID). Each meeting instance generates a UUID. For example, after a meeting ends, a new UUID is generated for the next meeting instance.\n\nIf the meeting UUID begins with a `/` character or contains a `//` character, you **must** double-encode the meeting UUID when using the meeting UUID for other API calls.",
		),
});

/**
 * @description **HTTP Status Code:** `204`   \n \n Meeting archived file deleted.
 */
export const deleteArchivedFiles204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n Only available for Paid account. <br>\n**Error Code:** `200` <br>\n Not available for this account. <br>\n
 */
export const deleteArchivedFiles400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {0} <br>\n
 */
export const deleteArchivedFiles404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const deleteArchivedFiles429Schema = z.unknown();

export const deleteArchivedFilesMutationResponseSchema = z.lazy(() => deleteArchivedFiles204Schema);

export const recordingGetPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"To get a meeting's cloud recordings, provide the meeting ID or UUID. If providing the meeting ID instead of UUID, the response will be for the latest meeting instance. \n\nTo get a webinar's cloud recordings, provide the webinar's ID or UUID. If providing the webinar ID instead of UUID, the response will be for the latest webinar instance. \n\nIf a UUID starts with `/` or contains `//` (example: `/ajXp112QmuoKj4854875==`), **[double encode](/docs/api/using-zoom-apis/#meeting-id-and-uuid) the UUID** before making an API request. ",
		),
});

export const recordingGetQueryParamsSchema = z
	.object({
		include_fields: z.optional(
			z
				.string()
				.describe(
					"Include fields in the response. Currently, only accepts `download_access_token` to get this token field and value for downloading the meeting's recordings. The `download_access_token` requires **View the recording content** enabled for the role authorizing the account. Use the format `include_fields=download_access_token`.",
				),
		),
		ttl: z.optional(
			z.coerce
				.number()
				.int()
				.min(0)
				.max(604800)
				.describe(
					"The `download_access_token` Time to Live (TTL) value. This parameter is only valid if the `include_fields` query parameter contains the value `download_access_token`.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `200`   \n \nRecording object returned. \n\n**Error Code:** `200`   \n \nYou do not have the right permissions.
 */
export const recordingGet200Schema = z
	.object({
		recording_files: z.optional(
			z
				.array(
					z.object({
						deleted_time: z.optional(
							z
								.string()
								.describe(
									"The time when the recording was deleted. Returned in the response only for the trash query.",
								),
						),
						download_url: z.optional(
							z
								.string()
								.describe(
									"The URL to download the recording. \n\nIf a user has authorized and installed your OAuth app that contains recording scopes, use the `download_access_token` or the user's [OAuth access token](/docs/integrations/oauth/) to download the file. Set the `access_token` as a Bearer token in the Authorization header. For example: \n\n`curl -H 'Authorization: Bearer <ACCESS_TOKEN>' https://{{base-domain}}/rec/archive/download/xyz`.\n\n**Note:** This field does **not** return for Zoom on-premise accounts. Instead, this API returns the `file_path` field. The URL may be a redirect. In that case, use `curl --location` to follow redirects or use another tool, like Postman.",
								),
						),
						file_path: z.optional(
							z
								.string()
								.describe(
									"The file path to the on-premise account recording. \n\n**Note:** This API only returns this field for Zoom On-Premise accounts. It does **not** return the `download_url` field.",
								),
						),
						file_size: z.optional(z.number().describe("The recording file size.")),
						file_type: z.optional(
							z
								.enum([
									"MP4",
									"M4A",
									"CHAT",
									"TRANSCRIPT",
									"CSV",
									"TB",
									"CC",
									"CHAT_MESSAGE",
									"SUMMARY",
								])
								.describe(
									"The recording file type. \n \n`MP4` - Video file of the recording.  \n `M4A` - Audio-only file of the recording.  \n `TIMELINE` - Timestamp file of the recording in JSON file format. To get a timeline file, the **Add a timestamp to the recording** setting must be enabled in the [recording settings](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0062627#h_3f14c3a4-d16b-4a3c-bbe5-ef7d24500048). The time will display in the host's timezone, set on their Zoom profile.\n  \n  `TRANSCRIPT` - Transcription file of the recording in VTT format.  \n  `CHAT` - A TXT file containing in-meeting chat messages that were sent during the meeting.  \n `CC` - File containing closed captions of the recording in VTT file format.  \n `CSV` - File containing polling data in csv format.\n\n  \n \n\nA recording file object with file type of either `CC` or `TIMELINE` **does not have** these properties.  \n \n\t`id`, `status`, `file_size`, `recording_type`, and `play_url`.  \n `SUMMARY` - Summary file of the recording in JSON file format.",
								),
						),
						file_extension: z.optional(
							z
								.enum(["MP4", "M4A", "TXT", "VTT", "CSV", "JSON", "JPG"])
								.describe("The file extension type of the recording file."),
						),
						id: z.optional(
							z
								.string()
								.describe(
									"The recording file ID. It's included in the response of the general query.",
								),
						),
						meeting_id: z.optional(z.string().describe("The meeting ID. ")),
						play_url: z.optional(z.string().describe("The URL that can play a recording file.")),
						recording_end: z.optional(
							z.string().describe("The recording end time. The response is in the general query."),
						),
						recording_start: z.optional(z.string().describe("The recording start time.")),
						recording_type: z.optional(
							z
								.enum([
									"shared_screen_with_speaker_view(CC)",
									"shared_screen_with_speaker_view",
									"shared_screen_with_gallery_view",
									"active_speaker",
									"gallery_view",
									"shared_screen",
									"audio_only",
									"audio_transcript",
									"chat_file",
									"poll",
									"host_video",
									"closed_caption",
									"timeline",
									"thumbnail",
									"audio_interpretation",
									"summary",
									"summary_next_steps",
									"summary_smart_chapters",
									"sign_interpretation",
									"production_studio",
								])
								.describe("The recording type."),
						),
						status: z.optional(z.enum(["completed"]).describe("The recording status.")),
					}),
				)
				.describe("List of recording files."),
		),
	})
	.and(
		z.object({
			account_id: z.optional(z.string().describe("The user account's unique identifier.")),
			duration: z.optional(z.int().describe("The duration of the meeting's recording.")),
			host_id: z.optional(
				z.string().describe("The ID of the user set as the host of the meeting."),
			),
			id: z.optional(z.int().describe("The meeting ID, also known as the meeting number.")),
			recording_count: z.optional(
				z
					.int()
					.describe(
						"The number of recording files returned in the response of this API call. This includes the `recording_files` and  `participant_audio_files` files.",
					),
			),
			start_time: z.optional(z.string().datetime().describe("The time when the meeting started.")),
			topic: z.optional(z.string().describe("The meeting topic.")),
			total_size: z.optional(
				z
					.int()
					.describe(
						"The recording's total file size. This includes the `recording_files` and `participant_audio_files` files.",
					),
			),
			type: z.optional(
				z
					.enum(["1", "2", "3", "4", "5", "6", "7", "8", "9", "99"])
					.describe(
						"The recording's associated type of meeting or webinar. \n\nIf the recording is of a meeting: \n* `1` - Instant meeting. \n* `2` - Scheduled meeting. \n* `3` - A recurring meeting with no fixed time. \n* `4` - A meeting created via PMI (Personal Meeting ID). \n* `7` - A [Personal Audio Conference](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0060449) (PAC). \n* `8` - Recurring meeting with a fixed time. \n\nIf the recording is of a webinar: \n* `5` - A webinar. \n* `6` - A recurring webinar without a fixed time \n* `9` - A recurring webinar with a fixed time.\n\nIf the recording is **not** from a meeting or webinar: \n\n* `99` - A recording uploaded via the [**Recordings**](https://zoom.us/recording) interface on the Zoom Web Portal.",
					),
			),
			uuid: z.optional(
				z
					.string()
					.describe(
						"The unique meeting identifier. Each instance of the meeting has its own UUID.",
					),
			),
			recording_play_passcode: z.optional(
				z
					.string()
					.describe(
						"The cloud recording's passcode to be used in the URL. Directly splice this recording's passcode in `play_url` or `share_url` with `?pwd=` to access and play. Example: 'https://zoom.us/rec/share/**************?pwd=yNYIS408EJygs7rE5vVsJwXIz4-VW7MH'.",
					),
			),
			auto_delete: z.optional(
				z
					.boolean()
					.describe(
						"Auto-delete status of a meeting's [cloud recording](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0062627).  \n\nPrerequisite: To get the auto-delete status, the host of the recording must have the recording setting **Delete cloud recordings after a specified number of days** enabled. ",
					),
			),
			auto_delete_date: z.optional(
				z
					.string()
					.describe(
						"The date when the recording will be auto-deleted when `auto_delete` is true. Otherwise, no date will be returned.",
					),
			),
		}),
	)
	.and(
		z.object({
			participant_audio_files: z.optional(
				z
					.array(
						z.object({
							download_url: z.optional(
								z
									.string()
									.describe(
										"The URL to download the recording. If a user has authorized and installed your OAuth app that contains recording scopes, use the user's [OAuth access token](/docs/integrations/oauth/) to download the file, and set the `access_token` as a Bearer token in the Authorization header.\n\n`curl -H 'Authorization: Bearer <ACCESS_TOKEN>' https://{{base-domain}}/rec/archive/download/xyz` \n\n**Note:** This field does **not** return for Zoom On-Premise accounts. Instead, this API will return the `file_path` field.",
									),
							),
							file_name: z.optional(z.string().describe("The recording file's name.")),
							file_path: z.optional(
								z
									.string()
									.describe(
										"The file path to the on-premise account recording. \n\n**Note:** This API only returns this field for Zoom on-premise accounts. It does **not** return the `download_url` field.",
									),
							),
							file_size: z.optional(z.number().describe("The recording file's size, in bytes.")),
							file_type: z.optional(
								z
									.string()
									.describe(
										"The recording file's format. \n\n* `MP4` - Video file.\n* `M4A` - Audio-only file.\n* `TIMELINE` - Timestamp file of the recording, in JSON file format. To get a timeline file, the **Add a timestamp to the recording** setting **must** be enabled in the [recording settings](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0062627#h_3f14c3a4-d16b-4a3c-bbe5-ef7d24500048). The time will display in the host's timezone.\n* `TRANSCRIPT` - A transcript of the recording, in VTT format.\n* `CHAT` - A text file containing chat messages sent during the meeting.\n* `CC` - A file containing the closed captions of the recording, in VTT file format.\n* `CSV` - A file containing polling data, in CSV format.\n\nA recording file object with file the `CC` or `TIMELINE` value **does not** have the `id`, `status`, `file_size`, `recording_type`, and `play_url` properties.",
									),
							),
							id: z.optional(
								z
									.string()
									.describe(
										"The recording file's unique ID. This is included in the general query response.",
									),
							),
							play_url: z.optional(
								z.string().describe("The URL where the recording file can be opened and played."),
							),
							recording_end: z.optional(
								z
									.string()
									.datetime()
									.describe(
										"The recording file's end time. This is included in the general query response.",
									),
							),
							recording_start: z.optional(
								z.string().datetime().describe("The recording file's start time."),
							),
							status: z.optional(z.enum(["completed"]).describe("The recording file's status.")),
						}),
					)
					.describe(
						"A list of recording files. The API only returns this response when the **Record a separate audio file of each participant** setting is enabled.",
					),
			),
		}),
	)
	.and(
		z.object({
			download_access_token: z.optional(
				z
					.string()
					.describe(
						"The JWT token to download the meeting's recording. This response only returns if the `download_access_token` is included in the `include_fields` query parameter.",
					),
			),
			password: z.optional(
				z
					.string()
					.describe(
						"The cloud recording's password.\nInclude fields in the response. The password field requires the user role of the authorized account to enable the `View Recording Content` permission.",
					),
			),
			recording_play_passcode: z.optional(
				z
					.string()
					.describe(
						"The cloud recording's passcode to be used in the URL. Directly splice this recording's passcode in `play_url` or `share_url` with `?pwd=` to access and play. Example: 'https://zoom.us/rec/share/**************?pwd=yNYIS408EJygs7rE5vVsJwXIz4-VW7MH'.",
					),
			),
		}),
	);

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `1010` <br>\n User not found on this account: {accountId}. <br>\n
 */
export const recordingGet400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User \"{userId}\" does not exist or does not belong to this account. <br>\n**Error Code:** `3301` <br>\n There is no recording for this meeting. <br>\n
 */
export const recordingGet404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const recordingGet429Schema = z.unknown();

export const recordingGetQueryResponseSchema = z.lazy(() => recordingGet200Schema);

export const recordingDeletePathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"To get a meeting's cloud recordings, provide the meeting ID or meeting UUID. If the meeting ID is provided instead of UUID, the response will be for the latest meeting instance. \n\nTo get a webinar's cloud recordings, provide the webinar ID or the webinar UUID. If the webinar ID is provided instead of UUID, the response will be for the latest webinar instance. \n\nIf a UUID starts with `/` or contains `//`, like `/ajXp112QmuoKj4854875==`, you must **double encode** the UUID before making an API request. ",
		),
});

export const recordingDeleteQueryParamsSchema = z.object({
	action: z
		.enum(["trash", "delete"])
		.default("trash")
		.describe(
			"The recording delete actions.  \n `trash` - Move recording to trash.  \n `delete` - Delete recording permanently.",
		),
});

/**
 * @description The recording was successfully deleted.
 */
export const recordingDelete204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `1010` <br>\n User does not belong to this account: {accountId}. <br>\n**Error Code:** `3310` <br>\n This recording was selected for a simulive webinar. You cannot delete or trash it. <br>\n
 */
export const recordingDelete400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User {userId} does not exist or does not belong to this account.<br> <br>\n**Error Code:** `3301` <br>\n There is no recording for this meeting. <br>\n
 */
export const recordingDelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const recordingDelete429Schema = z.unknown();

export const recordingDeleteMutationResponseSchema = z.lazy(() => recordingDelete204Schema);

export const analyticsDetailsPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"To get a meeting's cloud recordings, provide the meeting ID or meeting UUID. If the meeting ID is provided instead of UUID, the response will be for the latest meeting instance. \n\nTo get a webinar's cloud recordings, provide the webinar ID or the webinar UUID. If the webinar ID is provided instead of UUID, the response will be for the latest webinar instance. \n\nIf a UUID starts with `/` or contains `//`, like `/ajXp112QmuoKj4854875==`, you must **double encode** the UUID before making an API request. ",
		),
});

export const analyticsDetailsQueryParamsSchema = z.object({
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	from: z.optional(
		z.iso
			.date()
			.describe(
				"The start date for the monthly range to query. The maximum range can be a month. If you do not provide this value, this defaults to the current date.",
			),
	),
	to: z.optional(
		z.iso
			.date()
			.describe("The end date for the monthly range to query. The maximum range can be a month."),
	),
	type: z.optional(
		z
			.enum(["by_view", "by_download"])
			.describe(
				"The type of analytics details: \n* `by_view` &mdash; by_view. \n* `by_download` &mdash; by_download.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`   \n \nAnalytics Detail listed successfully.
 */
export const analyticsDetails200Schema = z.object({
	from: z.optional(z.iso.date().describe("The queried start date")),
	to: z.optional(z.iso.date().describe("The queried end date.")),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.",
			),
	),
	page_size: z.optional(
		z.int().max(300).describe("The number of records returned within a single API call."),
	),
	total_records: z.optional(
		z.int().describe("The total number of all the records available across pages."),
	),
	analytics_details: z.optional(
		z
			.array(
				z.object({
					date_time: z.optional(
						z.string().datetime().describe("Explicit time to watch or download the recording."),
					),
					name: z.optional(z.string().describe("The user's name who watched or downloaded.")),
					email: z.optional(
						z.string().describe("The user's email who downloaded this Meeting Recording."),
					),
					duration: z.optional(
						z
							.int()
							.describe(
								"When the query type is `by_view`, this field indicates the viewing time, unit: seconds",
							),
					),
				}),
			)
			.describe("Analytics Detail."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `1010` <br>\n User not found on this account: {accountId}. <br>\n
 */
export const analyticsDetails400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User \"{userId}\" does not exist or does not belong to this account. <br>\n**Error Code:** `3301` <br>\n There is no recording for this meeting. <br>\n
 */
export const analyticsDetails404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const analyticsDetails429Schema = z.unknown();

export const analyticsDetailsQueryResponseSchema = z.lazy(() => analyticsDetails200Schema);

export const analyticsSummaryPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"To get a meeting's cloud recordings, provide the meeting ID or meeting UUID. If the meeting ID is provided instead of UUID, the response will be for the latest meeting instance. \n\nTo get a webinar's cloud recordings, provide the webinar ID or the webinar UUID. If the webinar ID is provided instead of UUID, the response will be for the latest webinar instance. \n\nIf a UUID starts with `/` or contains `//`, like `/ajXp112QmuoKj4854875==`, you must **double encode** the UUID before making an API request. ",
		),
});

export const analyticsSummaryQueryParamsSchema = z
	.object({
		from: z.optional(
			z.iso
				.date()
				.describe(
					"The start date for the monthly range to query. The maximum range can be a month. If you do not provide this value, this defaults to the current date.",
				),
		),
		to: z.optional(
			z.iso
				.date()
				.describe("The end date for the monthly range to query. The maximum range can be a month."),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `200`   \n \nAnalytics Summary listed successfully.
 */
export const analyticsSummary200Schema = z.object({
	from: z.optional(z.iso.date().describe("The queried start date")),
	to: z.optional(z.iso.date().describe("The queried end date.")),
	analytics_summary: z.optional(
		z
			.array(
				z.object({
					date: z.optional(z.string().describe("Date of viewing or downloading the recording.")),
					views_total_count: z.optional(
						z.int().describe("The number of people who have watched this Meeting Recording."),
					),
					downloads_total_count: z.optional(
						z.int().describe("The number of people who downloaded this Meeting Recording."),
					),
				}),
			)
			.describe("Analytics Summary."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `1010` <br>\n User not found on this account: {accountId}. <br>\n
 */
export const analyticsSummary400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User \"{userId}\" does not exist or does not belong to this account. <br>\n**Error Code:** `3301` <br>\n There is no recording for this meeting. <br>\n
 */
export const analyticsSummary404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const analyticsSummary429Schema = z.unknown();

export const analyticsSummaryQueryResponseSchema = z.lazy(() => analyticsSummary200Schema);

export const meetingRecordingRegistrantsPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

export const meetingRecordingRegistrantsQueryParamsSchema = z.object({
	status: z
		.enum(["pending", "approved", "denied"])
		.default("approved")
		.describe(
			"Query by the registrant's status. \n* `pending` - The registration is pending. \n* `approved` - The registrant is approved. \n* `denied` - The registration is denied.",
		),
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	page_number: z.coerce
		.number()
		.int()
		.default(1)
		.describe(
			"**Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.",
		),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`   \n \n Registrants returned.
 */
export const meetingRecordingRegistrants200Schema = z
	.object({
		next_page_token: z.optional(
			z
				.string()
				.describe(
					"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
				),
		),
		page_count: z.optional(z.int().describe("The number of pages returned for the request made.")),
		page_number: z.optional(
			z
				.int()
				.default(1)
				.describe(
					"**Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.",
				),
		),
		page_size: z.optional(
			z
				.int()
				.max(300)
				.default(30)
				.describe("The number of records returned with a single API call."),
		),
		total_records: z.optional(
			z.int().describe("The total number of all the records available across pages."),
		),
		registrants: z.optional(
			z
				.array(
					z
						.object({
							address: z.optional(z.string().describe("The registrant's address.")),
							city: z.optional(z.string().describe("The registrant's city.")),
							comments: z.optional(z.string().describe("The registrant's questions and comments.")),
							country: z.optional(
								z
									.string()
									.describe(
										"The registrant's two-letter [country code](https://developers.zoom.us/docs/api/rest/other-references/abbreviation-lists/#countries).",
									),
							),
							custom_questions: z.optional(
								z
									.array(
										z
											.object({
												title: z.optional(z.string().describe("The custom question's title.")),
												value: z.optional(
													z
														.string()
														.max(128)
														.describe(
															"The custom question's response value. This has a limit of 128 characters.",
														),
												),
											})
											.describe("Information about custom questions."),
									)
									.describe("Information about custom questions."),
							),
							email: z
								.email()
								.max(128)
								.describe(
									"The registrant's email address. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for return value details.",
								),
							first_name: z.string().max(64).describe("The registrant's first name."),
							industry: z.optional(z.string().describe("The registrant's industry.")),
							job_title: z.optional(z.string().describe("The registrant's job title.")),
							last_name: z.optional(z.string().max(64).describe("The registrant's last name.")),
							no_of_employees: z.optional(
								z
									.enum([
										"",
										"1-20",
										"21-50",
										"51-100",
										"101-250",
										"251-500",
										"501-1,000",
										"1,001-5,000",
										"5,001-10,000",
										"More than 10,000",
									])
									.describe(
										"The registrant's number of employees. \n* `1-20` \n* `21-50` \n* `51-100` \n* `101-250` \n* `251-500` \n* `501-1,000` \n* `1,001-5,000` \n* `5,001-10,000` \n* `More than 10,000`",
									),
							),
							org: z.optional(z.string().describe("The registrant's organization.")),
							phone: z.optional(z.string().describe("The registrant's phone number.")),
							purchasing_time_frame: z.optional(
								z
									.enum([
										"",
										"Within a month",
										"1-3 months",
										"4-6 months",
										"More than 6 months",
										"No timeframe",
									])
									.describe(
										"The registrant's purchasing time frame. \n* `Within a month` \n* `1-3 months` \n* `4-6 months` \n* `More than 6 months` \n* `No timeframe`",
									),
							),
							role_in_purchase_process: z.optional(
								z
									.enum([
										"",
										"Decision Maker",
										"Evaluator/Recommender",
										"Influencer",
										"Not involved",
									])
									.describe(
										"The registrant's role in the purchase process. \n* `Decision Maker` \n* `Evaluator/Recommender` \n* `Influencer` \n* `Not involved`",
									),
							),
							state: z.optional(z.string().describe("The registrant's state or province.")),
							status: z.optional(
								z
									.enum(["approved", "denied", "pending"])
									.describe(
										"The registrant's status. \n* `approved` - Registrant is approved. \n* `denied` - Registrant is denied. \n* `pending` - Registrant is waiting for approval.",
									),
							),
							zip: z.optional(z.string().describe("The registrant's ZIP or postal code.")),
						})
						.and(
							z.object({
								id: z.optional(z.string().describe("The registrant's ID.")),
							}),
						),
				)
				.describe("Information about the cloud recording registrants."),
		),
	})
	.describe("Information about the meeting cloud recording registrant.");

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n
 */
export const meetingRecordingRegistrants404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const meetingRecordingRegistrants429Schema = z.unknown();

export const meetingRecordingRegistrantsQueryResponseSchema = z.lazy(
	() => meetingRecordingRegistrants200Schema,
);

export const meetingRecordingRegistrantCreatePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `201`   \n \nRegistration submitted.
 */
export const meetingRecordingRegistrantCreate201Schema = z.object({
	id: z.optional(
		z
			.int()
			.describe(
				"[Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in &quot;**long**&quot; format(represented as int64 data type in JSON), also known as the meeting number.",
			),
	),
	registrant_id: z.optional(z.string().describe("Registrant ID")),
	share_url: z.optional(
		z
			.string()
			.describe(
				"Share URL for the on-demand recording. This includes the &ldquo;tk&rdquo; token for the registrant. This is similar to the token that Zoom returns in the URL response to join a registered meeting, for example: `url?tk=xxxx`. Except while the meeting registration token can be used to join the meeting, this token can only be used to watch the recording.",
			),
	),
	topic: z.optional(z.string().describe("Meeting Topic")),
});

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n
 */
export const meetingRecordingRegistrantCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const meetingRecordingRegistrantCreate429Schema = z.unknown();

export const meetingRecordingRegistrantCreateMutationRequestSchema = z
	.object({
		address: z.optional(z.string().describe("The registrant's address.")),
		city: z.optional(z.string().describe("The registrant's city.")),
		comments: z.optional(z.string().describe("The registrant's questions and comments.")),
		country: z.optional(
			z
				.string()
				.describe(
					"The registrant's two-letter [country code](https://developers.zoom.us/docs/api/rest/other-references/abbreviation-lists/#countries).",
				),
		),
		custom_questions: z.optional(
			z
				.array(
					z
						.object({
							title: z.optional(z.string().describe("The title of the custom question.")),
							value: z.optional(
								z
									.string()
									.max(128)
									.describe(
										"The custom question's response value. This has a limit of 128 characters.",
									),
							),
						})
						.describe("Information about custom questions."),
				)
				.describe("Information about custom questions."),
		),
		email: z
			.email()
			.max(128)
			.describe(
				"The registrant's email address. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for return value details.",
			),
		first_name: z.string().max(64).describe("The registrant's first name."),
		industry: z.optional(z.string().describe("The registrant's industry.")),
		job_title: z.optional(z.string().describe("The registrant's job title.")),
		last_name: z.optional(z.string().max(64).describe("The registrant's last name.")),
		no_of_employees: z.optional(
			z
				.enum([
					"",
					"1-20",
					"21-50",
					"51-100",
					"101-250",
					"251-500",
					"501-1,000",
					"1,001-5,000",
					"5,001-10,000",
					"More than 10,000",
				])
				.describe(
					"The registrant's number of employees. \n* `1-20` \n* `21-50` \n* `51-100` \n* `101-250` \n* `251-500` \n* `501-1,000` \n* `1,001-5,000` \n* `5,001-10,000` \n* `More than 10,000`",
				),
		),
		org: z.optional(z.string().describe("The registrant's organization.")),
		phone: z.optional(z.string().describe("The registrant's phone number.")),
		purchasing_time_frame: z.optional(
			z
				.enum([
					"",
					"Within a month",
					"1-3 months",
					"4-6 months",
					"More than 6 months",
					"No timeframe",
				])
				.describe(
					"The registrant's purchasing time frame. \n* `Within a month` \n* `1-3 months` \n* `4-6 months` \n* `More than 6 months` \n* `No timeframe`",
				),
		),
		role_in_purchase_process: z.optional(
			z
				.enum(["", "Decision Maker", "Evaluator/Recommender", "Influencer", "Not involved"])
				.describe(
					"The registrant's role in the purchase process. \n* `Decision Maker` \n* `Evaluator/Recommender` \n* `Influencer` \n* `Not involved`",
				),
		),
		state: z.optional(z.string().describe("The registrant's state or province.")),
		status: z.optional(
			z
				.enum(["approved", "denied", "pending"])
				.describe(
					"The registrant's status. \n* `approved` - Registrant is approved. \n* `denied` - Registrant is denied. \n* `pending` - Registrant is waiting for approval.",
				),
		),
		zip: z.optional(z.string().describe("The registrant's ZIP or postal code.")),
	})
	.describe("Registrant.");

export const meetingRecordingRegistrantCreateMutationResponseSchema = z.lazy(
	() => meetingRecordingRegistrantCreate201Schema,
);

export const recordingRegistrantsQuestionsGetPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"To get a meeting's cloud recordings, provide the meeting ID or meeting UUID. If the meeting ID is provided instead of UUID, the response will be for the latest meeting instance. \n\nTo get a webinar's cloud recordings, provide the webinar ID or the webinar UUID. If the webinar ID is provided instead of UUID, the response will be for the latest webinar instance. \n\nIf a UUID starts with `/` or contains `//`, like `/ajXp112QmuoKj4854875==`, you must **double encode** the UUID before making an API request. ",
		),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nRecording registrant question object returned.
 */
export const recordingRegistrantsQuestionsGet200Schema = z
	.object({
		custom_questions: z.optional(
			z
				.array(
					z.object({
						answers: z.optional(
							z
								.array(z.string())
								.describe(
									"Answer choices for the question. Cannot be used with short answer type.",
								),
						),
						required: z.optional(
							z
								.boolean()
								.describe("Whether registrants are required to answer custom questions or not."),
						),
						title: z.optional(z.string().describe("The question's title.")),
						type: z.optional(
							z
								.enum(["short", "single", "multiple"])
								.describe("The type of registration question and answers."),
						),
					}),
				)
				.describe("Array of registrant custom questions."),
		),
		questions: z.optional(
			z
				.array(
					z.object({
						field_name: z.optional(
							z
								.enum([
									"last_name",
									"address",
									"city",
									"country",
									"zip",
									"state",
									"phone",
									"industry",
									"org",
									"job_title",
									"purchasing_time_frame",
									"role_in_purchase_process",
									"no_of_employees",
									"comments",
								])
								.describe("Field name."),
						),
						required: z.optional(
							z
								.boolean()
								.describe("Whether the field is required to be answered by the registrant or not."),
						),
					}),
				)
				.describe("Array of registrant questions."),
		),
	})
	.describe("Recording tegistrant questions");

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n
 */
export const recordingRegistrantsQuestionsGet404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const recordingRegistrantsQuestionsGet429Schema = z.unknown();

export const recordingRegistrantsQuestionsGetQueryResponseSchema = z.lazy(
	() => recordingRegistrantsQuestionsGet200Schema,
);

export const recordingRegistrantQuestionUpdatePathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"To get a meeting's cloud recordings, provide the meeting ID or meeting UUID. If the meeting ID is provided instead of UUID, the response will be for the latest meeting instance. \n\nTo get a webinar's cloud recordings, provide the webinar ID or the webinar UUID. If the webinar ID is provided instead of UUID,the response will be for the latest webinar instance. \n\nIf a UUID starts with `/` or contains `//`, like `/ajXp112QmuoKj4854875==`, you must **double encode** the UUID before making an API request. \n\nLearn more about [enabling cloud recordings](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0063923) and [managing cloud recording settings](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0065362).",
		),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nRecording registrant questions updated
 */
export const recordingRegistrantQuestionUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n
 */
export const recordingRegistrantQuestionUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const recordingRegistrantQuestionUpdate429Schema = z.unknown();

/**
 * @description Recording registrant questions.
 */
export const recordingRegistrantQuestionUpdateMutationRequestSchema = z.object({
	custom_questions: z.optional(
		z
			.array(
				z.object({
					answers: z.optional(
						z
							.array(z.string())
							.describe("Answer choices for the question. Cannot be used with short answer type."),
					),
					required: z.optional(
						z
							.boolean()
							.describe("Whether registrants are required to answer custom questions or not."),
					),
					title: z.optional(z.string().describe("The question's title.")),
					type: z.optional(
						z
							.enum(["short", "single", "multiple"])
							.describe("The type of registration question and answers."),
					),
				}),
			)
			.describe("Array of registrant custom questions."),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					field_name: z.optional(
						z
							.enum([
								"last_name",
								"address",
								"city",
								"country",
								"zip",
								"state",
								"phone",
								"industry",
								"org",
								"job_title",
								"purchasing_time_frame",
								"role_in_purchase_process",
								"no_of_employees",
								"comments",
							])
							.describe("Field name."),
					),
					required: z.optional(
						z
							.boolean()
							.describe("Whether the field is required to be answered by the registrant or not."),
					),
				}),
			)
			.describe("Array of registrant questions."),
	),
});

export const recordingRegistrantQuestionUpdateMutationResponseSchema = z.lazy(
	() => recordingRegistrantQuestionUpdate204Schema,
);

export const meetingRecordingRegistrantStatusPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `204`  \n \nRegistrant status updated.
 */
export const meetingRecordingRegistrantStatus204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n
 */
export const meetingRecordingRegistrantStatus404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const meetingRecordingRegistrantStatus429Schema = z.unknown();

export const meetingRecordingRegistrantStatusMutationRequestSchema = z
	.object({
		action: z.enum(["approve", "deny"]),
		registrants: z.optional(
			z
				.array(
					z.object({
						id: z.optional(z.string()),
					}),
				)
				.max(30)
				.describe("List of registrants."),
		),
	})
	.describe("Registrant status.");

export const meetingRecordingRegistrantStatusMutationResponseSchema = z.lazy(
	() => meetingRecordingRegistrantStatus204Schema,
);

export const recordingSettingUpdatePathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"The meeting ID lets you get cloud recording of a meeting or webinar.\n* Meeting - Provide the meeting ID or meeting UUID. If the meeting ID is provided instead of UUID, the response is for the latest meeting instance. \n\n* Webinar - Provide the webinar ID or the webinar UUID. If the webinar ID is provided instead of UUID, the response is for the latest webinar instance. \n\nIf a UUID starts with `/` or contains `//` (example: `/ajXp112QmuoKj4854875==`), you must **double encode** the UUID before making an API request. ",
		),
});

/**
 * @description **HTTP Status Code:** `200`    Meeting recording settings returned.
 */
export const recordingSettingUpdate200Schema = z.object({
	approval_type: z.optional(
		z
			.union([z.literal(0), z.literal(1), z.literal(2)])
			.describe(
				"The registration approval type.  \n \n`0` - Automatically approve the registration when a user registers.  \n \n`1` - Manually approve or deny the registration of a user.  \n \n`2` - No registration required to view the recording.",
			),
	),
	authentication_domains: z.optional(z.string().describe("The domains for authentication.")),
	authentication_option: z.optional(z.string().describe("The options for authentication.")),
	authentication_name: z.optional(z.string().describe("The name for authentication.")),
	on_demand: z.optional(
		z
			.boolean()
			.describe("This field determines whether registration is required to view the recording."),
	),
	password: z.optional(
		z
			.string()
			.min(8)
			.max(10)
			.describe(
				"This field enables passcode protection for the recording by setting a passcode. The passcode must have a minimum of **eight** characters with a mix of numbers, letters and special characters.  \n   \n \n**Note:** If the account owner or the admin has set minimum passcode strength requirements for recordings through Account Settings, the passcode value provided here must meet those requirements.   \n   \n If the requirements are enabled, you can view those requirements by calling either the [**Get user settings**](/api-reference/zoom-api/methods#operation/userSettings) API or the [**Get account settings**](/api-reference/zoom-api/ma#operation/accountSettings) API.",
			),
	),
	recording_authentication: z.optional(
		z.boolean().describe("Only allow authenticated users to view."),
	),
	send_email_to_host: z.optional(
		z
			.boolean()
			.describe(
				"Enable sending an email to the host when someone registers to view the recording. This applies for On-demand recordings only.",
			),
	),
	share_recording: z.optional(
		z
			.enum(["publicly", "internally", "none"])
			.describe("Determine how the meeting recording is shared."),
	),
	show_social_share_buttons: z.optional(
		z
			.boolean()
			.describe(
				"Show social share buttons on the registration page. This applies for On-demand recordings only.",
			),
	),
	topic: z.optional(z.string().describe("The recording's name.")),
	viewer_download: z.optional(
		z.boolean().describe("Determine whether a viewer can download the recording file or not."),
	),
	auto_delete: z.optional(
		z
			.boolean()
			.describe(
				'Auto-delete status of a meeting\'s [cloud recording](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording).  \n\nPrerequisite: To get the auto-delete status, the host of the recording must have the recording setting "Delete cloud recordings after a specified number of days" enabled. ',
			),
	),
	auto_delete_date: z.optional(
		z
			.string()
			.describe(
				"The date when the recording will be auto-deleted when `auto_delete` is `true`. Otherwise, no date is returned.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n
 */
export const recordingSettingUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const recordingSettingUpdate429Schema = z.unknown();

export const recordingSettingUpdateQueryResponseSchema = z.lazy(
	() => recordingSettingUpdate200Schema,
);

export const recordingSettingsUpdatePathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"To get cloud recordings of a meeting, provide the meeting ID or meeting UUID. If the meeting ID is provided instead of UUID, the response is for the latest meeting instance. \n\nTo get cloud recordings of a webinar, provide the webinar ID or the webinar UUID. If the webinar ID is provided instead of UUID, the response is for the latest webinar instance. \n\nIf a UUID starts with `/` or contains `//` (example: &quot;/ajXp112QmuoKj4854875==&quot;), you must **double encode** the UUID before making an API request. ",
		),
});

/**
 * @description **HTTP Status Code:** `204`    Meeting recording setting\'s updated.
 */
export const recordingSettingsUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n
 */
export const recordingSettingsUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const recordingSettingsUpdate429Schema = z.unknown();

export const recordingSettingsUpdateMutationRequestSchema = z.object({
	approval_type: z.optional(
		z
			.union([z.literal(0), z.literal(1), z.literal(2)])
			.describe(
				"The approval type for the registration.  \n \n`0`- Automatically approve the registration when a user registers.  \n \n`1` - Manually approve or deny the registration of a user.  \n \n`2` - No registration required to view the recording.",
			),
	),
	authentication_domains: z.optional(z.string().describe("The authentication domains.")),
	authentication_option: z.optional(z.string().describe("The authentication options.")),
	on_demand: z.optional(
		z.boolean().describe("Determine whether the registration is required to view the recording."),
	),
	password: z.optional(
		z
			.string()
			.min(8)
			.max(10)
			.describe(
				"Enable passcode protection for the recording by setting a passcode. \n\nThe passcode must have a minimum of **eight** characters with a mix of numbers, letters and special characters.  \n   \n \n**Note:** If the account owner or the admin has set minimum passcode strength requirements for recordings through Account Settings, the passcode value provided here must meet those requirements.   \n   \n If the requirements are enabled, you can view those requirements by calling either the [**Get user settings**](/api-reference/zoom-api/methods#operation/userSettings) API or the [**Get account settings**](/api-reference/zoom-api/ma#operation/accountSettings) API.",
			),
	),
	recording_authentication: z.optional(
		z.boolean().describe("Indicate that only authenticated users can view."),
	),
	send_email_to_host: z.optional(
		z
			.boolean()
			.describe(
				"Send an email to host when someone registers to view the recording. This setting applies for On-demand recordings only.",
			),
	),
	share_recording: z.optional(
		z
			.enum(["publicly", "internally", "none"])
			.describe("Determine how the meeting recording is shared."),
	),
	show_social_share_buttons: z.optional(
		z
			.boolean()
			.describe(
				"Show social share buttons on registration page. This setting applies for On-demand recordings only.",
			),
	),
	topic: z.optional(z.string().describe("The name of the recording.")),
	viewer_download: z.optional(
		z.boolean().describe("Determine whether a viewer can download the recording file or not."),
	),
	auto_delete: z.optional(
		z
			.boolean()
			.describe(
				'Update the auto-delete status of a meeting\'s [cloud recording](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording).  \n\nPrerequisite: To update the auto-delete status, the host of the recording must have the recording setting "Delete cloud recordings after a specified number of days" enabled.',
			),
	),
});

export const recordingSettingsUpdateMutationResponseSchema = z.lazy(
	() => recordingSettingsUpdate204Schema,
);

export const recordingDeleteOnePathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"To get a meeting's cloud recordings, provide the meeting ID or meeting UUID. If the meeting ID is provided instead of UUID, the response will be for the latest meeting instance. \n\nTo get a webinar's cloud recordings, provide the webinar ID or the webinar UUID. If the webinar ID is provided instead of UUID, the response will be for the latest webinar instance. \n\nIf a UUID starts with `/` or contains `//`, like `/ajXp112QmuoKj4854875==`, you must **double encode** the UUID before making an API request. ",
		),
	recordingId: z.string().describe("The recording ID."),
});

export const recordingDeleteOneQueryParamsSchema = z.object({
	action: z
		.enum(["trash", "delete"])
		.default("trash")
		.describe(
			"The recording delete actions. \n `trash` - Move recording to trash.  \n `delete` - Delete recording permanently.",
		),
});

/**
 * @description The recording file was successfully deleted.
 */
export const recordingDeleteOne204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `1010` <br>\n User does not belong to this account: {accountId}.<br> <br>\n**Error Code:** `3303` <br>\n You can not delete an uncompleted meeting. <br>\n**Error Code:** `3310` <br>\n This recording was selected for a simulive webinar. You cannot delete or trash it. <br>\n**Error Code:** `3310` <br>\n Unable to delete this file because this recording is being used for Zoom IQ for Sales. <br>\n
 */
export const recordingDeleteOne400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User {userId} does not exist or does not belong to this account.<br> <br>\n**Error Code:** `3301` <br>\n There is no recording for this meeting. <br>\n
 */
export const recordingDeleteOne404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const recordingDeleteOne429Schema = z.unknown();

export const recordingDeleteOneMutationResponseSchema = z.lazy(() => recordingDeleteOne204Schema);

export const recordingStatusUpdateOnePathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"To get a meeting's cloud recordings, provide the meeting ID or meeting UUID. If the meeting ID is provided instead of UUID, the response will be for the latest meeting instance. \n\nTo get a webinar's cloud recordings, provide the webinar ID or the webinar UUID. If the webinar ID is provided instead of UUID, the response will be for the latest webinar instance. \n\nIf a UUID starts with `/` or contains `//`, like `/ajXp112QmuoKj4854875==`, you must **double encode** the UUID before making an API request. ",
		),
	recordingId: z.string().describe("The recording ID."),
});

/**
 * @description **HTTP Status Code:** `204`   \n  Meeting recording recovered.\n\n
 */
export const recordingStatusUpdateOne204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `1010` <br>\n User does not belong to this account: {accountId}. <br>\n**Error Code:** `3309` <br>\n Not enough cloud storage available. Either purchase additional storage or delete cloud recordings to free up storage. <br>\n
 */
export const recordingStatusUpdateOne400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User {userId} does not exist or does not belong to this account.<br> <br>\n**Error Code:** `3301` <br>\n There is no recording for this meeting. <br>\n
 */
export const recordingStatusUpdateOne404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const recordingStatusUpdateOne429Schema = z.unknown();

export const recordingStatusUpdateOneMutationRequestSchema = z.object({
	action: z.optional(z.enum(["recover"])),
});

export const recordingStatusUpdateOneMutationResponseSchema = z.lazy(
	() => recordingStatusUpdateOne204Schema,
);

export const getMeetingTranscriptPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"To get a meeting's transcript, provide the meeting ID or meeting UUID. If the meeting ID is provided instead of UUID, the response will be for the latest meeting instance. \n\nTo get a webinar's transcript, provide the webinar ID or the webinar UUID. If the webinar ID is provided instead of UUID, the response will be for the latest webinar instance. \n\nIf a UUID starts with `/` or contains `//`, like `/ajXp112QmuoKj4854875==`, you must **double encode** the UUID before making an API request. ",
		),
});

/**
 * @description HTTP Status Code: 200  Transcript object returned.
 */
export const getMeetingTranscript200Schema = z.object({
	meeting_id: z.optional(z.string().describe("The meeting ID")),
	account_id: z.optional(z.string().describe("The user account's unique identifier.")),
	meeting_topic: z.optional(z.string().describe("The meeting topic.")),
	host_id: z.optional(z.string().describe("ID of the user set as the host of the meeting.")),
	transcript_created_time: z.optional(
		z.string().describe("The date and time that the meeting's transcript was created."),
	),
	can_download: z.optional(
		z
			.boolean()
			.describe(
				"Whether the meeting transcript is available for download.\n`true`: The transcript is ready and `download_url` will be returned.\n`false`: The transcript cannot be downloaded. and the `download_restriction_reason` field will be returned instead with the explanation.\n\nOnly when `can_download` is `true`, the transcript file can be accessed.",
			),
	),
	auto_delete: z.optional(
		z
			.boolean()
			.describe(
				"Auto-delete status of a meeting's transcript\n\nPrerequisite: To get the auto-delete status, the host of the recording must have the recording setting **Delete cloud recordings after a specified number of days** enabled. ",
			),
	),
	auto_delete_date: z.optional(
		z
			.string()
			.describe(
				"The date when the recording will be auto-deleted when `auto_delete` is true. Otherwise, no date will be returned.",
			),
	),
	download_url: z
		.string()
		.describe(
			"The URL to download the transcript. \n\nThis field is only present when `can_download` is `true`. If present, `download_restriction_reason` will not be included.\"\n\n\nIf a user has authorized and installed your OAuth app that contains recording scopes, use  the user's [OAuth access token](https://developers.zoom.us/docs/integrations/oauth/) to download the file. Set the `access_token` as a Bearer token in the Authorization header. For example: \n\n`curl -H 'Authorization: Bearer <ACCESS_TOKEN>' https://{{base-domain}}/rec/archive/download/xyz`.",
		)
		.nullish(),
	download_restriction_reason: z
		.enum(["DELETED_OR_TRASHED", "UNSUPPORTED", "NO_TRANSCRIPT_DATA", "NOT_READY"])
		.describe(
			'If `can_download` is false, this field provides the reason why the transcript cannot be downloaded.\n\nThis field is only present when `can_download` is `false`. If present, `download_url` will not be included."\n\n| Value                | Description                                                                                  |\n| -------------------- | -------------------------------------------------------------------------------------------- |\n| `DELETED_OR_TRASHED` | The transcript has been deleted or moved to trash and is no longer available.                |\n| `UNSUPPORTED`        | The transcript format is not supported for download. |\n| `NO_TRANSCRIPT_DATA` | No transcript data exists for the meeting.                                                   |\n| `NOT_READY`          | The transcript is still being processed and not yet ready for download.                      |\n',
		)
		.nullish(),
});

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  No permission \n\n
 */
export const getMeetingTranscript403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3322` <br>\n This meeting transcript does not exist. <br>\n
 */
export const getMeetingTranscript404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const getMeetingTranscript429Schema = z.unknown();

export const getMeetingTranscriptQueryResponseSchema = z.lazy(() => getMeetingTranscript200Schema);

export const deleteMeetingTranscriptPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"To delete a meeting's transcript, provide the meeting ID or meeting's unique universal identifier (UUID). If the meeting ID is provided instead of UUID, the response will be for the latest meeting instance. \n\nTo delete a webinar's transcript, provide the webinar ID or the webinar's UUID. If the webinar ID is provided instead of UUID, the response will be for the latest webinar instance. \n\nIf a UUID starts with `/` or contains `//`, like `/ajXp112QmuoKj4854875==`, you must **double encode** the UUID before making an API request. ",
		),
});

/**
 * @description **HTTP Status Code:** `204`   \n \nMeeting transcript has been deleted.
 */
export const deleteMeetingTranscript204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n
 */
export const deleteMeetingTranscript400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  No permission \n\n
 */
export const deleteMeetingTranscript403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3322` <br>\n This meeting transcript does not exist. <br>\n
 */
export const deleteMeetingTranscript404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const deleteMeetingTranscript429Schema = z.unknown();

export const deleteMeetingTranscriptMutationResponseSchema = z.lazy(
	() => deleteMeetingTranscript204Schema,
);

export const recordingStatusUpdatePathParamsSchema = z.object({
	meetingUUID: z
		.string()
		.describe(
			"The meeting's universally unique identifier (UUID). Each meeting instance generates a UUID. For example, after a meeting ends, a new UUID is generated for the next meeting instance.\n\nIf the meeting UUID begins with a `/` character or contains a `//` character, you **must** double-encode the meeting UUID when using the meeting UUID for other API calls.",
		),
});

/**
 * @description **HTTP Status Code:** `200`   \n \nRecordings recovered. \n\n**Error Code:** `200`  \n \nYou do not have the right permissions.
 */
export const recordingStatusUpdate200Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `1010` <br>\n User does not belong to this account: {accountId}. <br>\n**Error Code:** `3309` <br>\n Not enough cloud storage available. Either purchase additional storage or delete cloud recordings to free up storage. <br>\n
 */
export const recordingStatusUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: {userId}.<br> <br>\n**Error Code:** `3301` <br>\n There is no recording for this meeting. <br>\n
 */
export const recordingStatusUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const recordingStatusUpdate429Schema = z.unknown();

export const recordingStatusUpdateMutationRequestSchema = z.object({
	action: z.optional(z.enum(["recover"])),
});

export const recordingStatusUpdateMutationResponseSchema = z.lazy(
	() => recordingStatusUpdate200Schema,
);

export const recordingsListPathParamsSchema = z.object({
	userId: z
		.string()
		.describe("The user's ID or email address. For user-level apps, pass the `me` value."),
});

export const recordingsListQueryParamsSchema = z.object({
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"The next page token paginates through a large set of results. A next page token returns whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.",
			),
	),
	mc: z
		.string()
		.default("false")
		.describe(
			"The query metadata of the recording if using an on-premise meeting connector for the meeting.",
		),
	trash: z
		.boolean()
		.default(false)
		.describe(
			"The query trash.\n* `true` - List recordings from trash.  \n* `false` - Do not list recordings from the trash.  \n\nThe default value is `false`. If you set it to `true`, you can use the `trash_type` property to indicate the type of Cloud recording that you need to retrieve. ",
		),
	from: z.optional(
		z.iso
			.date()
			.describe(
				"The start date in 'yyyy-mm-dd' UTC format for the date range where you would like to retrieve recordings. The maximum range can be a month. If no value is provided for this field, the default will be current date. \n\nFor example, if you make the API request on June 30, 2020, without providing the `from` and `to` parameters, by default the value of 'from' field will be `2020-06-30` and the value of the 'to' field will be `2020-07-01`. \n\n**Note**: The `trash` files cannot be filtered by date range and thus, the `from` and `to` fields should not be used for trash files.",
			),
	),
	to: z.optional(z.iso.date().describe("The end date in 'yyyy-mm-dd' 'yyyy-mm-dd' UTC format. ")),
	trash_type: z
		.string()
		.default("meeting_recordings")
		.describe(
			"The type of cloud recording to retrieve from the trash. \n \n *   `meeting_recordings`: List all meeting recordings from the trash.  \n *  `recording_file`: List all individual recording files from the trash. ",
		),
	meeting_id: z.optional(z.coerce.number().int().describe("The meeting ID.")),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nList of recording objects returned.
 */
export const recordingsList200Schema = z.object({
	from: z.optional(z.iso.date().describe("The start date.")),
	to: z.optional(z.iso.date().describe("The end date.")),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"The next page token paginates through a large set of results. A next page token returns whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.",
			),
	),
	page_count: z.optional(z.int().describe("The number of pages returned for the request made.")),
	page_size: z.optional(
		z
			.int()
			.max(300)
			.default(30)
			.describe("The number of records returned within a single API call."),
	),
	total_records: z.optional(z.int().describe("The number of all records available across pages.")),
	meetings: z.optional(
		z
			.array(
				z
					.object({
						recording_files: z.optional(
							z
								.array(
									z.object({
										deleted_time: z.optional(
											z
												.string()
												.describe(
													"The time when recording was deleted. Returned in the response only for trash query.",
												),
										),
										download_url: z.optional(
											z
												.string()
												.describe(
													"The URL to download the recording. If a user has authorized and installed your OAuth app that contains recording scopes, use the `download_access_token` or the user's [OAuth access token](https://developers.zoom.us/docs/integrations/oauth/) to download the file. Set the token as a Bearer token in the Authorization header. \n\n`curl -H 'Authorization: Bearer <ACCESS_TOKEN>' https://{{base-domain}}/rec/archive/download/xyz`. \n\n**Note:** This field does **not** return for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). Instead, this API will return the `file_path` field. The URL may be a redirect. In that case, use `curl --location` to follow redirects or use another tool, like Postman.",
												),
										),
										file_path: z.optional(
											z
												.string()
												.describe(
													"The file path to the On-Premise account recording. \n\n**Note:** This API only returns this field for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). It does **not** return the `download_url` field.",
												),
										),
										file_size: z.optional(z.number().describe("The recording file size.")),
										file_type: z.optional(
											z
												.enum([
													"MP4",
													"M4A",
													"CHAT",
													"TRANSCRIPT",
													"CSV",
													"TB",
													"CC",
													"CHAT_MESSAGE",
													"SUMMARY",
												])
												.describe(
													"The recording file type.  \n \n`MP4` - Video file of the recording.  \n `M4A` Audio-only file of the recording.  \n `TIMELINE` - Timestamp file of the recording in JSON file format. To get a timeline file, the **Add a timestamp to the recording** setting must be enabled in the [recording settings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-recording#h_3f14c3a4-d16b-4a3c-bbe5-ef7d24500048). The time will display in the host's timezone, set on their Zoom profile.\n  \n  `TRANSCRIPT` - Transcription file of the recording in VTT format.  \n  `CHAT` - A TXT file containing in-meeting chat messages that were sent during the meeting.  \n `CC` - File containing closed captions of the recording in VTT file format.  \n `CSV` - File containing polling data in CSV format.\n\n  \n \n\nA recording file object with file type of either `CC` or `TIMELINE` **does not have** the following properties:  \n \n\t`id`, `status`, `file_size`, `recording_type`, and `play_url`.  \n `SUMMARY` - Summary file of the recording in JSON file format.",
												),
										),
										file_extension: z.optional(
											z
												.enum(["MP4", "M4A", "TXT", "VTT", "CSV", "JSON", "JPG"])
												.describe("The file extension type of the recording file."),
										),
										id: z.optional(
											z
												.string()
												.describe(
													"The recording file ID. Included in the response of general query.",
												),
										),
										meeting_id: z.optional(z.string().describe("The meeting ID. ")),
										play_url: z.optional(z.string().describe("The URL to play a recording file.")),
										recording_end: z.optional(
											z.string().describe("The recording end time. Response in general query."),
										),
										recording_start: z.optional(z.string().describe("The recording start time.")),
										recording_type: z.optional(
											z
												.enum([
													"shared_screen_with_speaker_view(CC)",
													"shared_screen_with_speaker_view",
													"shared_screen_with_gallery_view",
													"active_speaker",
													"gallery_view",
													"shared_screen",
													"audio_only",
													"audio_transcript",
													"chat_file",
													"poll",
													"host_video",
													"closed_caption",
													"timeline",
													"thumbnail",
													"audio_interpretation",
													"summary",
													"summary_next_steps",
													"summary_smart_chapters",
													"sign_interpretation",
													"production_studio",
												])
												.describe(
													"The recording type.  \n `shared_screen_with_speaker_view(CC)`  \n `shared_screen_with_speaker_view`  \n `shared_screen_with_gallery_view`  \n `active_speaker`  \n `gallery_view`  \n `shared_screen`  \n `audio_only`  \n `audio_transcript`  \n `chat_file`  \n `poll`  \n `timeline`  \n `closed_caption`  \n `audio_interpretation`  \n `summary`  \n `summary_next_steps`  \n `summary_smart_chapters`  \n `sign_interpretation`  \n `production_studio`",
												),
										),
										status: z.optional(z.enum(["completed"]).describe("The recording status.")),
									}),
								)
								.describe("List of recording file."),
						),
					})
					.and(
						z.object({
							account_id: z.optional(z.string().describe("Unique Identifier of the user account.")),
							duration: z.optional(z.int().describe("Meeting duration.")),
							host_id: z.optional(z.string().describe("ID of the user set as host of meeting.")),
							id: z.optional(z.int().describe("Meeting ID - also known as the meeting number.")),
							recording_count: z.optional(
								z
									.int()
									.describe(
										"Number of recording files returned in the response of this API call. This includes the `recording_files` and  `participant_audio_files` files.",
									),
							),
							start_time: z.optional(
								z.string().datetime().describe("The time when the meeting started."),
							),
							topic: z.optional(z.string().describe("Meeting topic.")),
							total_size: z.optional(
								z
									.int()
									.describe(
										"The total file size of the recording. This includes the `recording_files` and `participant_audio_files` files.",
									),
							),
							type: z.optional(
								z
									.enum(["1", "2", "3", "4", "5", "6", "7", "8", "9", "99"])
									.describe(
										"The recording's associated type of meeting or webinar: \n\nIf the recording is of a meeting: \n* `1` - Instant meeting. \n* `2` - Scheduled meeting. \n* `3` - A recurring meeting with no fixed time. \n* `4` - A meeting created viaPersonal Meeting ID (PMI). \n* `7` - A [Personal Audio Conference](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference) (PAC). \n* `8` - Recurring meeting with a fixed time. \n\nIf the recording is of a webinar: \n* `5` - A webinar. \n* `6` - A recurring webinar without a fixed time \n* `9` - A recurring webinar with a fixed time.\n\nIf the recording is **not** from a meeting or webinar: \n\n* `99` - A recording uploaded via the [**Recordings**](https://zoom.us/recording) interface on the Zoom Web Portal.",
									),
							),
							uuid: z.optional(
								z
									.string()
									.describe(
										"Unique Meeting Identifier. Each instance of the meeting will have its own UUID.",
									),
							),
							recording_play_passcode: z.optional(
								z
									.string()
									.describe(
										"The cloud recording's passcode to be used in the URL. \nInclude fields in the response. The password field requires the user role of the authorized account to enable the **View Recording Content** permission to be returned.\nThis recording's passcode can be directly spliced in `play_url` or `share_url` with `?pwd=` to access and play. For example, 'https://zoom.us/rec/share/**************?pwd=yNYIS408EJygs7rE5vVsJwXIz4-VW7MH'. If you want to use this field, please contact Zoom support.",
									),
							),
							auto_delete: z.optional(
								z
									.boolean()
									.describe(
										"Auto-delete status of a meeting's [cloud recording](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording).  \n\nPrerequisite: To get the auto-delete status, the host of the recording must have the recording setting **Delete cloud recordings after a specified number of days** enabled. ",
									),
							),
							auto_delete_date: z.optional(
								z
									.string()
									.describe(
										"The date when the recording will be auto-deleted when `auto_delete` is `true`. Otherwise, no date will be returned.",
									),
							),
						}),
					),
			)
			.describe("List of recordings."),
	),
});

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n **Error Code:** `124` <br>\n Requires an access token. <br>\n
 */
export const recordingsList401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User {userId} does not exist, or does not belong to this account. <br>\n**Error Code:** `3301` <br>\n There is no recording for this session. <br>\n
 */
export const recordingsList404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const recordingsList429Schema = z.unknown();

export const recordingsListQueryResponseSchema = z.lazy(() => recordingsList200Schema);

export const listDevicesQueryParamsSchema = z.object({
	search_text: z.optional(z.string().describe("Filter devices by name or serial number.")),
	platform_os: z.optional(
		z
			.enum(["win", "mac", "ipad", "iphone", "android", "linux"])
			.describe("Filter devices by platform operating system."),
	),
	is_enrolled_in_zdm: z
		.boolean()
		.default(true)
		.describe("Filter devices by enrollment of ZDM (Zoom Device Management)."),
	device_type: z
		.union([
			z.literal(-1),
			z.literal(0),
			z.literal(1),
			z.literal(2),
			z.literal(3),
			z.literal(4),
			z.literal(5),
			z.literal(6),
		])
		.default(-1)
		.describe(
			"Filter devices by device type.  \n  Device Type:  \n `-1` - All Zoom Room device(0,1,2,3,4,6).  \n `0` - Zoom Rooms Computer.  \n `1` - Zoom Rooms Controller.  \n `2` - Zoom Rooms Scheduling Display.  \n `3` - Zoom Rooms Control System.  \n `4` -  Zoom Rooms Whiteboard.  \n `5` - Zoom Phone Appliance.  \n `6` - Zoom Rooms Computer (with Controller).",
		),
	device_vendor: z.optional(z.string().describe("Filter devices by vendor.")),
	device_model: z.optional(z.string().describe("Filter devices by model.")),
	device_status: z
		.union([z.literal(-1), z.literal(0), z.literal(1)])
		.default(-1)
		.describe(
			"Filter devices by status.   \n  Device Status:  \n `0` - offline.  \n `1` - online.  \n `-1` - unlink",
		),
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200` **OK**  \n \nDevice detail returned successfully.
 */
export const listDevices200Schema = z.object({
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.",
			),
	),
	page_size: z.optional(
		z.int().describe("The number of records returned within a single API call."),
	),
	devices: z.optional(
		z.array(
			z
				.object({
					device_id: z.optional(z.string().describe("Unique identifier of the device.")),
					device_name: z.optional(z.string().describe("The name of the device.")),
					mac_address: z.optional(z.string().describe("The mac address of the device.")),
					serial_number: z.optional(z.string().describe("The device's serial number.")),
					vendor: z.optional(z.string().describe("The device's manufacturer.")),
					model: z.optional(z.string().describe("The device's model.")),
					platform_os: z.optional(z.string().describe("The device's platform.")),
					app_version: z.optional(z.string().describe("App version of Zoom Rooms.")),
					tag: z.optional(z.string().describe("The name of the tag.")),
					enrolled_in_zdm: z.optional(
						z.boolean().describe("Whether the device enrolled in ZDM (Zoom Device Management)."),
					),
					connected_to_zdm: z.optional(
						z.boolean().describe("Whether the device connected to ZDM (Zoom Device Management)."),
					),
					room_id: z.optional(z.string().describe("id of the Zoom Room.")),
					room_name: z.optional(z.string().describe("Name of the Zoom Room.")),
					device_type: z.optional(
						z
							.union([
								z.literal(0),
								z.literal(1),
								z.literal(2),
								z.literal(3),
								z.literal(4),
								z.literal(5),
								z.literal(6),
							])
							.describe(
								"Filter devices by device type.  \n  Device Type:  \n `-1` - All Zoom Room device(0,1,2,3,4,6).  \n `0` - Zoom Rooms Computer.  \n `1` - Zoom Rooms Controller.  \n `2` - Zoom Rooms Scheduling Display.  \n `3` - Zoom Rooms Control System.  \n `4` -  Zoom Rooms Whiteboard.  \n `5` - Zoom Phone Appliance.  \n `6` - Zoom Rooms Computer (with Controller).",
							),
					),
					skd_version: z.optional(z.string().describe("The version of the SDK.")),
					device_status: z.optional(
						z
							.union([z.literal(-1), z.literal(0), z.literal(1)])
							.describe(
								"Filter devices by status.   \n  Device Status:  \n `0` - offline.  \n `1` - online.  \n `-1` - unlink",
							),
					),
					last_online: z.optional(
						z.string().describe("The time when device was online last time."),
					),
					user_email: z.optional(z.string().describe("The owner of the phone device")),
				})
				.describe("The information about the device."),
		),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request\n\n**Error Code:** `30055008` <br>\nno permission.\n\n
 */
export const listDevices400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const listDevices429Schema = z.unknown();

export const listDevicesQueryResponseSchema = z.lazy(() => listDevices200Schema);

/**
 * @description **HTTP Status:** `202` **Accepted**\nRequest processed successfully.
 */
export const addDevice202Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request \n\n **Error Code:** `30055001` <br>\n zoom room does not exist.  <br>\n**Error Code:** `30055002` <br>\n required param can not be empty or null. <br>\n**Error Code:** `30055003` <br>\n device type does not support. <br>\n**Error Code:** `30055004` <br>\n model or vendor not exist. <br>\n**Error Code:** `30055005` <br>\n tag length can not be more than 64. <br>\n**Error Code:** `30055006` <br>\n device has already exist. <br>\n**Error Code:** `30055007` <br>\n invalid mac address. <br>\n**Error Code:** `30055008` <br>\n no permission. <br>\n**Error Code:** `30055009` <br>\n email does not have plan. <br>\n
 */
export const addDevice400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const addDevice429Schema = z.unknown();

export const addDeviceMutationRequestSchema = z.object({
	device_name: z.string().describe("The device's name."),
	mac_address: z.string().describe("The device's mac address."),
	serial_number: z.string().describe("The device's serial number."),
	vendor: z.string().describe("The device's manufacturer."),
	model: z.string().describe("The device's model."),
	room_id: z.optional(z.string().describe("The Zoom Room's ID. Only for Zoom Room devices.")),
	user_email: z.optional(
		z
			.string()
			.describe("User email for assigning the Zoom Phone device. Only for Zoom Phone devices."),
	),
	device_type: z
		.union([z.literal(0), z.literal(1), z.literal(5)])
		.describe(
			"Device type.  \n `0` - Zoom Rooms computer.  \n `1` - Zoom Rooms controller.  \n `5` - Zoom Phone appliance.",
		),
	tag: z.optional(z.string().describe("The name of the tag.")),
	zdm_group_id: z.optional(z.string().describe("The ZDM group ID.")),
	extension_number: z.optional(z.string().describe("The extension number.")),
});

export const addDeviceMutationResponseSchema = z.lazy(() => addDevice202Schema);

export const getzdmgroupinfoQueryParamsSchema = z
	.object({
		page_size: z.optional(
			z.coerce
				.number()
				.int()
				.describe(
					"The total number of records returned from a single API call.\nDefault - 30.\nMax -100.",
				),
		),
		next_page_token: z.optional(
			z
				.string()
				.describe(
					"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period token is 15 minutes.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `200` **OK**  Version detail returned successfully.
 */
export const getzdmgroupinfo200Schema = z.object({
	groups: z.optional(
		z
			.array(
				z.object({
					zdm_group_id: z.optional(z.string().describe("The ZDM group's unique ID.")),
					name: z.optional(z.string().describe("The ZDM group's name.")),
					description: z.optional(z.string().describe("The ZDM group's describe.")),
				}),
			)
			.max(50)
			.describe("All ZDM group information under current account."),
	),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through a large set of results. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	page_size: z.optional(
		z.int().describe("The total number of records returned from a single API call."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `30051037` <br>\n Invalid parameters. <br>\n
 */
export const getzdmgroupinfo400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n **Error Code:** `30055008` <br>\n No permission. <br>\n
 */
export const getzdmgroupinfo403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const getzdmgroupinfo429Schema = z.unknown();

export const getzdmgroupinfoQueryResponseSchema = z.lazy(() => getzdmgroupinfo200Schema);

/**
 * @description **HTTP Status Code:** `204` **No Content**   Request processed successfully.
 */
export const assigndevicetoauserCommonarea204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `30055003` <br>\n Device vendor does not support. <br>\n**Error Code:** `30055007` <br>\n Mac address is wrong. <br>\n**Error Code:** `30051039` <br>\n Device not exists. <br>\n**Error Code:** `30055002` <br>\n AUTO RECEPTIONIST user can not assign to device. <br>\n**Error Code:** `30055009` <br>\n User not have phone plan. <br>\n**Error Code:** `30052024` <br>\n Extension number not exists. <br>\n**Error Code:** `30055002` <br>\n Missing required input. <br>\n
 */
export const assigndevicetoauserCommonarea400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const assigndevicetoauserCommonarea429Schema = z.unknown();

export const assigndevicetoauserCommonareaMutationRequestSchema = z.object({
	extension_number: z.optional(z.string().describe("The extension number.")),
	mac_address: z.string().describe("The device's mac address."),
	vendor: z.string().describe("The device's manufacturer."),
});

export const assigndevicetoauserCommonareaMutationResponseSchema = z.lazy(
	() => assigndevicetoauserCommonarea204Schema,
);

export const getZpaDeviceListProfileSettingOfaUserQueryParamsSchema = z
	.object({
		user_id: z.optional(
			z
				.string()
				.describe(
					"The user's ID or email address. For user-level apps, pass `me` as the value for `user_id`.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `200` **OK**  Version detail returned successfully.
 */
export const getZpaDeviceListProfileSettingOfaUser200Schema = z.object({
	language: z.optional(z.string().describe("The user's language.")),
	timezone: z.optional(z.string().describe("The user's timezone.")),
	device_infos: z.optional(
		z
			.array(
				z.object({
					device_id: z.optional(z.string().describe("The device ID.")),
					device_type: z.optional(z.string().describe("The device type.")),
					vendor: z.optional(z.string().describe("The device's manufacturer.")),
					model: z.optional(z.string().describe("The device's model name.")),
					status: z.optional(
						z
							.enum(["online", "offline"])
							.describe("The device's status, either `online` or `offline`."),
					),
					policy: z.optional(
						z
							.object({
								hot_desking: z.optional(
									z.object({
										status: z.optional(
											z
												.enum(["online", "offline"])
												.describe("The device's status, either `online` or `offline`."),
										),
									}),
								),
								call_control: z.optional(
									z.object({
										status: z.optional(
											z
												.enum(["unsupported", "on", "off"])
												.describe(
													"This field lets the call control feature to the current device. Configure the desk phone devices to enable call control, which lets users perform desk phone's call control actions from the Zoom desktop client, including making and accepting calls. \n* `unsupported` \n* `on` \n* `off`",
												),
										),
									}),
								),
							})
							.describe("The device policy."),
					),
				}),
			)
			.min(0)
			.max(50)
			.describe("The ZPA information."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  Not Found \n\n **Error Code:** `30051037` <br>\n invalid parameters. <br>\n**Error Code:** `30052016` <br>\n User does not exist: {userId}. <br>\n
 */
export const getZpaDeviceListProfileSettingOfaUser400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n
 */
export const getZpaDeviceListProfileSettingOfaUser401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n **Error Code:** `403` <br>\n Access Restricted <br>\n
 */
export const getZpaDeviceListProfileSettingOfaUser403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const getZpaDeviceListProfileSettingOfaUser429Schema = z.unknown();

export const getZpaDeviceListProfileSettingOfaUserQueryResponseSchema = z.lazy(
	() => getZpaDeviceListProfileSettingOfaUser200Schema,
);

/**
 * @description The upgrade request has been accepted and is currently being processed.
 */
export const upgradeZpasApp202Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `30052029` <br>\n Missing required input: firmware_versions. <br>\n**Error Code:** `30055020` <br>\n Upgrade type dose not exist. <br>\n**Error Code:** `30055018` <br>\n Zdm group id dose not exist. <br>\n**Error Code:** `30052030` <br>\n Missing required input: app_version. <br>\n
 */
export const upgradeZpasApp400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const upgradeZpasApp429Schema = z.unknown();

export const upgradeZpasAppMutationRequestSchema = z.object({
	zdm_group_id: z.string().describe("The ZDM group ID."),
	data: z.union([
		z.object({
			firmware_versions: z.optional(
				z.array(
					z.object({
						vendor: z.optional(z.string().describe("The device's manufacturer.")),
						version: z.optional(z.string().describe("The firmware version.")),
						model: z.optional(
							z.string().describe("The device's model name. Maximum of 64 characters."),
						),
					}),
				),
			),
			upgrade_type: z
				.enum(["UPGRADE_FIRMWARE"])
				.default("UPGRADE_FIRMWARE")
				.describe("Upgrade firmware."),
		}),
		z.object({
			app_version: z.optional(
				z
					.string()
					.describe(
						"The app version to be upgraded. If upgrade type is `0`, this field won't work. If upgrade type is `1`, this field will work.",
					),
			),
			upgrade_type: z.enum(["UPGRADE_APP"]).describe("Upgrade app."),
		}),
	]),
});

export const upgradeZpasAppMutationResponseSchema = z.lazy(() => upgradeZpasApp202Schema);

export const deleteZpaDeviceByVendorAndMacAddressPathParamsSchema = z.object({
	vendor: z.string().describe("The device's manufacturer."),
	macAddress: z.string().describe("The device's mac address."),
});

/**
 * @description **HTTP Status Code:** `204` **No Content** Device deleted successfully.
 */
export const deleteZpaDeviceByVendorAndMacAddress204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `30052026` <br>\n Device is not ZPA. <br>\n**Error Code:** `30055003` <br>\n Device vendor does not support. <br>\n**Error Code:** `30055007` <br>\n Mac address is wrong. <br>\n
 */
export const deleteZpaDeviceByVendorAndMacAddress400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `30051039` <br>\n Zdm device not found. <br>\n
 */
export const deleteZpaDeviceByVendorAndMacAddress404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const deleteZpaDeviceByVendorAndMacAddress429Schema = z.unknown();

export const deleteZpaDeviceByVendorAndMacAddressMutationResponseSchema = z.lazy(
	() => deleteZpaDeviceByVendorAndMacAddress204Schema,
);

export const getZpaVersioninfoPathParamsSchema = z.object({
	zdmGroupId: z.string().describe("The Zoom Device Management (ZDM) group ID."),
});

/**
 * @description **HTTP Status Code:** `200` **OK**  Version detail returned successfully.
 */
export const getZpaVersioninfo200Schema = z
	.object({
		firmware_versions: z.optional(
			z
				.array(
					z
						.object({
							vendor: z.optional(z.string().describe("The device's manufacturer.")),
							model: z.optional(z.string().describe("The device's model name.")),
							version: z.optional(z.string().describe("The package version.")),
							warn_info: z.optional(
								z.string().describe("The prompt information for this version."),
							),
						})
						.describe("Details of firmware that the vendor can upgrade."),
				)
				.max(3)
				.describe("List of firmware that can be upgraded."),
		),
		app_versions: z.optional(
			z
				.array(z.string().describe("The app version."))
				.max(3)
				.describe("List of app versions that can be upgraded."),
		),
	})
	.describe("Information about the version list.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `30051037` <br>\n * AccountId is empty. <br>\n
 */
export const getZpaVersioninfo400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `30052027` <br>\n * ZdmGroup not found. <br>\n
 */
export const getZpaVersioninfo404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const getZpaVersioninfo429Schema = z.unknown();

export const getZpaVersioninfoQueryResponseSchema = z.lazy(() => getZpaVersioninfo200Schema);

export const getDevicePathParamsSchema = z.object({
	deviceId: z.string().describe("The device's unique identifier."),
});

/**
 * @description **HTTP Status Code:** `200` **OK** \n \nDevice detail returned successfully.
 */
export const getDevice200Schema = z
	.object({
		device_id: z.optional(z.string().describe("The device's unique identifier.")),
		device_name: z.optional(z.string().describe("The name of the device.")),
		mac_address: z.optional(z.string().describe("The device's MAC address.")),
		serial_number: z.optional(z.string().describe("The device's serial number.")),
		vendor: z.optional(z.string().describe("The device's manufacturer.")),
		model: z.optional(z.string().describe("The device's model.")),
		platform_os: z.optional(z.string().describe("The device's platform.")),
		app_version: z.optional(z.string().describe("App version of Zoom Rooms.")),
		tag: z.optional(z.string().describe("The tag's name.")),
		enrolled_in_zdm: z.optional(
			z.boolean().describe("Whether the device is enrolled in ZDM (Zoom Device Management)."),
		),
		connected_to_zdm: z.optional(
			z.boolean().describe("Whether the device is connected to ZDM (Zoom Device Management)."),
		),
		room_id: z.optional(z.string().describe("The Zoom Room's ID.")),
		room_name: z.optional(z.string().describe("The Zoom Room's name.")),
		device_type: z.optional(
			z
				.union([
					z.literal(0),
					z.literal(1),
					z.literal(2),
					z.literal(3),
					z.literal(4),
					z.literal(5),
					z.literal(6),
				])
				.describe(
					"Filter devices by device type.  \nDevice Type:  \n `-1` - All Zoom Room device(0,1,2,3,4,6).  \n `0` - Zoom Rooms Computer.  \n `1` - Zoom Rooms Controller.  \n `2` - Zoom Rooms Scheduling Display.  \n `3` - Zoom Rooms Control System.  \n `4` - Zoom Rooms Whiteboard.  \n `5` - Zoom Phone Appliance.  \n `6` - Zoom Rooms Computer (with Controller).",
				),
		),
		sdk_version: z.optional(z.string().describe("The SDK version.")),
		device_status: z.optional(
			z
				.union([z.literal(-1), z.literal(0), z.literal(1)])
				.describe(
					"Filter devices by status.  \n Device Status:  \n `0` - offline.  \n `1` - online.  \n `-1` - unlink",
				),
		),
		last_online: z.optional(z.string().describe("The time when the device was last online.")),
		user_email: z.optional(z.string().describe("The phone device's owner.")),
	})
	.describe("Information about the device.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request \n\n **Error Code:** `30055008` <br>\n No permission. <br>\n
 */
export const getDevice400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found \n\n **Error Code:** `30055012` <br>\n No found unified deviceId. <br>\n
 */
export const getDevice404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const getDevice429Schema = z.unknown();

export const getDeviceQueryResponseSchema = z.lazy(() => getDevice200Schema);

export const deleteDevicePathParamsSchema = z.object({
	deviceId: z.string().describe("Unique identifier of the device."),
});

/**
 * @description **HTTP Status Code:** `204` **No Content** Device deleted successfully.
 */
export const deleteDevice204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request \n\n **Error Code:** `30055008` <br>\n no permission. <br>\n
 */
export const deleteDevice400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found \n\n **Error Code:** `30055012` <br>\n no found unified deviceId. <br>\n
 */
export const deleteDevice404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const deleteDevice429Schema = z.unknown();

export const deleteDeviceMutationResponseSchema = z.lazy(() => deleteDevice204Schema);

export const updateDevicePathParamsSchema = z.object({
	deviceId: z.string().describe("Unique identifier of the device."),
});

/**
 * @description **HTTP Status Code:** `204` **No Content** \n \nRequest processed successfully.
 */
export const updateDevice204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request \n\n **Error Code:** `30055001` <br>\n zoom room does not exist. . <br>\n**Error Code:** `30055002` <br>\n required param can not be empty or null. <br>\n**Error Code:** `30055003` <br>\n device type does not support. <br>\n**Error Code:** `30055011` <br>\n device is not enrolled. <br>\n**Error Code:** `30055013` <br>\n device not support this app. <br>\n**Error Code:** `30055014` <br>\n room not support this app. <br>\n
 */
export const updateDevice400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found \n\n **Error Code:** `30055012` <br>\n Device does not exist: {deviceId}. <br>\n
 */
export const updateDevice404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const updateDevice429Schema = z.unknown();

export const updateDeviceMutationRequestSchema = z.object({
	device_name: z.string().describe("The name of the device."),
	tag: z.optional(z.string().describe("The name of the tag.")),
	room_id: z.optional(z.string().describe("id of the Zoom Room.")),
	device_type: z.optional(
		z
			.union([z.literal(0), z.literal(1), z.literal(3)])
			.describe(
				"Device Type:  \n `0` - Zoom Rooms Computer.  \n `1` - Zoom Rooms Controller.  \n `2` - Zoom Rooms Scheduling Display.",
			),
	),
});

export const updateDeviceMutationResponseSchema = z.lazy(() => updateDevice204Schema);

export const assginGroupPathParamsSchema = z.object({
	deviceId: z.string().describe("The device ID."),
});

export const assginGroupQueryParamsSchema = z.object({
	group_id: z.string().describe("The group's ID."),
});

/**
 * @description Request processed successfully.
 */
export const assginGroup204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `30052010` <br>\n Group does not exist. <br>\n
 */
export const assginGroup400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  No permission. \n\n
 */
export const assginGroup401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `30055012` <br>\n Device does not exist. <br>\n
 */
export const assginGroup404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const assginGroup429Schema = z.unknown();

export const assginGroupMutationResponseSchema = z.lazy(() => assginGroup204Schema);

export const changeDeviceAssociationPathParamsSchema = z.object({
	deviceId: z.string().describe("The device's unique identifier."),
});

/**
 * @description **HTTP Status Code:** `204` **No Content**  \n \nRequest processed successfully.
 */
export const changeDeviceAssociation204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `8500` <br>\n Device not enrolled in Zoom Device Management. <br>\n**Error Code:** `8501` <br>\n Device does not support this app. <br>\n**Error Code:** `8502` <br>\n Room does not support this app. <br>\n
 */
export const changeDeviceAssociation400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1012` <br>\n Room does not exist: {roomId}. <br>\n**Error Code:** `8503` <br>\n Device does not exist: {deviceId}. <br>\n
 */
export const changeDeviceAssociation404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const changeDeviceAssociation429Schema = z.unknown();

export const changeDeviceAssociationMutationRequestSchema = z.object({
	room_id: z.optional(
		z
			.string()
			.describe(
				"The Zoom Room ID of the device being associated to. The `room_id` is required. It can be ` ` or the specific room ID. If it is ` ` , it means release from the room. If the room ID is a specific value, assign that room to the device .",
			),
	),
	app_type: z.optional(
		z
			.enum(["ZR", "ZRC", "ZRP", "ZRW"])
			.default("ZR")
			.describe(
				"Specify one of these values for this field.\n\n`ZR` - Zoom Room computer.  \n \n`ZRC` - Zoom Room controller.  \n \n`ZRP` - Scheduling display.  \n \n`ZRW` - Companion whiteboard.",
			),
	),
});

export const changeDeviceAssociationMutationResponseSchema = z.lazy(
	() => changeDeviceAssociation204Schema,
);

export const deviceListQueryParamsSchema = z.object({
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	page_number: z.coerce
		.number()
		.int()
		.default(1)
		.describe(
			"**Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.",
		),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nList of H.323/SIP devices returned.  \n \n**Error Code:** `200`  \n \nNo permission.
 */
export const deviceList200Schema = z
	.object({
		next_page_token: z.optional(
			z
				.string()
				.describe(
					"The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.",
				),
		),
		page_count: z.optional(z.int().describe("The number of pages returned for the request made.")),
		page_number: z.optional(
			z
				.int()
				.default(1)
				.describe(
					"**Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.",
				),
		),
		page_size: z.optional(
			z
				.int()
				.max(300)
				.default(30)
				.describe("The number of records returned with a single API call."),
		),
		total_records: z.optional(
			z.int().describe("The total number of all the records available across pages."),
		),
		devices: z.optional(
			z
				.array(
					z.object({
						id: z.optional(z.string().describe("Device ID.")),
						encryption: z
							.enum(["auto", "yes", "no"])
							.describe("Device encryption:  \n `auto` - auto.  \n `yes` - yes.  \n `no` - no."),
						ip: z.string().describe("Device IP."),
						name: z.string().max(64).describe("Device name."),
						protocol: z
							.enum(["H.323", "SIP"])
							.describe("Device protocol:  \n `H.323` - H.323.  \n `SIP` - SIP."),
					}),
				)
				.describe("List of H.323/SIP Device objects."),
		),
	})
	.describe("List of H.323/SIP Devices.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n
 */
export const deviceList400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n
 */
export const deviceList401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n
 */
export const deviceList403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const deviceList429Schema = z.unknown();

export const deviceListQueryResponseSchema = z.lazy(() => deviceList200Schema);

/**
 * @description **HTTP Status Code:** `201`  \n \nH.323/SIP device created.
 */
export const deviceCreate201Schema = z.object({
	id: z.optional(z.string().describe("Device ID.")),
	encryption: z
		.enum(["auto", "yes", "no"])
		.describe("Device encryption:  \n `auto` - auto.  \n `yes` - yes.  \n `no` - no."),
	ip: z.string().describe("Device IP."),
	name: z.string().max(64).describe("Device name."),
	protocol: z
		.enum(["H.323", "SIP"])
		.describe("Device protocol:  \n `H.323` - H.323.  \n `SIP` - SIP."),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n No permission. <br>\n
 */
export const deviceCreate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n
 */
export const deviceCreate401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n
 */
export const deviceCreate403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `2020` <br>\n H.323 device\'s display name {displayName} is already in use. <br>\n
 */
export const deviceCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const deviceCreate429Schema = z.unknown();

/**
 * @description H.323/SIP device.
 */
export const deviceCreateMutationRequestSchema = z
	.object({
		encryption: z
			.enum(["auto", "yes", "no"])
			.describe("Device encryption:  \n `auto` - auto.  \n `yes` - yes.  \n `no` - no."),
		ip: z.string().describe("Device IP."),
		name: z.string().max(64).describe("Device name."),
		protocol: z
			.enum(["H.323", "SIP"])
			.describe("Device protocol:  \n `H.323` - H.323.  \n `SIP` - SIP."),
	})
	.describe("The H.323/SIP device object.");

export const deviceCreateMutationResponseSchema = z.lazy(() => deviceCreate201Schema);

export const deviceDeletePathParamsSchema = z.object({
	deviceId: z.string().describe("The device ID."),
});

/**
 * @description You do not have the permission to delete this device.
 */
export const deviceDelete200Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n
 */
export const deviceDelete400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n
 */
export const deviceDelete401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n
 */
export const deviceDelete403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n
 */
export const deviceDelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const deviceDelete429Schema = z.unknown();

export const deviceDeleteMutationResponseSchema = z.lazy(() => deviceDelete200Schema);

export const deviceUpdatePathParamsSchema = z.object({
	deviceId: z.string().describe("The device ID."),
});

/**
 * @description **HTTP Status Code:** `204`  \n \nH.323/SIP device updated.
 */
export const deviceUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n
 */
export const deviceUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n
 */
export const deviceUpdate401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n
 */
export const deviceUpdate403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `2020` <br>\n H.323 device\'s display name {displayName} is already in use. <br>\n
 */
export const deviceUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const deviceUpdate429Schema = z.unknown();

export const deviceUpdateMutationRequestSchema = z
	.object({
		encryption: z
			.enum(["auto", "yes", "no"])
			.describe("Device encryption:  \n `auto` - auto.  \n `yes` - yes.  \n `no` - no."),
		ip: z.string().describe("Device IP."),
		name: z.string().max(64).describe("Device name."),
		protocol: z
			.enum(["H.323", "SIP"])
			.describe("Device protocol.  \n `H.323` - H.323.  \n `SIP` - SIP."),
	})
	.describe("The H.323/SIP device object.");

export const deviceUpdateMutationResponseSchema = z.lazy(() => deviceUpdate204Schema);

export const meetingAppAddPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `201` App added.
 */
export const meetingAppAdd201Schema = z.object({
	id: z.optional(
		z
			.int()
			.describe(
				"The [meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in **long** format(represented as int64 data type in JSON), also known as the meeting number.",
			),
	),
	start_time: z.optional(
		z
			.string()
			.datetime()
			.describe(
				"For scheduled meetings only. Meeting start date-time in UTC/GMT, such as `2020-03-31T12:02:00Z`.",
			),
	),
	app_id: z.optional(z.string().describe("The app's ID.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `3000` <br>\n You can only add up to 3 apps. <br>\n**Error Code:** `3000` <br>\n Meeting {meetingId} has started. <br>\n**Error Code:** `3000` <br>\n Zoom Apps disabled. To use this feature, enable the \'Zoom Apps Quick Launch Button\' setting in the \'Settings\' page of the Zoom web portal. <br>\n
 */
export const meetingAppAdd400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId} <br>\n
 */
export const meetingAppAdd404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingAppAdd429Schema = z.unknown();

export const meetingAppAddMutationResponseSchema = z.lazy(() => meetingAppAdd201Schema);

export const meetingAppDeletePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `201` App deleted.
 */
export const meetingAppDelete204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `3000` <br>\n Meeting {meetingId} has started. <br>\n**Error Code:** `3000` <br>\n Zoom Apps disabled. To use this feature, enable the **Zoom Apps Quick Launch Button** setting in the **Settings** page of the Zoom web portal. <br>\n
 */
export const meetingAppDelete400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId} <br>\n
 */
export const meetingAppDelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingAppDelete429Schema = z.unknown();

export const meetingAppDeleteMutationResponseSchema = z.lazy(() => meetingAppDelete204Schema);

export const deleteMeetingChatMessageByIdPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, store it as a long-format integer and **not** an integer. Meeting IDs can be more than 10 digits.",
		),
	messageId: z
		.string()
		.describe(
			"The live meeting chat message's unique identifier (UUID), in base64-encoded format.",
		),
});

export const deleteMeetingChatMessageByIdQueryParamsSchema = z
	.object({
		file_ids: z.optional(
			z
				.string()
				.describe(
					"The live webinar chat file's universally unique identifier, in base64-encoded format. Separate multiple values with commas.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `204`   \n \nMeeting chat message deleted.
 */
export const deleteMeetingChatMessageById204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n DLP is not enabled on this account. <br>\n
 */
export const deleteMeetingChatMessageById400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const deleteMeetingChatMessageById404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const deleteMeetingChatMessageById429Schema = z.unknown();

export const deleteMeetingChatMessageByIdMutationResponseSchema = z.lazy(
	() => deleteMeetingChatMessageById204Schema,
);

export const updateMeetingChatMessageByIdPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, store it as a long-format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
	messageId: z
		.string()
		.describe(
			"The live meeting chat message's unique identifier (UUID), in base64-encoded format.",
		),
});

/**
 * @description **HTTP Status Code:** `204` <br>\n Meeting chat message updated.
 */
export const updateMeetingChatMessageById204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n DLP is not enabled on this account. <br>\n
 */
export const updateMeetingChatMessageById400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const updateMeetingChatMessageById404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const updateMeetingChatMessageById429Schema = z.unknown();

export const updateMeetingChatMessageByIdMutationRequestSchema = z.object({
	message_content: z.string().describe("The content of the chat message."),
});

export const updateMeetingChatMessageByIdMutationResponseSchema = z.lazy(
	() => updateMeetingChatMessageById204Schema,
);

export const inMeetingControlPathParamsSchema = z.object({
	meetingId: z.string().describe("The live meeting's ID."),
});

/**
 * @description **HTTP Status:** `202` **Accepted**\nRequest processed successfully.
 */
export const inMeetingControl202Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n * Meeting ID does not exist.<br>\n* Invalid meeting ID.<br>\n* Meeting does not exist.<br>\n* No permission.<br>\n* This API is not available for this account. Please contact Zoom support. <br>\n**Error Code:** `3309` <br>\n Not enough cloud storage available. Either purchase additional storage or delete cloud recordings to free up storage. <br>\n
 */
export const inMeetingControl400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n **Error Code:** `2314` <br>\n Not allowed to manage the AI Companion. To use this feature, enable either the **Allow users to ask AI Companion questions about the meeting** setting or the **Meeting summary with AI Companion** setting in the **Settings** page of the Zoom web portal. <br>\n**Error Code:** `2314` <br>\n Not allowed to manage the AI Companion summary. To use this feature, enable the **Meeting summary with AI Companion** setting in the **Settings** page of the Zoom web portal. <br>\n**Error Code:** `2314` <br>\n Not allowed to manage the AI Companion questions. To use this feature, enable the **Allow users to ask AI Companion questions about the meeting** setting in the **Settings** page of the Zoom web portal. <br>\n**Error Code:** `2314` <br>\n Not allowed to manage the AI Companion. To use this feature, enable either the **Allow users to ask AI Companion questions about the webinar** setting or the **Webinar summary with AI Companion** setting in the **Settings** page of the Zoom web portal. <br>\n**Error Code:** `2314` <br>\n Not allowed to manage the AI Companion summary. To use this feature, enable the **Webinar summary with AI Companion** setting in the **Settings** page of the Zoom web portal. <br>\n**Error Code:** `2314` <br>\n Not allowed to manage the AI Companion questions. To use this feature, enable the **Allow users to ask AI Companion questions about the webinar** setting in the **Settings** page of the Zoom web portal. <br>\n
 */
export const inMeetingControl403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting {meetingId} is not found or has expired. <br>\n
 */
export const inMeetingControl404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const inMeetingControl429Schema = z.unknown();

export const inMeetingControlMutationRequestSchema = z.object({
	method: z.optional(
		z
			.enum([
				"recording.start",
				"recording.stop",
				"recording.pause",
				"recording.resume",
				"participant.invite",
				"participant.invite.callout",
				"participant.invite.room_system_callout",
				"waiting_room.update",
				"ai_companion.start",
				"ai_companion.stop",
				"ai_companion.disable",
			])
			.describe(
				"The method that you would like to control.\n* `recording.start` - Start the recording.\n* `recording.stop` - Stop the recording.\n* `recording.pause` - Pause the recording.\n* `recording.resume` - Resume a paused recording.\n* `participant.invite` - Invite a participant to the meeting.\n* `participant.invite.callout` - Invite a participant to the meeting through [call out (phone)](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0062038).\n* `participant.invite.room_system_callout` - Invite a participant to the meeting through [call out (room system)](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0065721).\n* `waiting_room.update` - Update the waiting room with a custom message.\n* `ai_companion.start` - Start the AI Companion.\n* `ai_companion.stop` - Stop the AI Companion.\n* `ai_companion.disable` - Disable the AI Companion.",
			),
	),
	params: z.optional(
		z
			.object({
				contacts: z.optional(
					z
						.array(
							z.object({
								email: z.optional(
									z
										.string()
										.describe(
											"The user's email address. Use this value if you do not have the user's ID. \n\nIf you pass the `id` value, the API ignores this query parameter.",
										),
								),
								id: z.optional(z.string().describe("The user's ID.")),
							}),
						)
						.max(10)
						.describe(
							"The user's email address or the user ID, up to a maximum of 10 contacts. The account must be a part of the meeting host's account.",
						),
				),
				invitee_name: z.optional(
					z
						.string()
						.describe(
							"The user's name to display in the meeting. Use this field if you pass the `participant.invite.callout` value for the `method` field.",
						),
				),
				phone_number: z.optional(
					z
						.string()
						.describe(
							"The user's phone number. Use this field if you pass the `participant.invite.callout` value for the `method` field. As a best practice, ensure this includes a country code and area code.\r\n\r\nIf you are dialing a phone number that includes an extension, type a hyphen '-' after the phone number and enter the extension. For example, 6032331333-156 dials the extension 156.",
						),
				),
				invite_options: z.optional(
					z
						.object({
							require_greeting: z.optional(
								z
									.boolean()
									.default(true)
									.describe(
										"Whether to require a greeting before being connected. Use this field if you pass the `participant.invite.callout` value for the `method` field.",
									),
							),
							require_pressing_one: z.optional(
								z
									.boolean()
									.default(true)
									.describe(
										"Whether to require pressing 1 before being connected. Use this field if you pass the `participant.invite.callout` value for the `method` field.",
									),
							),
						})
						.describe("Information about the `participant.invite.callout` settings."),
				),
				call_type: z.optional(
					z
						.string()
						.describe(
							"The type of call out. Use a value of `h323` or `sip`. Use this field if you pass the `participant.invite.room_system_callout` value for the `method` field.",
						),
				),
				device_ip: z.optional(
					z
						.string()
						.describe(
							"The user's device IP address or URI. Use this field if you pass the `participant.invite.room_system_callout` value for the `method` field.",
						),
				),
				h323_headers: z.optional(
					z
						.object({
							from_display_name: z.optional(
								z
									.string()
									.max(64)
									.describe("Custom name that will be used within the h323 Header."),
							),
							to_display_name: z.optional(
								z
									.string()
									.max(64)
									.describe("Custom remote name that will be used within the meeting."),
							),
						})
						.describe(
							"Enable customers to leverage services that require customization of the FROM header to identify the caller. Use this field if you pass the `participant.invite.room_system_callout` value for the `method` field and the `h323` value for the `call_type` field.",
						),
				),
				sip_headers: z.optional(
					z
						.object({
							from_display_name: z.optional(
								z.string().max(64).describe("Custom name that will be used within the SIP Header."),
							),
							to_display_name: z.optional(
								z
									.string()
									.max(64)
									.describe("Custom remote name that will be used within the meeting."),
							),
							from_uri: z.optional(
								z
									.string()
									.max(256)
									.describe(
										"Custom URI that will be used within the SIP Header. The URI must start with 'sip:' or 'sips:' as a valid URI based on parameters defined by the platform.",
									),
							),
							additional_headers: z.optional(
								z
									.array(
										z.object({
											key: z.optional(
												z.string().max(32).describe("Additional custom SIP header's key."),
											),
											value: z.optional(
												z.string().max(256).describe("Additional custom SIP header's value."),
											),
										}),
									)
									.max(10)
									.describe(
										"Ability to add 1 to 10 custom headers, each of which has a maximum length of 256 bytes to comply with SIP standards.  Custom headers would leverage header names starting with 'X-' per SIP guidelines.",
									),
							),
						})
						.describe(
							"Enable customers to leverage services that require customization of the FROM header to identify the caller. Use this field if you pass the `participant.invite.room_system_callout` value for the `method` field and the `sip` value for the `call_type` field.",
						),
				),
				waiting_room_title: z.optional(
					z
						.string()
						.describe(
							"The title displayed in the waiting room. Use this field if you pass the `waiting_room.update` value for the `method` field.",
						),
				),
				waiting_room_description: z.optional(
					z
						.string()
						.describe(
							"The description shown in the waiting room. Use this field if you pass the `waiting_room.update` value for the `method` field.",
						),
				),
				ai_companion_mode: z.optional(
					z
						.enum(["questions", "summary", "all"])
						.default("all")
						.describe(
							"Which AI Companion mode to start or stop. Use this field if you pass the `ai_companion.start` or `ai_companion.stop` value for the `method` field.\n* `questions`  The AI Companion for answering questions.\n* `summary`  The AI Companion for generating meeting summaries.\n* `all`  Both modes.\n\nIf this field is not provided, `all` is used by default.",
						),
				),
				delete_meeting_assets: z.optional(
					z
						.boolean()
						.default(false)
						.describe(
							"Whether to delete all meeting assets - such as transcripts and summaries - when stopping the AI Companion. Use this field only if you pass the `ai_companion.stop` value for the `method` field **and** the `ai_companion_mode` field is set to `all`.",
						),
				),
			})
			.describe("The in-meeting parameters."),
	),
});

export const inMeetingControlMutationResponseSchema = z.lazy(() => inMeetingControl202Schema);

export const meetingLocalRecordingJoinTokenPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

export const meetingLocalRecordingJoinTokenQueryParamsSchema = z
	.object({
		bypass_waiting_room: z.optional(z.boolean().describe("Whether to bypass the waiting room.")),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `200`   \n \nMeeting local recording token returned.
 */
export const meetingLocalRecordingJoinToken200Schema = z
	.object({
		expire_in: z.optional(
			z
				.literal(120)
				.describe(
					"The number of seconds the join token is valid for before it expires. This value always returns `120`.",
				),
		),
		token: z.optional(z.string().describe("The join token.")),
	})
	.describe("Information about the meeting's local recorder join token.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `3000` <br>\n Cannot access webinar information. <br>\n**Error Code:** `124` <br>\n This API only supports OAuth2 authorization. <br>\n**Error Code:** `3000` <br>\n Not allowed to start local recording. To use this feature, enable the **Local Recording** setting in the **Settings** page of the Zoom web portal. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingLocalRecordingJoinToken400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `300` <br>\n Meeting ID does not exist. <br>\n**Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingLocalRecordingJoinToken404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingLocalRecordingJoinToken429Schema = z.unknown();

export const meetingLocalRecordingJoinTokenQueryResponseSchema = z.lazy(
	() => meetingLocalRecordingJoinToken200Schema,
);

export const meetingTokenPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

export const meetingTokenQueryParamsSchema = z.object({
	type: z
		.enum(["closed_caption_token"])
		.default("closed_caption_token")
		.describe(
			"The meeting token type. \n* `closed_caption_token` - The third-party closed caption API token. \n\nThis defaults to `closed_caption_token`.",
		),
});

/**
 * @description **HTTP Status Code:** `200`   \n \nMeeting token returned.
 */
export const meetingToken200Schema = z
	.object({
		token: z.optional(z.string().describe("The generated meeting token.")),
	})
	.describe("Information about the meeting token.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n**Error Code:** `3000` <br>\n Cannot access webinar information. <br>\n
 */
export const meetingToken400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `300` <br>\n Meeting ID does not exist. <br>\n**Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingToken404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingToken429Schema = z.unknown();

export const meetingTokenQueryResponseSchema = z.lazy(() => meetingToken200Schema);

export const addBatchRegistrantsPathParamsSchema = z.object({
	meetingId: z.string().describe("Unique identifier of the meeting (Meeting Number)."),
});

/**
 * @description **HTTP Status Code:** `200` **OK**   \n \nRegistrants added.
 */
export const addBatchRegistrants201Schema = z.object({
	registrants: z.optional(
		z.array(
			z.object({
				email: z.optional(z.string().describe("Email address of the registrant.")),
				join_url: z.optional(
					z.string().describe("Unique URL using which registrant can join the meeting."),
				),
				registrant_id: z.optional(z.string().describe("Unique identifier of the registrant.")),
				participant_pin_code: z.optional(
					z
						.int()
						.describe(
							"The participant PIN code is used to authenticate audio participants before they join the meeting.",
						),
				),
			}),
		),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3038` <br>\n Meeting is over, you can not register now. If you have any questions, please contact the Meeting host. <br>\n**Error Code:** `303` <br>\n This API can only be used for scheduled meeting(meeting type: 2). Batch registration is not supported for other meeting types. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n**Error Code:** `3043` <br>\n Meeting has reached maximum attendee capacity. <br>\n**Error Code:** `404` <br>\n Registration has not been enabled for this meeting: {meetingId}. <br>\n
 */
export const addBatchRegistrants400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const addBatchRegistrants404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const addBatchRegistrants429Schema = z.unknown();

export const addBatchRegistrantsMutationRequestSchema = z.object({
	auto_approve: z.optional(
		z
			.boolean()
			.describe(
				"If a meeting was scheduled with approval_type `1` (manual approval), but you would like to automatically approve the registrants that are added via this API, you can set the value of this field to `true`. \n\nYou **cannot** use this field to change approval setting for a meeting  that was originally scheduled with approval_type `0` (automatic approval).",
			),
	),
	registrants_confirmation_email: z.optional(
		z.boolean().describe("Send confirmation Email to Registrants"),
	),
	registrants: z.optional(
		z.array(
			z.object({
				email: z.email().describe("Email address of the registrant."),
				first_name: z.string().describe("First name of the registrant."),
				last_name: z.optional(z.string().describe("Last name of the registrant.")),
			}),
		),
	),
});

export const addBatchRegistrantsMutationResponseSchema = z.lazy(() => addBatchRegistrants201Schema);

export const meetingInvitationPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer, not a simple integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nMeeting invitation returned.
 */
export const meetingInvitation200Schema = z
	.object({
		invitation: z.optional(z.string().describe("Meeting invitation.")),
		sip_links: z.optional(z.array(z.string()).describe("A list of SIP phone addresses.")),
	})
	.describe("Meeting invitation details.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingInvitation400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingInvitation404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingInvitation429Schema = z.unknown();

export const meetingInvitationQueryResponseSchema = z.lazy(() => meetingInvitation200Schema);

export const meetingInviteLinksCreatePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `201`   \n \nMeeting invitation links created.
 */
export const meetingInviteLinksCreate201Schema = z
	.object({
		attendees: z.optional(
			z
				.array(
					z.object({
						join_url: z.optional(z.string().describe("The URL to join the meeting.")),
						name: z.optional(z.string().describe("The user's display name.")),
					}),
				)
				.min(1)
				.max(500)
				.describe("The attendee list."),
		),
	})
	.describe("Invite links response.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `3000` <br>\n Cannot access webinar information. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingInviteLinksCreate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId} <br>\n
 */
export const meetingInviteLinksCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingInviteLinksCreate429Schema = z.unknown();

export const meetingInviteLinksCreateMutationRequestSchema = z
	.object({
		attendees: z.optional(
			z
				.array(
					z.object({
						name: z.string().max(64).describe("User display name."),
						disable_video: z.optional(
							z
								.boolean()
								.default(false)
								.describe(
									"Whether to disable participant video when joining the meeting. If not provided or set to `false`, the participant video will follow the meeting's default settings.",
								),
						),
						disable_audio: z.optional(
							z
								.boolean()
								.default(false)
								.describe(
									"Whether to disable participant audio when joining the meeting. If not provided or set to `false`, the participant audio will follow the meeting's default settings.",
								),
						),
					}),
				)
				.min(1)
				.max(500)
				.describe("The attendees list."),
		),
		ttl: z.optional(
			z
				.int()
				.min(0)
				.max(7776000)
				.default(7200)
				.describe(
					"The invite link's expiration time, in seconds. \n\nThis value defaults to `7200`.",
				),
		),
	})
	.describe("Invite links.");

export const meetingInviteLinksCreateMutationResponseSchema = z.lazy(
	() => meetingInviteLinksCreate201Schema,
);

export const meetingRegistrantsPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, store it as a long format integer, not an integer. Meeting IDs can exceed 10 digits.",
		),
});

export const meetingRegistrantsQueryParamsSchema = z.object({
	occurrence_id: z.optional(z.string().describe("The meeting or webinar occurrence ID.")),
	status: z
		.enum(["pending", "approved", "denied"])
		.default("approved")
		.describe(
			"Query by the registrant's status. \n* `pending` - The registration is pending. \n* `approved` - The registrant is approved. \n* `denied` - The registration is denied.",
		),
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	page_number: z.coerce
		.number()
		.int()
		.default(1)
		.describe(
			"**Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.",
		),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nSuccessfully listed meeting registrants.
 */
export const meetingRegistrants200Schema = z
	.object({
		next_page_token: z.optional(
			z
				.string()
				.describe(
					"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
				),
		),
		page_count: z.optional(z.int().describe("The number of pages returned for the request made.")),
		page_number: z.optional(
			z
				.int()
				.default(1)
				.describe(
					"**Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.",
				),
		),
		page_size: z.optional(
			z
				.int()
				.max(300)
				.default(30)
				.describe("The number of records returned with a single API call."),
		),
		total_records: z.optional(
			z.int().describe("The total number of all the records available across pages."),
		),
		registrants: z.optional(
			z
				.array(
					z
						.object({
							address: z.optional(z.string().describe("The registrant's address.")),
							city: z.optional(z.string().describe("The registrant's city.")),
							comments: z.optional(z.string().describe("The registrant's questions and comments.")),
							country: z.optional(
								z
									.string()
									.describe(
										"The registrant's two-letter [country code](/docs/api/rest/other-references/abbreviation-lists/#countries).",
									),
							),
							custom_questions: z.optional(
								z
									.array(
										z
											.object({
												title: z.optional(z.string().describe("The title of the custom question.")),
												value: z.optional(
													z
														.string()
														.max(128)
														.describe(
															"The custom question's response value. This has a limit of 128 characters.",
														),
												),
											})
											.describe("Information about custom questions."),
									)
									.describe("Information about custom questions."),
							),
							email: z
								.email()
								.max(128)
								.describe(
									"The registrant's email address. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for return value details.",
								),
							first_name: z.string().max(64).describe("The registrant's first name."),
							industry: z.optional(z.string().describe("The registrant's industry.")),
							job_title: z.optional(z.string().describe("The registrant's job title.")),
							last_name: z.optional(z.string().max(64).describe("The registrant's last name.")),
							no_of_employees: z.optional(
								z
									.enum([
										"",
										"1-20",
										"21-50",
										"51-100",
										"101-250",
										"251-500",
										"501-1,000",
										"1,001-5,000",
										"5,001-10,000",
										"More than 10,000",
									])
									.describe(
										"The registrant's number of employees. \n* `1-20` \n* `21-50` \n* `51-100` \n* `101-250` \n* `251-500` \n* `501-1,000` \n* `1,001-5,000` \n* `5,001-10,000` \n* `More than 10,000`",
									),
							),
							org: z.optional(z.string().describe("The registrant's organization.")),
							phone: z.optional(z.string().describe("The registrant's phone number.")),
							purchasing_time_frame: z.optional(
								z
									.enum([
										"",
										"Within a month",
										"1-3 months",
										"4-6 months",
										"More than 6 months",
										"No timeframe",
									])
									.describe(
										"The registrant's purchasing time frame. \n* `Within a month` \n* `1-3 months` \n* `4-6 months` \n* `More than 6 months` \n* `No timeframe`",
									),
							),
							role_in_purchase_process: z.optional(
								z
									.enum([
										"",
										"Decision Maker",
										"Evaluator/Recommender",
										"Influencer",
										"Not involved",
									])
									.describe(
										"The registrant's role in the purchase process. \n* `Decision Maker` \n* `Evaluator/Recommender` \n* `Influencer` \n* `Not involved`",
									),
							),
							state: z.optional(z.string().describe("The registrant's state or province.")),
							status: z.optional(
								z
									.enum(["approved", "denied", "pending"])
									.describe(
										"The registrant's status. \n* `approved` - Registrant is approved. \n* `denied` - Registrant is denied. \n* `pending` - Registrant is waiting for approval.",
									),
							),
							zip: z.optional(z.string().describe("The registrant's ZIP or postal code.")),
						})
						.and(
							z.object({
								id: z.optional(z.string().describe("Registrant ID.")),
								create_time: z.optional(
									z.string().datetime().describe("The time when the registrant registered."),
								),
								join_url: z.optional(
									z
										.string()
										.describe(
											"The URL that an approved registrant can use to join the meeting or webinar.",
										),
								),
								status: z.optional(
									z
										.string()
										.describe(
											"The status of the registrant's registration.   \n  `approved` - User has been successfully approved for the webinar.  \n  `pending` - The registration is still pending.  \n  `denied` - User has been denied from joining the webinar.",
										),
								),
								participant_pin_code: z.optional(
									z
										.int()
										.describe(
											"The participant PIN code is used to authenticate audio participants before they join the meeting.",
										),
								),
							}),
						),
				)
				.describe("List of registrant objects."),
		),
	})
	.describe("List of users.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Cannot access webinar info. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingRegistrants400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingRegistrants404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingRegistrants429Schema = z.unknown();

export const meetingRegistrantsQueryResponseSchema = z.lazy(() => meetingRegistrants200Schema);

export const meetingRegistrantCreatePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

export const meetingRegistrantCreateQueryParamsSchema = z
	.object({
		occurrence_ids: z.optional(
			z
				.string()
				.describe(
					"A comma-separated list of meeting occurrence IDs. You can get this value with the [Get a meeting](/docs/api-reference/zoom-api/methods#operation/meeting) API.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `201`   \n \nMeeting registration created.
 */
export const meetingRegistrantCreate201Schema = z.object({
	id: z.optional(z.int().describe("The meeting ID.")),
	join_url: z.optional(
		z
			.string()
			.describe(
				"The URL the registrant can use to join the meeting. \n\nThe API will not return this field if the meeting was [created](/docs/api-reference/zoom-api/methods#operation/meetingCreate) with the `approval_type` field value of `1` (manual approval).",
			),
	),
	registrant_id: z.optional(z.string().describe("The registrant's ID.")),
	start_time: z.optional(z.string().datetime().describe("The meeting's start time.")),
	topic: z.optional(z.string().max(200).describe("The meeting's topic.")),
	occurrences: z.optional(
		z
			.array(
				z
					.object({
						duration: z.optional(z.int().describe("Duration.")),
						occurrence_id: z.optional(
							z
								.string()
								.describe(
									"Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.",
								),
						),
						start_time: z.optional(z.string().datetime().describe("Start time.")),
						status: z.optional(z.string().describe("Occurrence status.")),
					})
					.describe("Occurrence object. This object is only returned for Recurring Webinars."),
			)
			.describe("Array of occurrence objects."),
	),
	participant_pin_code: z.optional(
		z
			.int()
			.describe(
				"The participant PIN code is used to authenticate audio participants before they join the meeting.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3043` <br>\n Meeting has reached maximum attendee capacity. <br>\n**Error Code:** `3000` <br>\n Cannot access meeting info. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingRegistrantCreate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingRegistrantCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const meetingRegistrantCreate429Schema = z.unknown();

export const meetingRegistrantCreateMutationRequestSchema = z
	.object({
		first_name: z.string().max(64).describe("The registrant's first name."),
		last_name: z.optional(z.string().max(64).describe("The registrant's last name.")),
		email: z.email().max(128).describe("The registrant's email address."),
		address: z.optional(z.string().describe("The registrant's address.")),
		city: z.optional(z.string().describe("The registrant's city.")),
		state: z.optional(z.string().describe("The registrant's state or province.")),
		zip: z.optional(z.string().describe("The registrant's ZIP or postal code.")),
		country: z.optional(
			z
				.string()
				.describe(
					"The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).",
				),
		),
		phone: z.optional(z.string().describe("The registrant's phone number.")),
		comments: z.optional(z.string().describe("The registrant's questions and comments.")),
		custom_questions: z.optional(
			z
				.array(
					z
						.object({
							title: z.optional(z.string().describe("The title of the custom question.")),
							value: z.optional(
								z
									.string()
									.max(128)
									.describe(
										"The custom question's response value. This has a limit of 128 characters.",
									),
							),
						})
						.describe("Information about custom questions."),
				)
				.describe("Information about custom questions."),
		),
		industry: z.optional(z.string().describe("The registrant's industry.")),
		job_title: z.optional(z.string().describe("The registrant's job title.")),
		no_of_employees: z.optional(
			z
				.enum([
					"",
					"1-20",
					"21-50",
					"51-100",
					"101-500",
					"500-1,000",
					"1,001-5,000",
					"5,001-10,000",
					"More than 10,000",
				])
				.describe(
					"The registrant's number of employees: \n* `1-20` \n* `21-50` \n* `51-100` \n* `101-500` \n* `500-1,000` \n* `1,001-5,000` \n* `5,001-10,000` \n* `More than 10,000`",
				),
		),
		org: z.optional(z.string().describe("The registrant's organization.")),
		purchasing_time_frame: z.optional(
			z
				.enum([
					"",
					"Within a month",
					"1-3 months",
					"4-6 months",
					"More than 6 months",
					"No timeframe",
				])
				.describe(
					"The registrant's purchasing time frame: \n* `Within a month` \n* `1-3 months` \n* `4-6 months` \n* `More than 6 months` \n* `No timeframe`",
				),
		),
		role_in_purchase_process: z.optional(
			z
				.enum(["", "Decision Maker", "Evaluator/Recommender", "Influencer", "Not involved"])
				.describe(
					"The registrant's role in the purchase process: \n* `Decision Maker` \n* `Evaluator/Recommender` \n* `Influencer` \n* `Not involved`",
				),
		),
		language: z.optional(
			z
				.enum([
					"en-US",
					"de-DE",
					"es-ES",
					"fr-FR",
					"jp-JP",
					"pt-PT",
					"ru-RU",
					"zh-CN",
					"zh-TW",
					"ko-KO",
					"it-IT",
					"vi-VN",
					"pl-PL",
					"Tr-TR",
				])
				.describe(
					"The registrant's language preference for confirmation emails: \n* `en-US` &mdash; English (US) \n* `de-DE` &mdash; German (Germany) \n* `es-ES` &mdash; Spanish (Spain) \n* `fr-FR` &mdash; French (France) \n* `jp-JP` &mdash; Japanese \n* `pt-PT` &mdash; Portuguese (Portugal) \n* `ru-RU` &mdash; Russian \n* `zh-CN` &mdash; Chinese (PRC) \n* `zh-TW` &mdash; Chinese (Taiwan) \n* `ko-KO` &mdash; Korean \n* `it-IT` &mdash; Italian (Italy) \n* `vi-VN` &mdash; Vietnamese \n* `pl-PL` &mdash; Polish \n* `Tr-TR` &mdash; Turkish",
				),
		),
		auto_approve: z.optional(
			z
				.boolean()
				.describe(
					"If a meeting was scheduled with the `approval_type` field value of `1` (manual approval) but you want to automatically approve meeting registrants, set the value of this field to `true`. \n\n**Note:** You cannot use this field to change approval setting for a meeting originally scheduled with the `approval_type` field value of `0` (automatic approval).",
				),
		),
	})
	.describe("Information about the meeting registrant.");

export const meetingRegistrantCreateMutationResponseSchema = z.lazy(
	() => meetingRegistrantCreate201Schema,
);

export const meetingRegistrantsQuestionsGetPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, store it as a long format integer, not a simple integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nMeeting Registrant Question object returned
 */
export const meetingRegistrantsQuestionsGet200Schema = z.object({
	custom_questions: z.optional(
		z
			.array(
				z.object({
					answers: z.optional(
						z
							.array(z.string())
							.describe(
								"Answer choices for the question. Can not be used for `short` question type as this type of question requires registrants to type out the answer.",
							),
					),
					required: z.optional(
						z
							.boolean()
							.describe(
								"Whether or not the custom question is required to be answered by participants or not.",
							),
					),
					title: z.optional(z.string().describe("Title of the custom question.")),
					type: z.optional(
						z.enum(["short", "single"]).describe("Type of the question being asked."),
					),
				}),
			)
			.describe("Array of custom questions for registrants."),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					field_name: z.optional(
						z
							.enum([
								"last_name",
								"address",
								"city",
								"country",
								"zip",
								"state",
								"phone",
								"industry",
								"org",
								"job_title",
								"purchasing_time_frame",
								"role_in_purchase_process",
								"no_of_employees",
								"comments",
							])
							.describe("Field name of the question."),
					),
					required: z.optional(
						z
							.boolean()
							.describe(
								"Whether or not the displayed fields are required to be filled out by registrants.",
							),
					),
				}),
			)
			.describe("Array of registrant questions."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingRegistrantsQuestionsGet400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingRegistrantsQuestionsGet404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingRegistrantsQuestionsGet429Schema = z.unknown();

export const meetingRegistrantsQuestionsGetQueryResponseSchema = z.lazy(
	() => meetingRegistrantsQuestionsGet200Schema,
);

export const meetingRegistrantQuestionUpdatePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `204`  \n \nMeeting Registrant Questions Updated
 */
export const meetingRegistrantQuestionUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingRegistrantQuestionUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingRegistrantQuestionUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingRegistrantQuestionUpdate429Schema = z.unknown();

/**
 * @description Meeting Registrant Questions
 */
export const meetingRegistrantQuestionUpdateMutationRequestSchema = z.object({
	custom_questions: z.optional(
		z
			.array(
				z.object({
					answers: z.optional(
						z
							.array(z.string())
							.describe(
								"Answer choices for the question. Can not be used for `short` question type as this type of question requires registrants to type out the answer.",
							),
					),
					required: z.optional(
						z
							.boolean()
							.describe(
								"Indicates whether or not the custom question is required to be answered by participants or not.",
							),
					),
					title: z.optional(z.string().describe("Title of the custom question.")),
					type: z.optional(
						z.enum(["short", "single"]).describe("The type of question being asked."),
					),
				}),
			)
			.describe("Array of Registrant Custom Questions"),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					field_name: z.optional(
						z
							.enum([
								"last_name",
								"address",
								"city",
								"country",
								"zip",
								"state",
								"phone",
								"industry",
								"org",
								"job_title",
								"purchasing_time_frame",
								"role_in_purchase_process",
								"no_of_employees",
								"comments",
							])
							.describe("The question's field name."),
					),
					required: z.optional(
						z
							.boolean()
							.describe(
								"Indicates whether or not the displayed fields are required to be filled out by registrants.",
							),
					),
				}),
			)
			.describe("Array of registrant questions."),
	),
});

export const meetingRegistrantQuestionUpdateMutationResponseSchema = z.lazy(
	() => meetingRegistrantQuestionUpdate204Schema,
);

export const meetingRegistrantStatusPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, store it as a `long` format integer, not as a simple integer. Meeting IDs can exceed 10 digits.",
		),
});

export const meetingRegistrantStatusQueryParamsSchema = z
	.object({
		occurrence_id: z.optional(z.string().describe("The meeting or webinar occurrence ID.")),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `204`  \n \nRegistrant status updated.
 */
export const meetingRegistrantStatus204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3000` <br>\n Cannot access webinar information. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingRegistrantStatus400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingRegistrantStatus404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingRegistrantStatus429Schema = z.unknown();

export const meetingRegistrantStatusMutationRequestSchema = z.object({
	action: z
		.enum(["approve", "cancel", "deny"])
		.describe(
			"Registrant status. \n `approve` - Approve registrant.  \n `cancel` - Cancel previously approved registrant's registration.  \n `deny` - Deny registrant.",
		),
	registrants: z.optional(
		z
			.array(
				z.object({
					email: z.optional(z.string()),
					id: z.optional(z.string()),
				}),
			)
			.max(30)
			.describe("List of registrants."),
	),
});

export const meetingRegistrantStatusMutationResponseSchema = z.lazy(
	() => meetingRegistrantStatus204Schema,
);

export const meetingRegistrantGetPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
	registrantId: z.string().describe("The registrant ID."),
});

/**
 * @description Success.
 */
export const meetingRegistrantGet200Schema = z
	.object({
		address: z.optional(z.string().describe("The registrant's address.")),
		city: z.optional(z.string().describe("The registrant's city.")),
		comments: z.optional(z.string().describe("The registrant's questions and comments.")),
		country: z.optional(
			z
				.string()
				.describe(
					"The registrant's two-letter [country code](https://developers.zoom.us/docs/api/rest/other-references/abbreviation-lists/#countries).",
				),
		),
		custom_questions: z.optional(
			z
				.array(
					z
						.object({
							title: z.optional(z.string().describe("The title of the custom question.")),
							value: z.optional(
								z
									.string()
									.max(128)
									.describe(
										"The custom question's response value. This has a limit of 128 characters.",
									),
							),
						})
						.describe("Information about custom questions."),
				)
				.describe("Information about custom questions."),
		),
		email: z
			.email()
			.max(128)
			.describe(
				"The registrant's email address. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for return value details.",
			),
		first_name: z.string().max(64).describe("The registrant's first name."),
		industry: z.optional(z.string().describe("The registrant's industry.")),
		job_title: z.optional(z.string().describe("The registrant's job title.")),
		last_name: z.optional(z.string().max(64).describe("The registrant's last name.")),
		no_of_employees: z.optional(
			z
				.enum([
					"",
					"1-20",
					"21-50",
					"51-100",
					"101-250",
					"251-500",
					"501-1,000",
					"1,001-5,000",
					"5,001-10,000",
					"More than 10,000",
				])
				.describe(
					"The registrant's number of employees. \n* `1-20` \n* `21-50` \n* `51-100` \n* `101-250` \n* `251-500` \n* `501-1,000` \n* `1,001-5,000` \n* `5,001-10,000` \n* `More than 10,000`",
				),
		),
		org: z.optional(z.string().describe("The registrant's organization.")),
		phone: z.optional(z.string().describe("The registrant's phone number.")),
		purchasing_time_frame: z.optional(
			z
				.enum([
					"",
					"Within a month",
					"1-3 months",
					"4-6 months",
					"More than 6 months",
					"No timeframe",
				])
				.describe(
					"The registrant's purchasing time frame. \n* `Within a month` \n* `1-3 months` \n* `4-6 months` \n* `More than 6 months` \n* `No timeframe`",
				),
		),
		role_in_purchase_process: z.optional(
			z
				.enum(["", "Decision Maker", "Evaluator/Recommender", "Influencer", "Not involved"])
				.describe(
					"The registrant's role in the purchase process. \n* `Decision Maker` \n* `Evaluator/Recommender` \n* `Influencer` \n* `Not involved`",
				),
		),
		state: z.optional(z.string().describe("The registrant's state or province.")),
		status: z.optional(
			z
				.enum(["approved", "denied", "pending"])
				.describe(
					"The registrant's status. \n* `approved` - Registrant is approved. \n* `denied` - Registrant is denied. \n* `pending` - Registrant is waiting for approval.",
				),
		),
		zip: z.optional(z.string().describe("The registrant's ZIP or postal code.")),
	})
	.and(
		z.object({
			id: z.optional(z.string()),
			create_time: z.optional(
				z.string().datetime().describe("The registrant's registration date and time."),
			),
			join_url: z.optional(
				z.string().describe("The URL with which the approved registrant can join the meeting."),
			),
			status: z.optional(
				z
					.enum(["approved", "pending", "denied"])
					.describe(
						"The registrant's registration status.\n* `approved` - The registrant is approved to join the meeting. \n* `pending` - The registrant's registration is pending.\n* `denied` - The registrant was declined to join the meeting.",
					),
			),
			participant_pin_code: z.optional(
				z
					.int()
					.describe(
						"The participant PIN code is used to authenticate audio participants before they join the meeting.",
					),
			),
		}),
	);

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3000` <br>\n Cannot access webinar info. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingRegistrantGet400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingRegistrantGet404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const meetingRegistrantGet429Schema = z.unknown();

export const meetingRegistrantGetQueryResponseSchema = z.lazy(() => meetingRegistrantGet200Schema);

export const meetingregistrantdeletePathParamsSchema = z.object({
	meetingId: z.coerce.number().int().describe("The meeting ID."),
	registrantId: z.string().describe("The meeting registrant ID."),
});

export const meetingregistrantdeleteQueryParamsSchema = z
	.object({
		occurrence_id: z.optional(z.string().describe("The meeting occurrence ID.")),
	})
	.optional();

/**
 * @description **HTTP status code:** `204`   \n \nOK
 */
export const meetingregistrantdelete204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n Only available for paid users: {userId}. <br>\n**Error Code:** `300` <br>\n The value that you entered for the Registrant ID field is invalid. Enter a valid value and try again. <br>\n**Error Code:** `300` <br>\n Registration has not been enabled for this meeting: {meetingId}. <br>\n**Error Code:** `3000` <br>\n Cannot access webinar info. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingregistrantdelete400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingregistrantdelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingregistrantdelete429Schema = z.unknown();

export const meetingregistrantdeleteMutationResponseSchema = z.lazy(
	() => meetingregistrantdelete204Schema,
);

export const meetingLiveStreamingJoinTokenPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `200`   \n \nMeeting live streaming token returned.
 */
export const meetingLiveStreamingJoinToken200Schema = z
	.object({
		expire_in: z.optional(
			z
				.literal(120)
				.describe(
					"The number of seconds the join token is valid for before it expires. This value always returns `120`.",
				),
		),
		token: z.optional(z.string().describe("The join token.")),
	})
	.describe("Information about the meeting's join token.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `3000` <br>\n Cannot access webinar information. <br>\n**Error Code:** `124` <br>\n This API only supports OAuth2 authorization. <br>\n**Error Code:** `3000` <br>\n Not allowed to start live streaming. To use this feature, enable the \"Allow livestreaming of meetings\" setting in the \"Settings\" page of the Zoom web portal. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingLiveStreamingJoinToken400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `300` <br>\n Meeting ID does not exist. <br>\n**Error Code:** `3001` <br>\n Meeting does not exist: {meetingId} <br>\n
 */
export const meetingLiveStreamingJoinToken404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingLiveStreamingJoinToken429Schema = z.unknown();

export const meetingLiveStreamingJoinTokenQueryResponseSchema = z.lazy(
	() => meetingLiveStreamingJoinToken200Schema,
);

export const getMeetingLiveStreamDetailsPathParamsSchema = z.object({
	meetingId: z.string().describe("Unique identifier of the meeting."),
});

/**
 * @description **HTTP Status Code:** `200` **OK**  \n \nLive Stream details returned.\n\n
 */
export const getMeetingLiveStreamDetails200Schema = z.object({
	page_url: z.optional(
		z
			.string()
			.describe(
				"Live streaming page URL. This is the URL using which anyone can view the livestream of the meeting.",
			),
	),
	stream_key: z.optional(z.string().describe("Stream Key.")),
	stream_url: z.optional(z.string().describe("Stream URL.")),
	resolution: z.optional(
		z
			.string()
			.describe("The number of pixels in each dimension that the video camera can display."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid meeting id. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const getMeetingLiveStreamDetails400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const getMeetingLiveStreamDetails404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const getMeetingLiveStreamDetails429Schema = z.unknown();

export const getMeetingLiveStreamDetailsQueryResponseSchema = z.lazy(
	() => getMeetingLiveStreamDetails200Schema,
);

export const meetingLiveStreamUpdatePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `204`  \n \nMeeting livestream updated.
 */
export const meetingLiveStreamUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3000` <br>\n Cannot access webinar info. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingLiveStreamUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingLiveStreamUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const meetingLiveStreamUpdate429Schema = z.unknown();

/**
 * @description Meeting
 */
export const meetingLiveStreamUpdateMutationRequestSchema = z
	.object({
		page_url: z.url().max(1024).describe("The live stream page URL."),
		stream_key: z.string().max(512).describe("Stream name and key."),
		stream_url: z.string().max(1024).describe("Streaming URL."),
		resolution: z.optional(
			z
				.string()
				.describe(
					"The number of pixels in each dimension that the video camera can display, required when a user enables 1080p. Use a value of `720p` or `1080p`",
				),
		),
	})
	.describe("Meeting live stream.");

export const meetingLiveStreamUpdateMutationResponseSchema = z.lazy(
	() => meetingLiveStreamUpdate204Schema,
);

export const meetingLiveStreamStatusUpdatePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `204` <br> Meeting livestream updated.
 */
export const meetingLiveStreamStatusUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3000` <br>\n Cannot access webinar info. <br>\n**Error Code:** `3161` <br>\n Your user account is not allowed meeting hosting and scheduling capabilities. <br>\n**Error Code:** `4400` <br>\n End-to-end encrypted meetings currently do not support the livestreaming feature. <br>\n**Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `4927` <br>\n Meeting {meetingId} has not started. <br>\n
 */
export const meetingLiveStreamStatusUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingLiveStreamStatusUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingLiveStreamStatusUpdate429Schema = z.unknown();

/**
 * @description Meeting
 */
export const meetingLiveStreamStatusUpdateMutationRequestSchema = z
	.object({
		action: z.optional(
			z
				.enum(["start", "stop", "mode"])
				.describe(
					"The meeting's livestream status.\n* `start` - Start a livestream.\n* `stop` - Stop an ongoing livestream.\n* `mode` - Control a livestream view at runtime.",
				),
		),
		settings: z.optional(
			z
				.object({
					active_speaker_name: z.optional(
						z
							.boolean()
							.describe(
								"Whether to display the name of the active speaker during a meeting's livestream. Use this field if you pass the `start` value for the `action` field.",
							),
					),
					display_name: z.optional(
						z
							.string()
							.min(1)
							.max(50)
							.describe(
								"The display name of the meeting's livestream. Use this field if you pass the `start` value for the `action` field.",
							),
					),
					layout: z.optional(
						z
							.enum(["follow_host", "gallery_view", "speaker_view"])
							.default("follow_host")
							.describe(
								"The layout of the meeting's livestream. Use this field if you pass the `start` or `mode` value for the `action` field.\r\n* `follow_host` - Follow host view.\r\n* `gallery_view` - Gallery view.\r\n* `speaker_view` - Speaker view.",
							),
					),
					close_caption: z.optional(
						z
							.enum(["burnt-in", "embedded", "off"])
							.default("burnt-in")
							.describe(
								"The livestream's closed caption type for this session. Use this field if you pass the `start` or `mode` value for the `action` field.\r\n* `burnt-in` - Burnt in captions.\r\n* `embedded` - Embedded captions.\r\n* `off` - Turn off captions.",
							),
					),
				})
				.describe("The meeting's livestreaming settings."),
		),
	})
	.describe("The meeting's livestream status.");

export const meetingLiveStreamStatusUpdateMutationResponseSchema = z.lazy(
	() => meetingLiveStreamStatusUpdate204Schema,
);

export const meetingRTMSStatusUpdatePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID.\n\nWhen storing this value in your database, store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `204` Participant\'s RTMS app status updated.
 */
export const meetingRTMSStatusUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `3000` <br>\n Meeting {meetingId} has not started. <br>\n**Error Code:** `2310` <br>\n Failed to perform RTMS app operation. <br>\n**Error Code:** `13277` <br>\n Unable to \'{action}\' the RTMS app for user \'{participant_user_id}\' because it has not been started. <br>\n**Error Code:** `2312` <br>\n User does not exist: {participant_user_id}. <br>\n
 */
export const meetingRTMSStatusUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n **Error Code:** `2308` <br>\n User \'{participant_user_id}\' is not allowed to start the RTMS app. Only the meeting host or an alternative host can perform this action. <br>\n**Error Code:** `2309` <br>\n User \'{participant_user_id}\' is not allowed to start the RTMS app. Only the webinar host, alternative host, or panelist can perform this action. <br>\n**Error Code:** `13273` <br>\n The current meeting does not support the RTMS app feature. <br>\n**Error Code:** `13267` <br>\n RTMS app disabled. To use this feature, enable the **Share realtime meeting content with apps** setting in the **Settings** page of the Zoom web portal. <br>\n**Error Code:** `13262` <br>\n The app \'{client_id}\' is not authorized to access meeting content. Please add it in the **Allow apps to access meeting content** setting in the **Settings** page of the Zoom web portal. <br>\n
 */
export const meetingRTMSStatusUpdate403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingRTMSStatusUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const meetingRTMSStatusUpdate429Schema = z.unknown();

/**
 * @description Meeting
 */
export const meetingRTMSStatusUpdateMutationRequestSchema = z
	.object({
		action: z.optional(
			z
				.enum(["start", "stop", "pause", "resume"])
				.describe(
					"The participant's RTMS app status.\n* `start` - Start an RTMS app.\n* `stop` - Stop an ongoing RTMS app.\n* `pause` - Pause an ongoing RTMS app.\n* `resume` - Resume a paused RTMS app.",
				),
		),
		settings: z.optional(
			z
				.object({
					participant_user_id: z.optional(
						z
							.string()
							.describe(
								"The participant's user ID. This field is optional. If not provided, the user ID will be automatically obtained from the authentication token. This value matches the `id` field in the [**Get a user**](/docs/api/users/#tag/users/GET/users/{userId}) API response. Use this field if you pass the `start`, `stop`, `pause` or `resume` value for the `action` field.",
							),
					),
					client_id: z
						.string()
						.describe(
							"The unique identifier of the authorized app, configured in the Account Settings under **Allow apps to access meeting content**. This app must have host approval to access in-meeting content. Use this field if you pass the `start`, `stop`, `pause` or `resume` value for the `action` field.",
						),
				})
				.describe("The participant's RTMS app settings."),
		),
	})
	.describe("The participant's RTMS app status.");

export const meetingRTMSStatusUpdateMutationResponseSchema = z.lazy(
	() => meetingRTMSStatusUpdate204Schema,
);

export const meetingPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, store it as a long format integer and **not** an integer. Meeting IDs can be more than 10 digits.",
		),
});

export const meetingQueryParamsSchema = z
	.object({
		occurrence_id: z.optional(
			z
				.string()
				.describe(
					"Meeting occurrence ID. Provide this field to view meeting details of a particular occurrence of the [recurring meeting](https://support.zoom.us/hc/en-us/articles/214973206-Scheduling-Recurring-Meetings).",
				),
		),
		show_previous_occurrences: z.optional(
			z
				.boolean()
				.describe(
					"Set this field's value to `true` to view meeting details of all previous occurrences of a [recurring meeting](https://support.zoom.us/hc/en-us/articles/214973206-Scheduling-Recurring-Meetings). ",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `200`  \n \nMeeting object returned.
 */
export const meeting200Schema = z
	.object({
		assistant_id: z.optional(
			z.string().describe("The ID of the user who scheduled this meeting on behalf of the host."),
		),
		host_email: z.optional(z.email().describe("The meeting host's email address.")),
		host_id: z.optional(z.string().describe("The ID of the user who is set as the meeting host.")),
		id: z.optional(
			z
				.int()
				.describe(
					"[Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in **long** format, represented as int64 data type in JSON, also known as the meeting number.",
				),
		),
		uuid: z.optional(
			z
				.string()
				.describe(
					"Unique meeting ID. Each meeting instance generates its own meeting UUID - after a meeting ends, a new UUID is generated for the next instance of the meeting. Retrieve a list of UUIDs from past meeting instances using the [**List past meeting instances**](/docs/api/rest/reference/zoom-api/methods#operation/pastMeetings) API. [Double encode](/docs/api/rest/using-zoom-apis/#meeting-id-and-uuid) your UUID when using it for API calls if the UUID begins with a `/` or contains `//` in it.\n",
				),
		),
		agenda: z.optional(z.string().max(2000).describe("The meeting description.")),
		created_at: z.optional(z.string().datetime().describe("The creation time. ")),
		duration: z.optional(z.int().describe("The meeting duration.")),
		encrypted_password: z.optional(
			z.string().describe("Encrypted passcode for third party endpoints (H323/SIP)."),
		),
		pstn_password: z.optional(
			z
				.string()
				.describe(
					"Password for participants to join the meeting via [PSTN](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference).",
				),
		),
		h323_password: z.optional(z.string().describe("H.323/SIP room system passcode.")),
		join_url: z.optional(
			z
				.string()
				.describe(
					"The URL for participants to join the meeting. This URL should only be shared with users invited to the meeting.",
				),
		),
		chat_join_url: z.optional(z.string().describe("The URL to join the chat.")),
		occurrences: z.optional(
			z
				.array(
					z
						.object({
							duration: z.optional(z.int().describe("Duration.")),
							occurrence_id: z.optional(
								z
									.string()
									.describe(
										"Occurrence ID. The unique identifier for an occurrence of a recurring meeting. [Recurring meetings](https://support.zoom.us/hc/en-us/articles/214973206-Scheduling-Recurring-Meetings) can have a maximum of 50 occurrences.",
									),
							),
							start_time: z.optional(z.string().datetime().describe("Start time.")),
							status: z.optional(
								z
									.enum(["available", "deleted"])
									.describe(
										"Occurrence status. \n `available` - Available occurrence.  \n `deleted` -  Deleted occurrence.",
									),
							),
						})
						.describe("Occurrence object. This object is only returned for recurring meetings."),
				)
				.describe("Array of occurrence objects."),
		),
		password: z.optional(z.string().min(8).describe("Meeting passcode.")),
		pmi: z.optional(
			z
				.string()
				.describe(
					"[Personal meeting ID (PMI)](/docs/api/rest/using-zoom-apis/#understanding-personal-meeting-id-pmi). Only used for scheduled meetings and recurring meetings with no fixed time.",
				),
		),
		pre_schedule: z.optional(
			z
				.boolean()
				.default(false)
				.describe(
					"Whether the prescheduled meeting was created via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time). \n* `true` - A GSuite prescheduled meeting. \n* `false` - A regular meeting.",
				),
		),
		recurrence: z.optional(
			z
				.object({
					end_date_time: z.optional(
						z
							.string()
							.datetime()
							.describe(
								"Select the final date when the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with `end_times`.)",
							),
					),
					end_times: z.optional(
						z
							.int()
							.max(60)
							.default(1)
							.describe(
								"Select how many times the meeting should recur before it is canceled. If `end_times` is set to 0, it means there is no end time. The maximum number of recurrences is 60. Cannot be used with `end_date_time`.",
							),
					),
					monthly_day: z.optional(
						z
							.int()
							.default(1)
							.describe(
								"Use this field only if you're scheduling a recurring meeting of type `3` to state the day in a month when the meeting should recur. The value range is from 1 to 31.\n\nFor example, for a meeting to recur on 23rd of each month, provide `23` as this field's value and `1` as the `repeat_interval` field's value. Instead, to have the meeting to recur every three months on 23rd of the month, change the `repeat_interval` field's value to `3`.",
							),
					),
					monthly_week: z.optional(
						z
							.union([z.literal(-1), z.literal(1), z.literal(2), z.literal(3), z.literal(4)])
							.describe(
								"Use this field only if you're scheduling a recurring meeting of type `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.**   \n `-1` - Last week of the month.  \n `1` - First week of the month.  \n `2` - Second week of the month.  \n `3` - Third week of the month.  \n `4` - Fourth week of the month.",
							),
					),
					monthly_week_day: z.optional(
						z
							.union([
								z.literal(1),
								z.literal(2),
								z.literal(3),
								z.literal(4),
								z.literal(5),
								z.literal(6),
								z.literal(7),
							])
							.describe(
								"Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. \n\n  \n `1` - Sunday.  \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` - Thursday.  \n `6` - Friday.  \n `7` - Saturday.",
							),
					),
					repeat_interval: z.optional(
						z
							.int()
							.describe(
								"Define the interval when the meeting should recur. For instance, to schedule a meeting that recurs every two months, you must set this field's value as `2` and the `type` parameter's value as `3`. \n\nFor a daily meeting, the maximum interval you can set is `99` days. For a weekly meeting the maximum interval that you can set is  of `50` weeks. For a monthly meeting, there is a maximum of `10` months.\n\n",
							),
					),
					type: z
						.union([z.literal(1), z.literal(2), z.literal(3)])
						.describe(
							"Recurring meeting types. \n `1` - Daily.  \n `2` - Weekly.  \n `3` - Monthly.",
						),
					weekly_days: z.optional(
						z
							.enum(["1", "2", "3", "4", "5", "6", "7"])
							.default("1")
							.describe(
								"This field is required if you're scheduling a recurring meeting of type `2` to state which days of the week the meeting should repeat.   \n    \n  The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `1` as this field's value.  \n   \n  **Note** To have the meeting occur on multiple days of a week, provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `1,3` as this field's value.\n\n\n `1`  - Sunday.   \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` -  Thursday.  \n `6` - Friday.  \n `7` - Saturday.",
							),
					),
				})
				.describe(
					"Recurrence object. Use this object only for a meeting with type `8`, a recurring meeting with a fixed time. ",
				),
		),
		settings: z.optional(
			z
				.object({
					allow_multiple_devices: z.optional(
						z
							.boolean()
							.describe(
								"Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).",
							),
					),
					alternative_hosts: z.optional(
						z
							.string()
							.describe(
								"A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.",
							),
					),
					alternative_hosts_email_notification: z.optional(
						z
							.boolean()
							.default(true)
							.describe(
								"Flag to determine whether to send email notifications to alternative hosts, default value is true.",
							),
					),
					alternative_host_update_polls: z.optional(
						z
							.boolean()
							.describe(
								"Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.",
							),
					),
					alternative_host_manage_meeting_summary: z.optional(
						z
							.boolean()
							.describe("Whether to allow an alternative host to manage meeting summaries."),
					),
					alternative_host_manage_cloud_recording: z.optional(
						z
							.boolean()
							.describe("Whether to allow an alternative host to manage meeting cloud recordings."),
					),
					approval_type: z.optional(
						z
							.union([z.literal(0), z.literal(1), z.literal(2)])
							.default(2)
							.describe(
								"Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.**   \n   \n \n\n`0` - Automatically approve.  \n `1` - Manually approve.  \n `2` - No registration required.",
							),
					),
					approved_or_denied_countries_or_regions: z.optional(
						z
							.object({
								approved_list: z.optional(
									z
										.array(z.string())
										.describe(
											"List of countries/regions from where participants can join this meeting. ",
										),
								),
								denied_list: z.optional(
									z
										.array(z.string())
										.describe(
											"List of countries or regions from where participants can not join this meeting. ",
										),
								),
								enable: z.optional(
									z
										.boolean()
										.describe(
											"`true` - Setting enabled to either allow users or block users from specific regions to join your meetings.   \n \n\n`false` - Setting disabled.",
										),
								),
								method: z.optional(
									z
										.enum(["approve", "deny"])
										.describe(
											"Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting.   \n   \n \n`approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.  \n   \n \n`deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`",
										),
								),
							})
							.describe(
								"Approve or block users from specific regions/countries from joining this meeting. \n",
							),
					),
					audio: z.optional(
						z
							.enum(["both", "telephony", "voip", "thirdParty"])
							.default("both")
							.describe(
								"Determine how participants can join the audio portion of the meeting.  \n `both` - Both Telephony and VoIP.  \n `telephony` - Telephony only.  \n `voip` - VoIP only.  \n `thirdParty` - Third party audio conference.",
							),
					),
					audio_conference_info: z.optional(
						z.string().max(2048).describe("Third party audio conference information."),
					),
					authentication_domains: z.optional(
						z
							.string()
							.describe(
								"If user has configured [Sign Into Zoom with Specified Domains](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.",
							),
					),
					authentication_exception: z.optional(
						z
							.array(
								z.object({
									email: z.optional(z.email().describe("The participant's email address.")),
									name: z.optional(z.string().describe("The participant's name.")),
									join_url: z.optional(
										z.string().describe("URL for participants to join the meeting"),
									),
								}),
							)
							.describe(
								"The participants added here will receive unique meeting invite links and bypass authentication.",
							),
					),
					authentication_name: z.optional(
						z
							.string()
							.describe(
								"Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).",
							),
					),
					authentication_option: z.optional(
						z.string().describe("Meeting authentication option ID."),
					),
					auto_recording: z.optional(
						z
							.enum(["local", "cloud", "none"])
							.default("none")
							.describe(
								"Automatic recording.  \n `local` - Record on local.  \n `cloud` -  Record on cloud.  \n `none` - Disabled.",
							),
					),
					auto_add_recording_to_video_management: z.optional(
						z
							.object({
								enable: z
									.boolean()
									.default(false)
									.describe(
										"Whether to automatically add the meeting recording to video management.",
									),
								channels: z.optional(
									z
										.array(
											z.object({
												channel_id: z
													.string()
													.describe("The unique ID of a video management channel."),
												name: z.optional(
													z.string().describe("The name of the video management channel."),
												),
											}),
										)
										.min(1)
										.max(5)
										.describe(
											"List of video management channels where the meeting recording will be added.",
										),
								),
							})
							.describe(
								"Automatically add meeting recordings to a video channel in video management. To enable this feature for your account, please [contact Zoom Support](https://support.zoom.us/hc/en-us).",
							),
					),
					breakout_room: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Set this field's value to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.",
										),
								),
								rooms: z.optional(
									z
										.array(
											z.object({
												name: z.optional(z.string().describe("The breakout room's name.")),
												participants: z.optional(
													z
														.array(z.string())
														.describe(
															"Email addresses of the participants who are to be assigned to the breakout room.",
														),
												),
											}),
										)
										.describe("Create room or rooms."),
								),
							})
							.describe(
								"Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).",
							),
					),
					calendar_type: z.optional(
						z
							.union([z.literal(1), z.literal(2)])
							.describe(
								"Indicates the type of calendar integration used to schedule the meeting. \n* `1` - [Zoom Outlook add-in](https://support.zoom.us/hc/en-us/articles/360031592971-Getting-started-with-Outlook-plugin-and-add-in) \n* `2` - [Zoom for Google Workspace add-on](https://support.zoom.us/hc/en-us/articles/360020187492-Using-the-Zoom-for-Google-Workspace-add-on)\n\nWorks with the `private_meeting` field to determine whether to share details of meetings or not.",
							),
					),
					close_registration: z.optional(
						z.boolean().default(false).describe("Close registration after event date."),
					),
					cn_meeting: z.optional(z.boolean().default(false).describe("Host meeting in China.")),
					contact_email: z.optional(z.string().describe("Contact email for registration.")),
					contact_name: z.optional(z.string().describe("Contact name for registration.")),
					custom_keys: z.optional(
						z
							.array(
								z.object({
									key: z.optional(
										z.string().max(64).describe("Custom key associated with the user."),
									),
									value: z.optional(
										z
											.string()
											.max(256)
											.describe("Value of the custom key associated with the user."),
									),
								}),
							)
							.max(10)
							.describe("Custom keys and values assigned to the meeting."),
					),
					email_notification: z.optional(
						z
							.boolean()
							.default(true)
							.describe(
								"Whether to send email notifications to [alternative hosts](https://support.zoom.us/hc/en-us/articles/208220166) and [users with scheduling privileges](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-privilege). This value defaults to `true`.",
							),
					),
					encryption_type: z.optional(
						z
							.enum(["enhanced_encryption", "e2ee"])
							.describe(
								"Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. \n \n`enhanced_encryption` - Enhanced encryption. Encryption is stored in the cloud if you enable this option.   \n \n\n`e2ee` - [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions features.",
							),
					),
					enforce_login: z.optional(
						z
							.boolean()
							.describe(
								"Only signed in users can join this meeting.\n\n**This field is deprecated and will not be supported in the future.**    \n   \n As an alternative, use the `meeting_authentication`, `authentication_option`, and `authentication_domains` fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.",
							),
					),
					enforce_login_domains: z.optional(
						z
							.string()
							.describe(
								"Only signed in users with specified domains can join meetings.\n\n**This field is deprecated and will not be supported in the future.**    \n   \n As an alternative, use the `meeting_authentication`, `authentication_option`, and `authentication_domains` fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.",
							),
					),
					focus_mode: z.optional(
						z
							.boolean()
							.describe(
								"Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.",
							),
					),
					global_dial_in_countries: z.optional(
						z.array(z.string()).describe("List of global dial-in countries."),
					),
					global_dial_in_numbers: z.optional(
						z
							.array(
								z.object({
									city: z.optional(
										z.string().describe("City of the number, if any. For example, Chicago."),
									),
									country: z.optional(z.string().describe("Country code, such as BR.")),
									country_name: z.optional(
										z.string().describe("Full name of country, such as Brazil."),
									),
									number: z.optional(z.string().describe("Phone number, such as +1 2332357613.")),
									type: z.optional(z.enum(["toll", "tollfree"]).describe("Type of number. ")),
								}),
							)
							.describe("Global Dial-in Countries and Regions"),
					),
					host_video: z.optional(
						z.boolean().describe("Start video when the host joins the meeting."),
					),
					in_meeting: z.optional(z.boolean().default(false).describe("Host meeting in India.")),
					jbh_time: z.optional(
						z
							.union([z.literal(0), z.literal(5), z.literal(10), z.literal(15)])
							.describe(
								"If the value of `join_before_host` field is set to true, this field can be used to indicate time limits when a participant may join a meeting before a host.\n\n*  `0` - Allow participant to join anytime.\n*  `5` - Allow participant to join 5 minutes before meeting start time.\n * `10` - Allow participant to join 10 minutes before meeting start time.\n * `15` - Allow participant to join 15 minutes before meeting start time.",
							),
					),
					join_before_host: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.",
							),
					),
					question_and_answer: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Enable [Q&amp;A](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0065237) for the meeting.\n\n* `false` - Disable Q&amp;A for the meeting.",
										),
								),
								allow_submit_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to submit questions.\n\n* `false` - Don't allow participants to submit questions.",
										),
								),
								allow_anonymous_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to send questions without providing their name to the host, co-host, and panelists.\n\n* `false` - Don't allow anonymous questions. Not supported for simulive meetings.",
										),
								),
								question_visibility: z.optional(
									z
										.enum(["answered", "all"])
										.describe(
											"Indicate whether you want attendees to be able to view only answered questions, or view all questions.\n\n* `answered` - Attendees can only view answered questions.\n\n* `all` - Attendees can view all questions submitted in the Q&amp;A.",
										),
								),
								attendees_can_comment: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can answer questions or leave a comment in the question thread.\n\n* `false` - Attendees can't answer questions or leave a comment in the question thread.",
										),
								),
								attendees_can_upvote: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can select the thumbs up button to bring popular questions to the top of the Q&amp;A window.\n\n* `false` - Attendees can't select the thumbs up button on questions.",
										),
								),
							})
							.describe(
								"[Q&amp;A](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0065237) for meeting.",
							),
					),
					language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [language interpretation](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768) for the meeting.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two country IDs.\n\nOnly system-supported languages are allowed: `US` (English), `CN` (Chinese), `JP` (Japanese), `DE` (German), `FR` (French), `RU` (Russian), `PT` (Portuguese), `ES` (Spanish), and `KR` (Korean).\n\nFor example, to set an interpreter translating from English to Chinese, use `US,CN`.",
														),
												),
												interpreter_languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two languages.\n\nTo get this value, use the `language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/docs/api/users/#tag/users/GET/users/{userId}/settings) API response.\n\n**languages**: System-supported languages include `English`, `Chinese`, `Japanese`, `German`, `French`, `Russian`, `Portuguese`, `Spanish`, and `Korean`.\n\n**custom_languages**: User-defined languages added by the user.\n\nFor example, an interpreter translating between English and French should use `English,French`.",
														),
												),
											}),
										)
										.describe("Information about the meeting's language interpreters."),
								),
							})
							.describe(
								"The meeting's [language interpretation settings](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768). Make sure to add the language in the web portal in order to use it in the API. See link for details.\n\n**Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.",
							),
					),
					sign_language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the meeting.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												sign_language: z.optional(
													z
														.string()
														.describe(
															"The interpreter's sign language. \n\n To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/docs/api/rest/reference/zoom-api/methods#operation/userSettings) API response.",
														),
												),
											}),
										)
										.max(20)
										.describe("Information about the meeting's sign language interpreters."),
								),
							})
							.describe(
								"The meeting's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details. \n\n**Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.",
							),
					),
					meeting_authentication: z.optional(
						z.boolean().describe("`true` - Only authenticated users can join meetings."),
					),
					mute_upon_entry: z.optional(
						z.boolean().default(false).describe("Mute participants upon entry."),
					),
					participant_video: z.optional(
						z.boolean().describe("Start video when participants join the meeting."),
					),
					private_meeting: z.optional(
						z.boolean().describe("Whether the meeting is set as private."),
					),
					registrants_confirmation_email: z.optional(
						z
							.boolean()
							.describe(
								"Whether to send registrants an email confirmation.\n* `true` - Send a confirmation email.\n* `false` - Do not send a confirmation email.",
							),
					),
					registrants_email_notification: z.optional(
						z
							.boolean()
							.describe(
								"Whether to send registrants email notifications about their registration approval, cancellation, or rejection.\n\n* `true` - Send an email notification.\n* `false` - Do not send an email notification.\n\n Set this value to `true` to also use the `registrants_confirmation_email` parameter.",
							),
					),
					registration_type: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3)])
							.default(1)
							.describe(
								"Registration type. Used for recurring meeting with fixed time only. \n `1` Attendees register once and can attend any of the occurrences.  \n `2` Attendees need to register for each occurrence to attend.  \n `3` Attendees register once and can choose one or more occurrences to attend.",
							),
					),
					show_share_button: z.optional(
						z
							.boolean()
							.describe(
								"Show social share buttons on the meeting registration page.\nThis setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).",
							),
					),
					show_join_info: z.optional(
						z
							.boolean()
							.describe(
								"Whether to show the meeting's join information on the registration confirmation page. This setting is only applied to meetings with registration enabled.",
							),
					),
					use_pmi: z.optional(
						z
							.boolean()
							.describe(
								"Whether to use a [Personal Meeting ID (PMI)](/docs/api/using-zoom-apis/#understanding-personal-meeting-id-pmi) for the meeting. This field is only used for scheduled meetings(`2`) and recurring meetings with no fixed time(`3`).",
							),
					),
					waiting_room: z.optional(z.boolean().default(false).describe("Enable waiting room")),
					waiting_room_options: z.optional(
						z
							.object({
								mode: z
									.enum(["follow_setting", "custom"])
									.describe(
										"This field specifies the waiting room behavior for this meeting.\r\n* `follow_setting` - Use the Zoom web portal setting.\r\n* `custom` - Specify which participants should go into the waiting room.",
									),
								who_goes_to_waiting_room: z.optional(
									z
										.enum([
											"everyone",
											"users_not_in_account",
											"users_not_in_account_or_whitelisted_domains",
											"users_not_on_invite",
										])
										.describe(
											"This field specifies which participants should be placed into the waiting room. Required if `mode` is set to `custom`.\r\n* `everyone` - Everyone.\r\n* `users_not_in_account` - Users not in your account.\r\n* `users_not_in_account_or_whitelisted_domains` - Users who are not in your account and not part of your whitelisted domains.\r\n* `users_not_on_invite` - Users not on the meeting invite.",
										),
								),
							})
							.describe("Configuration settings for the meeting's waiting room."),
					),
					watermark: z.optional(
						z
							.boolean()
							.default(false)
							.describe("This field adds a watermark when viewing a shared screen."),
					),
					host_save_video_order: z.optional(
						z
							.boolean()
							.describe("Whether the **Allow host to save video order** feature is enabled."),
					),
					internal_meeting: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Whether to set the meeting as an internal meeting."),
					),
					meeting_invitees: z.optional(
						z
							.array(
								z.object({
									email: z.optional(z.email().describe("The invitee's email address.")),
									internal_user: z.optional(
										z
											.boolean()
											.default(false)
											.describe("Whether the meeting invitee is an internal user."),
									),
								}),
							)
							.describe("A list of the meeting's invitees."),
					),
					continuous_meeting_chat: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe("Whether to enable the **Enable continuous meeting chat** setting."),
								),
								auto_add_invited_external_users: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable the **Automatically add invited external users** setting.",
										),
								),
								auto_add_meeting_participants: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable the **Automatically add meeting participants** setting.",
										),
								),
								channel_id: z.optional(z.string().describe("The channel's ID.")),
							})
							.describe(
								"Information about the **Enable continuous meeting chat** feature. This setting only applies to scheduled and recurring meetings, types `2`, `3`, or `8`. It is **not supported** for type `1` instant meetings or type `10` screen share only meetings.",
							),
					),
					participant_focused_meeting: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Whether to set the meeting as a participant focused meeting."),
					),
					push_change_to_calendar: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to push meeting changes to the calendar. \n\n To enable this feature, configure the **Configure Calendar and Contacts Service** in the user's profile page of the Zoom web portal and enable the **Automatically sync Zoom calendar events information bi-directionally between Zoom and integrated calendars.** setting in the **Settings** page of the Zoom web portal.\n* `true` - Push meeting changes to the calendar.\n* `false` - Do not push meeting changes to the calendar.",
							),
					),
					resources: z.optional(
						z
							.array(
								z.object({
									resource_type: z.optional(z.enum(["whiteboard"]).describe("The resource type.")),
									resource_id: z.optional(z.string().describe("The resource ID.")),
									permission_level: z.optional(
										z
											.enum(["editor", "commenter", "viewer"])
											.default("editor")
											.describe(
												"The permission levels for users to access the whiteboard. \n* `editor` - Users with link access can edit the board. \n* `commenter` - Users with link access can comment on the board. \n* `viewer` - Users with link access can view the board.",
											),
									),
								}),
							)
							.describe("The meeting's resources."),
					),
					auto_start_meeting_summary: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Whether to automatically start a meeting summary."),
					),
					who_will_receive_summary: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4)])
							.describe(
								"Defines who will receive a summary after this meeting. This field is applicable only when `auto_start_meeting_summary` is set to `true`.\r\n* `1` - Only meeting host.\r\n* `2` - Only meeting host, co-hosts, and alternative hosts.\r\n* `3` - Only meeting host and meeting invitees in our organization.\r\n* `4` - All meeting invitees including those outside of our organization.",
							),
					),
					auto_start_ai_companion_questions: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Whether to automatically start AI Companion questions."),
					),
					who_can_ask_questions: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5)])
							.describe(
								"Defines who can ask questions about this meeting's transcript. This field is applicable only when `auto_start_ai_companion_questions` is set to `true`.\r\n* `1` - All participants and invitees.\r\n* `2` - All participants only from when they join.\r\n* `3` - Only meeting host.\r\n* `4` - Participants and invitees in our organization.\r\n* `5` - Participants in our organization only from when they join.",
							),
					),
					summary_template_id: z.optional(
						z
							.string()
							.describe(
								"The summary template ID used to generate a meeting summary based on a predefined template. To get available summary templates, use the **Get user summary templates** API. To enable this feature for your account, please [contact Zoom Support](https://support.zoom.com/hc/en).",
							),
					),
					device_testing: z.optional(
						z.boolean().default(false).describe("Enable the device testing."),
					),
					request_permission_to_unmute_participants: z.optional(
						z
							.boolean()
							.describe(
								"Whether to enable the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting) setting. This option cannot be used together with `allow_host_control_participant_mute_state`, only one of the two can be enabled at a time.",
							),
					),
					allow_host_control_participant_mute_state: z.optional(
						z
							.boolean()
							.describe(
								"Whether to allow the host and co-hosts to fully control the mute state of participants. This option cannot be used together with `request_permission_to_unmute_participants`, only one of the two can be enabled at a time.",
							),
					),
					disable_participant_video: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to disable the participant video during meeting. To enable this feature for your account, please [contact Zoom Support](https://support.zoom.us/hc/en-us).",
							),
					),
					email_in_attendee_report: z.optional(
						z
							.boolean()
							.describe(
								"Whether to include authenticated guest's email addresses in meetings' attendee reports.",
							),
					),
				})
				.describe("Meeting settings."),
		),
		start_time: z.optional(
			z
				.string()
				.datetime()
				.describe(
					"Meeting start time in GMT or UTC. Start time will not be returned if the meeting is an **instant** meeting. \n",
				),
		),
		start_url: z.optional(
			z
				.string()
				.describe(
					"The `start_url` of a meeting is a URL that a host or an alternative host can start the meeting. \n\nThe expiration time for the `start_url` field listed in the response of the [**Create a meeting**](/docs/api/rest/reference/zoom-api/methods#operation/meetingCreate) API is two hours for all regular users. \n\t\nFor users created using the `custCreate` option via the [**Create users**](/docs/api/rest/reference/zoom-api/methods#operation/userCreate) API, the expiration time of the `start_url` field is 90 days.\n\t\nFor security reasons, to retrieve the updated value for the `start_url` field programmatically after the expiry time, you must call the [**Get a meeting](/docs/api/rest/reference/zoom-api/methods#operation/meeting) API and refer to the value of the `start_url` field in the response.  \n This URL should only be used by the host of the meeting and **should not be shared with anyone other than the host** of the meeting as anyone with this URL will be able to login to the Zoom Client as the host of the meeting.",
				),
		),
		status: z.optional(
			z
				.enum(["waiting", "started"])
				.describe(
					"The meeting status.\n* `waiting` - The meeting has not started.\n* `started` - The meeting is currently in progress.",
				),
		),
		timezone: z.optional(z.string().describe("The timezone to format the meeting start time.")),
		topic: z.optional(z.string().describe("Meeting topic.")),
		tracking_fields: z.optional(
			z
				.array(
					z.object({
						field: z.optional(z.string().describe("The tracking field's label.")),
						value: z.optional(z.string().describe("The tracking field's value.")),
						visible: z.optional(
							z
								.boolean()
								.describe(
									"Indicates whether the [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields) is visible in the meeting scheduling options in the Zoom Web Portal or not.\n\n`true`: Tracking field is visible.   \n \n\n`false`: Tracking field is not visible to the users when they look at the meeting details in the Zoom Web Portal but the field was used while scheduling this meeting via API. An invisible tracking field can be used by users while scheduling meetings via API only. ",
								),
						),
					}),
				)
				.describe("Tracking fields."),
		),
		type: z.optional(
			z
				.union([
					z.literal(1),
					z.literal(2),
					z.literal(3),
					z.literal(4),
					z.literal(8),
					z.literal(10),
				])
				.default(2)
				.describe(
					"The type of meeting. \n* `1` - An instant meeting. \n* `2` - A scheduled meeting. \n* `3` - A recurring meeting with no fixed time. \n* `4` - A PMI Meeting. \n* `8` - A recurring meeting with fixed time. \n* `10` - A screen share only meeting.",
				),
		),
		dynamic_host_key: z.optional(z.string().describe("The meeting dynamic host key.")),
		creation_source: z.optional(
			z
				.enum(["other", "open_api", "web_portal"])
				.describe(
					"The platform used when creating the meeting.\n* `other` - Created through another platform.\n* `open_api` - Created through Open API.\n* `web_portal` - Created through the web portal.",
				),
		),
	})
	.describe("Meeting object.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3000` <br>\n Cannot access webinar info. <br>\n**Error Code:** `3161` <br>\n Your user account is not allowed meeting hosting and scheduling capabilities. <br>\n
 */
export const meeting400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meeting404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const meeting429Schema = z.unknown();

export const meetingQueryResponseSchema = z.lazy(() => meeting200Schema);

export const meetingDeletePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

export const meetingDeleteQueryParamsSchema = z
	.object({
		occurrence_id: z.optional(z.string().describe("The meeting or webinar occurrence ID.")),
		schedule_for_reminder: z.optional(
			z
				.boolean()
				.describe(
					"`true`: Notify host and alternative host about the meeting cancellation via email.\n`false`: Do not send any email notification.",
				),
		),
		cancel_meeting_reminder: z.optional(
			z
				.boolean()
				.describe(
					"`true`: Notify registrants about the meeting cancellation via email. \n\n`false`: Do not send any email notification to meeting registrants. \n\nThe default value of this field is `false`.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code**: `204`   \n \nMeeting deleted.
 */
export const meetingDelete204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid parameter: `occurrence_id`. <br>\n**Error Code:** `3000` <br>\n Cannot access webinar information. <br>\n**Error Code:** `3018` <br>\n Not allowed to delete PMI. <br>\n**Error Code:** `3037` <br>\n Not allowed to delete PAC. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingDelete400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingDelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingDelete429Schema = z.unknown();

export const meetingDeleteMutationResponseSchema = z.lazy(() => meetingDelete204Schema);

export const meetingUpdatePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, store it as a long format integer and **not** an integer. Meeting IDs can be greater than 10 digits.",
		),
});

export const meetingUpdateQueryParamsSchema = z
	.object({
		occurrence_id: z.optional(
			z
				.string()
				.describe(
					"Meeting occurrence ID. Support change of agenda, `start_time`, duration, or settings {`host_video`, `participant_video`, `join_before_host`, `mute_upon_entry`, `waiting_room`, `watermark`, `auto_recording`}.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `204`  \n \nMeeting updated.
 */
export const meetingUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3161` <br>\n Your user account is not allowed meeting hosting and scheduling capabilities. <br>\n**Error Code:** `300` <br>\n The value that you entered in the `schedule_for` field is invalid. Enter a valid value and try again. <br>\n**Error Code:** `300` <br>\n Invalid `enforce_login_domains`. Separate multiple domains with semicolons. <br>\n**Error Code:** `3000` <br>\n Cannot access webinar information. <br>\n**Error Code:** `3000` <br>\n Instant meetings do not support the `schedule_for` parameter, and you can\'t schedule an instant meeting for another user. <br>\n**Error Code:** `3000` <br>\n Users in \'{userId}\' have been blocked from joining meetings and webinars. To unblock them, go to the **Settings** page in the Zoom web portal and update **Block users in specific domains from joining meetings and webinars**. <br>\n**Error Code:** `3000` <br>\n You cannot schedule a meeting for {userId} <br>\n**Error Code:** `3000` <br>\n Prescheduling is only available for scheduled meetings (type 2) and recurring meetings with no fixed time (type 3). <br>\n**Error Code:** `3000` <br>\n Unable to schedule for a user outside of your account for a meeting with continuous chat. <br>\n
 */
export const meetingUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const meetingUpdate429Schema = z.unknown();

/**
 * @description Meeting
 */
export const meetingUpdateMutationRequestSchema = z
	.object({
		agenda: z.optional(z.string().max(2000).describe("Meeting description.")),
		duration: z.optional(
			z
				.int()
				.min(1)
				.max(1440)
				.describe(
					"The meeting's scheduled duration, in minutes. This field is used for type `2` scheduled meetings and type `8` recurring meetings with a fixed time. The value must be between 1 and 1440 minutes, which equates to 24 hours.",
				),
		),
		password: z.optional(
			z
				.string()
				.max(10)
				.describe(
					"The passcode required to join the meeting. By default, a passcode can **only** have a maximum length of 10 characters and only contain alphanumeric characters and the `@`, `-`, `_`, and `*` characters.\n\n**Note**\n* If the account owner or administrator has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode **must** meet those requirements. \n* If passcode requirements are enabled, use the [**Get user settings**](/docs/api/users/#tag/users/GET/users/{userId}/settings) API or the [**Get account settings**](/docs/api/accounts/#tag/accounts/GET/accounts/{accountId}/settings) API to get the requirements.\n* If the **Require a passcode when scheduling new meetings** account setting is enabled and locked, a passcode will be automatically generated if one is not provided.",
				),
		),
		pre_schedule: z.optional(
			z
				.boolean()
				.default(false)
				.describe(
					"Whether to create a prescheduled meeting through the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` - scheduled meetings- and `3` - recurring meetings with no fixed time. \n* `true` - Create a prescheduled meeting. \n* `false` - Create a regular meeting.",
				),
		),
		schedule_for: z.optional(
			z.string().describe("The email address or `userId` of the user to schedule a meeting for."),
		),
		recurrence: z.optional(
			z
				.object({
					end_date_time: z.optional(
						z
							.string()
							.datetime()
							.describe(
								"Select the final date when the meeting recurs before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. Cannot be used with `end_times`.",
							),
					),
					end_times: z.optional(
						z
							.int()
							.max(60)
							.default(1)
							.describe(
								"Select how many times the meeting should recur before it is canceled. If `end_times` is set to 0, it means there is no end time. The maximum number of recurrences is 60. Cannot be used with `end_date_time`.",
							),
					),
					monthly_day: z.optional(
						z
							.int()
							.default(1)
							.describe(
								"Use this field **only if you're scheduling a recurring meeting of type** `3` to state the day in a month when the meeting should recur. The value range is from 1 to 31.\n\nFor instance, if the meeting should recur on 23rd of each month, provide `23` as this field's value and `1` as the `repeat_interval` field's value. If the meeting should recur every three months on 23rd of the month, change the `repeat_interval` field's value to `3`.",
							),
					),
					monthly_week: z.optional(
						z
							.union([z.literal(-1), z.literal(1), z.literal(2), z.literal(3), z.literal(4)])
							.describe(
								"Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.   \n `-1` - Last week of the month.  \n `1` - First week of the month.  \n `2` - Second week of the month.  \n `3` - Third week of the month.  \n `4` - Fourth week of the month.",
							),
					),
					monthly_week_day: z.optional(
						z
							.union([
								z.literal(1),
								z.literal(2),
								z.literal(3),
								z.literal(4),
								z.literal(5),
								z.literal(6),
								z.literal(7),
							])
							.describe(
								"Use this field only if you're scheduling a recurring meeting of type `3` to state a specific day in a week when a monthly meeting should recur. To use this field, you must also use the `monthly_week` field. \n\n  \n `1` - Sunday.  \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` - Thursday.  \n `6` - Friday.  \n `7` - Saturday.",
							),
					),
					repeat_interval: z.optional(
						z
							.int()
							.describe(
								"Define the interval when the meeting should recur. For instance, to schedule a meeting that recurs every two months, set this field's value as `2` and the `type` parameter's value to `3`. \n\nFor a daily meeting, the maximum interval is `99` days. For a weekly meeting, the maximum interval is `50` weeks. For a monthly meeting, the maximum value is `10` months.\n\n",
							),
					),
					type: z
						.union([z.literal(1), z.literal(2), z.literal(3)])
						.describe(
							"Recurrence meeting types. \n `1` - Daily.  \n `2` - Weekly.  \n `3` - Monthly.",
						),
					weekly_days: z.optional(
						z
							.enum(["1", "2", "3", "4", "5", "6", "7"])
							.default("1")
							.describe(
								"This field is required if you're scheduling a recurring meeting of type `2`, to state which days of the week the meeting should repeat.   \n\nThiw field's value could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `1` as this field's value.  \n   \n  **Note** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `1,3` as this field's value.\n\n   \n `1`  - Sunday.   \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` -  Thursday.  \n `6` - Friday.  \n `7` - Saturday.",
							),
					),
				})
				.describe(
					"Recurrence object. Use this object only for a meeting with type `8`, a recurring meeting with fixed time. ",
				),
		),
		settings: z.optional(
			z
				.object({
					allow_multiple_devices: z.optional(
						z
							.boolean()
							.describe(
								"Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).",
							),
					),
					alternative_hosts: z.optional(
						z
							.string()
							.describe(
								"A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.",
							),
					),
					alternative_hosts_email_notification: z.optional(
						z
							.boolean()
							.default(true)
							.describe(
								"Flag to determine whether to send email notifications to alternative hosts, default value is true.",
							),
					),
					alternative_host_update_polls: z.optional(
						z
							.boolean()
							.describe(
								"Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.",
							),
					),
					alternative_host_manage_meeting_summary: z.optional(
						z
							.boolean()
							.describe("Whether to allow an alternative host to manage meeting summaries."),
					),
					alternative_host_manage_cloud_recording: z.optional(
						z
							.boolean()
							.describe("Whether to allow an alternative host to manage meeting cloud recordings."),
					),
					approval_type: z.optional(
						z
							.union([z.literal(0), z.literal(1), z.literal(2)])
							.default(2)
							.describe(
								"Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.**   \n   \n \n\n`0` - Automatically approve.  \n `1` - Manually approve.  \n `2` - No registration required.",
							),
					),
					approved_or_denied_countries_or_regions: z.optional(
						z
							.object({
								approved_list: z.optional(
									z
										.array(z.string())
										.describe(
											"List of countries or regions from where participants can join this meeting. ",
										),
								),
								denied_list: z.optional(
									z
										.array(z.string())
										.describe(
											"List of countries or regions from where participants can not join this meeting. ",
										),
								),
								enable: z.optional(
									z
										.boolean()
										.describe(
											"`true` - Setting enabled to either allow users or block users from specific regions to join your meetings.\n \n\n`false` - Setting disabled.",
										),
								),
								method: z.optional(
									z
										.enum(["approve", "deny"])
										.describe(
											"Specify whether to allow users from specific regions to join this meeting, or block users from specific regions from joining this meeting.\n\n \n`approve` - Allow users from specific regions or countries to join this meeting. If this setting is selected, include the approved regions or countries in the `approved_list`.  \n\n\n`deny` - Block users from specific regions or countries from joining this meeting. If this setting is selected, include the approved regions orcountries in the `denied_list`",
										),
								),
							})
							.describe(
								"Approve or block users from specific regions or countries from joining this meeting. \n",
							),
					),
					audio: z.optional(
						z
							.enum(["both", "telephony", "voip", "thirdParty"])
							.default("both")
							.describe(
								"Determine how participants can join the audio portion of the meeting.  \n `both` - Both Telephony and VoIP.  \n `telephony` - Telephony only.  \n `voip` - VoIP only.  \n `thirdParty` - Third party audio conference.",
							),
					),
					audio_conference_info: z.optional(
						z.string().max(2048).describe("Third party audio conference info."),
					),
					authentication_domains: z.optional(
						z
							.string()
							.describe(
								"If user has configured [Sign Into Zoom with Specified Domains](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.",
							),
					),
					authentication_exception: z.optional(
						z
							.array(
								z.object({
									email: z.optional(z.email().describe("The participant's email address.")),
									name: z.optional(z.string().describe("The participant's name.")),
									join_url: z.optional(
										z.string().describe("URL for participants to join the meeting"),
									),
								}),
							)
							.describe(
								"The participants added here will receive unique meeting invite links and bypass authentication.",
							),
					),
					authentication_name: z.optional(
						z
							.string()
							.describe(
								"Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).",
							),
					),
					authentication_option: z.optional(
						z.string().describe("Meeting authentication option ID."),
					),
					auto_recording: z.optional(
						z
							.enum(["local", "cloud", "none"])
							.default("none")
							.describe(
								"Automatic recording. \n `local` - Record on local.  \n `cloud` -  Record on cloud.  \n `none` - Disabled.",
							),
					),
					auto_add_recording_to_video_management: z.optional(
						z
							.object({
								enable: z
									.boolean()
									.default(false)
									.describe(
										"Whether to automatically add the meeting recording to video management.",
									),
								channels: z.optional(
									z
										.array(
											z.object({
												channel_id: z
													.string()
													.describe("The unique ID of a video management channel."),
												name: z.optional(
													z.string().describe("The video management channel's name."),
												),
											}),
										)
										.min(1)
										.max(5)
										.describe(
											"List of video management channels where the meeting recording will be added.",
										),
								),
							})
							.describe(
								"Automatically add meeting recordings to a video channel in video management. To enable this feature for your account, please [contact Zoom Support](https://support.zoom.us/hc/en-us).",
							),
					),
					breakout_room: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Set this field's value to `true` to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.",
										),
								),
								rooms: z.optional(
									z
										.array(
											z.object({
												name: z.optional(z.string().describe("The breakout room's name.")),
												participants: z.optional(
													z
														.array(z.string())
														.describe(
															"Email addresses of the participants who are to be assigned to the breakout room.",
														),
												),
											}),
										)
										.describe("Create room(s)."),
								),
							})
							.describe(
								"Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).",
							),
					),
					calendar_type: z.optional(
						z
							.union([z.literal(1), z.literal(2)])
							.describe(
								"The type of calendar integration used to schedule the meeting. \n* `1` - [Zoom Outlook add-in](https://support.zoom.us/hc/en-us/articles/360031592971-Getting-started-with-Outlook-plugin-and-add-in) \n* `2` - [Zoom for Google Workspace add-on](https://support.zoom.us/hc/en-us/articles/360020187492-Using-the-Zoom-for-Google-Workspace-add-on)\n\nWorks with the `private_meeting` field to determine whether to share details of meetings.",
							),
					),
					close_registration: z.optional(
						z.boolean().default(false).describe("Close registration after the event date."),
					),
					cn_meeting: z.optional(z.boolean().default(false).describe("Host the meeting in China.")),
					contact_email: z.optional(z.string().describe("Contact email for registration.")),
					contact_name: z.optional(z.string().describe("Contact name for registration.")),
					custom_keys: z.optional(
						z
							.array(
								z.object({
									key: z.optional(
										z.string().max(64).describe("Custom key associated with the user."),
									),
									value: z.optional(
										z
											.string()
											.max(256)
											.describe("Value of the custom key associated with the user."),
									),
								}),
							)
							.max(10)
							.describe("Custom keys and values assigned to the meeting."),
					),
					email_notification: z.optional(
						z
							.boolean()
							.default(true)
							.describe(
								"Whether to send email notifications to [alternative hosts](https://support.zoom.us/hc/en-us/articles/208220166) and [users with scheduling privileges](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-privilege). This value defaults to `true`.",
							),
					),
					encryption_type: z.optional(
						z
							.enum(["enhanced_encryption", "e2ee"])
							.describe(
								"Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features such cloud recording and phone/SIP/H.323 dial-in, will be **automatically disabled**.   \n\n`enhanced_encryption` - Enhanced encryption. Encryption is stored in the cloud if you enable this option.   \n \n\n`e2ee` - [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the features join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.",
							),
					),
					enforce_login: z.optional(
						z
							.boolean()
							.describe(
								"Only signed in users can join this meeting.\n\n**This field is deprecated and will not be supported in the future.**    \n   \n As an alternative, use the `meeting_authentication`, `authentication_option`, and `authentication_domains` fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.",
							),
					),
					enforce_login_domains: z.optional(
						z
							.string()
							.describe(
								"Only signed in users with specified domains can join meetings.\n\n**This field is deprecated and will not be supported in the future.**    \n   \n As an alternative, use the `meeting_authentication`, `authentication_option`. and `authentication_domains` fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.",
							),
					),
					focus_mode: z.optional(
						z
							.boolean()
							.describe(
								"Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.",
							),
					),
					global_dial_in_countries: z.optional(
						z.array(z.string()).describe("List of global dial-in countries"),
					),
					global_dial_in_numbers: z.optional(
						z
							.array(
								z.object({
									city: z.optional(
										z.string().describe("City of the number, if any, such as Chicago."),
									),
									country: z.optional(z.string().describe("Country code, such as BR.")),
									country_name: z.optional(
										z.string().describe("Full name of country, such as Brazil."),
									),
									number: z.optional(z.string().describe("Phone number, such as +1 2332357613.")),
									type: z.optional(z.enum(["toll", "tollfree"]).describe("Type of number. ")),
								}),
							)
							.describe("Global dial-in countries or regions"),
					),
					host_video: z.optional(
						z.boolean().describe("Start video when the host joins the meeting."),
					),
					in_meeting: z.optional(z.boolean().default(false).describe("Host meeting in India.")),
					jbh_time: z.optional(
						z
							.union([z.literal(0), z.literal(5), z.literal(10), z.literal(15)])
							.describe(
								"If the value of `join_before_host` field is set to true, use this field to indicate time limits for a participant to join a meeting before a host.\n\n*  `0` - Allow participant to join anytime.\n*  `5` - Allow participant to join 5 minutes before meeting start time.\n * `10` - Allow participant to join 10 minutes before meeting start time.\n * `15` - Allow participant to join 15 minutes before meeting start time.",
							),
					),
					join_before_host: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.",
							),
					),
					question_and_answer: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Enable [Q&amp;A](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0065237) for meeting.\n\n* `false` - Disable Q&amp;A for meeting.",
										),
								),
								allow_submit_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true`: Allow participants to submit questions.\n\n* `false`: Do not allow submit questions.",
										),
								),
								allow_anonymous_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to send questions without providing their name to the host, co-host, and panelists..\n\n* `false` - Do not allow anonymous questions.(Not supported for simulive meeting.)",
										),
								),
								question_visibility: z.optional(
									z
										.enum(["answered", "all"])
										.describe(
											"Indicate whether you want attendees to be able to view answered questions only or view all questions.\n\n* `answered` - Attendees are able to view answered questions only.\n\n*  `all` - Attendees are able to view all questions submitted in the Q&amp;A.",
										),
								),
								attendees_can_comment: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can answer questions or leave a comment in the question thread.\n\n* `false` - Attendees can not answer questions or leave a comment in the question thread",
										),
								),
								attendees_can_upvote: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can click the thumbs up button to bring popular questions to the top of the Q&amp;A window.\n\n* `false` - Attendees can not click the thumbs up button on questions.",
										),
								),
							})
							.describe(
								"[Q&amp;A](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0065237) for meeting.",
							),
					),
					language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [language interpretation](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768) for the meeting.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two country IDs.\n\nOnly system-supported languages are allowed: `US` (English), `CN` (Chinese), `JP` (Japanese), `DE` (German), `FR` (French), `RU` (Russian), `PT` (Portuguese), `ES` (Spanish), and `KR` (Korean).\n\nFor example, to set an interpreter translating from English to Chinese, use `US,CN`.",
														),
												),
												interpreter_languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two languages.\n\nTo get this value, use the `language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/docs/api/users/#tag/users/GET/users/{userId}/settings) API response.\n\n**languages**: System-supported languages include `English`, `Chinese`, `Japanese`, `German`, `French`, `Russian`, `Portuguese`, `Spanish`, and `Korean`.\n\n**custom_languages**: User-defined languages added by the user.\n\nFor example, an interpreter translating between English and French should use `English,French`.",
														),
												),
											}),
										)
										.describe("Information about the meeting's language interpreters."),
								),
							})
							.describe(
								"The meeting's [language interpretation settings](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768). Make sure to add the language in the web portal in order to use it in the API. See link for details.\n\n**Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.",
							),
					),
					sign_language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the meeting.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												sign_language: z.optional(
													z
														.string()
														.describe(
															"The interpreter's sign language. \n\n To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/api-reference/zoom-api/methods#operation/userSettings) API response.",
														),
												),
											}),
										)
										.max(20)
										.describe("Information about the meeting's sign language interpreters."),
								),
							})
							.describe(
								"The meeting's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details. \n\n**Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.",
							),
					),
					meeting_authentication: z.optional(
						z.boolean().describe("`true`- Only authenticated users can join meetings."),
					),
					meeting_invitees: z.optional(
						z
							.array(
								z.object({
									email: z.optional(z.email().describe("The invitee's email address.")),
								}),
							)
							.describe("A list of the meeting's invitees."),
					),
					mute_upon_entry: z.optional(
						z.boolean().default(false).describe("Mute participants upon entry."),
					),
					participant_video: z.optional(
						z.boolean().describe("Start video when participants join the meeting."),
					),
					private_meeting: z.optional(
						z.boolean().describe("Whether the meeting is set as private."),
					),
					registrants_confirmation_email: z.optional(
						z
							.boolean()
							.describe(
								"Whether to send registrants an email confirmation.\n* `true` - Send a confirmation email.\n* `false` - Do not send a confirmation email.",
							),
					),
					registrants_email_notification: z.optional(
						z
							.boolean()
							.describe(
								"Whether to send registrants email notifications about their registration approval, cancellation, or rejection.\n\n* `true` - Send an email notification.\n* `false` - Do not send an email notification.\n\n Set this value to `true` to also use the `registrants_confirmation_email` parameter.",
							),
					),
					registration_type: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3)])
							.default(1)
							.describe(
								"Registration type. Used for recurring meeting with fixed time only.\n `1` - Attendees register once and can attend any of the occurrences.  \n `2` - Attendees need to register for each occurrence to attend.  \n `3` - Attendees register once and can choose one or more occurrences to attend.",
							),
					),
					show_share_button: z.optional(
						z
							.boolean()
							.describe(
								"Show social share buttons on the meeting registration page.\nThis setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).",
							),
					),
					use_pmi: z.optional(
						z
							.boolean()
							.describe(
								"Whether to use a [Personal Meeting ID (PMI)](/docs/api/using-zoom-apis/#understanding-personal-meeting-id-pmi) for the meeting. This field is only used for scheduled meetings(`2`) and recurring meetings with no fixed time(`3`).",
							),
					),
					waiting_room: z.optional(z.boolean().default(false).describe("Enable waiting room.")),
					waiting_room_options: z.optional(
						z
							.object({
								mode: z
									.enum(["follow_setting", "custom"])
									.describe(
										"Specifies the waiting room behavior for this meeting.\r\n* `follow_setting` - Use the Zoom web portal setting.\r\n* `custom` - Specify which participants should go into the waiting room.",
									),
								who_goes_to_waiting_room: z.optional(
									z
										.enum([
											"everyone",
											"users_not_in_account",
											"users_not_in_account_or_whitelisted_domains",
											"users_not_on_invite",
										])
										.describe(
											"Specifies which participants should be placed into the waiting room. Required if `mode` is set to `custom`.\r\n* `everyone` - Everyone.\r\n* `users_not_in_account` - Users not in your account.\r\n* `users_not_in_account_or_whitelisted_domains` - Users who are not in your account and not part of your whitelisted domains.\r\n* `users_not_on_invite` - Users not on the meeting invite.",
										),
								),
							})
							.describe("Configuration settings for the meeting's waiting room."),
					),
					watermark: z.optional(
						z.boolean().default(false).describe("Add a watermark when viewing a shared screen."),
					),
					host_save_video_order: z.optional(
						z
							.boolean()
							.describe("Whether the **Allow host to save video order** feature is enabled."),
					),
					internal_meeting: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Whether to set the meeting as an internal meeting."),
					),
					continuous_meeting_chat: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe("Whether to enable the **Enable continuous meeting chat** setting."),
								),
								auto_add_invited_external_users: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable the **Automatically add invited external users** setting.",
										),
								),
								auto_add_meeting_participants: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable the **Automatically add meeting participants** setting.",
										),
								),
							})
							.describe(
								"Information about the **Enable continuous meeting chat** feature. This setting only applies to scheduled and recurring meetings, type `2`, `3`, and `8`. It is **not supported** for type `1` instant meetings or type `10` screen share only meetings.",
							),
					),
					participant_focused_meeting: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Whether to set the meeting as a participant focused meeting."),
					),
					push_change_to_calendar: z.optional(
						z
							.boolean()
							.describe(
								"Whether to push meeting changes to the calendar. \n\n To enable this feature, configure the **Configure Calendar and Contacts Service** in the user's profile page of the Zoom web portal and enable the **Automatically sync Zoom calendar events information bi-directionally between Zoom and integrated calendars.** setting in the **Settings** page of the Zoom web portal.\n* `true` - Push meeting changes to the calendar.\n* `false` - Do not push meeting changes to the calendar.",
							),
					),
					resources: z.optional(
						z
							.array(
								z.object({
									resource_type: z.optional(z.enum(["whiteboard"]).describe("The resource type.")),
									resource_id: z.optional(z.string().describe("The resource ID.")),
									permission_level: z.optional(
										z
											.enum(["editor", "commenter", "viewer"])
											.default("editor")
											.describe(
												"The permission levels for users to access the whiteboard. \n* `editor` - Users with link access can edit the board. \n* `commenter` - Users with link access can comment on the board. \n* `viewer` - Users with link access can view the board.",
											),
									),
								}),
							)
							.describe("The meeting's resources."),
					),
					auto_start_meeting_summary: z.optional(
						z.boolean().default(false).describe("Whether to automatically start meeting summary."),
					),
					who_will_receive_summary: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4)])
							.describe(
								"Defines who will receive a summary after this meeting. This field is applicable only when `auto_start_meeting_summary` is set to `true`.\r\n* `1` - Only meeting host.\r\n* `2` - Only meeting host, co-hosts, and alternative hosts.\r\n* `3` - Only meeting host and meeting invitees in our organization.\r\n* `4` - All meeting invitees including those outside of our organization.",
							),
					),
					auto_start_ai_companion_questions: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Whether to automatically start AI Companion questions."),
					),
					who_can_ask_questions: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5)])
							.describe(
								"Defines who can ask questions about this meeting's transcript. This field is applicable only when `auto_start_ai_companion_questions` is set to `true`.\r\n* `1` - All participants and invitees.\r\n* `2` - All participants only from when they join.\r\n* `3` - Only meeting host.\r\n* `4` - Participants and invitees in our organization.\r\n* `5` - Participants in our organization only from when they join.",
							),
					),
					summary_template_id: z.optional(
						z
							.string()
							.describe(
								"The summary template ID used to generate a meeting summary based on a predefined template. To get available summary templates, use the **Get user summary templates** API. To enable this feature for your account, please [contact Zoom Support](https://support.zoom.com/hc/en).",
							),
					),
					device_testing: z.optional(
						z.boolean().default(false).describe("Enable the device testing."),
					),
					request_permission_to_unmute_participants: z.optional(
						z
							.boolean()
							.describe(
								"Whether to enable the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting) setting. This option cannot be used together with `allow_host_control_participant_mute_state`, only one of the two can be enabled at a time.",
							),
					),
					allow_host_control_participant_mute_state: z.optional(
						z
							.boolean()
							.describe(
								"Whether to allow the host and co-hosts to fully control the mute state of participants. This option cannot be used together with `request_permission_to_unmute_participants`, only one of the two can be enabled at a time.",
							),
					),
					disable_participant_video: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to disable the participant video during a meeting. To enable this feature for your account, [contact Zoom Support](https://support.zoom.us/hc/en-us).",
							),
					),
					email_in_attendee_report: z.optional(
						z
							.boolean()
							.describe(
								"Whether to include authenticated guest's email addresses in meetings' attendee reports.",
							),
					),
				})
				.describe("Meeting settings."),
		),
		start_time: z.optional(
			z
				.string()
				.datetime()
				.describe(
					"Meeting start time. When using a format like `yyyy-MM-dd'T'HH:mm:ss'Z'`, always use GMT time. When using a format like `yyyy-MM-dd'T'HH:mm:ss`, use local time and specify the time zone. Only used for scheduled meetings and recurring meetings with a fixed time.",
				),
		),
		template_id: z.optional(
			z
				.string()
				.describe(
					"Unique identifier of the meeting template. \n\n[Schedule the meeting from a meeting template](https://support.zoom.us/hc/en-us/articles/360036559151-Meeting-templates#h_86f06cff-0852-4998-81c5-c83663c176fb). Retrieve this field's value by calling the [List meeting templates](/docs/api/rest/reference/zoom-api/methods/#operation/listMeetingTemplates) API.",
				),
		),
		timezone: z.optional(
			z
				.string()
				.describe(
					"The timezone to assign to the `start_time` value. Only use this field for scheduled or recurring meetings with a fixed time.\n\nFor a list of supported timezones and their formats, see our [timezone list](/docs/api/references/abbreviations/#timezones).",
				),
		),
		topic: z.optional(z.string().max(200).describe("Meeting topic.")),
		tracking_fields: z.optional(
			z
				.array(
					z.object({
						field: z.optional(z.string().describe("Tracking fields type.")),
						value: z.optional(z.string().describe("Tracking fields value.")),
					}),
				)
				.describe("Tracking fields."),
		),
		type: z.optional(
			z
				.union([z.literal(1), z.literal(2), z.literal(3), z.literal(8), z.literal(10)])
				.default(2)
				.describe(
					"The type of meeting. \n* `1` - An instant meeting. \n* `2` - A scheduled meeting. \n* `3` - A recurring meeting with no fixed time. \n* `8` - A recurring meeting with fixed time. \n* `10` - A screen share only meeting.",
				),
		),
	})
	.describe("Meeting object.");

export const meetingUpdateMutationResponseSchema = z.lazy(() => meetingUpdate204Schema);

export const getSipDialingWithPasscodePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `200`   \n \nMeeting\'s encoded SIP URI returned.
 */
export const getSipDialingWithPasscode200Schema = z
	.object({
		sip_dialing: z.optional(z.string().describe("The meeting's encoded SIP URI.")),
		paid_crc_plan_participant: z.optional(
			z.boolean().describe("Whether the API caller has a CRC (Conference Room Connector) plan."),
		),
		participant_identifier_code: z.optional(
			z
				.string()
				.describe(
					"This value identifies the meeting participant. It is automatically embedded in the SIP URI if the API caller has a CRC (Conference Room Connector) plan.",
				),
		),
		expire_in: z.optional(
			z.int().describe("The number of seconds the encoded SIP URI is valid before it expires."),
		),
	})
	.describe("Information about the meeting's encoded SIP URI.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `3000` <br>\n The meeting\'s SIP URI does not exist: {meetingId}. <br>\n
 */
export const getSipDialingWithPasscode400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `300` <br>\n Meeting ID does not exist. <br>\n**Error Code:** `3001` <br>\n Meeting does not exist: {meetingId} <br>\n
 */
export const getSipDialingWithPasscode404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const getSipDialingWithPasscode429Schema = z.unknown();

export const getSipDialingWithPasscodeMutationRequestSchema = z.object({
	passcode: z.optional(
		z
			.string()
			.describe(
				"If customers desire that a passcode be embedded in the SIP URI dial string, they must supply the passcode. Zoom will not validate the passcode.",
			),
	),
});

export const getSipDialingWithPasscodeMutationResponseSchema = z.lazy(
	() => getSipDialingWithPasscode200Schema,
);

export const meetingStatusPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a `long` format integer and not an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `204`  \n \nMeeting updated.
 */
export const meetingStatus204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3000` <br>\n Cannot access webinar info. <br>\n**Error Code:** `3063` <br>\n Can not end on-premise user\'s meeting: {meetingId}. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingStatus400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingStatus404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingStatus429Schema = z.unknown();

export const meetingStatusMutationRequestSchema = z.object({
	action: z.optional(
		z
			.enum(["end", "recover"])
			.describe(
				"`end` - End a meeting.  \n \n`recover` - [Recover](https://support.zoom.us/hc/en-us/articles/360038297111-Recover-a-deleted-meeting) a deleted meeting.\n",
			),
	),
});

export const meetingStatusMutationResponseSchema = z.lazy(() => meetingStatus204Schema);

export const pastMeetingDetailsPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"The meeting's ID or universally unique ID (UUID). \n* If you provide a meeting ID, the API will return a response for the latest meeting instance. \n* If you provide a meeting UUID that begins with a `/` character or contains the `//` characters, you **must** [double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) the meeting UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200` Meeting information returned.
 */
export const pastMeetingDetails200Schema = z.object({
	id: z.optional(
		z
			.int()
			.describe(
				"The [meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID).",
			),
	),
	uuid: z.optional(
		z
			.string()
			.describe(
				"The meeting's UUID. You must [double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) this value if the meeting UUID begins with a `/` character or contains the `//` character.",
			),
	),
	duration: z.optional(z.int().describe("The meeting's duration, in minutes.")),
	start_time: z.optional(z.string().datetime().describe("The meeting's start date and time.")),
	end_time: z.optional(z.string().datetime().describe("The meeting's end date and time.")),
	host_id: z.optional(z.string().describe("The host's ID.")),
	dept: z.optional(z.string().describe("The meeting host's department.")),
	participants_count: z.optional(z.int().describe("The number of meeting participants.")),
	source: z.optional(
		z
			.string()
			.describe(
				"Whether the meeting was created directly through Zoom or via an API request: \n* If the meeting was created via an OAuth app, this field returns the OAuth app's name. \n* If the meeting was created via JWT or the Zoom Web Portal, this returns the `Zoom` value.",
			),
	),
	topic: z.optional(z.string().describe("The meeting's topic.")),
	total_minutes: z.optional(
		z
			.int()
			.describe("The total number of minutes attended by the meeting's host and participants."),
	),
	type: z.optional(
		z
			.union([
				z.literal(0),
				z.literal(1),
				z.literal(2),
				z.literal(3),
				z.literal(4),
				z.literal(7),
				z.literal(8),
			])
			.describe(
				"The meeting type. \n* `0` - A prescheduled meeting. \n* `1` - An instant meeting. \n* `2` - A scheduled meeting. \n* `3` - A recurring meeting with no fixed time. \n* `4` - A [personal meeting room](https://support.zoom.us/hc/en-us/articles/201362843). \n* `7` - A [PAC (personal audio conference)](https://support.zoom.us/hc/en-us/articles/205172455-Hosting-a-Personal-Audio-Conference-PAC-meeting) meeting. \n* `8` - A recurring meeting with a fixed time.",
			),
	),
	user_email: z.optional(z.email().describe("The user's email address.")),
	user_name: z.optional(z.string().describe("The user's display name.")),
	has_meeting_summary: z.optional(
		z.boolean().describe("Whether the summary feature was used in the meeting."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Cannot access meeting information. <br>\n**Error Code:** `200` <br>\n Only available for paid account: {accountId}. <br>\n**Error Code:** `12702` <br>\n Cannot access a meeting a year ago. <br>\n
 */
export const pastMeetingDetails400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const pastMeetingDetails404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const pastMeetingDetails429Schema = z.unknown();

export const pastMeetingDetailsQueryResponseSchema = z.lazy(() => pastMeetingDetails200Schema);

export const pastMeetingsPathParamsSchema = z.object({
	meetingId: z.coerce.number().int().describe("The past meeting's ID."),
});

/**
 * @description **HTTP Status Code:** `200`   \n \n List of ended meeting instances returned.
 */
export const pastMeetings200Schema = z
	.object({
		meetings: z.optional(
			z
				.array(
					z.object({
						start_time: z.optional(z.string().datetime().describe("Start time")),
						uuid: z.optional(
							z
								.string()
								.describe(
									"Meeting UUID. Unique meeting ID. Each meeting instance will generate its own Meeting UUID (i.e., after a meeting ends, a new UUID will be generated for the next instance of the meeting). [Double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it.\n\n",
								),
						),
					}),
				)
				.describe("List of ended meeting instances."),
		),
	})
	.describe("List of Meetings");

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const pastMeetings404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const pastMeetings429Schema = z.unknown();

export const pastMeetingsQueryResponseSchema = z.lazy(() => pastMeetings200Schema);

export const pastMeetingParticipantsPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"The meeting's ID or universally unique ID (UUID). \n* If you provide a meeting ID, the API will return a response for the latest meeting instance. \n* If you provide a meeting UUID that begins with a `/` character or contains the `//` characters, you **must** double-encode the meeting UUID before making an API request.",
		),
});

export const pastMeetingParticipantsQueryParamsSchema = z.object({
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nMeeting participants\' report returned.
 */
export const pastMeetingParticipants200Schema = z.object({
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.",
			),
	),
	page_count: z.optional(z.int().describe("The number of pages returned for the request made.")),
	page_size: z.optional(
		z
			.int()
			.max(300)
			.default(30)
			.describe("The number of records returned within a single API call."),
	),
	total_records: z.optional(z.int().describe("The number of all records available across pages.")),
	participants: z.optional(
		z
			.array(
				z.object({
					id: z.optional(
						z
							.string()
							.describe(
								"Universally unique identifier of the Participant. It is the same as the User ID of the participant if the participant joins the meeting by logging into Zoom. If the participant joins the meeting without logging in, the value of this field will be blank.",
							),
					),
					name: z.optional(z.string().describe("Participant display name.")),
					user_id: z.optional(
						z
							.string()
							.describe(
								"Participant ID. This is a unique ID assigned to the participant joining a meeting and is valid for that meeting only.",
							),
					),
					registrant_id: z.optional(
						z
							.string()
							.describe(
								"The participant's unique registrant ID. This field only returns if you pass the `registrant_id` value for the `include_fields` query parameter. \n\nThis field does not return if the `type` query parameter is the `live` value.",
							),
					),
					user_email: z.optional(
						z
							.string()
							.describe(
								"Email address of the user. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for details.",
							),
					),
					join_time: z.optional(z.string().datetime().describe("Participant join time.")),
					leave_time: z.optional(z.string().datetime().describe("Participant leave time.")),
					duration: z.optional(
						z
							.int()
							.describe(
								"Participant duration, in seconds, calculated by subtracting the `leave_time` from the `join_time` for the `user_id`. If the participant leaves and rejoins the same meeting, they will be assigned a different `user_id` and Zoom displays their new duration in a separate object. Note that because of this, the duration may not reflect the total time the user was in the meeting.",
							),
					),
					failover: z.optional(
						z.boolean().describe("Indicates if failover happened during the meeting."),
					),
					status: z.optional(
						z
							.enum(["in_meeting", "in_waiting_room"])
							.describe(
								"The participant's status. \n* `in_meeting` - In a meeting. \n* `in_waiting_room` - In a waiting room.",
							),
					),
					internal_user: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Whether the meeting participant is an internal user."),
					),
				}),
			)
			.describe("Array of meeting participant objects."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n Only available for paid account: {accountId} <br>\n**Error Code:** `12702` <br>\n Can not access a meeting a year ago. <br>\n
 */
export const pastMeetingParticipants400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const pastMeetingParticipants404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const pastMeetingParticipants429Schema = z.unknown();

export const pastMeetingParticipantsQueryResponseSchema = z.lazy(
	() => pastMeetingParticipants200Schema,
);

export const listPastMeetingQAPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"The meeting's ID or universally unique ID (UUID). \n* If you provide a meeting ID, the API will return a response for the latest meeting instance. \n* If you provide a meeting UUID that begins with a `/` character or contains the `//` characters, you **must** double-encode the meeting UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200` **OK**  \n \nQ&amp;A returned successfully.
 */
export const listPastMeetingQA200Schema = z.object({
	id: z.optional(
		z
			.int()
			.describe(
				"[Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in **long** format, represented as int64 data type in JSON, also known as the meeting number.",
			),
	),
	questions: z.optional(
		z.array(
			z.object({
				email: z.optional(
					z
						.string()
						.describe(
							"The user's email address. If the user is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for details.",
						),
				),
				name: z.optional(
					z
						.string()
						.describe(
							"The user's name. If `anonymous` option is enabled for the Q&amp;A, the participant's information is be kept anonymous and the value of `name` field is `Anonymous Attendee`.",
						),
				),
				question_details: z.optional(
					z.array(
						z.object({
							answer: z.optional(
								z
									.string()
									.describe(
										"An answer submitted for the question. The value is 'live answered' if this is a live answer.",
									),
							),
							question: z.optional(z.string().describe("A question asked during the Q&amp;A.")),
						}),
					),
				),
			}),
		),
	),
	start_time: z.optional(z.string().datetime().describe("The meeting's start time.")),
	uuid: z.optional(z.string().describe("Meeting UUID.")),
});

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n **Error Code:** `1010` <br>\n User does not belong to this account:{accountId}. <br>\n
 */
export const listPastMeetingQA401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting ID is invalid or not end. <br>\n
 */
export const listPastMeetingQA404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const listPastMeetingQA429Schema = z.unknown();

export const listPastMeetingQAQueryResponseSchema = z.lazy(() => listPastMeetingQA200Schema);

export const meetingsPathParamsSchema = z.object({
	userId: z
		.string()
		.describe("The user's user ID or email address. For user-level apps, pass the `me` value."),
});

export const meetingsQueryParamsSchema = z.object({
	type: z
		.enum(["scheduled", "live", "upcoming", "upcoming_meetings", "previous_meetings"])
		.default("scheduled")
		.describe(
			"The type of meeting. \n* `scheduled` - All valid previous (unexpired) meetings, live meetings, and upcoming scheduled meetings. \n* `live` - All the ongoing meetings. \n* `upcoming` - All upcoming meetings, including live meetings. \n* `upcoming_meetings` - All upcoming meetings, including live meetings. \n* `previous_meetings` - All the previous meetings.",
		),
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	page_number: z.optional(
		z.coerce
			.number()
			.int()
			.describe("The page number of the current page in the returned records."),
	),
	from: z.optional(z.iso.date().describe("The start date.")),
	to: z.optional(z.iso.date().describe("The end date.")),
	timezone: z.optional(
		z
			.string()
			.describe(
				"The timezone to assign to the `from` and `to` value. For a list of supported timezones and their formats, see our [timezone list](https://developers.zoom.us/docs/api/rest/other-references/abbreviation-lists/#timezones).",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nList of meeting objects returned.
 */
export const meetings200Schema = z.object({
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	page_count: z.optional(z.int().describe("The number of pages returned for the request made.")),
	page_number: z.optional(z.int().default(1).describe("The page number of the current results.")),
	page_size: z.optional(
		z.int().max(300).default(30).describe("The number of records returned with a single API call."),
	),
	total_records: z.optional(
		z.int().describe("The total number of all the records available across pages."),
	),
	meetings: z.optional(
		z
			.array(
				z.object({
					agenda: z.optional(
						z
							.string()
							.describe(
								"Meeting description. The length of agenda gets truncated to 250 characters when you list all of a user's meetings. To view a meeting's complete agenda, or to retrieve details for a single meeting, use the [**Get a meeting**](/docs/api-reference/zoom-api/methods#operation/meeting) API.",
							),
					),
					created_at: z.optional(z.string().datetime().describe("Time of creation.")),
					duration: z.optional(z.int().describe("Meeting duration.")),
					host_id: z.optional(
						z.string().describe("ID of the user who is set as the meeting's host."),
					),
					id: z.optional(
						z
							.int()
							.describe("Meeting ID - also known as the meeting number in long (int64) format."),
					),
					join_url: z.optional(
						z.string().describe("URL using which participants can join a meeting."),
					),
					pmi: z.optional(
						z
							.string()
							.describe(
								"[Personal meeting ID](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#understanding-personal-meeting-id-pmi). This field is only returned if PMI was used to schedule the meeting.",
							),
					),
					start_time: z.optional(z.string().datetime().describe("Meeting start time.")),
					timezone: z.optional(z.string().describe("Timezone to format the meeting start time. ")),
					topic: z.optional(z.string().describe("Meeting topic.")),
					type: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3), z.literal(8)])
							.describe(
								"Meeting types.  \n `1` - Instant meeting.  \n `2` - Scheduled meeting.  \n `3` - Recurring meeting with no fixed time.  \n `8` - Recurring meeting with fixed time.",
							),
					),
					uuid: z.optional(
						z
							.string()
							.describe(
								"Unique Meeting ID. Each meeting instance will generate its own Meeting UUID.",
							),
					),
				}),
			)
			.describe("List of meeting objects."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetings400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: {userId}. <br>\n
 */
export const meetings404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetings429Schema = z.unknown();

export const meetingsQueryResponseSchema = z.lazy(() => meetings200Schema);

export const meetingCreatePathParamsSchema = z.object({
	userId: z
		.string()
		.describe("The user's user ID or email address. For user-level apps, pass the `me` value."),
});

/**
 * @description **HTTP Status Code:** `201` Meeting created.
 */
export const meetingCreate201Schema = z
	.object({
		assistant_id: z.optional(
			z.string().describe("The ID of the user who scheduled this meeting on behalf of the host."),
		),
		host_email: z.optional(z.email().describe("The meeting host's email address.")),
		host_id: z.optional(z.string().describe("The ID of the user who is set as the meeting host.")),
		id: z.optional(
			z
				.int()
				.describe(
					"The [meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in **long** format(represented as int64 data type in JSON), also known as the meeting number.",
				),
		),
		uuid: z.optional(
			z
				.string()
				.describe(
					"Unique meeting ID. Each meeting instance generates its own meeting UUID - after a meeting ends, a new UUID is generated for the next instance of the meeting. Retrieve a list of UUIDs from past meeting instances using the [**List past meeting instances**](/docs/api/rest/reference/zoom-api/methods#operation/pastMeetings) API. [Double encode](/docs/api/rest/using-zoom-apis/#meeting-id-and-uuid) your UUID when using it for API calls if the UUID begins with a `/` or contains `//` in it.",
				),
		),
		registration_url: z.optional(
			z
				.string()
				.describe(
					"The URL that registrants can use to register for a meeting. This field is only returned for meetings that have enabled registration.",
				),
		),
		agenda: z.optional(z.string().describe("Agenda")),
		created_at: z.optional(
			z.string().datetime().describe("The date and time when this meeting was created."),
		),
		duration: z.optional(z.int().describe("The meeting duration.")),
		encrypted_password: z.optional(
			z.string().describe("Encrypted passcode for third party endpoints (H323/SIP)."),
		),
		pstn_password: z.optional(
			z
				.string()
				.describe(
					"Passcode for participants to join the meeting via [PSTN](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference).",
				),
		),
		h323_password: z.optional(z.string().describe("H.323/SIP room system passcode")),
		join_url: z.optional(
			z
				.string()
				.describe(
					"URL for participants to join the meeting. This URL should only be shared with users that you would like to invite for the meeting.",
				),
		),
		chat_join_url: z.optional(z.string().describe("The URL to join the chat.")),
		occurrences: z.optional(
			z
				.array(
					z
						.object({
							duration: z.optional(z.int().describe("Duration.")),
							occurrence_id: z.optional(
								z
									.string()
									.describe(
										"Occurrence ID. The unique identifier for an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.",
									),
							),
							start_time: z.optional(z.string().datetime().describe("Start time.")),
							status: z.optional(
								z
									.enum(["available", "deleted"])
									.describe(
										"Occurrence status. \n `available` - Available occurrence.  \n `deleted` -  Deleted occurrence.",
									),
							),
						})
						.describe("Occurrence object. This object is only returned for recurring webinars."),
				)
				.describe("Array of occurrence objects."),
		),
		password: z.optional(
			z
				.string()
				.describe(
					"The meeting passcode. By default, it can be up to 10 characters in length and may contain alphanumeric characters as well as special characters such as !, @, #, etc.",
				),
		),
		pmi: z.optional(
			z
				.string()
				.describe(
					"[Personal meeting ID (PMI)](/docs/api/using-zoom-apis/#understanding-personal-meeting-id-pmi). Only used for scheduled meetings and recurring meetings with no fixed time.",
				),
		),
		pre_schedule: z.optional(
			z
				.boolean()
				.default(false)
				.describe(
					"Whether the prescheduled meeting was created via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This only supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time). \n* `true` - A GSuite prescheduled meeting. \n* `false` - A regular meeting.",
				),
		),
		recurrence: z.optional(
			z
				.object({
					end_date_time: z.optional(
						z
							.string()
							.datetime()
							.describe(
								"Select the final date when the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. Cannot be used with `end_times`.",
							),
					),
					end_times: z.optional(
						z
							.int()
							.max(60)
							.default(1)
							.describe(
								"Select how many times the meeting should recur before it is canceled. If `end_times` is set to 0, it means there is no end time. The maximum number of recurring is 60. Cannot be used with `end_date_time`.",
							),
					),
					monthly_day: z.optional(
						z
							.int()
							.default(1)
							.describe(
								"Use this field only if you're scheduling a recurring meeting of type `3` to state the day in a month when the meeting should recur. The value range is from 1 to 31.\n\nFor instance, if you would like the meeting to recur on 23rd of each month, provide `23` as this field's value and `1` as the `repeat_interval` field's value. Instead, to have the meeting recur every three months on 23rd of the month, change the value of the `repeat_interval` field to `3`.",
							),
					),
					monthly_week: z.optional(
						z
							.union([z.literal(-1), z.literal(1), z.literal(2), z.literal(3), z.literal(4)])
							.describe(
								"Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.   \n `-1` - Last week of the month.  \n `1` - First week of the month.  \n `2` - Second week of the month.  \n `3` - Third week of the month.  \n `4` - Fourth week of the month.",
							),
					),
					monthly_week_day: z.optional(
						z
							.union([
								z.literal(1),
								z.literal(2),
								z.literal(3),
								z.literal(4),
								z.literal(5),
								z.literal(6),
								z.literal(7),
							])
							.describe(
								"Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. \n\n  \n `1` - Sunday.  \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` - Thursday.  \n `6` - Friday.  \n `7` - Saturday.",
							),
					),
					repeat_interval: z.optional(
						z
							.int()
							.describe(
								"Define the interval for the meeting to recur. For instance, to schedule a meeting that recurs every two months, set this field's value to `2` and the value of the `type` parameter as `3`. \n\nFor a daily meeting, the maximum interval you can set is `99` days. For a weekly meeting the maximum interval that you can set is  of `50` weeks. For a monthly meeting, there is a maximum of `10` months.\n\n",
							),
					),
					type: z
						.union([z.literal(1), z.literal(2), z.literal(3)])
						.describe(
							"Recurrence meeting types.\n `1` - Daily.  \n `2` - Weekly.  \n `3` - Monthly.",
						),
					weekly_days: z.optional(
						z
							.enum(["1", "2", "3", "4", "5", "6", "7"])
							.default("1")
							.describe(
								"This field is required **if you're scheduling a recurring meeting of type** `2` to state the days of the week when the meeting should repeat.\n \n  This field's value could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `1` as this field's value.  \n   \n  **Note:** If you would like the meeting to occur on multiple days of a week, provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays, provide `1,3` as this field's value.\n\n   \n `1`  - Sunday.   \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` -  Thursday.  \n `6` - Friday.  \n `7` - Saturday.",
							),
					),
				})
				.describe(
					"Recurrence object. Use this object only for a meeting with type `8`, a recurring meeting with fixed time. ",
				),
		),
		settings: z.optional(
			z
				.object({
					allow_multiple_devices: z.optional(
						z
							.boolean()
							.describe(
								"Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).",
							),
					),
					alternative_hosts: z.optional(
						z
							.string()
							.describe(
								"A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.",
							),
					),
					alternative_hosts_email_notification: z.optional(
						z
							.boolean()
							.default(true)
							.describe(
								"Flag to determine whether to send email notifications to alternative hosts, default value is true.",
							),
					),
					alternative_host_update_polls: z.optional(
						z
							.boolean()
							.describe(
								"Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.",
							),
					),
					alternative_host_manage_meeting_summary: z.optional(
						z
							.boolean()
							.describe("Whether to allow an alternative host to manage meeting summaries."),
					),
					alternative_host_manage_cloud_recording: z.optional(
						z
							.boolean()
							.describe("Whether to allow an alternative host to manage meeting cloud recordings."),
					),
					approval_type: z.optional(
						z
							.union([z.literal(0), z.literal(1), z.literal(2)])
							.default(2)
							.describe(
								"Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.**   \n   \n \n\n`0` - Automatically approve.  \n `1` - Manually approve.  \n `2` - No registration required.",
							),
					),
					approved_or_denied_countries_or_regions: z.optional(
						z
							.object({
								approved_list: z.optional(
									z
										.array(z.string())
										.describe(
											"List of countries or regions from where participants can join this meeting. ",
										),
								),
								denied_list: z.optional(
									z
										.array(z.string())
										.describe(
											"List of countries or regions from where participants can not join this meeting. ",
										),
								),
								enable: z.optional(
									z
										.boolean()
										.describe(
											"`true` - Setting enabled to either allow users or block users from specific regions to join your meetings.   \n \n\n`false` - Setting disabled.",
										),
								),
								method: z.optional(
									z
										.enum(["approve", "deny"])
										.describe(
											"Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting.   \n   \n \n`approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.  \n   \n \n`deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`",
										),
								),
							})
							.describe(
								"Approve or block users from specific regions or countries from joining this meeting. \n",
							),
					),
					audio: z.optional(
						z
							.enum(["both", "telephony", "voip", "thirdParty"])
							.default("both")
							.describe(
								"Determine how participants can join the audio portion of the meeting.  \n `both` - Both Telephony and VoIP.  \n `telephony` - Telephony only.  \n `voip` - VoIP only.  \n `thirdParty` - Third party audio conference.",
							),
					),
					audio_conference_info: z.optional(
						z.string().max(2048).describe("Third party audio conference info."),
					),
					authentication_domains: z.optional(
						z
							.string()
							.describe(
								"If user has configured [Sign Into Zoom with Specified Domains](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.",
							),
					),
					authentication_exception: z.optional(
						z
							.array(
								z.object({
									email: z.optional(z.email().describe("The participant's email address.")),
									name: z.optional(z.string().describe("The participant's name.")),
									join_url: z.optional(
										z.string().describe("URL for participants to join the meeting."),
									),
								}),
							)
							.describe(
								"The participants added here will receive unique meeting invite links and bypass authentication.",
							),
					),
					authentication_name: z.optional(
						z
							.string()
							.describe(
								"Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).",
							),
					),
					authentication_option: z.optional(
						z.string().describe("Meeting authentication option ID."),
					),
					auto_recording: z.optional(
						z
							.enum(["local", "cloud", "none"])
							.default("none")
							.describe(
								"Automatic recording.\n `local` - Record on local.  \n `cloud` -  Record on cloud.  \n `none` - Disabled.",
							),
					),
					auto_add_recording_to_video_management: z.optional(
						z
							.object({
								enable: z
									.boolean()
									.default(false)
									.describe(
										"Whether to automatically add the meeting recording to video management.",
									),
								channels: z.optional(
									z
										.array(
											z.object({
												channel_id: z
													.string()
													.describe("The unique ID of a video management channel."),
												name: z.optional(
													z.string().describe("The name of the video management channel."),
												),
											}),
										)
										.min(1)
										.max(5)
										.describe(
											"List of video management channels where the meeting recording will be added.",
										),
								),
							})
							.describe(
								"Automatically add meeting recordings to a video channel in Video Management. To enable this feature for your account, please [contact Zoom Support](https://support.zoom.us/hc/en-us).",
							),
					),
					breakout_room: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Set this field's value to `true` to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.",
										),
								),
								rooms: z.optional(
									z
										.array(
											z.object({
												name: z.optional(z.string().describe("The breakout room's name.")),
												participants: z.optional(
													z
														.array(z.string())
														.describe(
															"Email addresses of the participants who are to be assigned to the breakout room.",
														),
												),
											}),
										)
										.describe("Create a room or rooms."),
								),
							})
							.describe(
								"Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).",
							),
					),
					calendar_type: z.optional(
						z
							.union([z.literal(1), z.literal(2)])
							.describe(
								"The type of calendar integration used to schedule the meeting. \n* `1` - [Zoom Outlook add-in](https://support.zoom.us/hc/en-us/articles/360031592971-Getting-started-with-Outlook-plugin-and-add-in) \n* `2` - [Zoom for Google Workspace add-on](https://support.zoom.us/hc/en-us/articles/360020187492-Using-the-Zoom-for-Google-Workspace-add-on)\n\nWorks with the `private_meeting` field to determine whether to share details of meetings or not.",
							),
					),
					close_registration: z.optional(
						z.boolean().default(false).describe("Close registration after event date."),
					),
					cn_meeting: z.optional(z.boolean().default(false).describe("Host meeting in China.")),
					contact_email: z.optional(z.string().describe("Contact email for registration")),
					contact_name: z.optional(z.string().describe("Contact name for registration")),
					custom_keys: z.optional(
						z
							.array(
								z.object({
									key: z.optional(
										z.string().max(64).describe("Custom key associated with the user."),
									),
									value: z.optional(
										z
											.string()
											.max(256)
											.describe("Value of the custom key associated with the user."),
									),
								}),
							)
							.max(10)
							.describe("Custom keys and values assigned to the meeting."),
					),
					email_notification: z.optional(
						z
							.boolean()
							.default(true)
							.describe(
								"Whether to send email notifications to [alternative hosts](https://support.zoom.us/hc/en-us/articles/208220166) and [users with scheduling privileges](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-privilege). This value defaults to `true`.",
							),
					),
					encryption_type: z.optional(
						z
							.enum(["enhanced_encryption", "e2ee"])
							.describe(
								"Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**.\n \n`enhanced_encryption` - Enhanced encryption. Encryption is stored in the cloud if you enable this option.   \n \n\n`e2ee` - [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions features.",
							),
					),
					enforce_login: z.optional(
						z
							.boolean()
							.describe(
								"Only signed in users can join this meeting.\n\n**This field is deprecated and will not be supported in the future.**    \n   \n As an alternative, use the `meeting_authentication`, `authentication_option`, and `authentication_domains` fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.",
							),
					),
					enforce_login_domains: z.optional(
						z
							.string()
							.describe(
								"Only signed in users with specified domains can join meetings.\n\n**This field is deprecated and will not be supported in the future.**    \n   \n As an alternative, use the `meeting_authentication`, `authentication_option`, and `authentication_domains` fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.",
							),
					),
					focus_mode: z.optional(
						z
							.boolean()
							.describe(
								"Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.",
							),
					),
					global_dial_in_countries: z.optional(
						z.array(z.string()).describe("List of global dial-in countries."),
					),
					global_dial_in_numbers: z.optional(
						z
							.array(
								z.object({
									city: z.optional(z.string().describe("City of the number, such as Chicago.")),
									country: z.optional(z.string().describe("The country code, such as BR.")),
									country_name: z.optional(
										z.string().describe("Full name of country, such as Brazil."),
									),
									number: z.optional(z.string().describe("A phone number, such as +1 2332357613.")),
									type: z.optional(z.enum(["toll", "tollfree"]).describe("Type of number.")),
								}),
							)
							.describe("Global dial-in countries or regions."),
					),
					host_video: z.optional(
						z.boolean().describe("Start video when the host joins the meeting."),
					),
					in_meeting: z.optional(z.boolean().default(false).describe("Host meeting in India.")),
					jbh_time: z.optional(
						z
							.union([z.literal(0), z.literal(5), z.literal(10), z.literal(15)])
							.describe(
								"If the value of `join_before_host` field is set to `true`, use this field to indicate time limits when a participant may join a meeting before a host.\n\n*  `0` - Allow participant to join anytime.\n*  `5`- Allow participant to join 5 minutes before meeting start time.\n * `10` - Allow participant to join 10 minutes before meeting start time.\n* `15` - Allow the participant to join 15 minutes before the meeting's start time.",
							),
					),
					join_before_host: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.",
							),
					),
					question_and_answer: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Enable [Q&amp;A](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0065237) for meeting.\n\n* `false` - Disable Q&amp;A for meeting. If not provided, the default value will be based on the user's setting.",
										),
								),
								allow_submit_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true`: Allow participants to submit questions.\n\n* `false`: Do not allow submit questions.",
										),
								),
								allow_anonymous_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to send questions without providing their name to the host, co-host, and panelists..\n\n* `false` - Do not allow anonymous questions.(Not supported for simulive meeting.)",
										),
								),
								question_visibility: z.optional(
									z
										.enum(["answered", "all"])
										.describe(
											"Indicate whether you want attendees to be able to view answered questions only or view all questions.\n\n* `answered` - Attendees are able to view answered questions only.\n\n*  `all` - Attendees are able to view all questions submitted in the Q&amp;A.",
										),
								),
								attendees_can_comment: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can answer questions or leave a comment in the question thread.\n\n* `false` - Attendees can not answer questions or leave a comment in the question thread",
										),
								),
								attendees_can_upvote: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can click the thumbs up button to bring popular questions to the top of the Q&amp;A window.\n\n* `false` - Attendees can not click the thumbs up button on questions.",
										),
								),
							})
							.describe(
								"[Q&amp;A](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0065237) for meeting.",
							),
					),
					language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [language interpretation](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768) for the meeting. If not provided, the default value will be based on the user's setting.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two country IDs.\n\nOnly system-supported languages are allowed: `US` (English), `CN` (Chinese), `JP` (Japanese), `DE` (German), `FR` (French), `RU` (Russian), `PT` (Portuguese), `ES` (Spanish), and `KR` (Korean).\n\nFor example, to set an interpreter translating from English to Chinese, use `US,CN`.",
														),
												),
												interpreter_languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two languages.\n\nTo get this value, use the `language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/docs/api/users/#tag/users/GET/users/{userId}/settings) API response.\n\n**languages**: System-supported languages include `English`, `Chinese`, `Japanese`, `German`, `French`, `Russian`, `Portuguese`, `Spanish`, and `Korean`.\n\n**custom_languages**: User-defined languages added by the user.\n\nFor example, an interpreter translating between English and French should use `English,French`.",
														),
												),
											}),
										)
										.describe("Information about the meeting's language interpreters."),
								),
							})
							.describe(
								"The meeting's [language interpretation settings](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768). Make sure to add the language in the web portal in order to use it in the API. See link for details.\n\n**Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.",
							),
					),
					sign_language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the meeting. If not provided, the default value will be based on the user's setting.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												sign_language: z.optional(
													z
														.string()
														.describe(
															"The interpreter's sign language. \n\n To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/api-reference/zoom-api/methods#operation/userSettings) API response.",
														),
												),
											}),
										)
										.max(20)
										.describe("Information about the meeting's sign language interpreters."),
								),
							})
							.describe(
								"The meeting's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details. \n\n**Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.",
							),
					),
					meeting_authentication: z.optional(
						z.boolean().describe("`true` - Only authenticated users can join meetings."),
					),
					mute_upon_entry: z.optional(
						z.boolean().default(false).describe("Mute participants upon entry."),
					),
					participant_video: z.optional(
						z.boolean().describe("Start video when participants join the meeting."),
					),
					private_meeting: z.optional(
						z.boolean().describe("Whether the meeting is set as private."),
					),
					registrants_confirmation_email: z.optional(
						z
							.boolean()
							.describe(
								"Whether to send registrants an email confirmation.\n* `true` - Send a confirmation email.\n* `false` - Do not send a confirmation email.",
							),
					),
					registrants_email_notification: z.optional(
						z
							.boolean()
							.describe(
								"Whether to send registrants email notifications about their registration approval, cancellation, or rejection.\n\n* `true` - Send an email notification.\n* `false` - Do not send an email notification.\n\n Set this value to `true` to also use the `registrants_confirmation_email` parameter.",
							),
					),
					registration_type: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3)])
							.default(1)
							.describe(
								"Registration type. Used for recurring meeting with fixed time only. \n `1` - Attendees register once and can attend any of the occurrences.  \n `2` - Attendees need to register for each occurrence to attend.  \n `3` - Attendees register once and can choose one or more occurrences to attend.",
							),
					),
					show_share_button: z.optional(
						z
							.boolean()
							.describe(
								"Show social share buttons on the meeting registration page.\nThis setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).",
							),
					),
					show_join_info: z.optional(
						z
							.boolean()
							.describe(
								"Whether to show the meeting's join information on the registration confirmation page. This setting is only applied to meetings with registration enabled.",
							),
					),
					use_pmi: z.optional(
						z
							.boolean()
							.describe(
								"Whether to use a [Personal Meeting ID (PMI)](/docs/api/using-zoom-apis/#understanding-personal-meeting-id-pmi) for the meeting. This field is only used for scheduled meetings(`2`) and recurring meetings with no fixed time(`3`). If not provided, the default value will be based on the user's setting.",
							),
					),
					waiting_room: z.optional(z.boolean().default(false).describe("Enable the waiting room.")),
					waiting_room_options: z.optional(
						z
							.object({
								mode: z
									.enum(["follow_setting", "custom"])
									.describe(
										"Specifies the waiting room behavior for this meeting.\r\n* `follow_setting` - Use the Zoom web portal setting.\r\n* `custom` - Specify which participants should go into the waiting room.",
									),
								who_goes_to_waiting_room: z.optional(
									z
										.enum([
											"everyone",
											"users_not_in_account",
											"users_not_in_account_or_whitelisted_domains",
											"users_not_on_invite",
										])
										.describe(
											"Specifies which participants should be placed into the waiting room. Required if `mode` is set to `custom`.\r\n* `everyone` - Everyone.\r\n* `users_not_in_account` - Users not in your account.\r\n* `users_not_in_account_or_whitelisted_domains` - Users who are not in your account and not part of your whitelisted domains.\r\n* `users_not_on_invite` - Users not on the meeting invite.",
										),
								),
							})
							.describe("Configuration settings for the meeting's waiting room."),
					),
					watermark: z.optional(
						z
							.boolean()
							.describe(
								"Whether to add a watermark when viewing a shared screen. If not provided, the default value will be based on the user's setting.",
							),
					),
					host_save_video_order: z.optional(
						z
							.boolean()
							.describe("Whether the **Allow host to save video order** feature is enabled."),
					),
					internal_meeting: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Whether to set the meeting as an internal meeting."),
					),
					meeting_invitees: z.optional(
						z
							.array(
								z.object({
									email: z.optional(z.email().describe("The invitee's email address.")),
								}),
							)
							.describe("A list of the meeting's invitees."),
					),
					continuous_meeting_chat: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable the **Enable continuous meeting chat** setting. The default value is based on user settings. When the **Enable continuous meeting chat** setting is enabled, the default value is true. When the setting is disabled, the default value is false.",
										),
								),
								auto_add_invited_external_users: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable the **Automatically add invited external users** setting.",
										),
								),
								auto_add_meeting_participants: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable the **Automatically add meeting participants** setting.",
										),
								),
								channel_id: z.optional(z.string().describe("The channel's ID.")),
							})
							.describe(
								"Information about the **Enable continuous meeting chat** feature. This setting only applies to scheduled and recurring meetings (type `2`, `3`, and `8`). It is **not supported** for type `1` instant meetings or type `10` screen share only meetings.",
							),
					),
					participant_focused_meeting: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Whether to set the meeting as a participant focused meeting."),
					),
					push_change_to_calendar: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to push meeting changes to the calendar. \n\n To enable this feature, configure the **Configure Calendar and Contacts Service** in the user's profile page of the Zoom web portal and enable the **Automatically sync Zoom calendar events information bi-directionally between Zoom and integrated calendars.** setting in the **Settings** page of the Zoom web portal.\n* `true` - Push meeting changes to the calendar.\n* `false` - Do not push meeting changes to the calendar.",
							),
					),
					resources: z.optional(
						z
							.array(
								z.object({
									resource_type: z.optional(z.enum(["whiteboard"]).describe("The resource type.")),
									resource_id: z.optional(z.string().describe("The resource ID.")),
									permission_level: z.optional(
										z
											.enum(["editor", "commenter", "viewer"])
											.default("editor")
											.describe(
												"The permission levels for users to access the whiteboard. \n* `editor` - Users with link access can edit the board. \n* `commenter` - Users with link access can comment on the board. \n* `viewer` - Users with link access can view the board.",
											),
									),
								}),
							)
							.describe("The meeting's resources."),
					),
					auto_start_meeting_summary: z.optional(
						z
							.boolean()
							.describe(
								"Whether to automatically start a meeting summary. If not provided, the default value will be based on the user's setting.",
							),
					),
					who_will_receive_summary: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4)])
							.describe(
								"Defines who will receive a summary after this meeting. This field is applicable only when `auto_start_meeting_summary` is set to `true`.\r\n* `1` - Only meeting host.\r\n* `2` - Only meeting host, co-hosts, and alternative hosts.\r\n* `3` - Only meeting host and meeting invitees in our organization.\r\n* `4` - All meeting invitees including those outside of our organization. If not provided, the default value will be based on the user's setting.",
							),
					),
					auto_start_ai_companion_questions: z.optional(
						z
							.boolean()
							.describe(
								"Whether to automatically start AI Companion questions. If not provided, the default value will be based on the user's setting.",
							),
					),
					who_can_ask_questions: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5)])
							.describe(
								"Defines who can ask questions about this meeting's transcript. This field is applicable only when `auto_start_ai_companion_questions` is set to `true`.\r\n* `1` - All participants and invitees.\r\n* `2` - All participants only from when they join.\r\n* `3` - Only meeting host.\r\n* `4` - Participants and invitees in our organization.\r\n* `5` - Participants in our organization only from when they join. If not provided, the default value will be based on the user's setting.",
							),
					),
					summary_template_id: z.optional(
						z
							.string()
							.describe(
								"The summary template ID used to generate a meeting summary based on a predefined template. To get available summary templates, use the **Get user summary templates** API. If not provided, the default value will be based on the user's setting. To enable this feature for your account, please [contact Zoom Support](https://support.zoom.com/hc/en).",
							),
					),
					device_testing: z.optional(
						z.boolean().default(false).describe("Enable the device testing."),
					),
					request_permission_to_unmute_participants: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to enable the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting) setting. This option cannot be used together with `allow_host_control_participant_mute_state`, only one of the two can be enabled at a time.",
							),
					),
					allow_host_control_participant_mute_state: z.optional(
						z
							.boolean()
							.describe(
								"Whether to allow the host and co-hosts to fully control the mute state of participants. If not provided, the default value will be based on the user's setting. This option cannot be used together with `request_permission_to_unmute_participants`, only one of the two can be enabled at a time.",
							),
					),
					disable_participant_video: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to disable the participant video during meeting. To enable this feature for your account, please [contact Zoom Support](https://support.zoom.us/hc/en-us).",
							),
					),
					email_in_attendee_report: z.optional(
						z
							.boolean()
							.describe(
								"Whether to include authenticated guest's email addresses in meetings' attendee reports.",
							),
					),
				})
				.describe("Meeting settings."),
		),
		start_time: z.optional(
			z
				.string()
				.datetime()
				.describe("Meeting start date-time in UTC/GMT, such as `2020-03-31T12:02:00Z`."),
		),
		start_url: z.optional(
			z
				.string()
				.describe(
					"URL to start the meeting. This URL should only be used by the host of the meeting and **should not be shared with anyone other than the host** of the meeting, since anyone with this URL will be able to log in to the Zoom Client as the host of the meeting.",
				),
		),
		status: z.optional(
			z
				.enum(["waiting", "started"])
				.describe(
					"The meeting status.\n* `waiting` - The meeting has not started.\n* `started` - The meeting is currently in progress.",
				),
		),
		timezone: z.optional(z.string().describe("Timezone to format `start_time`.")),
		topic: z.optional(z.string().max(200).describe("Meeting topic.")),
		tracking_fields: z.optional(
			z
				.array(
					z.object({
						field: z.optional(z.string().describe("The tracking field's label.")),
						value: z.optional(z.string().describe("The tracking field's value.")),
						visible: z.optional(
							z
								.boolean()
								.describe(
									"Indicates whether the [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields) is visible in the meeting scheduling options in the Zoom Web Portal or not.\n\n`true`: Tracking field is visible.   \n \n\n`false`: Tracking field is not visible to the users in the meeting options in the Zoom Web Portal but the field was used while scheduling this meeting via API. An invisible tracking field can be used by users while scheduling meetings via API only. ",
								),
						),
					}),
				)
				.describe("Tracking fields."),
		),
		type: z.optional(
			z
				.union([z.literal(1), z.literal(2), z.literal(3), z.literal(8), z.literal(10)])
				.default(2)
				.describe(
					"The meeting type.\n* `1` - An instant meeting. \n* `2` - A scheduled meeting. \n* `3` - A recurring meeting with no fixed time. \n* `8` - A recurring meeting with fixed time. \n* `10` - A screen share only meeting.",
				),
		),
		dynamic_host_key: z.optional(z.string().describe("The meeting dynamic host key.")),
		creation_source: z.optional(
			z
				.enum(["other", "open_api", "web_portal"])
				.describe(
					"The platform through which the meeting was created.\n* `other` - Created through another platform.\n* `open_api` - Created through Open API.\n* `web_portal` - Created through the web portal.",
				),
		),
	})
	.describe("Meeting object.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3161` <br>\n Your user account is not allowed meeting hosting and scheduling capabilities. <br>\n**Error Code:** `3000` <br>\n Instant meetings do not support the `schedule_for` parameter, and you can\'t schedule an instant meeting for another user. <br>\n**Error Code:** `3000` <br>\n Users in \'{userId}\' have been blocked from joining meetings and webinars. To unblock them, go to the **Settings** page in the Zoom web portal and update **Block users in specific domains from joining meetings and webinars**. <br>\n**Error Code:** `3000` <br>\n You cannot schedule a meeting for {userId} <br>\n**Error Code:** `300` <br>\n The value that you entered in the `schedule_for` field is invalid. Enter a valid value and try again. <br>\n**Error Code:** `300` <br>\n Invalid `enforce_login_domains`. Separate multiple domains with semicolons. <br>\n
 */
export const meetingCreate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: {userId}. <br>\n
 */
export const meetingCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const meetingCreate429Schema = z.unknown();

/**
 * @description The meeting object.
 */
export const meetingCreateMutationRequestSchema = z
	.object({
		agenda: z.optional(
			z
				.string()
				.max(2000)
				.describe("The meeting's agenda. This value has a maximum length of 2,000 characters."),
		),
		default_password: z.optional(
			z
				.boolean()
				.default(true)
				.describe(
					"Whether to automatically generate a passcode for the meeting when no passcode is provided and the user's **Require a passcode when scheduling new meetings** setting is enabled. Defaults to `true`. When set to `false`, meetings will only have a passcode if one is explicitly provided.",
				),
		),
		duration: z.optional(
			z
				.int()
				.min(1)
				.max(1440)
				.default(60)
				.describe(
					"The meeting's scheduled duration, in minutes. This field is used for `2` scheduled meetings and `8` recurring meetings with a fixed time. The value must be between 1 and 1440 minutes, which is equivalent to 24 hours.",
				),
		),
		password: z.optional(
			z
				.string()
				.max(10)
				.describe(
					"The meeting passcode. By default, it can be up to 10 characters in length and may contain alphanumeric characters as well as special characters such as !, @, #, etc.\n\n**Note**:\n- If the account owner or administrator has configured [Passcode Requirement](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0063160#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode **must** meet those requirements. You can retrieve the requirements using the [**Get user settings**](/docs/api/users/#tag/users/GET/users/{userId}/settings) API or the [**Get account settings**](/docs/api/accounts/#tag/accounts/GET/accounts/{accountId}/settings) API.\n- If the **Require a passcode when scheduling new meetings** user setting is enabled and `default_password` is not explicitly set to `false`, a passcode will be automatically generated when one is not provided.\n- If the **Require a passcode when scheduling new meetings** setting is enabled and [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, a passcode will be automatically generated when one is not provided.",
				),
		),
		pre_schedule: z.optional(
			z
				.boolean()
				.default(false)
				.describe(
					"Whether to create a prescheduled meeting via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` scheduled meetings and `3` recurring meetings with no fixed time. \n* `true` - Create a prescheduled meeting. \n* `false` - Create a regular meeting.",
				),
		),
		recurrence: z.optional(
			z
				.object({
					end_date_time: z.optional(
						z
							.string()
							.datetime()
							.describe(
								"This field selects the final date when the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. Cannot be used with `end_times`.",
							),
					),
					end_times: z.optional(
						z
							.int()
							.max(60)
							.default(1)
							.describe(
								"This field selects how many times the meeting should recur before it is canceled. If `end_times` is set to 0, it means there is no end time. The maximum number of recurring is 60. Cannot be used with `end_date_time`.",
							),
					),
					monthly_day: z.optional(
						z
							.int()
							.default(1)
							.describe(
								"This field is **only** for scheduling a **recurring meeting of type `3`**. It states the day in a month when the meeting should recur. The value range is from `1` to `31`.\n\nFor the meeting to recur on 23rd of each month, provide `23` as this field's value and `1` as the `repeat_interval` field's value. To have the meeting recur every three months on 23rd of the month, change the `repeat_interval` field value to `3`.",
							),
					),
					monthly_week: z.optional(
						z
							.union([z.literal(-1), z.literal(1), z.literal(2), z.literal(3), z.literal(4)])
							.describe(
								"This field is **only if** for scheduling a **recurring meeting of type `3`**.  It states the week of the month when the meeting should recur. If you use this field, you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.   \n `-1` - Last week of the month.  \n `1` - First week of the month.  \n `2` - Second week of the month.  \n `3` - Third week of the month.  \n `4` - Fourth week of the month.",
							),
					),
					monthly_week_day: z.optional(
						z
							.union([
								z.literal(1),
								z.literal(2),
								z.literal(3),
								z.literal(4),
								z.literal(5),
								z.literal(6),
								z.literal(7),
							])
							.describe(
								"This field is **only if** for scheduling a **recurring meeting of type `3`**. It states a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. \n\n  \n `1` - Sunday.  \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` - Thursday.  \n `6` - Friday.  \n `7` - Saturday.",
							),
					),
					repeat_interval: z.optional(
						z
							.int()
							.describe(
								"This field defines the interval when the meeting should recur. For instance, to schedule a meeting that recurs every two months, set this field's value as `2` and the value of the `type` parameter as `3`. \n\nFor a daily meeting, the maximum number of recurrences is `99` days. For a weekly meeting, the maximum is `50` weeks. For a monthly meeting, the maximum is `10` months.\n\n",
							),
					),
					type: z
						.union([z.literal(1), z.literal(2), z.literal(3)])
						.describe(
							"The recurrence meeting types.\n `1` - Daily.  \n `2` - Weekly.  \n `3` - Monthly.",
						),
					weekly_days: z.optional(
						z
							.enum(["1", "2", "3", "4", "5", "6", "7"])
							.default("1")
							.describe(
								"This field is **required** if you're scheduling a recurring meeting of type `2`. It states the days of the week when the meeting should repeat. \n\nThis field's value could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `1` as this field's value.  \n\n**Note:** To set the meeting to occur on multiple days of a week, provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays, provide `1,3` as this field's value.\n\n   \n `1` - Sunday.   \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` -  Thursday.  \n `6` - Friday.  \n `7` - Saturday.",
							),
					),
				})
				.describe(
					"The recurrence object. Use this object only for a meeting with type `8`, a recurring meeting with a fixed time. ",
				),
		),
		schedule_for: z.optional(
			z.string().describe("The email address or user ID of the user to schedule a meeting for."),
		),
		settings: z.optional(
			z
				.object({
					additional_data_center_regions: z.optional(
						z
							.array(z.string())
							.describe(
								"This field adds additional meeting [data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars). Provide this value as an array of [country codes](/docs/api/references/abbreviations/#countries) for the countries available as data center regions in the [**Account Profile**](https://zoom.us/account/setting) interface but have been opted out of in the [user settings](https://zoom.us/profile).\n\nFor example, the data center regions selected in your [**Account Profile**](https://zoom.us/account) are `Europe`, `Hong Kong SAR`, `Australia`, `India`, `Japan`, `China`, `United States`, and `Canada`. However, in the [**My Profile**](https://zoom.us/profile) settings, you did **not** select `India` and `Japan` for meeting and webinar traffic routing.\n\nTo include `India` and `Japan` as additional data centers, use the `[IN, TY]` value for this field.",
							),
					),
					allow_multiple_devices: z.optional(
						z
							.boolean()
							.describe(
								"Whether to allow attendees to join a meeting from multiple devices. This setting is only applied to meetings with registration enabled.",
							),
					),
					alternative_hosts: z.optional(
						z
							.string()
							.describe(
								"A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.",
							),
					),
					alternative_hosts_email_notification: z.optional(
						z
							.boolean()
							.default(true)
							.describe(
								"Whether to send email notifications to alternative hosts. This value defaults to `true`.",
							),
					),
					approval_type: z.optional(
						z
							.union([z.literal(0), z.literal(1), z.literal(2)])
							.default(2)
							.describe(
								"Enable meeting registration approval.\n* `0` - Automatically approve registration.\n* `1` - Manually approve registration.\n* `2` - No registration required.\n\nThis value defaults to `2`.",
							),
					),
					approved_or_denied_countries_or_regions: z.optional(
						z
							.object({
								approved_list: z.optional(
									z.array(z.string()).describe("The list of approved countries or regions."),
								),
								denied_list: z.optional(
									z.array(z.string()).describe("The list of blocked countries or regions."),
								),
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable the [**Approve or block entry for users from specific countries/regions**](https://support.zoom.us/hc/en-us/articles/360060086231-Approve-or-block-entry-for-users-from-specific-countries-regions) setting.",
										),
								),
								method: z.optional(
									z
										.enum(["approve", "deny"])
										.describe(
											"Whether to allow or block users from specific countries or regions.\n* `approve` - Allow users from specific countries or regions to join the meeting. If you select this setting, include the approved countries or regions in the `approved_list` field. \n* `deny` - Block users from specific countries or regions from joining the meeting. If you select this setting, include the blocked countries or regions in the `denied_list` field.",
										),
								),
							})
							.describe(
								"The list of approved or blocked users from specific countries or regions who can join the meeting.",
							),
					),
					audio: z.optional(
						z
							.enum(["both", "telephony", "voip", "thirdParty"])
							.default("both")
							.describe(
								"How participants join the audio portion of the meeting.\n* `both` - Both telephony and VoIP. \n* `telephony` - Telephony only. \n* `voip` - VoIP only. \n* `thirdParty` - Third party audio conference.",
							),
					),
					audio_conference_info: z.optional(
						z.string().max(2048).describe("Third party audio conference information."),
					),
					authentication_domains: z.optional(
						z
							.string()
							.describe(
								"The meeting's authenticated domains. Only Zoom users whose email address contains an authenticated domain can join the meeting. Comma-separate multiple domains or use a wildcard for listing domains.",
							),
					),
					authentication_exception: z.optional(
						z
							.array(
								z.object({
									email: z.optional(z.email().describe("The participant's email address.")),
									name: z.optional(z.string().describe("The participant's name.")),
								}),
							)
							.describe(
								"A list of participants who can bypass meeting authentication. These participants will receive a unique meeting invite.",
							),
					),
					authentication_option: z.optional(
						z
							.string()
							.describe(
								"If the `meeting_authentication` value is `true`, the type of authentication required for users to join a meeting.\n\nTo get this value, use the `authentication_options` array's `id` value in the [**Get user settings**](/docs/api-reference/zoom-api/methods#operation/userSettings) API response.",
							),
					),
					auto_recording: z.optional(
						z
							.enum(["local", "cloud", "none"])
							.default("none")
							.describe(
								"The automatic recording settings. \n* `local` - Record the meeting locally. \n* `cloud` - Record the meeting to the cloud. \n* `none` - Auto-recording disabled.\n\nThis value defaults to `none`.",
							),
					),
					auto_add_recording_to_video_management: z.optional(
						z
							.object({
								enable: z
									.boolean()
									.default(false)
									.describe(
										"Whether to automatically add the meeting recording to video management.",
									),
								channels: z.optional(
									z
										.array(
											z.object({
												channel_id: z
													.string()
													.describe("The unique ID of a video management channel."),
												name: z.optional(
													z.string().describe("The name of the video management channel."),
												),
											}),
										)
										.min(1)
										.max(5)
										.describe(
											"List of video management channels where the meeting recording will be added.",
										),
								),
							})
							.describe(
								"Automatically add meeting recordings to a video channel in video management. To enable this feature for your account, please [contact Zoom Support](https://support.zoom.us/hc/en-us).",
							),
					),
					breakout_room: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable the [**Breakout Room pre-assign**](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms) option.",
										),
								),
								rooms: z.optional(
									z
										.array(
											z.object({
												name: z.optional(z.string().describe("The breakout room's name.")),
												participants: z.optional(
													z
														.array(z.string())
														.describe(
															"The email addresses of the participants to assign to the breakout room.",
														),
												),
											}),
										)
										.describe("Information about the breakout rooms."),
								),
							})
							.describe(
								"The [pre-assigned breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms) settings.",
							),
					),
					calendar_type: z.optional(
						z
							.union([z.literal(1), z.literal(2)])
							.describe(
								"The type of calendar integration used to schedule the meeting.\n* `1` - [Zoom Outlook add-in](https://support.zoom.us/hc/en-us/articles/360031592971-Getting-started-with-Outlook-plugin-and-add-in) \n* `2` - [Zoom for Google Workspace add-on](https://support.zoom.us/hc/en-us/articles/360020187492-Using-the-Zoom-for-Google-Workspace-add-on)\n\nWorks with the `private_meeting` field to determine whether to share details of meetings or not.",
							),
					),
					close_registration: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to close registration after the event date. This value defaults to `false`.",
							),
					),
					cn_meeting: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to host the meeting in China (CN). This value defaults to `false`.",
							),
					),
					contact_email: z.optional(
						z.string().describe("The contact email address for meeting registration."),
					),
					contact_name: z.optional(
						z.string().describe("The contact name for meeting registration."),
					),
					email_notification: z.optional(
						z
							.boolean()
							.default(true)
							.describe(
								"Whether to send email notifications to [alternative hosts](https://support.zoom.us/hc/en-us/articles/208220166) and [users with scheduling privileges](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-privilege). This value defaults to `true`.",
							),
					),
					encryption_type: z.optional(
						z
							.enum(["enhanced_encryption", "e2ee"])
							.describe(
								"The type of [end-to-end (E2EE) encryption](https://support.zoom.us/hc/en-us/articles/360048660871) to use for the meeting. \n* `enhanced_encryption` - Enhanced encryption. Encryption is stored in the cloud when you enable this option. \n* `e2ee` - End-to-end encryption. The encryption key is stored on your local device and **cannot** be obtained by anyone else. When you use E2EE encryption, [certain features](https://support.zoom.us/hc/en-us/articles/360048660871), such as cloud recording or phone and SIP/H.323 dial-in, are **disabled**.",
							),
					),
					focus_mode: z.optional(
						z
							.boolean()
							.describe(
								"Whether to enable the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) when the meeting starts.",
							),
					),
					global_dial_in_countries: z.optional(
						z.array(z.string()).describe("A list of available global dial-in countries."),
					),
					host_video: z.optional(
						z.boolean().describe("Whether to start meetings with the host video on."),
					),
					in_meeting: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to host the meeting in India (IN). This value defaults to `false`.",
							),
					),
					jbh_time: z.optional(
						z
							.union([z.literal(0), z.literal(5), z.literal(10), z.literal(15)])
							.describe(
								"If the value of the `join_before_host` field is `true`, this field indicates the time limits when a participant can join a meeting before the meeting's host.\n\n* `0` - Allow the participant to join the meeting at anytime.\n* `5` - Allow the participant to join 5 minutes before the meeting's start time.\n* `10` - Allow the participant to join 10 minutes before the meeting's start time.\n* `15` - Allow the participant to join 15 minutes before the meeting's start time.",
							),
					),
					join_before_host: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether participants can join the meeting before its host. This field is only used for scheduled meetings (`2`) or recurring meetings (`3` and `8`). This value defaults to `false`.\n\nIf the [**Waiting Room** feature](https://support.zoom.us/hc/en-us/articles/115000332726-Waiting-Room) is enabled, this setting is **disabled**.",
							),
					),
					question_and_answer: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Enable [Q&amp;A](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0065237) for meeting.\n\n* `false` - Disable Q&amp;A for meeting. If not provided, the default value will be based on the user's setting.",
										),
								),
								allow_submit_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to submit questions.\n\n* `false` - Don't allow participants to submit questions.",
										),
								),
								allow_anonymous_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to send questions without providing their name to the host, co-host, and panelists.\n\n* `false` - Do not allow anonymous questions. Not supported for simulive meeting.",
										),
								),
								question_visibility: z.optional(
									z
										.enum(["answered", "all"])
										.describe(
											"Indicate whether you want to allow attendees to be able to view only answered questions or all questions.\n\n* `answered` - Attendees are able to view answered questions only.\n\n*  `all` - Attendees are able to view all questions submitted in the Q&amp;A.",
										),
								),
								attendees_can_comment: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can answer questions or leave a comment in the question thread.\n\n* `false` - Attendees can not answer questions or leave a comment in the question thread",
										),
								),
								attendees_can_upvote: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can select the thumbs up button to bring popular questions to the top of the Q&amp;A window.\n\n* `false` - Attendees can't select the thumbs up button on questions.",
										),
								),
							})
							.describe(
								"[Q&amp;A](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0065237) for meeting.",
							),
					),
					language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [language interpretation](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768) for the meeting. If not provided, the default value will be based on the user's setting.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two country IDs.\n\nOnly system-supported languages are allowed: `US` (English), `CN` (Chinese), `JP` (Japanese), `DE` (German), `FR` (French), `RU` (Russian), `PT` (Portuguese), `ES` (Spanish), and `KR` (Korean).\n\nFor example, to set an interpreter translating from English to Chinese, use `US,CN`.",
														),
												),
												interpreter_languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two languages.\n\nTo get this value, use the `language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/docs/api/users/#tag/users/GET/users/{userId}/settings) API response.\n\n**languages**: System-supported languages include `English`, `Chinese`, `Japanese`, `German`, `French`, `Russian`, `Portuguese`, `Spanish`, and `Korean`.\n\n**custom_languages**: User-defined languages added by the user.\n\nFor example, an interpreter translating between English and French should use `English,French`.",
														),
												),
											}),
										)
										.describe("Information about the meeting's language interpreters."),
								),
							})
							.describe(
								"The meeting's [language interpretation settings](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768). Make sure to add the language in the web portal in order to use it in the API. See link for details.\n\n**Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.",
							),
					),
					sign_language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the meeting. If not provided, the default value will be based on the user's setting.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												sign_language: z.optional(
													z
														.string()
														.describe(
															"The interpreter's sign language. \n\n To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/api-reference/zoom-api/methods#operation/userSettings) API response.",
														),
												),
											}),
										)
										.max(20)
										.describe("Information about the meeting's sign language interpreters."),
								),
							})
							.describe(
								"The meeting's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details. \n\n**Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.",
							),
					),
					meeting_authentication: z.optional(
						z
							.boolean()
							.describe(
								"If true, only [authenticated](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) users can join the meeting.",
							),
					),
					meeting_invitees: z.optional(
						z
							.array(
								z.object({
									email: z.optional(z.email().describe("The invitee's email address.")),
								}),
							)
							.describe("A list of the meeting's invitees."),
					),
					mute_upon_entry: z.optional(
						z.boolean().default(false).describe("Whether to mute participants upon entry."),
					),
					participant_video: z.optional(
						z.boolean().describe("Whether to start meetings with the participant video on."),
					),
					private_meeting: z.optional(
						z.boolean().describe("Whether to set the meeting as private."),
					),
					registrants_confirmation_email: z.optional(
						z
							.boolean()
							.describe(
								"Whether to send registrants an email confirmation. \n* `true` - Send a confirmation email. \n* `false` - Do not send a confirmation email.",
							),
					),
					registrants_email_notification: z.optional(
						z
							.boolean()
							.describe(
								"Whether to send registrants email notifications about their registration approval, cancellation, or rejection.\n\n* `true` - Send an email notification.\n* `false` - Do not send an email notification.\n\n Set this value to `true` to also use the `registrants_confirmation_email` parameter.",
							),
					),
					registration_type: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3)])
							.default(1)
							.describe(
								"The meeting's registration type. \n* `1` - Attendees register once and can attend any meeting occurrence. \n* `2` - Attendees must register for each meeting occurrence. \n* `3` - Attendees register once and can select one or more meeting occurrences to attend.\n\nThis field is only for recurring meetings with fixed times (`8`). This value defaults to `1`.",
							),
					),
					show_share_button: z.optional(
						z
							.boolean()
							.describe(
								"Whether to include social media sharing buttons on the meeting's registration page. This setting is only applied to meetings with registration enabled.",
							),
					),
					show_join_info: z.optional(
						z
							.boolean()
							.describe(
								"Whether to show the meeting's join information on the registration confirmation page. This setting is only applied to meetings with registration enabled.",
							),
					),
					use_pmi: z.optional(
						z
							.boolean()
							.describe(
								"Whether to use a [Personal Meeting ID (PMI)](/docs/api/using-zoom-apis/#understanding-personal-meeting-id-pmi) for the meeting. This field is only used for scheduled meetings(`2`) and recurring meetings with no fixed time(`3`). If not provided, the default value will be based on the user's setting.",
							),
					),
					waiting_room: z.optional(
						z
							.boolean()
							.describe(
								"Whether to enable the [**Waiting Room** feature](https://support.zoom.us/hc/en-us/articles/115000332726-Waiting-Room). If this value is `true`, this **disables** the `join_before_host` setting.",
							),
					),
					waiting_room_options: z.optional(
						z
							.object({
								mode: z
									.enum(["follow_setting", "custom"])
									.describe(
										"Specifies the waiting room behavior for this meeting.\r\n* `follow_setting` - Use the Zoom web portal setting.\r\n* `custom` - Specify which participants should go into the waiting room.",
									),
								who_goes_to_waiting_room: z.optional(
									z
										.enum([
											"everyone",
											"users_not_in_account",
											"users_not_in_account_or_whitelisted_domains",
											"users_not_on_invite",
										])
										.describe(
											"Specifies which participants should be placed into the waiting room. Required if `mode` is set to `custom`.\r\n* `everyone` - Everyone.\r\n* `users_not_in_account` - Users not in your account.\r\n* `users_not_in_account_or_whitelisted_domains` - Users who are not in your account and not part of your whitelisted domains.\r\n* `users_not_on_invite` - Users not on the meeting invite.",
										),
								),
							})
							.describe("Configuration settings for the meeting's waiting room."),
					),
					watermark: z.optional(
						z
							.boolean()
							.describe(
								"Whether to add a watermark when viewing a shared screen. If not provided, the default value will be based on the user's setting.",
							),
					),
					host_save_video_order: z.optional(
						z
							.boolean()
							.describe("Whether the **Allow host to save video order** feature is enabled."),
					),
					alternative_host_update_polls: z.optional(
						z
							.boolean()
							.describe(
								"Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.",
							),
					),
					alternative_host_manage_meeting_summary: z.optional(
						z
							.boolean()
							.describe("Whether to allow an alternative host to manage meeting summaries."),
					),
					alternative_host_manage_cloud_recording: z.optional(
						z
							.boolean()
							.describe("Whether to allow an alternative host to manage meeting cloud recordings."),
					),
					internal_meeting: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Whether to set the meeting as an internal meeting."),
					),
					continuous_meeting_chat: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable the **Enable continuous meeting chat** setting. The default value is based on user settings. When the **Enable continuous meeting chat** setting is enabled, the default value is true. When the setting is disabled, the default value is false.",
										),
								),
								auto_add_invited_external_users: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable the **Automatically add invited external users** setting.",
										),
								),
								auto_add_meeting_participants: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable the **Automatically add meeting participants** setting.",
										),
								),
							})
							.describe(
								"Information about the **Enable continuous meeting chat** feature. This setting only applies to scheduled and recurring meetings, types `2`, `3`, and `8`. It is **not supported** for type `1` instant meetings or type `10` screen share only meetings.",
							),
					),
					participant_focused_meeting: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Whether to set the meeting as a participant focused meeting."),
					),
					push_change_to_calendar: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to push meeting changes to the calendar. \n\n To enable this feature, configure the **Configure Calendar and Contacts Service** in the user's profile page of the Zoom web portal and enable the **Automatically sync Zoom calendar events information bi-directionally between Zoom and integrated calendars.** setting in the **Settings** page of the Zoom web portal.\n* `true` - Push meeting changes to the calendar.\n* `false` - Do not push meeting changes to the calendar.",
							),
					),
					resources: z.optional(
						z
							.array(
								z.object({
									resource_type: z.optional(z.enum(["whiteboard"]).describe("The resource type.")),
									resource_id: z.optional(z.string().describe("The resource ID.")),
									permission_level: z.optional(
										z
											.enum(["editor", "commenter", "viewer"])
											.default("editor")
											.describe(
												"The permission levels for users to access the whiteboard. \n* `editor` - Users with link access can edit the board. \n* `commenter` - Users with link access can comment on the board. \n* `viewer` - Users with link access can view the board.",
											),
									),
								}),
							)
							.describe("The meeting's resources."),
					),
					auto_start_meeting_summary: z.optional(
						z
							.boolean()
							.describe(
								"Whether to automatically start a meeting summary. If not provided, the default value will be based on the user's setting.",
							),
					),
					who_will_receive_summary: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4)])
							.describe(
								"Defines who will receive a summary after this meeting. This field is applicable only when `auto_start_meeting_summary` is set to `true`.\n\n* `1` - Only meeting host.\n\n* `2` - Only meeting host, co-hosts, and alternative hosts.\n\n* `3` - Only meeting host and meeting invitees in our organization.\n\n* `4` - All meeting invitees including those outside of our organization. If not provided, the default value will be based on the user's setting.",
							),
					),
					auto_start_ai_companion_questions: z.optional(
						z
							.boolean()
							.describe(
								"Whether to automatically start AI Companion questions. If not provided, the default value will be based on the user's setting.",
							),
					),
					who_can_ask_questions: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4), z.literal(5)])
							.describe(
								"Defines who can ask questions about this meeting's transcript. This field is applicable only when `auto_start_ai_companion_questions` is set to `true`.\n\n* `1` - All participants and invitees.\n\n* `2` - All participants only from when they join.\n\n* `3` - Only meeting host.\n\n* `4` - Participants and invitees in our organization.\n\n* `5` - Participants in our organization only from when they join. If not provided, the default value will be based on the user's setting.",
							),
					),
					summary_template_id: z.optional(
						z
							.string()
							.describe(
								"The summary template ID used to generate a meeting summary based on a predefined template. To get available summary templates, use the **Get user summary templates** API. If not provided, the default value will be based on the user's setting. To enable this feature for your account, please [contact Zoom Support](https://support.zoom.com/hc/en).",
							),
					),
					device_testing: z.optional(
						z.boolean().default(false).describe("Enable the device testing."),
					),
					request_permission_to_unmute_participants: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to enable the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting) setting. This option cannot be used together with `allow_host_control_participant_mute_state`, only one of the two can be enabled at a time.",
							),
					),
					allow_host_control_participant_mute_state: z.optional(
						z
							.boolean()
							.describe(
								"Whether to allow the host and co-hosts to fully control the mute state of participants. If not provided, the default value will be based on the user's setting. This option cannot be used together with `request_permission_to_unmute_participants`, only one of the two can be enabled at a time.",
							),
					),
					disable_participant_video: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to disable the participant video during meeting. To enable this feature for your account, please [contact Zoom Support](https://support.zoom.us/hc/en-us).",
							),
					),
					email_in_attendee_report: z.optional(
						z
							.boolean()
							.describe(
								"Whether to include authenticated guest's email addresses in meetings' attendee reports.",
							),
					),
				})
				.describe("Information about the meeting's settings."),
		),
		start_time: z.optional(
			z
				.string()
				.datetime()
				.describe(
					"The meeting's start time. This field is only used for scheduled or recurring meetings with a fixed time. This supports local time and GMT formats. \n* To set a meeting's start time in GMT, use the `yyyy-MM-ddTHH:mm:ssZ` date-time format, such as `2020-03-31T12:02:00Z`. \n* To set a meeting's start time using a specific timezone, use the `yyyy-MM-ddTHH:mm:ss` date-time format and specify the [timezone ID](/docs/api/references/abbreviations/#timezones) in the `timezone` field. If you do not specify a timezone, the `timezone` value defaults to your Zoom account's timezone. You can also use `UTC` for the `timezone` value.\n\n**Note:** If `start_time` is not specified or is set to a past value, it defaults to the current time.",
				),
		),
		template_id: z.optional(
			z
				.string()
				.describe(
					"The account admin meeting template ID used to schedule a meeting using a [meeting template](https://support.zoom.us/hc/en-us/articles/360036559151-Meeting-templates). For a list of account admin-provided meeting templates, use the [**List meeting templates**](/docs/api-reference/zoom-api/methods#operation/listMeetingTemplates) API. \n* At this time, this field **only** accepts account admin meeting template IDs. \n* To enable the account admin meeting templates feature, [contact Zoom support](https://support.zoom.us/hc/en-us).",
				),
		),
		timezone: z.optional(
			z
				.string()
				.describe(
					"The timezone to assign to the `start_time` value. This field is only used for scheduled or recurring meetings with a fixed time.\n\nFor a list of supported timezones and their formats, see our [timezone list](/docs/api/references/abbreviations/#timezones).",
				),
		),
		topic: z.optional(z.string().max(200).describe("The meeting's topic.")),
		tracking_fields: z.optional(
			z
				.array(
					z.object({
						field: z.string().describe("The tracking field's label."),
						value: z.optional(z.string().describe("The tracking field's value.")),
					}),
				)
				.describe("Information about the meeting's tracking fields."),
		),
		type: z.optional(
			z
				.union([z.literal(1), z.literal(2), z.literal(3), z.literal(8), z.literal(10)])
				.default(2)
				.describe(
					"The type of meeting.\n* `1` - An instant meeting. \n* `2` - A scheduled meeting. \n* `3` - A recurring meeting with no fixed time. \n* `8` - A recurring meeting with fixed time. \n* `10` - A screen share only meeting.",
				),
		),
	})
	.describe("The base meeting object.");

export const meetingCreateMutationResponseSchema = z.lazy(() => meetingCreate201Schema);

export const listUpcomingMeetingPathParamsSchema = z.object({
	userId: z
		.string()
		.describe(
			"The user's user ID or email address. For user-level apps, pass [the `me` value](/docs/api/rest/using-zoom-apis/#the-me-keyword).",
		),
});

/**
 * @description **HTTP Status Code:** `200` List of upcoming meeting objects returned.
 */
export const listUpcomingMeeting200Schema = z.object({
	total_records: z.optional(
		z.int().describe("The total number of all records available across all pages."),
	),
	meetings: z.optional(
		z
			.array(
				z.object({
					id: z.optional(
						z
							.int()
							.describe(
								"The [meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-) - a unique identifier of the meeting in **long** format, represented as int64 data type in JSON. Also known as the meeting number.",
							),
					),
					topic: z.optional(z.string().describe("The meeting topic.")),
					type: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3), z.literal(8)])
							.describe(
								"Meeting types.\n`1` - Instant meeting.\n`2` - Scheduled meeting.\n`3` - Recurring meeting with no fixed time.\n`8` - Recurring meeting with a fixed time.",
							),
					),
					start_time: z.optional(z.string().datetime().describe("The meeting's start time.")),
					duration: z.optional(z.int().describe("Meeting duration.")),
					timezone: z.optional(
						z.string().describe("The timezone to format the meeting start time."),
					),
					created_at: z.optional(z.string().datetime().describe("The meeting creation time.")),
					join_url: z.optional(
						z.string().describe("The URL that participants can use to join a meeting."),
					),
					passcode: z.optional(
						z
							.string()
							.describe(
								"The meeting passcode. This passcode may only contain characters `[a-z A-Z 0-9 @ - _ * !]`.",
							),
					),
					use_pmi: z.optional(
						z
							.boolean()
							.describe(
								"Use a [personal meeting ID (PMI)](/docs/api/rest/using-zoom-apis/#understanding-personal-meeting-id-pmi). Only used for scheduled meetings and recurring meetings with no fixed time.",
							),
					),
					is_host: z.optional(
						z.boolean().describe("Whether the current user is the host of the meeting."),
					),
					is_all_day: z.optional(
						z.boolean().describe("Whether the meeting is scheduled as an all-day event."),
					),
				}),
			)
			.describe("List of upcoming meeting objects."),
	),
});

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n User does not exist: {userId}. <br>\n
 */
export const listUpcomingMeeting404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const listUpcomingMeeting429Schema = z.unknown();

export const listUpcomingMeetingQueryResponseSchema = z.lazy(() => listUpcomingMeeting200Schema);

export const userPACsPathParamsSchema = z.object({
	userId: z
		.string()
		.describe("The user's user ID or email address. For user-level apps, pass the `me` value."),
});

/**
 * @description **HTTP Status Code:** `200`   \n \n PAC account list returned.
 */
export const userPACs200Schema = z.object({
	pac_accounts: z.optional(
		z
			.array(
				z.object({
					conference_id: z.optional(z.int().describe("The conference ID.")),
					dedicated_dial_in_number: z.optional(
						z
							.array(
								z.object({
									country: z.optional(z.string().describe("The dial-in country code.")),
									number: z.optional(z.string().max(16).describe("The dial-in number.")),
								}),
							)
							.describe("Information about the account's dedicated dial-in numbers."),
					),
					global_dial_in_numbers: z.optional(
						z
							.array(
								z.object({
									country: z.optional(z.string().describe("The global dial-in country code.")),
									number: z.optional(z.string().max(16).describe("The global dial-in number.")),
								}),
							)
							.describe("Information about the account's global dial-in numbers."),
					),
					listen_only_password: z.optional(
						z.string().max(6).describe("The listen-only password, up to six characters in length."),
					),
					participant_password: z.optional(
						z.string().max(6).describe("The participant password, up to six characters in length."),
					),
				}),
			)
			.describe("Information about the PAC accounts."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `2024` <br>\n User does not have PAC enabled. <br>\n
 */
export const userPACs400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: $userId <br>\n
 */
export const userPACs404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const userPACs429Schema = z.unknown();

export const userPACsQueryResponseSchema = z.lazy(() => userPACs200Schema);

export const createBatchPollsPathParamsSchema = z.object({
	meetingId: z.string(),
});

/**
 * @description **HTTP Status Code:** `201`   \n \nMeeting Poll Created
 */
export const createBatchPolls201Schema = z.object({
	polls: z.optional(
		z.array(
			z.object({
				anonymous: z.optional(
					z
						.boolean()
						.describe(
							"Whether to allow meeting participants to answer poll questions anonymously: \n* `true` &mdash; Anonymous polls enabled. \n* `false` &mdash; Participants cannot answer poll questions anonymously.",
						),
				),
				id: z.optional(z.string().describe("Meeting Poll ID")),
				poll_type: z.optional(
					z
						.union([z.literal(1), z.literal(2), z.literal(3)])
						.describe(
							"The type of poll: \n* `1` &mdash; Poll. \n* `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account. \n* `3` &mdash; Quiz. This feature must be enabled in your Zoom account.",
						),
				),
				questions: z.optional(
					z
						.array(
							z.object({
								answer_max_character: z.optional(
									z
										.int()
										.describe(
											"The allowed maximum number of characters. This field only returns for `short_answer` and `long_answer` polls.",
										),
								),
								answer_min_character: z.optional(
									z
										.int()
										.describe(
											"The allowed minimum number of characters. This field only returns for `short_answer` and `long_answer` polls.",
										),
								),
								answer_required: z.optional(
									z
										.boolean()
										.describe(
											"Whether participants must answer the question: \n* `true` &mdash; The participant must answer the question. \n* `false` &mdash; The participant does not need to answer the question.",
										),
								),
								answers: z.optional(
									z.array(z.string()).describe("The poll question's available answers."),
								),
								case_sensitive: z.optional(
									z
										.boolean()
										.default(false)
										.describe(
											"Whether the correct answer is case sensitive. This field only returns for `fill_in_the_blank` polls: \n* `true` &mdash; The answer is case-sensitive. \n* `false` &mdash; The answer is not case-sensitive.",
										),
								),
								name: z.optional(
									z
										.string()
										.describe(
											"The poll question's title. For `fill_in_the_blank` polls, this field is the poll's question.",
										),
								),
								prompts: z.optional(
									z
										.array(
											z.object({
												prompt_question: z.optional(
													z.string().describe("The question prompt's title."),
												),
												prompt_right_answers: z.optional(
													z.array(z.string()).describe("The question prompt's correct answers."),
												),
											}),
										)
										.describe(
											"The information about the prompt questions. This object only returns for `matching` and `rank_order` polls.",
										),
								),
								rating_max_label: z.optional(
									z
										.string()
										.describe(
											"The high score label for the `rating_max_value` field. This field only returns for `rating_scale` polls.",
										),
								),
								rating_max_value: z.optional(
									z
										.int()
										.max(10)
										.describe(
											"The rating scale's maximum value. This field only returns for `rating_scale` polls.",
										),
								),
								rating_min_label: z.optional(
									z
										.string()
										.describe(
											"The low score label for the `rating_min_value` field. This field only returns for `rating_scale` polls.",
										),
								),
								rating_min_value: z.optional(
									z
										.int()
										.describe(
											"The rating scale's minimum value. This field only returns for `rating_scale` polls.",
										),
								),
								right_answers: z.optional(
									z.array(z.string()).describe("The poll question's correct answer(s)."),
								),
								show_as_dropdown: z.optional(
									z
										.boolean()
										.describe(
											"Whether to display the radio selection as a drop-down box: \n* `true` &mdash; Show as a drop-down box. \n* `false` &mdash; Do not show as a drop-down box.",
										),
								),
								type: z.optional(
									z
										.enum([
											"single",
											"multiple",
											"matching",
											"rank_order",
											"short_answer",
											"long_answer",
											"fill_in_the_blank",
											"rating_scale",
										])
										.describe(
											"The poll's question and answer type: \n* `single` &mdash; Single choice. \n* `multiple` &mdash; Multiple choice. \n* `matching` &mdash; Matching. \n* `rank_order` &mdash; Rank order. \n* `short_answer` &mdash; Short answer. \n* `long_answer` &mdash; Long answer. \n* `fill_in_the_blank` &mdash; Fill in the blank. \n* `rating_scale` &mdash; Rating scale.",
										),
								),
							}),
						)
						.describe("The information about the poll's questions."),
				),
				status: z.optional(
					z
						.enum(["notstart", "started", "ended", "sharing"])
						.describe(
							"The status of the meeting poll:  \n `notstart` - Poll not started  \n `started` - Poll started  \n `ended` - Poll ended  \n `sharing` - Sharing poll results",
						),
				),
				title: z.optional(z.string().describe("The title for the poll.")),
			}),
		),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid Meeting ID. <br>\n**Error Code:** `3000` <br>\n Cannot access meeting information. <br>\n**Error Code:** `4400` <br>\n You can only add a maximum of 50 polls.  <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n**Error Code:** `4400` <br>\n Meeting polls disabled. To enable this feature, enable the \"Meeting Polls/Quizzes\" setting in the Zoom web portal\'s \"Settings\" interface.  <br>\n**Error Code:** `4400` <br>\n Advanced meeting polls disabled. To enable this feature, enable the \"Allow host to create advanced polls and quizzes\" setting in the Zoom web portal\'s \"Settings\" interface. <br>\n
 */
export const createBatchPolls400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const createBatchPolls404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const createBatchPolls429Schema = z.unknown();

/**
 * @description The batch meeting poll object
 */
export const createBatchPollsMutationRequestSchema = z.object({
	polls: z.optional(
		z
			.array(
				z.object({
					anonymous: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to allow meeting participants to answer poll questions anonymously: \n* `true` &mdash; Anonymous polls enabled. \n* `false` &mdash; Participants cannot answer poll questions anonymously. \n\nThis value defaults to `false`.",
							),
					),
					poll_type: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3)])
							.default(1)
							.describe(
								"The type of poll: \n* `1` &mdash; Poll. \n* `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account. \n* `3` &mdash; Quiz. This feature must be enabled in your Zoom account. \n\n This value defaults to `1`.",
							),
					),
					questions: z.optional(
						z
							.array(
								z.object({
									answer_max_character: z.optional(
										z
											.int()
											.describe(
												"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: \n* For `short_answer` polls, a maximum of 500 characters. \n* For `long_answer` polls, a maximum of 2,000 characters.",
											),
									),
									answer_min_character: z.optional(
										z
											.int()
											.min(1)
											.describe(
												"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.",
											),
									),
									answer_required: z.optional(
										z
											.boolean()
											.default(false)
											.describe(
												"Whether participants must answer the question: \n* `true` &mdash; The participant must answer the question. \n* `false` &mdash; The participant does not need to answer the question. \n\n**Note:** \n* When the poll's `type` value is `1` (Poll), this value defaults to `true`. \n* When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.",
											),
									),
									answers: z.optional(
										z
											.array(z.string())
											.min(2)
											.describe(
												"The poll question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` polls, you can only provide a maximum of 10 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
											),
									),
									case_sensitive: z.optional(
										z
											.boolean()
											.default(false)
											.describe(
												"Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: \n* `true` &mdash; The answer is case-sensitive. \n* `false` &mdash; The answer is not case-sensitive. \n\nThis value defaults to `false`.",
											),
									),
									name: z.optional(
										z
											.string()
											.max(1024)
											.describe(
												"The poll question's title, up to 1024 characters. \n\nFor `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.",
											),
									),
									prompts: z.optional(
										z
											.array(
												z.object({
													prompt_question: z.optional(
														z.string().describe("The question prompt's title."),
													),
													prompt_right_answers: z.optional(
														z
															.array(z.string())
															.describe(
																"The question prompt's correct answers: \n* For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. \n* For `rank_order` polls, you can only provide one correct answer.",
															),
													),
												}),
											)
											.describe(
												"The information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
											),
									),
									rating_max_label: z.optional(
										z
											.string()
											.describe(
												"The high score label for the `rating_max_value` field. \n\nThis field only applies to the `rating_scale` poll.",
											),
									),
									rating_max_value: z.optional(
										z
											.int()
											.max(10)
											.describe(
												"The rating scale's maximum value, up to a maximum value of 10. \n\nThis field only applies to the `rating_scale` poll.",
											),
									),
									rating_min_label: z.optional(
										z
											.string()
											.describe(
												"The low score label for the `rating_min_value` field. \n\nThis field only applies to the `rating_scale` poll.",
											),
									),
									rating_min_value: z.optional(
										z
											.int()
											.min(1)
											.describe(
												"The rating scale's minimum value. This value cannot be less than zero. \n\nThis field only applies to the `rating_scale` poll.",
											),
									),
									right_answers: z.optional(
										z
											.array(z.string())
											.min(1)
											.describe(
												"The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). \n\n For `single` and `matching` polls, this field only accepts one answer.",
											),
									),
									show_as_dropdown: z.optional(
										z
											.boolean()
											.default(false)
											.describe(
												"Whether to display the radio selection as a drop-down box: \n* `true` &mdash; Show as a drop-down box. \n* `false` &mdash; Do not show as a drop-down box. \n\nThis value defaults to `false`.",
											),
									),
									type: z.optional(
										z
											.enum([
												"single",
												"multiple",
												"matching",
												"rank_order",
												"short_answer",
												"long_answer",
												"fill_in_the_blank",
												"rating_scale",
											])
											.describe(
												"The poll's question and answer type: \n* `single` &mdash; Single choice. \n* `multiple` &mdash; Multiple choice. \n* `matching` &mdash; Matching. \n* `rank_order` &mdash; Rank order. \n* `short_answer` &mdash; Short answer. \n* `long_answer` &mdash; Long answer. \n* `fill_in_the_blank` &mdash; Fill in the blank. \n* `rating_scale` &mdash; Rating scale.",
											),
									),
								}),
							)
							.min(1)
							.describe("The information about the poll's questions."),
					),
					title: z.optional(z.string().max(64).describe("The poll's title, up to 64 characters.")),
				}),
			)
			.min(1)
			.max(25)
			.describe("The information about the meeting's polls."),
	),
});

export const createBatchPollsMutationResponseSchema = z.lazy(() => createBatchPolls201Schema);

export const meetingPollsPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

export const meetingPollsQueryParamsSchema = z
	.object({
		anonymous: z.optional(
			z
				.boolean()
				.describe(
					"Whether to query for polls with the **Anonymous** option enabled: \n* `true` &mdash; Query for polls with the **Anonymous** option enabled. \n* `false` &mdash; Do not query for polls with the **Anonymous** option enabled.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:**   \n \nList polls of a Meeting  returned
 */
export const meetingPolls200Schema = z
	.object({
		polls: z.optional(
			z
				.array(
					z.object({
						id: z.optional(z.string().describe("The poll ID.")),
						status: z.optional(
							z
								.enum(["notstart", "started", "ended", "sharing", "deactivated"])
								.describe(
									"The meeting poll's status.\n`notstart` - Poll not started\n`started` - Poll started\n`ended` - Poll ended\n`sharing` - Sharing poll results\n`deactivated` - Poll deactivated",
								),
						),
						anonymous: z.optional(
							z
								.boolean()
								.default(false)
								.describe(
									"Whether meeting participants can answer poll questions anonymously. \n\nThis value defaults to `false`.",
								),
						),
						poll_type: z.optional(
							z
								.union([z.literal(1), z.literal(2), z.literal(3)])
								.describe(
									"The type of poll. \n* `1` - Poll. \n* `2` - Advanced Poll. This feature must be enabled in your Zoom account. \n* `3` - Quiz. This feature must be enabled in your Zoom account. \n\n This value defaults to `1`.",
								),
						),
						questions: z.optional(
							z
								.array(
									z.object({
										answer_max_character: z.optional(
											z
												.int()
												.describe(
													"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: \n* For `short_answer` polls, a maximum of 500 characters. \n* For `long_answer` polls, a maximum of 2,000 characters.",
												),
										),
										answer_min_character: z.optional(
											z
												.int()
												.min(1)
												.describe(
													"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.",
												),
										),
										answer_required: z.optional(
											z
												.boolean()
												.default(false)
												.describe(
													"Whether participants must answer the question: \n* `true` &mdash; The participant must answer the question. \n* `false` &mdash; The participant does not need to answer the question. \n\n**Note:** \n* When the poll's `type` value is `1` (Poll), this value defaults to `true`. \n* When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.",
												),
										),
										answers: z.optional(
											z
												.array(z.string())
												.min(2)
												.describe(
													"The poll question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` polls, you can only provide a maximum of 10 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
												),
										),
										case_sensitive: z.optional(
											z
												.boolean()
												.default(false)
												.describe(
													"Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: \n* `true` &mdash; The answer is case-sensitive. \n* `false` &mdash; The answer is not case-sensitive. \n\nThis value defaults to `false`.",
												),
										),
										name: z.optional(
											z
												.string()
												.max(1024)
												.describe(
													"The poll question, up to 1024 characters. \n\nFor `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.",
												),
										),
										prompts: z.optional(
											z
												.array(
													z.object({
														prompt_question: z.optional(
															z.string().describe("The question prompt's title."),
														),
														prompt_right_answers: z.optional(
															z
																.array(z.string())
																.describe(
																	"The question prompt's correct answers: \n* For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. \n* For `rank_order` polls, you can only provide one correct answer.",
																),
														),
													}),
												)
												.describe(
													"Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
												),
										),
										rating_max_label: z.optional(
											z
												.string()
												.describe(
													"The high score label for the `rating_max_value` field. \n\nThis field only applies to the `rating_scale` poll.",
												),
										),
										rating_max_value: z.optional(
											z
												.int()
												.max(10)
												.describe(
													"The rating scale's maximum value, up to a maximum value of 10. \n\nThis field only applies to the `rating_scale` poll.",
												),
										),
										rating_min_label: z.optional(
											z
												.string()
												.describe(
													"The low score label for the `rating_min_value` field. \n\nThis field only applies to the `rating_scale` poll.",
												),
										),
										rating_min_value: z.optional(
											z
												.int()
												.min(0)
												.describe(
													"The rating scale's minimum value. This value cannot be less than zero. \n\nThis field only applies to the `rating_scale` poll.",
												),
										),
										right_answers: z.optional(
											z
												.array(z.string())
												.min(1)
												.describe(
													"The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). \n\n For `single` and `matching` polls, this field only accepts one answer.",
												),
										),
										show_as_dropdown: z.optional(
											z
												.boolean()
												.default(false)
												.describe(
													"Whether to display the radio selection as a drop-down box: \n* `true` &mdash; Show as a drop-down box. \n* `false` &mdash; Do not show as a drop-down box. \n\nThis value defaults to `false`.",
												),
										),
										type: z.optional(
											z
												.enum([
													"single",
													"multiple",
													"matching",
													"rank_order",
													"short_answer",
													"long_answer",
													"fill_in_the_blank",
													"rating_scale",
												])
												.describe(
													"The poll's question and answer type: \n* `single` &mdash; Single choice. \n* `multiple` &mdash; Multiple choice. \n* `matching` &mdash; Matching. \n* `rank_order` &mdash; Rank order. \n* `short_answer` &mdash; Short answer. \n* `long_answer` &mdash; Long answer. \n* `fill_in_the_blank` &mdash; Fill in the blank. \n* `rating_scale` &mdash; Rating scale.",
												),
										),
									}),
								)
								.describe("Information about the poll's questions."),
						),
						title: z.optional(
							z.string().max(64).describe("The poll's title, up to 64 characters."),
						),
					}),
				)
				.describe("An array of polls."),
		),
		total_records: z.optional(z.int().describe("The number of all records available across pages")),
	})
	.describe("Poll List");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `4400` <br>\n Meeting polls disabled. To enable this feature, enable the \"Meeting Polls/Quizzes\" setting in the Zoom web portal\'s \"Settings\" interface. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingPolls400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `404` <br>\n Meeting Poll not found <br>\n
 */
export const meetingPolls404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingPolls429Schema = z.unknown();

export const meetingPollsQueryResponseSchema = z.lazy(() => meetingPolls200Schema);

export const meetingPollCreatePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `201`   \n \nMeeting Poll Created
 */
export const meetingPollCreate201Schema = z.object({
	id: z.optional(z.string().describe("The meeting poll ID")),
	status: z.optional(
		z
			.enum(["notstart", "started", "ended", "sharing"])
			.describe(
				"The status of the meeting poll:  \n `notstart` - Poll not started  \n `started` - Poll started  \n `ended` - Poll ended  \n `sharing` - Sharing poll results",
			),
	),
	anonymous: z.optional(
		z
			.boolean()
			.default(false)
			.describe(
				"Whether meeting participants answer poll questions anonymously. \n\nThis value defaults to `false`.",
			),
	),
	poll_type: z.optional(
		z
			.union([z.literal(1), z.literal(2), z.literal(3)])
			.describe(
				"The type of poll: \n* `1` &mdash; Poll. \n* `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account. \n* `3` &mdash; Quiz. This feature must be enabled in your Zoom account. \n\n This value defaults to `1`.",
			),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					answer_max_character: z.optional(
						z
							.int()
							.describe(
								"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: \n* For `short_answer` polls, a maximum of 500 characters. \n* For `long_answer` polls, a maximum of 2,000 characters.",
							),
					),
					answer_min_character: z.optional(
						z
							.int()
							.min(1)
							.describe(
								"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.",
							),
					),
					answer_required: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether participants must answer the question: \n* `true` &mdash; The participant must answer the question. \n* `false` &mdash; The participant does not need to answer the question. \n\n**Note:** \n* When the poll's `type` value is `1` (Poll), this value defaults to `true`. \n* When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.",
							),
					),
					answers: z.optional(
						z
							.array(z.string())
							.min(2)
							.describe(
								"The poll question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` polls, you can only provide a maximum of 10 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
							),
					),
					case_sensitive: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: \n* `true` &mdash; The answer is case-sensitive. \n* `false` &mdash; The answer is not case-sensitive. \n\nThis value defaults to `false`.",
							),
					),
					name: z.optional(
						z
							.string()
							.max(1024)
							.describe(
								"The poll question, up to 1024 characters. \n\nFor `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.",
							),
					),
					prompts: z.optional(
						z
							.array(
								z.object({
									prompt_question: z.optional(z.string().describe("The question prompt's title.")),
									prompt_right_answers: z.optional(
										z
											.array(z.string())
											.describe(
												"The question prompt's correct answers: \n* For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. \n* For `rank_order` polls, you can only provide one correct answer.",
											),
									),
								}),
							)
							.describe(
								"The information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
							),
					),
					rating_max_label: z.optional(
						z
							.string()
							.describe(
								"The high score label for the `rating_max_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_max_value: z.optional(
						z
							.int()
							.max(10)
							.describe(
								"The rating scale's maximum value, up to a maximum value of 10. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_label: z.optional(
						z
							.string()
							.describe(
								"The low score label for the `rating_min_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_value: z.optional(
						z
							.int()
							.min(0)
							.describe(
								"The rating scale's minimum value. This value cannot be less than zero. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					right_answers: z.optional(
						z
							.array(z.string())
							.min(1)
							.describe(
								"The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). \n\n For `single` and `matching` polls, this field only accepts one answer.",
							),
					),
					show_as_dropdown: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the radio selection as a drop-down box: \n* `true` &mdash; Show as a drop-down box. \n* `false` &mdash; Do not show as a drop-down box. \n\nThis value defaults to `false`.",
							),
					),
					type: z.optional(
						z
							.enum([
								"single",
								"multiple",
								"matching",
								"rank_order",
								"short_answer",
								"long_answer",
								"fill_in_the_blank",
								"rating_scale",
							])
							.describe(
								"The poll's question and answer type: \n* `single` &mdash; Single choice. \n* `multiple` &mdash; Multiple choice. \n* `matching` &mdash; Matching. \n* `rank_order` &mdash; Rank order. \n* `short_answer` &mdash; Short answer. \n* `long_answer` &mdash; Long answer. \n* `fill_in_the_blank` &mdash; Fill in the blank. \n* `rating_scale` &mdash; Rating scale.",
							),
					),
				}),
			)
			.describe("The information about the poll's questions."),
	),
	title: z.optional(z.string().max(64).describe("The poll's title, up to 64 characters.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `4400` <br>\n * Meeting polls disabled. To enable this feature, enable the \"Meeting Polls/Quizzes\" setting in the Zoom web portal\'s \"Settings\" interface. \n* Advanced meeting polls disabled. To enable this feature, enable the \"Allow host to create advanced polls and quizzes\" setting in the Zoom web portal\'s \"Settings\" interface. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingPollCreate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `404` <br>\n Meeting not found <br>\n
 */
export const meetingPollCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const meetingPollCreate429Schema = z.unknown();

/**
 * @description The meeting poll object.
 */
export const meetingPollCreateMutationRequestSchema = z.object({
	anonymous: z.optional(
		z
			.boolean()
			.default(false)
			.describe(
				"Whether meeting participants answer poll questions anonymously. \n\nThis value defaults to `false`.",
			),
	),
	poll_type: z.optional(
		z
			.union([z.literal(1), z.literal(2), z.literal(3)])
			.describe(
				"The type of poll: \n* `1` &mdash; Poll. \n* `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account. \n* `3` &mdash; Quiz. This feature must be enabled in your Zoom account. \n\n This value defaults to `1`.",
			),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					answer_max_character: z.optional(
						z
							.int()
							.describe(
								"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: \n* For `short_answer` polls, a maximum of 500 characters. \n* For `long_answer` polls, a maximum of 2,000 characters.",
							),
					),
					answer_min_character: z.optional(
						z
							.int()
							.min(1)
							.describe(
								"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.",
							),
					),
					answer_required: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether participants must answer the question: \n* `true` &mdash; The participant must answer the question. \n* `false` &mdash; The participant does not need to answer the question. \n\n**Note:** \n* When the poll's `type` value is `1` (Poll), this value defaults to `true`. \n* When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.",
							),
					),
					answers: z.optional(
						z
							.array(z.string())
							.min(2)
							.describe(
								"The poll question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` polls, you can only provide a maximum of 10 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
							),
					),
					case_sensitive: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: \n* `true` &mdash; The answer is case-sensitive. \n* `false` &mdash; The answer is not case-sensitive. \n\nThis value defaults to `false`.",
							),
					),
					name: z.optional(
						z
							.string()
							.max(1024)
							.describe(
								"The poll question, up to 1024 characters. \n\nFor `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.",
							),
					),
					prompts: z.optional(
						z
							.array(
								z.object({
									prompt_question: z.optional(z.string().describe("The question prompt's title.")),
									prompt_right_answers: z.optional(
										z
											.array(z.string())
											.describe(
												"The question prompt's correct answers: \n* For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. \n* For `rank_order` polls, you can only provide one correct answer.",
											),
									),
								}),
							)
							.describe(
								"The information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
							),
					),
					rating_max_label: z.optional(
						z
							.string()
							.describe(
								"The high score label for the `rating_max_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_max_value: z.optional(
						z
							.int()
							.max(10)
							.describe(
								"The rating scale's maximum value, up to a maximum value of 10. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_label: z.optional(
						z
							.string()
							.describe(
								"The low score label for the `rating_min_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_value: z.optional(
						z
							.int()
							.min(0)
							.describe(
								"The rating scale's minimum value. This value cannot be less than zero. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					right_answers: z.optional(
						z
							.array(z.string())
							.min(1)
							.describe(
								"The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). \n\n For `single` and `matching` polls, this field only accepts one answer.",
							),
					),
					show_as_dropdown: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the radio selection as a drop-down box: \n* `true` &mdash; Show as a drop-down box. \n* `false` &mdash; Do not show as a drop-down box. \n\nThis value defaults to `false`.",
							),
					),
					type: z.optional(
						z
							.enum([
								"single",
								"multiple",
								"matching",
								"rank_order",
								"short_answer",
								"long_answer",
								"fill_in_the_blank",
								"rating_scale",
							])
							.describe(
								"The poll's question and answer type: \n* `single` &mdash; Single choice. \n* `multiple` &mdash; Multiple choice. \n* `matching` &mdash; Matching. \n* `rank_order` &mdash; Rank order. \n* `short_answer` &mdash; Short answer. \n* `long_answer` &mdash; Long answer. \n* `fill_in_the_blank` &mdash; Fill in the blank. \n* `rating_scale` &mdash; Rating scale.",
							),
					),
				}),
			)
			.describe("The information about the poll's questions."),
	),
	title: z.optional(z.string().max(64).describe("The poll's title, up to 64 characters.")),
});

export const meetingPollCreateMutationResponseSchema = z.lazy(() => meetingPollCreate201Schema);

export const meetingPollGetPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, store it as a `long` format integer, not a simple integer. Meeting IDs can exceed 10 digits.",
		),
	pollId: z.string().describe("The poll ID."),
});

/**
 * @description **HTTP Status Code:** `200`   \n \nMeeting Poll object returned
 */
export const meetingPollGet200Schema = z.object({
	id: z.optional(z.string().describe("The meeting poll ID.")),
	status: z.optional(
		z
			.enum(["notstart", "started", "ended", "sharing", "deactivated"])
			.describe(
				"The meeting poll's status.\n`notstart` - Poll not started\n`started` - Poll started\n`ended` - Poll ended\n`sharing` - Sharing poll results\n`deactivated` - Poll deactivated",
			),
	),
	anonymous: z.optional(
		z
			.boolean()
			.default(false)
			.describe(
				"Whether meeting participants answer poll questions anonymously. \n\nThis value defaults to `false`.",
			),
	),
	poll_type: z.optional(
		z
			.union([z.literal(1), z.literal(2), z.literal(3)])
			.describe(
				"The poll's type. \n* `1` - Poll. \n* `2` - Advanced poll. This feature must be enabled in your Zoom account. \n* `3` - Quiz. This feature must be enabled in your Zoom account. \n\n This value defaults to `1`.",
			),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					answer_max_character: z.optional(
						z
							.int()
							.describe(
								"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls. \n* For `short_answer` polls, a maximum of 500 characters. \n* For `long_answer` polls, a maximum of 2,000 characters.",
							),
					),
					answer_min_character: z.optional(
						z
							.int()
							.min(1)
							.describe(
								"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a one-character minimum value.",
							),
					),
					answer_required: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether participants must answer the question. \n* `true` - The participant must answer the question. \n* `false` - The participant does not need to answer the question. \n\n**Note:** \n* When the poll's `type` value is `1` (Poll), this value defaults to `true`. \n* When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.",
							),
					),
					answers: z.optional(
						z
							.array(z.string())
							.min(2)
							.describe(
								"The poll question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` polls, you can only provide a maximum of 10 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
							),
					),
					case_sensitive: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: \n* `true` &mdash; The answer is case-sensitive. \n* `false` &mdash; The answer is not case-sensitive. \n\nThis value defaults to `false`.",
							),
					),
					name: z.optional(
						z
							.string()
							.max(1024)
							.describe(
								"The poll question, up to 1024 characters. \n\nFor `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.",
							),
					),
					prompts: z.optional(
						z
							.array(
								z.object({
									prompt_question: z.optional(z.string().describe("The question prompt's title.")),
									prompt_right_answers: z.optional(
										z
											.array(z.string())
											.describe(
												"The question prompt's correct answers: \n* For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. \n* For `rank_order` polls, you can only provide one correct answer.",
											),
									),
								}),
							)
							.describe(
								"The information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
							),
					),
					rating_max_label: z.optional(
						z
							.string()
							.describe(
								"The high score label for the `rating_max_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_max_value: z.optional(
						z
							.int()
							.max(10)
							.describe(
								"The rating scale's maximum value, up to a maximum value of 10. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_label: z.optional(
						z
							.string()
							.describe(
								"The low score label for the `rating_min_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_value: z.optional(
						z
							.int()
							.min(0)
							.describe(
								"The rating scale's minimum value. This value cannot be less than zero. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					right_answers: z.optional(
						z
							.array(z.string())
							.min(1)
							.describe(
								"The poll question's correct answer(s). This field is required if the poll's `type` value is `3` (Quiz). \n\n For `single` and `matching` polls, this field only accepts one answer.",
							),
					),
					show_as_dropdown: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the radio selection as a drop-down box. \n* `true` - Show as a drop-down box. \n* `false` - Do not show as a drop-down box. \n\nThis value defaults to `false`.",
							),
					),
					type: z.optional(
						z
							.enum([
								"single",
								"multiple",
								"matching",
								"rank_order",
								"short_answer",
								"long_answer",
								"fill_in_the_blank",
								"rating_scale",
							])
							.describe(
								"The poll's question and answer type. \n* `single` - Single choice. \n* `multiple` - Multiple choice. \n* `matching` - Matching. \n* `rank_order` - Rank order. \n* `short_answer` - Short answer. \n* `long_answer` - Long answer. \n* `fill_in_the_blank` - Fill in the blank. \n* `rating_scale` - Rating scale.",
							),
					),
				}),
			)
			.describe("Information about the poll's questions."),
	),
	title: z.optional(z.string().max(64).describe("The poll's title, up to 64 characters.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `4400` <br>\n Meeting polls disabled. To enable this feature, enable the \"Meeting Polls/Quizzes\" setting in the Zoom web portal\'s \"Settings\" interface. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingPollGet400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `404` <br>\n Meeting Poll not found. <br>\n
 */
export const meetingPollGet404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingPollGet429Schema = z.unknown();

export const meetingPollGetQueryResponseSchema = z.lazy(() => meetingPollGet200Schema);

export const meetingPollUpdatePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
	pollId: z.string().describe("The poll ID."),
});

/**
 * @description **HTTP Status Code:** `204`   \n \nMeeting Poll Updated
 */
export const meetingPollUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `4400` <br>\n Meeting polls disabled. To enable this feature, enable the \"Meeting Polls/Quizzes\" setting in the Zoom web portal\'s \"Settings\" interface.  <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n**Error Code:** `4400` <br>\n Advanced meeting polls disabled. To enable this feature, enable the **Allow host to create advanced polls and quizzes** setting in the Zoom web portal\'s **Settings** interface. <br>\n
 */
export const meetingPollUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `404` <br>\n Meeting Poll not found <br>\n**Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingPollUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingPollUpdate429Schema = z.unknown();

/**
 * @description The meeting poll.
 */
export const meetingPollUpdateMutationRequestSchema = z.object({
	anonymous: z.optional(
		z
			.boolean()
			.default(false)
			.describe(
				"Whether meeting participants answer poll questions anonymously. \n\nThis value defaults to `false`.",
			),
	),
	poll_type: z.optional(
		z
			.union([z.literal(1), z.literal(2), z.literal(3)])
			.describe(
				"The type of poll. \n* `1` - Poll. \n* `2` - Advanced Poll. This feature must be enabled in your Zoom account. \n* `3` - Quiz. This feature must be enabled in your Zoom account. \n\n This value defaults to `1`.",
			),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					answer_max_character: z.optional(
						z
							.int()
							.describe(
								"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls. \n* For `short_answer` polls, a maximum of 500 characters. \n* For `long_answer` polls, a maximum of 2,000 characters.",
							),
					),
					answer_min_character: z.optional(
						z
							.int()
							.min(1)
							.describe(
								"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a one character minimum value.",
							),
					),
					answer_required: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether participants must answer the question. \n* `true` - The participant must answer the question. \n* `false` - The participant does not need to answer the question. \n\n**Note:** \n* When the poll's `type` value is `1` (Poll), this value defaults to `true`. \n* When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.",
							),
					),
					answers: z.optional(
						z
							.array(z.string())
							.min(2)
							.describe(
								"The poll question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` polls, you can only provide a maximum of 10 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
							),
					),
					case_sensitive: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: \n* `true` - The answer is case-sensitive. \n* `false` - The answer is not case-sensitive. \n\nThis value defaults to `false`.",
							),
					),
					name: z.optional(
						z
							.string()
							.max(1024)
							.describe(
								"The poll question, up to 1024 characters. \n\nFor `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.",
							),
					),
					prompts: z.optional(
						z
							.array(
								z.object({
									prompt_question: z.optional(z.string().describe("The question prompt's title.")),
									prompt_right_answers: z.optional(
										z
											.array(z.string())
											.describe(
												"The question prompt's correct answers: \n* For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. \n* For `rank_order` polls, you can only provide one correct answer.",
											),
									),
								}),
							)
							.describe(
								"The information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You must provide a minimum of two prompts, up to a maximum of 10 prompts.",
							),
					),
					rating_max_label: z.optional(
						z
							.string()
							.describe(
								"The high score label for the `rating_max_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_max_value: z.optional(
						z
							.int()
							.max(10)
							.describe(
								"The rating scale's maximum value, up to a maximum value of 10. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_label: z.optional(
						z
							.string()
							.describe(
								"The low score label for the `rating_min_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_value: z.optional(
						z
							.int()
							.min(0)
							.describe(
								"The rating scale's minimum value. This value cannot be less than zero. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					right_answers: z.optional(
						z
							.array(z.string())
							.min(1)
							.describe(
								"The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). \n\n For `single` and `matching` polls, this field only accepts one answer.",
							),
					),
					show_as_dropdown: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the radio selection as a drop-down box. \n* `true` - Show as a drop-down box. \n* `false` - Do not show as a drop-down box. \n\nThis value defaults to `false`.",
							),
					),
					type: z.optional(
						z
							.enum([
								"single",
								"multiple",
								"matching",
								"rank_order",
								"short_answer",
								"long_answer",
								"fill_in_the_blank",
								"rating_scale",
							])
							.describe(
								"The poll's question and answer type. \n* `single` - Single choice. \n* `multiple` - Multiple choice. \n* `matching` - Matching. \n* `rank_order` - Rank order. \n* `short_answer` - Short answer. \n* `long_answer` - Long answer. \n* `fill_in_the_blank` - Fill in the blank. \n* `rating_scale` - Rating scale.",
							),
					),
				}),
			)
			.describe("The information about the poll's questions."),
	),
	title: z.optional(z.string().max(64).describe("The poll's title, up to 64 characters.")),
});

export const meetingPollUpdateMutationResponseSchema = z.lazy(() => meetingPollUpdate204Schema);

export const meetingPollDeletePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
	pollId: z.string().describe("The poll ID"),
});

/**
 * @description **HTTP Status Code:** `204`   \n \nMeeting Poll deleted
 */
export const meetingPollDelete204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `4400` <br>\n Meeting polls disabled. To enable this feature, enable the **Meeting Polls/Quizzes** setting in the Zoom web portal\'s **Settings** interface. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingPollDelete400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `404` <br>\n Meeting poll not found. <br>\n
 */
export const meetingPollDelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingPollDelete429Schema = z.unknown();

export const meetingPollDeleteMutationResponseSchema = z.lazy(() => meetingPollDelete204Schema);

export const listPastMeetingPollsPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"The meeting's ID or universally unique ID (UUID). \n* If you provide a meeting ID, the API will return a response for the latest meeting instance. \n* If you provide a meeting UUID that begins with a `/` character or contains the `//` characters, you **must** double-encode the meeting UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200` **OK**  \n \nPolls returned successfully.
 */
export const listPastMeetingPolls200Schema = z.object({
	id: z.optional(
		z
			.int()
			.describe(
				"[Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in **long** format(represented as int64 data type in JSON), also known as the meeting number.",
			),
	),
	questions: z.optional(
		z.array(
			z.object({
				email: z.optional(
					z
						.string()
						.describe(
							"Email address of the user who submitted answers to the poll. If the user is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for details.",
						),
				),
				name: z.optional(
					z
						.string()
						.describe(
							"Name of the user who submitted answers to the poll. If `anonymous` option is enabled for a poll, the participant's polling information will be kept anonymous and the value of `name` field will be `Anonymous Attendee`.",
						),
				),
				question_details: z.optional(
					z.array(
						z.object({
							answer: z.optional(z.string().describe("Answer submitted by the user.")),
							date_time: z.optional(
								z
									.string()
									.datetime()
									.describe("Date and time at which the answer to the poll was submitted."),
							),
							polling_id: z.optional(z.string().describe("Unique identifier of the poll.")),
							question: z.optional(z.string().describe("Question asked during the poll.")),
						}),
					),
				),
			}),
		),
	),
	start_time: z.optional(z.string().datetime().describe("The start time of the meeting.")),
	uuid: z.optional(z.string().describe("Meeting UUID.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `12702` <br>\n Can not access a meeting a year ago. <br>\n
 */
export const listPastMeetingPolls400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const listPastMeetingPolls429Schema = z.unknown();

export const listPastMeetingPollsQueryResponseSchema = z.lazy(() => listPastMeetingPolls200Schema);

export const reportSignInSignOutActivitiesQueryParamsSchema = z
	.object({
		from: z.optional(
			z.iso
				.date()
				.describe(
					"Start date for which you would like to view the activity logs report. Using the `from` and `to` parameters, specify a monthly date range for the report as the API only provides one month worth of data in one request. The specified date range should fall within the last six months.",
				),
		),
		to: z.optional(
			z.iso
				.date()
				.describe("End date up to which you would like to view the activity logs report."),
		),
		page_size: z.optional(
			z.coerce
				.number()
				.int()
				.describe("The number of records to be returned within a single API call"),
		),
		next_page_token: z.optional(
			z.string().describe("Next page token is used to paginate through large result sets"),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `200`  \n \nSuccess
 */
export const reportSignInSignOutActivities200Schema = z
	.object({
		activity_logs: z.optional(
			z
				.array(
					z.object({
						client_type: z.optional(
							z
								.string()
								.describe("The client interface type using which the activity was performed."),
						),
						email: z.optional(
							z.email().describe("Email address of the user used for the activity."),
						),
						ip_address: z.optional(z.string().describe("The IP address of the user's device.")),
						time: z.optional(
							z.string().datetime().describe("Time during which the activity occurred."),
						),
						type: z.optional(
							z
								.enum(["Sign in", "Sign out"])
								.describe(
									"The type of activity. \n* `Sign in` &mdash; Sign in activity by user. \n* `Sign out` &mdash; Sign out activity by user.",
								),
						),
						version: z.optional(z.string().describe("Zoom client version of the user.")),
					}),
				)
				.describe("Array of activity logs."),
		),
		from: z.optional(
			z
				.string()
				.describe("Start date from which you want the activity logs report to be generated."),
		),
		next_page_token: z.optional(
			z
				.string()
				.describe(
					"The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.",
				),
		),
		page_size: z.optional(
			z.int().describe("The number of records returned with a single API call."),
		),
		to: z.optional(
			z.string().describe("End date until which you want the activity logs report to be generated"),
		),
	})
	.describe("Report object");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request\n\n**Error Code:** `200` <br>\nNo permission.<br>\n\n
 */
export const reportSignInSignOutActivities400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportSignInSignOutActivities429Schema = z.unknown();

export const reportSignInSignOutActivitiesQueryResponseSchema = z.lazy(
	() => reportSignInSignOutActivities200Schema,
);

/**
 * @description **HTTP Status Code:** `200` **OK**  \n \nBilling report returned.
 */
export const getBillingReport200Schema = z.object({
	billing_reports: z.optional(
		z.array(
			z.object({
				end_date: z.optional(z.iso.date().describe("End date of the billing period.")),
				id: z.optional(
					z
						.string()
						.describe(
							"Unique Identifier of the report. Use this ID to retrieve billing invoice via the &quot;Get Billing Invoices API&quot;. \n\nYou can also use this ID to export a CSV file of the billing report from this URL: `https://zoom.us/account/report/billing/export?id={id}`.",
						),
				),
				start_date: z.optional(z.iso.date().describe("Start date of the billing period.")),
				tax_amount: z.optional(z.string().describe("Total tax amount for this billing period.")),
				total_amount: z.optional(
					z.string().describe("Total billing amount for this billing period."),
				),
				type: z.optional(
					z
						.union([z.literal(0), z.literal(1)])
						.describe(
							"Type of the billing report. The value should be either of the following:  \n \n`0` - Detailed Billing Reports\n`1` - Custom Billing Reports",
						),
				),
			}),
		),
	),
	currency: z.optional(z.string().describe("Currency of the billed amount.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request\n\n**Error Code:** `200` <br>\nNo permission.\n\n
 */
export const getBillingReport400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const getBillingReport429Schema = z.unknown();

export const getBillingReportQueryResponseSchema = z.lazy(() => getBillingReport200Schema);

export const getBillingInvoicesReportsQueryParamsSchema = z.object({
	billing_id: z
		.string()
		.describe(
			"The billing report's unique identifier. Retrieve this ID from the response of **Get Billing Reports** API request. \n\n",
		),
});

/**
 * @description **HTTP Status Code:** `200` **OK**  \n \nBilling Invoice reports returned.
 */
export const getBillingInvoicesReports200Schema = z.object({
	currency: z.optional(z.string().describe("Currency of the billed amount in the invoice.")),
	invoices: z.optional(
		z.array(
			z.object({
				end_date: z.optional(z.iso.date().describe("End date of the invoice period.")),
				invoice_charge_name: z.optional(z.string().describe("Name of the invoice.")),
				invoice_number: z.optional(z.string().describe("Invoice number ")),
				quantity: z.optional(z.int().describe("Number of licenses bought.")),
				start_date: z.optional(z.iso.date().describe("Start date of the invoice period.")),
				tax_amount: z.optional(z.string().describe("Tax amount in the invoice.")),
				total_amount: z.optional(z.string().describe("Total billed amount in the invoice.")),
			}),
		),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid parameter \"billing_id\" <br>\n
 */
export const getBillingInvoicesReports400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `5010` <br>\n Report does not exist. <br>\n
 */
export const getBillingInvoicesReports404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const getBillingInvoicesReports429Schema = z.unknown();

export const getBillingInvoicesReportsQueryResponseSchema = z.lazy(
	() => getBillingInvoicesReports200Schema,
);

export const reportCloudRecordingQueryParamsSchema = z.object({
	from: z.iso
		.date()
		.describe(
			"Start date in 'yyyy-mm-dd' format. The date range defined by the &quot;from&quot; and &quot;to&quot; parameters should only be one month as the report includes only one month worth of data at once.",
		),
	to: z.iso.date().describe("End date."),
	group_id: z.optional(
		z
			.string()
			.describe(
				"The group ID. To get a group ID, use the [**List groups**](/api-reference/zoom-api/methods#operation/groups) API. \n\n **Note:** The API response will only contain users who are members of the queried group ID.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nCloud Recording Report Returned
 */
export const reportCloudRecording200Schema = z.object({
	from: z.optional(z.iso.date().describe("Start date for this report")),
	to: z.optional(z.iso.date().describe("End date for this report")),
	cloud_recording_storage: z.optional(
		z
			.array(
				z.object({
					date: z.optional(z.iso.date().describe("Date of the usage")),
					free_usage: z.optional(z.string().describe("Free storage")),
					plan_usage: z.optional(z.string().describe("Paid storage")),
					usage: z.optional(z.string().describe("Storage used on the date")),
				}),
			)
			.describe("Array of cloud usage objects"),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request\n\n**Error Code:** `200` <br>\nNo permission.<br>\n\n\n
 */
export const reportCloudRecording400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportCloudRecording429Schema = z.unknown();

export const reportCloudRecordingQueryResponseSchema = z.lazy(() => reportCloudRecording200Schema);

export const reportDailyQueryParamsSchema = z
	.object({
		year: z.optional(z.coerce.number().int().describe("Year for this report")),
		month: z.optional(z.coerce.number().int().describe("Month for this report")),
		group_id: z.optional(
			z
				.string()
				.describe(
					"The group ID. To get a group ID, use the [**List groups**](/docs/api/users/#tag/groups/GET/groups) API. \n\n **Note:** The API response will only contain users who are members of the queried group ID.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `200`  \n \nDaily report retrieved.  \n \nThis is only available for paid accounts:{accountId}.
 */
export const reportDaily200Schema = z.object({
	dates: z.optional(
		z
			.array(
				z.object({
					date: z.optional(z.iso.date().describe("Date for this object.")),
					meeting_minutes: z.optional(z.int().describe("Number of meeting minutes on this date.")),
					meetings: z.optional(z.int().describe("Number of meetings on this date.")),
					new_users: z.optional(z.int().describe("Number of new users on this date.")),
					participants: z.optional(z.int().describe("Number of participants on this date.")),
				}),
			)
			.describe("Array of date objects."),
	),
	month: z.optional(z.int().describe("Month for this report.")),
	year: z.optional(z.int().describe("Year for this report.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Daily report can only be provided for a month that falls within the recent 6 months. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n
 */
export const reportDaily400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rate-limits/). \n\n
 */
export const reportDaily429Schema = z.unknown();

export const reportDailyQueryResponseSchema = z.lazy(() => reportDaily200Schema);

export const gethistorymeetingandwebinarlistQueryParamsSchema = z.object({
	from: z
		.string()
		.describe(
			"The start date in `yyyy-mm-dd` format. The date range defined by the `from` and `to` parameters should only be one month, as the report includes only one month worth of data at once.",
		),
	to: z.string().describe("The end date in `yyyy-mm-dd` format."),
	date_type: z.optional(
		z
			.enum(["start_time", "end_time"])
			.describe(
				"The type of date to query.\n* `start_time` - Query by meeting's start time. \n* `end_time` - Query by meeting's end time. \n\nThis value defaults to `start_time`.",
			),
	),
	meeting_type: z.optional(
		z
			.enum(["meeting", "webinar", "all"])
			.describe(
				"The meeting type to query. \n- `all` - rerturn meetings and webinars \n- `meeting` - only return meetings \n- `webinar` - only return webinars",
			),
	),
	report_type: z.optional(
		z
			.enum(["all", "poll", "survey", "qa", "resource", "reaction"])
			.describe(
				"Query meetings that have this type of report.\n- `all` - all meetings\n- `poll` - meetings with poll data \n- `survey` - meetings with survey data \n- `qa` - meetings with Q&A data \n- `resource` - meetings with resource link data \n- `reaction` - meetings with reaction data",
			),
	),
	search_key: z.optional(z.string().describe("The keywords of meeting topic or meeting ID.")),
	page_size: z.optional(
		z.coerce
			.number()
			.int()
			.describe("The number of records to be returned within a single API call."),
	),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	group_id: z.optional(
		z
			.string()
			.describe(
				"The group ID. To get a group ID, use the [**List groups**](/docs/api/rest/reference/user/methods/#operation/groups) API. \n\n **Note:** The API response will only contain users who are members of the queried group ID.",
			),
	),
	meeting_feature: z.optional(
		z
			.enum([
				"screen_sharing",
				"video_on",
				"remote_control",
				"closed_caption",
				"language_interpretation",
				"telephone_usage",
				"in_meeting_chat",
				"poll",
				"join_by_room",
				"waiting_room",
				"live_transcription",
				"reaction",
				"zoom_apps",
				"annotation",
				"raise_hand",
				"virtual_background",
				"whiteboard",
				"immersive_scene",
				"avatar",
				"switch_to_mobile",
				"file_sharing",
				"meeting_summary",
				"meeting_questions",
				"record_to_computer",
				"record_to_cloud",
				"live_translation",
				"registration",
				"smart_recording",
				"multi_speaker",
				"meeting_wallpaper",
				"gen_ai_virtual_background",
				"multi_share",
				"document_collaboration",
				"portrait_lighting",
				"personalized_audio_isolation",
				"color_themes",
			])
			.describe(
				"The meeting features to query and return history meetings that use one or more of these features. To provide multiple values, separate them with commas, like `meeting_summary,meeting_questions`",
			),
	),
});

/**
 * @description HTTP Status Code: 200 Success.
 */
export const gethistorymeetingandwebinarlist200Schema = z.object({
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	page_size: z.optional(z.int().describe("The number of records returned with a single API call.")),
	history_meetings: z.optional(
		z
			.array(
				z
					.object({
						meeting_uuid: z.optional(
							z
								.string()
								.describe(
									"The meeting unique universal identifier (UUID). Double encode your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it.",
								),
						),
						meeting_id: z.optional(
							z
								.int()
								.describe(
									"The [meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in &quot;**long**&quot; format(represented as int64 data type in JSON), also known as the meeting number.",
								),
						),
						type: z.optional(
							z
								.enum(["Meeting", "Webinar"])
								.describe("The meeting type, either Meeting or Webinar."),
						),
						host_display_name: z.optional(z.string().describe("The host's display name.")),
						host_email: z.optional(z.string().describe("The host's email address.")),
						start_time: z.optional(z.string().describe("The meeting's start date and time.")),
						end_time: z.optional(z.string().describe("The meeting's end date and time.")),
						topic: z.optional(z.string().describe("The meeting's topic.")),
						participants: z.optional(z.int().describe("The number of meeting participants.")),
						duration: z.optional(z.int().describe("The meeting's duration, in minutes.")),
						total_participant_minutes: z.optional(
							z.int().describe("The total duration of all participants, in minutes."),
						),
						department: z.optional(z.string().describe("The host's department.")),
						group: z.optional(
							z
								.array(z.string().describe("The host's group name"))
								.max(200)
								.describe("The host's groups"),
						),
						source: z.optional(
							z
								.string()
								.describe(
									"Whether the meeting was created directly through Zoom or via an API request: \n* If the meeting was created via an OAuth app, this field returns the OAuth app's name. \n* If the meeting was created via JWT or the Zoom Web Portal, this returns the `Zoom` value.",
								),
						),
						unique_viewers: z.optional(
							z
								.int()
								.describe(
									"This value shows how many people viewed the webinar on their computer. It does not include panelists or attendees who only listened by phone. Viewers who joined the meeting multiple times or from multiple devices are counted only once.",
								),
						),
						max_concurrent_views: z.optional(
							z
								.int()
								.describe(
									"The maximum number of online viewers at the same time during the webinar, excluding panelists.",
								),
						),
						create_time: z.optional(z.string().describe("The meeting's create date and time.")),
						custom_fields: z.optional(
							z
								.array(
									z.object({
										key: z.optional(z.string().describe("The custom attribute's name.")),
										value: z.optional(z.string().describe("The custom attribute's value.")),
									}),
								)
								.max(5)
								.describe("The custom attributes that the host is assigned"),
						),
						tracking_fields: z.optional(
							z
								.array(
									z.object({
										field: z.optional(z.string().describe("The label of the tracking field.")),
										value: z.optional(z.string().describe("The value of the tracking field.")),
									}),
								)
								.max(10)
								.describe("The tracking fields and values assigned to the meeting."),
						),
						feature_used: z.optional(
							z
								.object({
									screen_sharing: z.optional(
										z.boolean().describe("Whether the screen was shared in the meeting."),
									),
									video_on: z.optional(
										z.boolean().describe("Whether the video was on in the meeting."),
									),
									remote_control: z.optional(
										z.boolean().describe("Whether to use remote control in the meeting."),
									),
									closed_caption: z.optional(
										z.boolean().describe("Whether closed caption was enabled in the meeting."),
									),
									breakout_room: z.optional(
										z.boolean().describe("Whether breakout room was enabled in the meeting."),
									),
									language_interpretation: z.optional(
										z.boolean().describe("Whether language translation was used in the meeting."),
									),
									telephone_usage: z.optional(
										z.boolean().describe("Whether anyone has joined the meeting by telephone."),
									),
									in_meeting_chat: z.optional(
										z
											.boolean()
											.describe(
												"Whether anyone in the meeting has sent a message in the meeting chat.",
											),
									),
									poll: z.optional(z.boolean().describe("Whether the meeting has poll data.")),
									join_by_room: z.optional(
										z.boolean().describe("Whether anyone has joined the meeting by Zoom Room."),
									),
									waiting_room: z.optional(
										z.boolean().describe("Whether to open the waiting room for the meeting."),
									),
									live_transcription: z.optional(
										z.boolean().describe("Whether live transcription was turned on."),
									),
									reaction: z.optional(z.boolean().describe("Whether anyone sent an emoticon.")),
									zoom_apps: z.optional(
										z.boolean().describe("Whether the Zoom app was used in the meeting."),
									),
									annotation: z.optional(
										z.boolean().describe("Whether annotation was used in the meeting."),
									),
									raise_hand: z.optional(
										z.boolean().describe("Whether anyone has raised hand in the meeting."),
									),
									virtual_background: z.optional(
										z
											.boolean()
											.describe("Whether anyone used a virtual background in the meeting."),
									),
									whiteboard: z.optional(
										z.boolean().describe("Whether a whiteboard was used in the meeting."),
									),
									immersive_scene: z.optional(
										z.boolean().describe("Whether immersive scene was enabled in then meeting."),
									),
									avatar: z.optional(
										z.boolean().describe("Whether anyone used an avatar in the meeting."),
									),
									switch_to_mobile: z.optional(
										z
											.boolean()
											.describe("Whether anyone switched the meeting to their mobile phone."),
									),
									file_sharing: z.optional(
										z.boolean().describe("Whether anyone sent files in the meeting chat."),
									),
									meeting_summary: z.optional(
										z.boolean().describe("Whether the meeting summary was enabled."),
									),
									meeting_questions: z.optional(
										z.boolean().describe("Whether the meeting questions was enabled."),
									),
									record_to_computer: z.optional(
										z.boolean().describe("Whether to record the meeting to the local computer."),
									),
									record_to_cloud: z.optional(
										z.boolean().describe("Whether to record the meeting to the cloud."),
									),
									live_translation: z.optional(
										z.boolean().describe("Whether live translation was used in the meeting."),
									),
									registration: z.optional(
										z.boolean().describe("Whether registration was enabled for the meeting."),
									),
									smart_recording: z.optional(
										z.boolean().describe("Whether smart recording was enabled for the meeting."),
									),
									multi_speaker: z.optional(
										z
											.boolean()
											.describe("Whether anyone used the multi-speaker view in the meeting."),
									),
									meeting_wallpaper: z.optional(
										z.boolean().describe("Whether host set wallpaper in the meeting."),
									),
									gen_ai_virtual_background: z.optional(
										z
											.boolean()
											.describe("Whether anyone used the GenAI virtual background in the meeting."),
									),
									multi_share: z.optional(
										z.boolean().describe("Whether multi-share was used in the meeting"),
									),
									document_collaboration: z.optional(
										z.boolean().describe("Whether anyone shared the document in the meeting."),
									),
									portrait_lighting: z.optional(
										z.boolean().describe("Whether anyone used portrait lighting in the meeting."),
									),
									personalized_audio_isolation: z.optional(
										z
											.boolean()
											.describe("Whether anyone used personalized audio isolation in the meeting."),
									),
									color_themes: z.optional(
										z.boolean().describe("Whether anyone used color themes in the meeting."),
									),
								})
								.describe("Features used in the meeting."),
						),
					})
					.describe("The history meeting detail."),
			)
			.max(300)
			.describe("Array of history meetings."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n The next page token is invalid or expired. <br>\n**Error Code:** `300` <br>\n Invalid parameter: {0}. <br>\n
 */
export const gethistorymeetingandwebinarlist400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n
 */
export const gethistorymeetingandwebinarlist401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n **Error Code:** `12703` <br>\n No permission for the group: {0}. <br>\n
 */
export const gethistorymeetingandwebinarlist403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const gethistorymeetingandwebinarlist429Schema = z.unknown();

export const gethistorymeetingandwebinarlistQueryResponseSchema = z.lazy(
	() => gethistorymeetingandwebinarlist200Schema,
);

export const reportMeetingactivitylogsQueryParamsSchema = z.object({
	from: z.iso
		.date()
		.describe(
			"The start date in 'yyyy-MM-dd'format. The date range defined by the `from` and `to` parameters should only be one month, as the report includes only one month's worth of data at once.",
		),
	to: z.iso.date().describe("The end date 'yyyy-MM-dd' format."),
	page_size: z.optional(
		z.coerce
			.number()
			.int()
			.max(300)
			.default(30)
			.describe("The number of records to be returned within a single API call."),
	),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	meeting_number: z.optional(z.string().describe("The meeting's number.")),
	search_key: z.optional(z.string().describe("An operator's name or email.")),
	activity_type: z
		.enum([
			"All Activities",
			"Meeting Created",
			"Meeting Started",
			"User Join",
			"User Left",
			"Remote Control",
			"In-Meeting Chat",
			"Meeting Ended",
		])
		.default("All Activities")
		.describe(
			"Activity type. \n-1 - All activities. \n0 - Meeting created. \n1 - Meeting started. \n2 - User joined. \n3 - User left. \n4 - Remote control. \n5 - In-meeting chat. \n9 - Meeting ended.",
		),
});

/**
 * @description **HTTP Status Code:** `200`  Success. Only available for Paid or ZMP account {accountId}.
 */
export const reportMeetingactivitylogs200Schema = z
	.object({
		meeting_activity_logs: z.optional(
			z
				.array(
					z.object({
						meeting_number: z.string().describe("The meeting number."),
						activity_time: z.string().describe("The operator's activity time."),
						operator: z.string().describe("The operator's display name."),
						operator_email: z.string().describe("The operator's email."),
						activity_category: z
							.string()
							.describe(
								"The operator's activity category. \n-1 - All Activities. \n0 - Meeting created. \n1 - Meeting started. \n2 - User joined. \n3 - User left. \n4 - Remote control. \n5 - In-meeting chat. \n9 - Meeting ended.",
							),
						activity_detail: z.string().describe("The operator's activity detail."),
					}),
				)
				.max(300)
				.describe("Array of meeting activity logs."),
		),
		next_page_token: z.optional(
			z
				.string()
				.describe(
					"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
				),
		),
		page_size: z.optional(
			z.number().default(30).describe("The number of records returned with a single API call."),
		),
	})
	.describe("Report object");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n
 */
export const reportMeetingactivitylogs400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  No permission. \n\n
 */
export const reportMeetingactivitylogs403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1010` <br>\n User does not belong to this account {accountId}.<br> <br>\n
 */
export const reportMeetingactivitylogs404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportMeetingactivitylogs429Schema = z.unknown();

export const reportMeetingactivitylogsQueryResponseSchema = z.lazy(
	() => reportMeetingactivitylogs200Schema,
);

export const reportMeetingDetailsPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"The meeting's ID or universally unique ID (UUID). \n* If you provide a meeting ID, the API returns a response for the latest meeting instance. \n* If you provide a meeting UUID that begins with a `/` character or contains the `//` characters, you **must** [double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) the meeting UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nMeeting details returned.  \n \nThis is only available for paid account.
 */
export const reportMeetingDetails200Schema = z.object({
	custom_keys: z.optional(
		z
			.array(
				z.object({
					key: z.optional(z.string().max(64).describe("Custom key associated with the user.")),
					value: z.optional(
						z.string().max(256).describe("Value of the custom key associated with the user."),
					),
				}),
			)
			.max(10)
			.describe("Custom keys and values assigned to the meeting."),
	),
	dept: z.optional(z.string().describe("Department of the host.")),
	duration: z.optional(z.int().describe("Meeting duration.")),
	end_time: z.optional(z.string().datetime().describe("Meeting end time.")),
	id: z.optional(
		z
			.int()
			.describe(
				"[Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in &quot;**long**&quot; format(represented as int64 data type in JSON), also known as the meeting number.",
			),
	),
	participants_count: z.optional(z.int().describe("Number of meeting participants.")),
	start_time: z.optional(z.string().datetime().describe("Meeting start time.")),
	topic: z.optional(z.string().describe("Meeting topic.")),
	total_minutes: z.optional(
		z
			.int()
			.describe(
				"Number of meeting minutes. This represents the total amount of meeting minutes attended by each participant including the host, for meetings hosted by the user. For instance if there were one host(named A) and one participant(named B) in a meeting, the value of total_minutes would be calculated as below:\n\n**total_minutes** = Total Meeting Attendance Minutes of A + Total Meeting Attendance Minutes of B",
			),
	),
	tracking_fields: z.optional(
		z
			.array(
				z.object({
					field: z.optional(z.string().describe("Tracking fields type.")),
					value: z.optional(z.string().describe("Tracking fields value.")),
				}),
			)
			.describe("Tracking fields."),
	),
	type: z.optional(z.int().describe("Meeting type.")),
	user_email: z.optional(z.string().describe("User email.")),
	user_name: z.optional(z.string().describe("User display name.")),
	uuid: z.optional(
		z
			.string()
			.describe(
				"Meeting UUID. Each meeting instance will generate its own UUID(i.e., after a meeting ends, a new UUID will be generated for the next instance of the meeting). [Double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) your UUID when using it for API calls if the UUID begins with a '/' or contains '//' in it.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `12702` <br>\n Can not access meeting a year ago.<br> <br>\n**Error Code:** `200` <br>\n No permission.<br> <br>\n
 */
export const reportMeetingDetails400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting {meetingId} not found or has expired.<br> <br>\n**Error Code:** `1001` <br>\n User does not exist. <br>\n
 */
export const reportMeetingDetails404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportMeetingDetails429Schema = z.unknown();

export const reportMeetingDetailsQueryResponseSchema = z.lazy(() => reportMeetingDetails200Schema);

export const reportMeetingParticipantsPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"The meeting's ID or universally unique ID (UUID). \n* If you provide a meeting ID, the API will return a response for the latest meeting instance. \n* If you provide a meeting UUID that begins with a `/` character or contains the `//` characters, you **must** double-encode the meeting UUID before making an API request.",
		),
});

export const reportMeetingParticipantsQueryParamsSchema = z.object({
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	include_fields: z.optional(
		z
			.enum(["registrant_id"])
			.describe(
				"Provide `registrant_id` as the value for this field if you would like to see the registrant ID attribute in the response of this API call. A registrant ID is a unique identifier of a [meeting registrant](/docs/api-reference/zoom-api/methods#operation/meetingRegistrants).",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nMeeting participants report returned.  \n \nOnly available for Paid or ZMP account: {accountId}.
 */
export const reportMeetingParticipants200Schema = z.object({
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.",
			),
	),
	page_count: z.optional(z.int().describe("The number of pages returned for the request made.")),
	page_size: z.optional(
		z
			.int()
			.max(300)
			.default(30)
			.describe("The number of records returned within a single API call."),
	),
	total_records: z.optional(z.int().describe("The number of all records available across pages.")),
	participants: z.optional(
		z
			.array(
				z.object({
					customer_key: z.optional(
						z
							.string()
							.max(35)
							.describe(
								"The participant's SDK identifier. This value can be alphanumeric, up to a maximum length of 35 characters.",
							),
					),
					duration: z.optional(
						z
							.int()
							.describe(
								"Participant duration, in seconds, calculated by subtracting the `leave_time` from the `join_time` for the `user_id`. If the participant leaves and rejoins the same meeting, they are assigned a different `user_id` and Zoom displays their new duration in a separate object. Because of this, the duration may not reflect the total time the user was in the meeting.",
							),
					),
					failover: z.optional(
						z.boolean().describe("Indicates if failover happened during the meeting."),
					),
					id: z.optional(
						z
							.string()
							.describe(
								"The participant's universally unique ID (UUID). \n* If the participant joins the meeting by logging into Zoom, this value is the `id` value in the [**Get a user**](/docs/api-reference/zoom-api/methods#operation/user) API response. \n* If the participant joins the meeting **without** logging into Zoom, this returns an empty string value. \n\n**Note:** Use the `participant_user_id` value instead of this value. We will remove this response in a future release.",
							),
					),
					join_time: z.optional(z.string().datetime().describe("Participant join time.")),
					leave_time: z.optional(z.string().datetime().describe("Participant leave time.")),
					name: z.optional(
						z
							.string()
							.describe(
								"Participant display name.\n\nThis returns an empty string value if the account calling the API is a BAA account.",
							),
					),
					registrant_id: z.optional(
						z
							.string()
							.describe(
								"Unique identifier of the registrant. This field is only returned if you entered &quot;registrant_id&quot; as the value of `include_fields` query parameter.",
							),
					),
					status: z.optional(
						z
							.enum(["in_meeting", "in_waiting_room"])
							.describe(
								"The participant's status. \n* `in_meeting` - In a meeting. \n* `in_waiting_room` - In a waiting room.",
							),
					),
					user_email: z.optional(
						z
							.string()
							.describe(
								"Participant email.\n\nIf the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](/docs/api-reference/using-zoom-apis#email-address) for details. This returns an empty string value if the account calling the API is a BAA account.",
							),
					),
					user_id: z.optional(
						z
							.string()
							.describe(
								"Participant ID. This is a unique ID assigned to the participant joining a meeting and is valid for that meeting only.",
							),
					),
					bo_mtg_id: z.optional(
						z
							.string()
							.describe(
								"The [breakout room](https://support.zoom.us/hc/en-us/articles/206476313-Managing-breakout-rooms) ID. Each breakout room is assigned a unique ID.",
							),
					),
					participant_user_id: z.optional(
						z
							.string()
							.describe(
								"The participant's universally unique ID (UUID). \n* If the participant joins the meeting by logging into Zoom, this value is the `id` value in the [**Get a user**](/docs/api-reference/zoom-api/methods#operation/user) API response. \n* If the participant joins the meeting **without** logging into Zoom, this returns an empty string value.",
							),
					),
				}),
			)
			.describe("Array of meeting participant objects."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `1010` <br>\n User does not belong to this account:{accountId}.<br> <br>\n**Error Code:** `12702` <br>\n Can not access meeting a year ago.<br> <br>\n**Error Code:** `200` <br>\n No permission.<br> <br>\n
 */
export const reportMeetingParticipants400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting  {MeetingId} not found or has expired.<br> <br>\n
 */
export const reportMeetingParticipants404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const reportMeetingParticipants429Schema = z.unknown();

export const reportMeetingParticipantsQueryResponseSchema = z.lazy(
	() => reportMeetingParticipants200Schema,
);

export const reportMeetingPollsPathParamsSchema = z.object({
	meetingId: z
		.union([z.coerce.number().int(), z.string()])
		.describe(
			"The meeting's ID or universally unique ID (UUID). \n* If you provide a meeting ID, the API will return a response for the latest meeting instance. \n* If you provide a meeting UUID that begins with a `/` character or contains the `//` characters, you **must** [double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) the meeting UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200` \n* Meeting polls report returned. \n* This is only available for paid account: {accountId}
 */
export const reportMeetingPolls200Schema = z.object({
	id: z.optional(
		z
			.int()
			.describe(
				"The [meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID).",
			),
	),
	uuid: z.optional(
		z
			.string()
			.describe(
				"The meeting's universally unique identifier (UUID). Each meeting instance generates a meeting UUID.",
			),
	),
	start_time: z.optional(z.string().datetime().describe("The meeting's start time.")),
	questions: z.optional(
		z
			.array(
				z.object({
					email: z.optional(z.email().describe("The participant's email address.")),
					name: z.optional(
						z
							.string()
							.describe(
								"The participant's display name. If the **Allow participants to answer questions anonymously** setting is enabled for a [poll](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meet), the participant's polling information is kept anonymous and the `name` field will return the &quot;Anonymous Attendee&quot; value.",
							),
					),
					first_name: z.optional(
						z
							.string()
							.describe(
								"The participant's first name. If the **Allow participants to answer questions anonymously** setting is enabled for a [poll](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meet), the participant's polling information is kept anonymous and the `first_name` field will return the &quot;Anonymous Attendee&quot; value.",
							),
					),
					last_name: z.optional(
						z
							.string()
							.describe(
								"The participant's last name. If the **Allow participants to answer questions anonymously** setting is enabled for a [poll](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meet), the participant's polling information is kept anonymous and the `last_name` field will return the &quot;Anonymous Attendee&quot; value.",
							),
					),
					question_details: z.optional(
						z
							.array(
								z.object({
									answer: z.optional(z.string().describe("The user's given answer.")),
									date_time: z.optional(
										z
											.string()
											.describe("The date and time at which the user answered the poll question."),
									),
									polling_id: z.optional(z.string().describe("The poll's ID.")),
									question: z.optional(z.string().describe("The poll question.")),
								}),
							)
							.describe("Information about the user's questions and answers."),
					),
				}),
			)
			.describe("Information about the meeting questions."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request\n\n**Error Code:** `12702` <br>\nCan not access meeting a year ago.\n\n**Error Code:** `200` <br>\nNo permission.<br>\n\n
 */
export const reportMeetingPolls400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found\n\n**Error Code:** `3001` <br>\nMeeting \"{meetingId}\" not found or has expired.\n\n
 */
export const reportMeetingPolls404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportMeetingPolls429Schema = z.unknown();

export const reportMeetingPollsQueryResponseSchema = z.lazy(() => reportMeetingPolls200Schema);

export const reportMeetingQAPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"The meeting's ID or universally unique ID (UUID). \n* If you provide a meeting ID, the API will return a response for the latest meeting instance. \n* If you provide a meeting UUID that begins with a `/` character or contains the `//` characters, you **must** double-encode the meeting UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nMeeting Q&amp;A report returned.  \n \nOnly available for Paid or ZMP account: {accountId}.
 */
export const reportMeetingQA200Schema = z.object({
	id: z.optional(
		z
			.int()
			.describe(
				"The meeting ID in `long` format, represented as int64 data type in JSON. Also known as the meeting number.",
			),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					user_id: z.optional(
						z
							.string()
							.describe(
								"The user ID of the user who asked the question. This value returns blank for external users.",
							),
					),
					email: z.optional(
						z
							.string()
							.describe(
								"Participant's email. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for details.",
							),
					),
					name: z.optional(
						z
							.string()
							.describe(
								"Participant's display name.  \n  \n\nIf the anonymous [Q&amp;A](https://support.zoom.us/hc/en-us/articles/203686015-Getting-Started-with-Question-Answer) option is enabled and if a participant submits the Q&amp;A without providing their name, the value of the `name` field is &quot;Anonymous Attendee&quot;.",
							),
					),
					question_details: z.optional(
						z
							.array(
								z.object({
									answer: z.optional(
										z
											.string()
											.describe(
												"The given answer. If this is a live answer, the value is 'live answered'.\n**Note:** All answers will be returned together and separated by semicolons. For more detailed answer information, please see the \"answer_details\" field.",
											),
									),
									question: z.optional(z.string().describe("Asked question.")),
									question_id: z.optional(z.string().describe("Question UUID.")),
									create_time: z.optional(z.string().describe("Question create time.")),
									question_status: z.optional(
										z
											.enum(["default", "open", "dismissed", "answered", "deleted"])
											.describe("Question status.\nIf not supported, the value will be `default`."),
									),
									answer_details: z.optional(
										z
											.array(
												z.object({
													user_id: z.optional(
														z
															.string()
															.describe(
																"The user ID of the user who answered the question. This value returns blank for external users.",
															),
													),
													name: z.optional(
														z
															.string()
															.describe("User display name, including the host or participant."),
													),
													email: z.optional(
														z
															.string()
															.describe(
																"Participant's email. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for details.",
															),
													),
													content: z.optional(
														z
															.string()
															.max(1024)
															.describe("The answer from host or the comment from participant."),
													),
													create_time: z.optional(z.string().describe("Content submit time.")),
													type: z.optional(
														z
															.enum([
																"default",
																"host_answered_publicly",
																"host_answered_privately",
																"participant_commented",
																"host_answered",
															])
															.default("default")
															.describe("Type of answer."),
													),
												}),
											)
											.describe("Array of answers from the user."),
									),
								}),
							)
							.describe("Array of questions from user."),
					),
				}),
			)
			.describe("Array of meeting question objects."),
	),
	start_time: z.optional(z.string().datetime().describe("Meeting start time.")),
	uuid: z.optional(
		z
			.string()
			.describe(
				"The meeting UUID. Each meeting instance will generate its own UUID - for example, after a meeting ends, a new UUID will be generated for the next instance of the meeting. Double-encode your UUID when using it for API calls if the UUID begins with a '/' or contains '//'.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n No permission.<br> <br>\n
 */
export const reportMeetingQA400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: {userId}.<br> <br>\n**Error Code:** `3001` <br>\n Meeting {meetingId} not found or has expired.<br> <br>\n
 */
export const reportMeetingQA404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportMeetingQA429Schema = z.unknown();

export const reportMeetingQAQueryResponseSchema = z.lazy(() => reportMeetingQA200Schema);

export const reportMeetingSurveyPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"The meeting's ID or universally unique ID (UUID). \n* If you provide a meeting ID, the API will return a response for the latest meeting instance. \n* If you provide a meeting UUID that begins with a `/` character or contains the `//` characters, you **must** double-encode the meeting UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nMeeting survey report returned.   \n \nOnly available for Paid or ZMP account: {accountId}.
 */
export const reportMeetingSurvey200Schema = z.object({
	meeting_id: z.optional(z.int().describe("The meeting ID.")),
	meeting_uuid: z.optional(
		z
			.string()
			.describe(
				"The meeting's universally unique identifier (UUID). Each meeting instance generates a meeting UUID.",
			),
	),
	start_time: z.optional(z.string().datetime().describe("The meeting's start time.")),
	survey_id: z.optional(z.string().describe("The survey's ID")),
	survey_name: z.optional(z.string().describe("The name of survey")),
	survey_answers: z.optional(
		z
			.array(
				z.object({
					email: z.optional(z.email().describe("The participant's email address.")),
					name: z.optional(
						z
							.string()
							.describe(
								"The participant's display name. **Allow participants to answer questions anonymously** setting is enabled for a [survey](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0057559), the participant's survey information is kept anonymous and the `name` field will return the &quot;Anonymous Attendee&quot; value.",
							),
					),
					first_name: z.optional(
						z
							.string()
							.describe(
								"The participant's first name. If the **Allow participants to answer questions anonymously** setting is enabled for a [survey](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0057559), the participant's survey information is kept anonymous and the `first_name` field will return the &quot;Anonymous Attendee&quot; value.",
							),
					),
					last_name: z.optional(
						z
							.string()
							.describe(
								"The participant's last name. If the **Allow participants to answer questions anonymously** setting is enabled for a [survey](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0057559), the participant's survey information is kept anonymous and the `last_name` field will return the &quot;Anonymous Attendee&quot; value.",
							),
					),
					answer_details: z.optional(
						z
							.array(
								z.object({
									question: z.optional(z.string().describe("The survey question.")),
									question_id: z.optional(z.string().describe("The question's ID")),
									answer: z.optional(z.string().describe("The user's given answer.")),
									date_time: z.optional(
										z
											.string()
											.describe(
												"The date and time at which the user answered the survey question.",
											),
									),
								}),
							)
							.describe("Information about the user's questions and answers."),
					),
				}),
			)
			.describe("Information about the survey questions and answers."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `1010` <br>\n User does not belong to this account:{accountId}.<br> <br>\n**Error Code:** `12702` <br>\n Can not access a webinar a year ago.<br> <br>\n**Error Code:** `200` <br>\n No permission.<br> <br>\n
 */
export const reportMeetingSurvey400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar  {webinarId} not found or has expired.<br> <br>\n
 */
export const reportMeetingSurvey404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportMeetingSurvey429Schema = z.unknown();

export const reportMeetingSurveyQueryResponseSchema = z.lazy(() => reportMeetingSurvey200Schema);

export const reportOperationLogsQueryParamsSchema = z.object({
	from: z.iso
		.date()
		.describe(
			"Start date in 'yyyy-mm-dd' or 'yyyy-MM-dd HH:mm' format. The date range defined by the `from` and `to` parameters should only be one month as the report includes only one month worth of data at once.",
		),
	to: z.iso.date().describe("End date in 'yyyy-mm-dd' or 'yyyy-MM-dd HH:mm' format."),
	page_size: z.optional(
		z.coerce
			.number()
			.int()
			.max(300)
			.default(30)
			.describe("The number of records returned within a single API call."),
	),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	category_type: z.optional(
		z
			.enum([
				"all",
				"user",
				"user_settings",
				"account",
				"billing",
				"im",
				"recording",
				"phone_contacts",
				"webinar",
				"sub_account",
				"role",
				"zoom_rooms",
			])
			.describe(
				"**Optional**  \n \nFilter your response by a category type to see reports for a specific category.\nThe value for this field can be one of the following:  \n  `all`  \n `user`  \n `user_settings`  \n `account`  \n `billing`  \n `im`  \n `recording`  \n `phone_contacts`  \n `webinar`  \n `sub_account`  \n `role`  \n `zoom_rooms`",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nOperation Logs Report Returned
 */
export const reportOperationLogs200Schema = z.object({
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of the available result list exceeds the page size. The expiration period is 15 minutes.",
			),
	),
	page_size: z.optional(
		z
			.int()
			.max(300)
			.default(30)
			.describe("The amount of records returns within a single API call. "),
	),
	operation_logs: z.optional(
		z
			.array(
				z.object({
					action: z.optional(z.string().describe("Action")),
					category_type: z.optional(z.string().describe("Category type")),
					operation_detail: z.optional(z.string().describe("Operation detail")),
					operator: z.optional(z.string().describe("The user who performed the operation.")),
					time: z.optional(
						z.string().datetime().describe("The time at which the operation was performed."),
					),
				}),
			)
			.describe("Array of operation log objects"),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n No permission.<br> <br>\n
 */
export const reportOperationLogs400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const reportOperationLogs429Schema = z.unknown();

export const reportOperationLogsQueryResponseSchema = z.lazy(() => reportOperationLogs200Schema);

export const getremotesupportreportQueryParamsSchema = z.object({
	from: z
		.string()
		.describe(
			"The start date in `yyyy-MM-dd` format. The date range defined by the `from` and `to` parameters should only be one month, as the report includes only one month's worth of data at once. It is the date range for remote support to start.",
		),
	to: z.string().describe("The end date in `yyyy-MM-dd` format."),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	page_size: z.optional(
		z.string().describe("The number of records to be returned within a single API call."),
	),
});

/**
 * @description Remote support records list.
 */
export const getremotesupportreport200Schema = z.object({
	remote_support_logs: z.optional(
		z
			.array(
				z
					.object({
						meeting_start_time: z.optional(z.string().describe("The meeting's start time.")),
						meeting_uuid: z.optional(
							z
								.string()
								.describe(
									"The meeting's unique universal identifier (UUID). Double encode your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it.",
								),
						),
						meeting_number: z.optional(z.int().describe("The meeting number.")),
						topic: z.optional(z.string().describe("The meeting's topic.")),
						meeting_host_id: z.optional(z.string().describe("The meeting's host id.")),
						supporter_name: z.optional(z.string().describe("The supporter's user name.")),
						supporter_email: z.optional(z.string().describe("The supporter's user email.")),
						supportee_name: z.optional(z.string().describe("The supportee's user name.")),
						supportee_email: z.optional(z.string().describe("The supportee's user email.")),
						request_time: z.optional(z.string().describe("The time to request remote support.")),
						wait_time: z.optional(
							z
								.string()
								.describe(
									"The waiting time for remote support from request to start, formatted in `hh:mm:ss`.",
								),
						),
						start_time: z.optional(z.string().describe("Remote support start time.")),
						end_time: z.optional(z.string().describe("Remote support end time")),
						duration: z.optional(
							z.string().describe("The duration of remote support, formatted in `hh:mm:ss`."),
						),
					})
					.describe("The remote support log's detail."),
			)
			.describe("Array of remote support logs."),
	),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	page_size: z.optional(z.int().describe("The number of records returned with a single API call.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n The next page token is invalid or expired. <br>\n
 */
export const getremotesupportreport400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n
 */
export const getremotesupportreport401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rate-limits/). \n\n
 */
export const getremotesupportreport429Schema = z.unknown();

export const getremotesupportreportQueryResponseSchema = z.lazy(
	() => getremotesupportreport200Schema,
);

export const reportTelephoneQueryParamsSchema = z.object({
	type: z.optional(
		z
			.enum(["1", "2", "3"])
			.default("1")
			.describe(
				"Audio types:  \n `1` - Toll-free Call-in &amp; Call-out.  \n `2` - Toll   \n \n`3` - SIP Connected Audio",
			),
	),
	query_date_type: z.optional(
		z
			.enum(["start_time", "end_time", "meeting_start_time", "meeting_end_time"])
			.default("start_time")
			.describe(
				"The type of date to query. \n* `start_time` &mdash; Query by call start time. \n* `end_time` &mdash; Query by call end time. \n* `meeting_start_time` &mdash; Query by meeting start time. \n* `meeting_end_time` &mdash; Query by meeting end time. \n\nThis value defaults to `start_time`.",
			),
	),
	from: z.iso
		.date()
		.describe(
			"Start date in 'yyyy-mm-dd' format. The date range defined by the &quot;from&quot; and &quot;to&quot; parameters should only be one month as the report includes only one month worth of data at once.",
		),
	to: z.iso.date().describe("End date."),
	page_size: z.optional(
		z.coerce
			.number()
			.int()
			.max(300)
			.default(30)
			.describe("The number of records returned within a single API call."),
	),
	page_number: z.optional(
		z.coerce
			.number()
			.int()
			.default(1)
			.describe(
				"The page number of the current page in the returned records. This field is **not** available if the `query_date_type` parameter is the `meeting_start_time` or `meeting_end_time` value. \n\nThis field is deprecated. Use the `next_page_token` query parameter for pagination.",
			),
	),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nTelephone report returned.  \n \nThis is only available for paid account: {accountId}.  \n \nThe requested report cannot be generated for this account because this account has not subscribed to toll-free audio conference plan.  \n \nEnable the **Toll Report** feature to perform this action. Contact the Zoom Support team for help.
 */
export const reportTelephone200Schema = z.object({
	from: z.optional(z.iso.date().describe("Start date for this report.")),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.",
			),
	),
	page_count: z.optional(
		z
			.int()
			.describe(
				"The number of pages returned for the request made. This field does **not** return if the `query_date_type` parameter is the `meeting_start_time` or `meeting_end_time` value.",
			),
	),
	page_size: z.optional(z.int().describe("The number of records returned with a single API call.")),
	to: z.optional(z.iso.date().describe("End date for this report.")),
	total_records: z.optional(
		z
			.int()
			.describe(
				"The total number of all the records available across pages. This field does **not** return if the `query_date_type` parameter is the `meeting_start_time` or `meeting_end_time` value.",
			),
	),
	telephony_usage: z.optional(
		z
			.array(
				z.object({
					call_in_number: z.optional(z.string().describe("Caller's call-in number.")),
					country_name: z.optional(z.string().describe("Country name.")),
					dept: z.optional(z.string().describe("User department.")),
					duration: z.optional(z.int().describe("Call leg duration")),
					end_time: z.optional(z.string().datetime().describe("Call leg end time")),
					host_email: z.optional(z.string().describe("User email.")),
					host_id: z.optional(z.string().describe("The user ID of the meeting host.")),
					host_name: z.optional(z.string().describe("User display name.")),
					meeting_id: z.optional(
						z
							.int()
							.describe(
								"[Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in &quot;**long**&quot; format(represented as int64 data type in JSON), also known as the meeting number.",
							),
					),
					meeting_type: z.optional(z.string().describe("Meeting type.")),
					phone_number: z.optional(z.string().describe("Toll-free telephone number. ")),
					rate: z.optional(z.number().describe("Calling rate for the telephone call.")),
					signaled_number: z.optional(z.string().describe("The number that is signaled to Zoom. ")),
					start_time: z.optional(z.string().datetime().describe("Call leg start time")),
					total: z.optional(
						z
							.number()
							.describe("Total cost (USD) for Call Out. Calculated as plan rate by duration."),
					),
					type: z.optional(
						z
							.enum([
								"toll-free",
								"call-out",
								"call-in",
								"US toll-number",
								"global toll-number",
								"premium",
								"premium call-in",
								"Toll",
							])
							.describe("Call type."),
					),
					uuid: z.optional(z.string().describe("Meeting UUID.")),
				}),
			)
			.max(300)
			.describe("Array of telephony objects."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n The next page token is invalid or expired. <br>\n
 */
export const reportTelephone400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n
 */
export const reportTelephone401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n
 */
export const reportTelephone403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const reportTelephone429Schema = z.unknown();

export const reportTelephoneQueryResponseSchema = z.lazy(() => reportTelephone200Schema);

export const reportUpcomingEventsQueryParamsSchema = z.object({
	from: z.iso
		.date()
		.describe(
			"Start date in 'yyyy-mm-dd' format. The date range defined by the &quot;from&quot; and &quot;to&quot; parameters should only be one month as the report includes only one month worth of data at once.",
		),
	to: z.iso.date().describe("End date."),
	page_size: z.optional(
		z.coerce
			.number()
			.int()
			.max(300)
			.default(30)
			.describe("The number of records returned within a single API call."),
	),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	type: z.optional(
		z
			.enum(["meeting", "webinar", "all"])
			.default("all")
			.describe(
				"The type of event to query. \n* `meeting` &mdash; A meeting event. \n* `webinar` &mdash; A webinar event. \n* `all` &mdash; Both meeting and webinar events.\n\nThis value defaults to `all`.",
			),
	),
	group_id: z.optional(
		z
			.string()
			.describe(
				"The group ID. To get a group ID, use the [**List groups**](/api-reference/zoom-api/methods#operation/groups) API. \n\n **Note:** The API response will only contain meetings where the host is a member of the queried group ID.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nUpcoming events report returned.  \n \n
 */
export const reportUpcomingEvents200Schema = z.object({
	from: z.optional(
		z.iso
			.date()
			.describe("The report's start date. This value must be within the past six months."),
	),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"The next page token is used to paginate through large result sets. A next page token returns when the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.",
			),
	),
	page_size: z.optional(
		z.int().max(300).default(30).describe("The number of records returned in a single API call."),
	),
	to: z.optional(
		z.iso
			.date()
			.describe(
				"The report's end date. This value must be within the past six months and cannot exceed a month from the `from` value.",
			),
	),
	upcoming_events: z.optional(
		z
			.array(
				z.object({
					dept: z.optional(z.string().describe("The event host's department.")),
					host_id: z.optional(z.string().describe("The event host's ID.")),
					host_name: z.optional(z.string().describe("The event host's name.")),
					id: z.optional(z.string().describe("The event's unique ID.")),
					start_time: z.optional(z.string().describe("The event's start time.")),
					topic: z.optional(z.string().describe("The event's topic.")),
				}),
			)
			.describe("Information about the upcoming event."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request\n\n**Error Code:** `200` <br>\nThis is only available for the paid account: {accountId} <br>\n\n**Error Code:** `300` <br>\nThe next page token is invalid or expired.\n\n**Error Code:** `200` <br>\nNo permission.<br>\n\n
 */
export const reportUpcomingEvents400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportUpcomingEvents429Schema = z.unknown();

export const reportUpcomingEventsQueryResponseSchema = z.lazy(() => reportUpcomingEvents200Schema);

export const reportUsersQueryParamsSchema = z.object({
	type: z.optional(
		z
			.enum(["active", "inactive"])
			.describe(
				"Active or inactive hosts.  \n `active` - Active hosts.   \n `inactive` - Inactive hosts.",
			),
	),
	from: z.iso
		.date()
		.describe(
			"Start date in 'yyyy-mm-dd' format. The date range defined by the `from` and `to` parameters should only be one month as the report includes only one month worth of data at once.",
		),
	to: z.iso.date().describe("End date."),
	page_size: z.optional(
		z.coerce
			.number()
			.int()
			.max(300)
			.default(30)
			.describe("The number of records returned within a single API call."),
	),
	page_number: z.optional(
		z.coerce
			.number()
			.int()
			.default(1)
			.describe("The page number of the current page in the returned records."),
	),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.",
			),
	),
	group_id: z.optional(
		z
			.string()
			.describe(
				"The group ID. To get a group ID, use the [**List groups**](/docs/api/rest/reference/user/methods/#operation/groups) API. \n\n **Note:** The API response will only contain users who are members of the queried group ID.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nActive or inactive hosts report returned.  \n \nOnly available for Paid or ZMP account: {accountId}.
 */
export const reportUsers200Schema = z.object({
	from: z.optional(z.iso.date().describe("Start date for this report.")),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.",
			),
	),
	page_count: z.optional(z.int().describe("The number of pages returned for the request made.")),
	page_number: z.optional(z.int().default(1).describe("The page number of the current results.")),
	page_size: z.optional(
		z.int().max(300).default(30).describe("The number of records returned with a single API call."),
	),
	to: z.optional(z.iso.date().describe("End date for this report.")),
	total_records: z.optional(
		z.int().describe("The total number of all the records available across pages."),
	),
	total_meeting_minutes: z.optional(z.int().describe("Number of meeting minutes for this range.")),
	total_meetings: z.optional(z.int().describe("Number of meetings for this range.")),
	total_participants: z.optional(z.int().describe("Number of participants for this range.")),
	users: z.optional(
		z
			.array(
				z
					.object({
						custom_attributes: z.optional(
							z
								.array(
									z.object({
										key: z.optional(z.string().describe("Identifier for the custom attribute.")),
										name: z.optional(z.string().describe("Name of the custom attribute.")),
										value: z.optional(z.string().describe("Value of the custom attribute.")),
									}),
								)
								.describe("Custom attributes that have been assigned to the user."),
						),
						dept: z.optional(z.string().describe("User department.")),
						email: z.optional(z.string().describe("User email.")),
						id: z.optional(z.string().describe("User ID.")),
						meeting_minutes: z.optional(z.int().describe("Number of meeting minutes for user.")),
						meetings: z.optional(z.int().describe("Number of meetings for user.")),
						participants: z.optional(
							z.int().describe("Number of participants in meetings for user."),
						),
						type: z.optional(z.int().describe("User type.")),
						user_name: z.optional(z.string().describe("User display name.")),
					})
					.describe("user object"),
			)
			.describe("Array of user objects."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n No permission. <br>\n
 */
export const reportUsers400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportUsers429Schema = z.unknown();

export const reportUsersQueryResponseSchema = z.lazy(() => reportUsers200Schema);

export const reportMeetingsPathParamsSchema = z.object({
	userId: z
		.string()
		.describe(
			"The user ID or email address of the user. For user-level apps, pass the `me` value.",
		),
});

export const reportMeetingsQueryParamsSchema = z.object({
	from: z.iso
		.date()
		.describe(
			"Start date in 'yyyy-mm-dd' format. The date range defined by the &quot;from&quot; and &quot;to&quot; parameters should only be one month as the report includes only one month worth of data at once.",
		),
	to: z.iso.date().describe("End date."),
	page_size: z.optional(
		z.coerce
			.number()
			.int()
			.max(300)
			.default(30)
			.describe("The number of records returned within a single API call."),
	),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	type: z.optional(
		z
			.enum(["past", "pastOne", "pastJoined"])
			.default("past")
			.describe(
				"The meeting type to query for: \n* `past` - All past meetings. \n* `pastOne` - A single past user meeting. \n* `pastJoined` - All past meetings the account's users hosted or joined.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nActive or inactive hosts report returned.  \n \n
 */
export const reportMeetings200Schema = z.object({
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.",
			),
	),
	page_count: z.optional(z.int().describe("The number of pages returned for the request made.")),
	page_number: z.optional(
		z
			.int()
			.default(1)
			.describe(
				"**Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.",
			),
	),
	page_size: z.optional(
		z.int().max(300).default(30).describe("The number of records returned with a single API call."),
	),
	total_records: z.optional(
		z.int().describe("The total number of all the records available across pages."),
	),
	from: z.optional(z.iso.date().describe("The report's start date.")),
	meetings: z.optional(
		z
			.array(
				z.object({
					custom_keys: z.optional(
						z
							.array(
								z.object({
									key: z.optional(z.string().max(64).describe("The custom key name.")),
									value: z.optional(z.string().max(256).describe("The custom key's value.")),
								}),
							)
							.max(10)
							.describe(
								"Information about the meeting's assigned custom keys and values. This returns a maximum of 10 items.",
							),
					),
					duration: z.optional(z.int().describe("The meeting's duration.")),
					end_time: z.optional(z.string().datetime().describe("The meeting's end date and time.")),
					id: z.optional(
						z
							.int()
							.describe(
								"The [meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID).",
							),
					),
					participants_count: z.optional(z.int().describe("The number of meeting participants.")),
					session_key: z.optional(z.string().describe("The Video SDK custom session ID.")),
					source: z.optional(
						z
							.string()
							.describe(
								"Whether the meeting was created directly through Zoom or via an API request: \n* If the meeting was created via an OAuth app, this field returns the OAuth app's name. \n* If the meeting was created via JWT or the Zoom Web Portal, this returns the `Zoom` value.",
							),
					),
					start_time: z.optional(
						z.string().datetime().describe("The meeting's start date and time."),
					),
					topic: z.optional(z.string().describe("The meeting's topic.")),
					total_minutes: z.optional(
						z
							.int()
							.describe("The sum of meeting minutes from all meeting participants in the meeting."),
					),
					type: z.optional(
						z
							.union([
								z.literal(1),
								z.literal(2),
								z.literal(3),
								z.literal(4),
								z.literal(5),
								z.literal(6),
								z.literal(7),
								z.literal(8),
								z.literal(9),
							])
							.describe(
								"The type of meeting or webinar. \n\nmeeting: \n* `1` - Instant meeting. \n* `2` - Scheduled meeting. \n* `3` - A recurring meeting with no fixed time. \n* `4` - A meeting created via PMI (Personal Meeting ID). \n* `7` - A [Personal Audio Conference](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference) (PAC). \n* `8` - Recurring meeting with a fixed time. \n\nwebinar: \n* `5` - A webinar. \n* `6` - A recurring webinar without a fixed time \n* `9` - A recurring webinar with a fixed time. ",
							),
					),
					user_email: z.optional(z.email().describe("The user's email address.")),
					user_name: z.optional(z.string().describe("The user's display name.")),
					uuid: z.optional(
						z
							.string()
							.describe(
								"The meeting's universally unique identifier (UUID). Each meeting instance generates a meeting UUID.",
							),
					),
					schedule_time: z.optional(z.string().describe("The meeting's scheduled date and time.")),
					join_waiting_room_time: z.optional(
						z.string().describe("The date and time at which the attendee joined the waiting room."),
					),
					join_time: z.optional(
						z.string().describe("The date and time at which the attendee joined the meeting."),
					),
					leave_time: z.optional(
						z.string().describe("The date and time at which the attendee left the meeting."),
					),
					host_organization: z.optional(
						z.string().describe("Host Account Name of Hosting Organization."),
					),
					host_name: z.optional(z.string().describe("Host's name.")),
					has_screen_share: z.optional(
						z
							.boolean()
							.describe(
								"Whether or not the screenshare feature was used by this user in the meeting. This is meeting feature for attendee level.",
							),
					),
					has_recording: z.optional(
						z
							.boolean()
							.describe(
								"Whether or not the recording feature was enabled by this user in the meeting. This is meeting feature for attendee level.",
							),
					),
					has_chat: z.optional(
						z
							.boolean()
							.describe(
								"Whether or not the chat feature was used by this user in the meeting. This is meeting feature for attendee level.",
							),
					),
					meeting_encryption_status: z.optional(
						z
							.union([z.literal(1), z.literal(2)])
							.describe(
								"The meeting's encryption status. \n* `1` - E2E encryption. \n* `2` - Enhanced encryption.",
							),
					),
					participants_count_my_account: z.optional(
						z.int().describe("The number of meeting participants from my account."),
					),
				}),
			)
			.describe("Information about the meeting."),
	),
	to: z.optional(z.iso.date().describe("The report's end date.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n This is only available for paid account: {accountId}.<br> <br>\n**Error Code:** `300` <br>\n The next page token is invalid or expired. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n
 */
export const reportMeetings400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User {userId} not exist or not belong to this account. <br>\n
 */
export const reportMeetings404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests  For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const reportMeetings429Schema = z.unknown();

export const reportMeetingsQueryResponseSchema = z.lazy(() => reportMeetings200Schema);

export const reportWebinarDetailsPathParamsSchema = z.object({
	webinarId: z
		.string()
		.describe(
			"The webinar's ID or universally unique ID (UUID). \n* If you provide a webinar ID, the API will return a response for the latest webinar instance. \n* If you provide a webinar UUID that begins with a `/` character or contains the `//` characters, you **must** [double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) the webinar UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nWebinar details returned.  \n \nThis is only available for paid account:{accountId}.
 */
export const reportWebinarDetails200Schema = z.object({
	custom_keys: z.optional(
		z
			.array(
				z.object({
					key: z.optional(z.string().max(64).describe("Custom key associated with the user.")),
					value: z.optional(
						z.string().max(256).describe("Value of the custom key associated with the user."),
					),
				}),
			)
			.max(10)
			.describe("Custom keys and values assigned to the meeting."),
	),
	dept: z.optional(z.string().describe("Department of the host.")),
	duration: z.optional(z.int().describe("Meeting duration.")),
	end_time: z.optional(z.string().datetime().describe("Meeting end time.")),
	id: z.optional(
		z
			.int()
			.describe(
				"[Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in &quot;**long**&quot; format(represented as int64 data type in JSON), also known as the meeting number.",
			),
	),
	participants_count: z.optional(z.int().describe("Number of meeting participants.")),
	start_time: z.optional(z.string().datetime().describe("Meeting start time.")),
	topic: z.optional(z.string().describe("Meeting topic.")),
	total_minutes: z.optional(
		z
			.int()
			.describe(
				"Number of Webinar minutes. This represents the total amount of Webinar minutes attended by each participant including the host, for a Webinar hosted by the user. For instance if there were one host(named A) and one participant(named B) in a Webinar, the value of total_minutes would be calculated as below:\n\n**total_minutes** = Total Webinar Attendance Minutes of A + Total Webinar Attendance Minutes of B",
			),
	),
	tracking_fields: z.optional(
		z
			.array(
				z.object({
					field: z.optional(z.string().describe("Tracking fields type.")),
					value: z.optional(z.string().describe("Tracking fields value.")),
				}),
			)
			.describe("Tracking fields."),
	),
	type: z.optional(z.int().describe("Meeting type.")),
	user_email: z.optional(z.string().describe("User email.")),
	user_name: z.optional(z.string().describe("User display name.")),
	uuid: z.optional(
		z
			.string()
			.describe(
				"Webinar UUID. Each webinar instance will generate its own UUID(i.e., after a meeting ends, a new UUID will be generated when the next instance of the webinar starts). [double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) the UUID when using it for API calls if the UUID begins with a '/' or contains '//' in it.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request\n\n**Error Code:** `1010` <br>\nUser does not belong to this account:{accountId}.<br>\n\n**Error Code:** `12702` <br>\nCan not access a webinar a year ago.<br>\n\n**Error Code:** `200` <br>\nNo permission.<br>\n\n
 */
export const reportWebinarDetails400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found\n\n**Error Code:** `3001` <br>\nMeeting  {meetingId} not found or has expired.<br>\n\n
 */
export const reportWebinarDetails404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportWebinarDetails429Schema = z.unknown();

export const reportWebinarDetailsQueryResponseSchema = z.lazy(() => reportWebinarDetails200Schema);

export const reportWebinarParticipantsPathParamsSchema = z.object({
	webinarId: z
		.string()
		.describe(
			"The webinar's ID or universally unique ID (UUID). \n* If you provide a webinar ID, the API will return a response for the latest webinar instance. \n* If you provide a webinar UUID that begins with a `/` character or contains the `//` characters, you **must** double-encode the webinar UUID before making an API request.",
		),
});

export const reportWebinarParticipantsQueryParamsSchema = z.object({
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	include_fields: z.optional(
		z
			.enum(["registrant_id"])
			.describe(
				"The additional query parameters to include. \n* `registrant_id` - Include the registrant's ID in the API response. The registrant ID is the webinar participant's unique ID.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200` \n* Meeting participants report returned.  \n \nOnly available for Paid or ZMP account: {accountId}.
 */
export const reportWebinarParticipants200Schema = z.object({
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	page_count: z.optional(z.int().describe("The number of pages returned for the request made.")),
	page_size: z.optional(
		z
			.int()
			.max(300)
			.default(30)
			.describe("The number of records returned within a single API call."),
	),
	total_records: z.optional(z.int().describe("The number of all records available across pages.")),
	participants: z.optional(
		z
			.array(
				z.object({
					customer_key: z.optional(
						z
							.string()
							.max(35)
							.describe(
								"The participant's SDK identifier. This value can be alphanumeric, up to a maximum length of 35 characters.",
							),
					),
					duration: z.optional(
						z
							.int()
							.describe(
								"Participant duration, in seconds, calculated by subtracting the `leave_time` from the `join_time` for the `user_id`. If the participant leaves and rejoins the same meeting, they will be assigned a different `user_id` and Zoom displays their new duration in a separate object. Note that because of this, the duration may not reflect the total time the user was in the meeting.",
							),
					),
					failover: z.optional(
						z.boolean().describe("Whether failover occurred during the webinar."),
					),
					id: z.optional(
						z
							.string()
							.describe(
								"The participant's universally unique ID (UUID). \n* If the participant joins the meeting by logging into Zoom, this value is the `id` value in the [**Get a user**](/docs/api-reference/zoom-api/methods#operation/user) API response. \n* If the participant joins the meeting **without** logging into Zoom, this returns an empty string value. \n\n**Note:** Use the `participant_user_id` value instead of this value. We will remove this response in a future release.",
							),
					),
					join_time: z.optional(z.string().datetime().describe("The participant's join time.")),
					leave_time: z.optional(z.string().datetime().describe("The participant's leave time.")),
					name: z.optional(
						z
							.string()
							.describe(
								"The participant's display name. This returns an empty string value if the account calling the API is a BAA account.",
							),
					),
					registrant_id: z.optional(
						z
							.string()
							.describe(
								"The registrant's ID. This field only returns if you provide the `registrant_id` value for the `include_fields` query parameter.",
							),
					),
					status: z.optional(
						z
							.enum(["in_meeting", "in_waiting_room"])
							.describe(
								"The participant's status. \n* `in_meeting` - In a meeting. \n* `in_waiting_room` - In a waiting room.",
							),
					),
					user_email: z.optional(
						z
							.string()
							.regex(
								/(^\s*$|^[A-Za-z0-9!#$%&''*+/=?^_`{|}~-]+(\.[A-Za-z0-9!#$%&''*+/=?^_`{|}~-]+)*@[A-Za-z0-9-]+(\.[A-Za-z0-9-]+)*(\.[A-Za-z]{2,})$)/,
							)
							.describe(
								"The participant's email address. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](/docs/api-reference/using-zoom-apis#email-address) for details. This returns an empty string value if the account calling the API is a BAA account.",
							),
					),
					user_id: z.optional(
						z
							.string()
							.describe(
								"The participant's ID. This ID is assigned to the participant upon joining the webinar and is only valid for that webinar.",
							),
					),
					participant_user_id: z.optional(
						z
							.string()
							.describe(
								"The participant's universally unique ID (UUID). \n* If the participant joins the meeting by logging into Zoom, this value is the `id` value in the [**Get a user**](/docs/api-reference/zoom-api/methods#operation/user) API response. \n* If the participant joins the meeting **without** logging into Zoom, this returns an empty string value.",
							),
					),
					bo_mtg_id: z.optional(
						z
							.string()
							.describe(
								"The [breakout room](https://support.zoom.us/hc/en-us/articles/206476313-Managing-breakout-rooms) ID. Each breakout room is assigned a unique ID.",
							),
					),
				}),
			)
			.describe("Information about the webinar participant."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `1010` <br>\n User does not belong to this account: {accountId} <br>\n**Error Code:** `12702` <br>\n Can not access a webinar a year ago.<br> <br>\n**Error Code:** `200` <br>\n No permission.<br> <br>\n
 */
export const reportWebinarParticipants400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar \"{webinarId}\" not found or has expired <br>\n
 */
export const reportWebinarParticipants404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportWebinarParticipants429Schema = z.unknown();

export const reportWebinarParticipantsQueryResponseSchema = z.lazy(
	() => reportWebinarParticipants200Schema,
);

export const reportWebinarPollsPathParamsSchema = z.object({
	webinarId: z
		.string()
		.describe(
			"The webinar's ID or universally unique ID (UUID). \n* If you provide a webinar ID, the API will return a response for the latest webinar instance. \n* If you provide a webinar UUID that begins with a `/` character or contains the `//` characters, you **must** double-encode the webinar UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nWebinar polls report returned.  \n \nMissing webinar subscription plan.  \n \nOnly available for Paid or ZMP account: {accountId}.
 */
export const reportWebinarPolls200Schema = z.object({
	id: z.optional(z.int().describe("The webinar ID.")),
	questions: z.optional(
		z
			.array(
				z.object({
					email: z.optional(z.email().describe("The participant's email address.")),
					name: z.optional(
						z
							.string()
							.describe(
								"The participant's display name. **Allow participants to answer questions anonymously** setting is enabled for a [poll](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meet), the participant's polling information is kept anonymous and the `name` field will return the &quot;Anonymous Attendee&quot; value.",
							),
					),
					first_name: z.optional(
						z
							.string()
							.describe(
								"The participant's first name. If the **Allow participants to answer questions anonymously** setting is enabled for a [poll](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meet), the participant's polling information is kept anonymous and the `first_name` field will return the &quot;Anonymous Attendee&quot; value.",
							),
					),
					last_name: z.optional(
						z
							.string()
							.describe(
								"The participant's last name. If the **Allow participants to answer questions anonymously** setting is enabled for a [poll](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meet), the participant's polling information is kept anonymous and the `last_name` field will return the &quot;Anonymous Attendee&quot; value.",
							),
					),
					question_details: z.optional(
						z
							.array(
								z.object({
									answer: z.optional(z.string().describe("The user's given answer.")),
									date_time: z.optional(
										z
											.string()
											.describe("The date and time at which the user answered the poll question."),
									),
									polling_id: z.optional(z.string().describe("The poll's ID.")),
									question: z.optional(z.string().describe("The poll question.")),
								}),
							)
							.describe("Information about the user's questions and answers."),
					),
				}),
			)
			.describe("Information about the webinar questions."),
	),
	start_time: z.optional(z.string().datetime().describe("The webinar's start time.")),
	uuid: z.optional(
		z
			.string()
			.describe(
				"The webinar's universally unique identifier (UUID). Each webinar instance generates a webinar UUID.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request\n\n**Error Code:** `1010` <br>\nUser does not belong to this account:{accountId}.<br>\n\n**Error Code:** `12702` <br>\nCan not access a webinar a year ago.<br>\n\n**Error Code:** `200` <br>\nNo permission.<br>\n\n
 */
export const reportWebinarPolls400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found\n\n**Error Code:** `3001` <br>\nWebinar  {webinarId} not found or has expired.<br>\n\n
 */
export const reportWebinarPolls404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportWebinarPolls429Schema = z.unknown();

export const reportWebinarPollsQueryResponseSchema = z.lazy(() => reportWebinarPolls200Schema);

export const reportWebinarQAPathParamsSchema = z.object({
	webinarId: z
		.string()
		.describe(
			"The webinar's ID or universally unique ID (UUID). \n* If you provide a webinar ID, the API will return a response for the latest webinar instance. \n* If you provide a webinar UUID that begins with a `/` character or contains the `//` characters, you **must** double-encode the webinar UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200`   Webinar Q&A report returned. Only available for Paid or ZMP account: {accountId}.   A report can\'t be generated for this account because this account is not subscribed to a webinar plan.
 */
export const reportWebinarQA200Schema = z.object({
	id: z.optional(
		z
			.int()
			.describe(
				"Webinar ID in `long` format, represented as int64 data type in JSON. Also known as the webinar number.",
			),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					user_id: z.optional(
						z
							.string()
							.describe(
								"The user ID of the user who asked the question. This value returns blank for external users.",
							),
					),
					email: z.optional(
						z
							.string()
							.describe(
								"Participant's email. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for details.",
							),
					),
					name: z.optional(
						z
							.string()
							.describe(
								"Participant's display name.  \n  \n\nIf anonymous [Q&amp;A](https://support.zoom.us/hc/en-us/articles/203686015-Getting-Started-with-Question-Answer) option is enabled and if a participant submits the Q&amp;A without providing their name, the value of the `name` field will be &quot;Anonymous Attendee&quot;.",
							),
					),
					question_details: z.optional(
						z
							.array(
								z.object({
									answer: z.optional(
										z
											.string()
											.describe(
												"The given answer. If this is a live answer, the value is 'live answered'.\n**Note:** All answers will be returned together and separated by semicolons. For more detailed answer information, please see the \"answer_details\" field.",
											),
									),
									question: z.optional(z.string().describe("Asked question.")),
									question_id: z.optional(z.string().describe("Question UUID.")),
									create_time: z.optional(z.string().describe("Question creation time.")),
									question_status: z.optional(
										z
											.enum(["default", "open", "dismissed", "answered", "deleted"])
											.describe("Question status.\nIf not supported, the value will be `default`."),
									),
									answer_details: z.optional(
										z
											.array(
												z.object({
													user_id: z.optional(
														z
															.string()
															.describe(
																"The user ID of the user who answered the question. This value returns blank for external users.",
															),
													),
													name: z.optional(
														z
															.string()
															.describe("User display name, including the host or participant. "),
													),
													email: z.optional(
														z
															.string()
															.describe(
																"Participant's email. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for details.",
															),
													),
													content: z.optional(
														z
															.string()
															.max(1024)
															.describe(
																"The answer from the host or the comment from a participant.",
															),
													),
													create_time: z.optional(z.string().describe("Content submission time.")),
													type: z.optional(
														z
															.enum([
																"default",
																"host_answered_publicly",
																"host_answered_privately",
																"participant_commented",
																"host_answered",
															])
															.default("default")
															.describe("Type of answer."),
													),
												}),
											)
											.describe("Array of answers from user."),
									),
								}),
							)
							.describe("Array of questions from the user."),
					),
				}),
			)
			.describe("Array of webinar question objects."),
	),
	start_time: z.optional(z.string().datetime().describe("Webinar start time.")),
	uuid: z.optional(
		z
			.string()
			.describe(
				"Webinar UUID. Each webinar instance will generate its own UUID - after a webinar ends, a new UUID will be generated for the next instance of the webinar. Double-encode your UUID when using it for API calls if the UUID begins with a '/' or contains '//' in it.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n No permission.<br> <br>\n
 */
export const reportWebinarQA400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: {userId}.<br> <br>\n**Error Code:** `3001` <br>\n Webinar  {webinarId} not found or has expired.<br> <br>\n
 */
export const reportWebinarQA404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportWebinarQA429Schema = z.unknown();

export const reportWebinarQAQueryResponseSchema = z.lazy(() => reportWebinarQA200Schema);

export const reportWebinarSurveyPathParamsSchema = z.object({
	webinarId: z
		.string()
		.describe(
			"The webinar's ID or universally unique ID (UUID). \n* If you provide a webinar ID, the API returns a response for the latest webinar instance. \n* If you provide a webinar UUID that begins with a `/` character or contains the `//` characters, you **must** double-encode the webinar UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nWebinar survey report returned.  \n \nMissing webinar subscription plan.  \n \nOnly available for Paid or ZMP account: {accountId}.
 */
export const reportWebinarSurvey200Schema = z.object({
	webinar_id: z.optional(z.int().describe("The webinar ID.")),
	webinar_uuid: z.optional(
		z
			.string()
			.describe(
				"The webinar's universally unique identifier (UUID). Each webinar instance generates a webinar UUID.",
			),
	),
	start_time: z.optional(z.string().datetime().describe("The webinar's start time.")),
	survey_id: z.optional(z.string().describe("The survey's ID")),
	survey_name: z.optional(z.string().describe("The name of survey")),
	survey_answers: z.optional(
		z
			.array(
				z.object({
					email: z.optional(z.email().describe("The participant's email address.")),
					name: z.optional(
						z
							.string()
							.describe(
								"The participant's display name. **Allow participants to answer questions anonymously** setting is enabled for a [survey](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0057559), the participant's survey information is kept anonymous and the `name` field will return the &quot;Anonymous Attendee&quot; value.",
							),
					),
					first_name: z.optional(
						z
							.string()
							.describe(
								"The participant's first name. If the **Allow participants to answer questions anonymously** setting is enabled for a [survey](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0057559), the participant's survey information is kept anonymous and the `first_name` field will return the &quot;Anonymous Attendee&quot; value.",
							),
					),
					last_name: z.optional(
						z
							.string()
							.describe(
								"The participant's last name. If the **Allow participants to answer questions anonymously** setting is enabled for a [survey](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0057559), the participant's survey information is kept anonymous and the `last_name` field will return the &quot;Anonymous Attendee&quot; value.",
							),
					),
					answer_details: z.optional(
						z
							.array(
								z.object({
									question: z.optional(z.string().describe("The survey question.")),
									question_id: z.optional(z.string().describe("The question's ID")),
									answer: z.optional(z.string().describe("The user's given answer.")),
									date_time: z.optional(
										z
											.string()
											.describe(
												"The date and time at which the user answered the survey question.",
											),
									),
								}),
							)
							.describe("Information about the user's questions and answers."),
					),
				}),
			)
			.describe("Information about the survey questions and answers."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `1010` <br>\n User does not belong to this account:{accountId}.<br> <br>\n**Error Code:** `12702` <br>\n Can not access a webinar a year ago.<br> <br>\n**Error Code:** `200` <br>\n No permission.<br> <br>\n
 */
export const reportWebinarSurvey400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar  {webinarId} not found or has expired.<br> <br>\n
 */
export const reportWebinarSurvey404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const reportWebinarSurvey429Schema = z.unknown();

export const reportWebinarSurveyQueryResponseSchema = z.lazy(() => reportWebinarSurvey200Schema);

export const listSIPPhonePhonesQueryParamsSchema = z.object({
	search_key: z.optional(
		z
			.string()
			.describe(
				"A user's user name or email address. If this parameter is provided, only the SIP phone system integration enabled for that specific user will be returned. Otherwise, all SIP phones on an account will be returned.",
			),
	),
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. This tokan's expiration period is 15 minutes.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nSIP phones listed successfully.\n\n**Error Code:** `200`  \n \nPermission missing. Enable SIP phone integration by contacting a Zoom admin first.
 */
export const listSIPPhonePhones200Schema = z.object({
	next_page_token: z.optional(z.string()),
	page_size: z.optional(
		z
			.int()
			.max(300)
			.default(30)
			.describe("The number of records returned within a single API call."),
	),
	phones: z.optional(
		z
			.array(
				z.object({
					authorization_name: z.optional(
						z
							.string()
							.describe("The authorization name of the user that is registered for SIP phone."),
					),
					domain: z.optional(
						z.string().describe("The name or IP address of your provider's SIP domain."),
					),
					phone_id: z.optional(z.string().describe("The SIP phone ID.")),
					password: z.optional(
						z.string().describe("The password generated for the user in the SIP account.\n"),
					),
					registration_expire_time: z.optional(
						z
							.int()
							.describe(
								"The number of minutes after which the SIP registration of the Zoom client user will expire, and the client will auto register to the SIP server. ",
							),
					),
					user_email: z.optional(
						z
							.email()
							.describe(
								"The email address of the user to associate with the SIP Phone. Can add `.pc`, `.mobile`, `.pad` at the end of the email (for example, `user@example.com.pc`) to add accounts for different platforms for the same user.",
							),
					),
					user_name: z.optional(
						z.string().describe("The phone number associated with the user in the SIP account. "),
					),
					voice_mail: z.optional(z.string().describe("The number to dial for checking voicemail.")),
					display_number: z.optional(
						z
							.string()
							.max(64)
							.describe(
								"The displayed phone number associated with the user can be either in extension format or E.164 format. You can specify the displayed number when the dialable number differs from the SIP username.",
							),
					),
					server: z.optional(
						z
							.object({
								proxy_server: z.optional(
									z
										.string()
										.describe(
											"The IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.",
										),
								),
								register_server: z.optional(
									z
										.string()
										.describe(
											"The IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.",
										),
								),
								transport_protocol: z.optional(
									z
										.enum(["UDP", "TCP", "TLS", "AUTO"])
										.describe(
											"Protocols supported by the SIP provider.  \n  The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.",
										),
								),
							})
							.describe(
								"Defined a set of basic components of SIP network architecture, including proxy_server, register_server and transport_protocol.",
							),
					),
					server_2: z.optional(
						z
							.object({
								proxy_server: z.optional(
									z
										.string()
										.describe(
											"The IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.",
										),
								),
								register_server: z.optional(
									z
										.string()
										.describe(
											"The IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.",
										),
								),
								transport_protocol: z.optional(
									z
										.enum(["UDP", "TCP", "TLS", "AUTO"])
										.describe(
											"Protocols supported by the SIP provider.  \n  The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.",
										),
								),
							})
							.describe(
								"Defined a set of basic components of SIP network architecture, including proxy_server, register_server and transport_protocol.",
							),
					),
					server_3: z.optional(
						z
							.object({
								proxy_server: z.optional(
									z
										.string()
										.describe(
											"The IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.",
										),
								),
								register_server: z.optional(
									z
										.string()
										.describe(
											"The IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.",
										),
								),
								transport_protocol: z.optional(
									z
										.enum(["UDP", "TCP", "TLS", "AUTO"])
										.describe(
											"Protocols supported by the SIP provider.  \n  The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.",
										),
								),
							})
							.describe(
								"Defined a set of basic components of SIP network architecture, including proxy_server, register_server and transport_protocol.",
							),
					),
				}),
			)
			.max(300)
			.describe("SIP phones object."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n
 */
export const listSIPPhonePhones400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n **Error Code:** `124` <br>\n Invalid access token. <br>\n
 */
export const listSIPPhonePhones401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n **Error Code:** `3306` <br>\n No permission. <br>\n
 */
export const listSIPPhonePhones403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const listSIPPhonePhones429Schema = z.unknown();

export const listSIPPhonePhonesQueryResponseSchema = z.lazy(() => listSIPPhonePhones200Schema);

/**
 * @description **HTTP Status Code:** `201`  \n \nSIP phone created.\n
 */
export const enableSIPPhonePhones201Schema = z.object({
	phone_id: z.optional(z.string().describe("The SIP phone ID.")),
	authorization_name: z.optional(
		z
			.string()
			.max(64)
			.describe("The authorization name of the user that is registered for SIP phone."),
	),
	domain: z.optional(
		z
			.string()
			.max(64)
			.describe("The name or IP address of your provider's SIP domain (example: CDC.WEB). "),
	),
	password: z.optional(
		z.string().describe("The password generated for the user in the SIP account."),
	),
	registration_expire_time: z.optional(
		z
			.int()
			.min(1)
			.max(127)
			.default(60)
			.describe(
				"The number of minutes after which the SIP registration of the Zoom client user will expire, and the client will auto register to the SIP server.",
			),
	),
	user_email: z.optional(
		z
			.email()
			.max(64)
			.describe(
				"The email address of the user to associate with the SIP Phone. Can add `.pc`, `.mobile`, `.pad` at the end of the email (for example, `user@example.com.mac`) to add accounts for different platforms for the same user.",
			),
	),
	user_name: z.optional(
		z.string().max(64).describe("The phone number associated with the user in the SIP account."),
	),
	voice_mail: z.optional(
		z.string().max(255).describe("The number to dial for checking voicemail."),
	),
	display_number: z.optional(
		z
			.string()
			.max(64)
			.describe(
				"The displayed phone number associated with the user can be either in extension format or E.164 format. You can specify the displayed number when the dialable number differs from the SIP username.",
			),
	),
	server: z.optional(
		z
			.object({
				proxy_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.",
						),
				),
				register_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.",
						),
				),
				transport_protocol: z.optional(
					z
						.enum(["UDP", "TCP", "TLS", "AUTO"])
						.describe(
							"Protocols supported by the SIP provider.  \n  The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.",
						),
				),
			})
			.describe(
				"Defined a set of basic components of SIP network architecture, including proxy_server, register_server and transport_protocol.",
			),
	),
	server_2: z.optional(
		z
			.object({
				proxy_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.",
						),
				),
				register_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.",
						),
				),
				transport_protocol: z.optional(
					z
						.enum(["UDP", "TCP", "TLS", "AUTO"])
						.describe(
							"Protocols supported by the SIP provider.  \n  The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.",
						),
				),
			})
			.describe(
				"Defined a set of basic components of SIP network architecture, including proxy_server, register_server and transport_protocol.",
			),
	),
	server_3: z.optional(
		z
			.object({
				proxy_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.",
						),
				),
				register_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.",
						),
				),
				transport_protocol: z.optional(
					z
						.enum(["UDP", "TCP", "TLS", "AUTO"])
						.describe(
							"Protocols supported by the SIP provider.  \n  The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.",
						),
				),
			})
			.describe(
				"Defined a set of basic components of SIP network architecture, including proxy_server, register_server and transport_protocol.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n Permission missing. Enable SIP phone integration by contacting a Zoom admin first.<br> <br>\n**Error Code:** `300` <br>\n SIP phone with the same email already exists. <br>\n
 */
export const enableSIPPhonePhones400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n **Error Code:** `124` <br>\n Invalid access token. <br>\n
 */
export const enableSIPPhonePhones401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n **Error Code:** `3306` <br>\n No permission. <br>\n
 */
export const enableSIPPhonePhones403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User {email} not exist or not belong to this account. <br>\n
 */
export const enableSIPPhonePhones404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const enableSIPPhonePhones429Schema = z.unknown();

export const enableSIPPhonePhonesMutationRequestSchema = z.object({
	authorization_name: z
		.string()
		.max(64)
		.describe("The authorization name of the user that is registered for SIP phone."),
	domain: z
		.string()
		.max(64)
		.describe("The name or IP address of your provider's SIP domain, such as example.com. "),
	password: z.string().describe("The password generated for the user in the SIP account."),
	registration_expire_time: z.optional(
		z
			.int()
			.min(1)
			.max(127)
			.default(60)
			.describe(
				"The number of minutes after which the SIP registration of the Zoom client user expires, and the client will auto register to the SIP server.",
			),
	),
	user_email: z
		.email()
		.max(64)
		.describe(
			"The email address of the user to associate with the SIP Phone. Can add `.pc`, `.mobile`, `.pad` at the end of the email, such as `user@example.com.pc`, to add accounts for different platforms for the same user.",
		),
	user_name: z
		.string()
		.max(64)
		.describe("The phone number associated with the user in the SIP account."),
	voice_mail: z.optional(
		z.string().max(255).describe("The number to dial for checking voicemail."),
	),
	display_number: z.optional(
		z
			.string()
			.max(64)
			.describe(
				"The displayed phone number associated with the user can be either in extension format or E.164 format. You can specify the displayed number when the dialable number differs from the SIP username.",
			),
	),
	server: z
		.object({
			proxy_server: z.optional(
				z
					.string()
					.describe(
						"The IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.",
					),
			),
			register_server: z.optional(
				z
					.string()
					.describe(
						"The IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.",
					),
			),
			transport_protocol: z.optional(
				z
					.enum(["UDP", "TCP", "TLS", "AUTO"])
					.describe(
						"Protocols supported by the SIP provider.  \n  The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.",
					),
			),
		})
		.describe(
			"Defined a set of basic components of SIP network architecture, including proxy_server, register_server and transport_protocol.",
		),
	server_2: z.optional(
		z
			.object({
				proxy_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.",
						),
				),
				register_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.",
						),
				),
				transport_protocol: z.optional(
					z
						.enum(["UDP", "TCP", "TLS", "AUTO"])
						.describe(
							"Protocols supported by the SIP provider.  \n  The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.",
						),
				),
			})
			.describe(
				"Defined a set of basic components of SIP network architecture, including proxy_server, register_server and transport_protocol.",
			),
	),
	server_3: z.optional(
		z
			.object({
				proxy_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.",
						),
				),
				register_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.",
						),
				),
				transport_protocol: z.optional(
					z
						.enum(["UDP", "TCP", "TLS", "AUTO"])
						.describe(
							"Protocols supported by the SIP provider.  \n  The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.",
						),
				),
			})
			.describe(
				"Defined a set of basic components of SIP network architecture, including proxy_server, register_server and transport_protocol.",
			),
	),
});

export const enableSIPPhonePhonesMutationResponseSchema = z.lazy(
	() => enableSIPPhonePhones201Schema,
);

export const deleteSIPPhonePhonesPathParamsSchema = z.object({
	phoneId: z
		.string()
		.describe("The SIP phone ID. It can be retrieved from the **List SIP phones** API."),
});

/**
 * @description **HTTP Status Code:** `204`   SIP phone deleted.
 */
export const deleteSIPPhonePhones204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n **Error Code:** `124` <br>\n Invalid access token. <br>\n
 */
export const deleteSIPPhonePhones401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n **Error Code:** `3336` <br>\n No permission. <br>\n
 */
export const deleteSIPPhonePhones403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `2305` <br>\n SIP phone does not exist: {phone_id}. <br>\n
 */
export const deleteSIPPhonePhones404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const deleteSIPPhonePhones429Schema = z.unknown();

export const deleteSIPPhonePhonesMutationResponseSchema = z.lazy(
	() => deleteSIPPhonePhones204Schema,
);

export const updateSIPPhonePhonesPathParamsSchema = z.object({
	phoneId: z.string().describe("The SIP phone ID. Retrieve this with the **List SIP phones** API."),
});

/**
 * @description **Status Code:** `204` SIP phone updated.
 */
export const updateSIPPhonePhones204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n
 */
export const updateSIPPhonePhones400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `401` <br>\n Unauthorized  \n\n **Error Code:** `124` <br>\n Invalid access token. <br>\n
 */
export const updateSIPPhonePhones401Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n **Error Code:** `3336` <br>\n No permission. <br>\n
 */
export const updateSIPPhonePhones403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `2305` <br>\n SIP phone does not exist: {phone_id}. <br>\n
 */
export const updateSIPPhonePhones404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const updateSIPPhonePhones429Schema = z.unknown();

export const updateSIPPhonePhonesMutationRequestSchema = z.object({
	authorization_name: z.optional(
		z
			.string()
			.max(64)
			.describe("The authorization name of the user that is registered for SIP phone."),
	),
	domain: z.optional(
		z
			.string()
			.max(64)
			.describe("The name or IP address of your provider's SIP domain, such as example.com. "),
	),
	password: z.optional(
		z.string().describe("The password generated for the user in the SIP account."),
	),
	registration_expire_time: z.optional(
		z
			.int()
			.min(1)
			.max(127)
			.default(60)
			.describe(
				"The number of minutes after which the SIP registration of the Zoom client user will expire, and the client will auto register to the SIP server.",
			),
	),
	user_name: z.optional(
		z.string().max(64).describe("The phone number associated with the user in the SIP account."),
	),
	voice_mail: z.optional(
		z.string().max(255).describe("The number to dial for checking voicemail."),
	),
	display_number: z.optional(
		z
			.string()
			.max(64)
			.describe(
				"The displayed phone number associated with the user can be either in extension format or E.164 format. You can specify the displayed number when the dialable number differs from the SIP username.",
			),
	),
	server: z.optional(
		z
			.object({
				proxy_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.",
						),
				),
				register_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.",
						),
				),
				transport_protocol: z.optional(
					z
						.enum(["UDP", "TCP", "TLS", "AUTO"])
						.describe(
							"Protocols supported by the SIP provider.  \n  The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.",
						),
				),
			})
			.describe(
				"Defined a set of basic components of SIP network architecture, including proxy_server, register_server and transport_protocol.",
			),
	),
	server_2: z.optional(
		z
			.object({
				proxy_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.",
						),
				),
				register_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.",
						),
				),
				transport_protocol: z.optional(
					z
						.enum(["UDP", "TCP", "TLS", "AUTO"])
						.describe(
							"Protocols supported by the SIP provider.  \n  The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.",
						),
				),
			})
			.describe(
				"Defined a set of basic components of SIP network architecture, including proxy_server, register_server and transport_protocol.",
			),
	),
	server_3: z.optional(
		z
			.object({
				proxy_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.",
						),
				),
				register_server: z.optional(
					z
						.string()
						.describe(
							"The IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.",
						),
				),
				transport_protocol: z.optional(
					z
						.enum(["UDP", "TCP", "TLS", "AUTO"])
						.describe(
							"Protocols supported by the SIP provider.  \n  The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.",
						),
				),
			})
			.describe(
				"Defined a set of basic components of SIP network architecture, including proxy_server, register_server and transport_protocol.",
			),
	),
});

export const updateSIPPhonePhonesMutationResponseSchema = z.lazy(
	() => updateSIPPhonePhones204Schema,
);

export const listmeetingsummariesQueryParamsSchema = z.object({
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through a large set of results. The next page token returns whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	from: z.optional(
		z
			.string()
			.datetime()
			.describe(
				"The start date, in `yyyy-MM-dd'T'HH:mm:ss'Z'` UTC format, used to retrieve the meeting summaries' creation date range.",
			),
	),
	to: z.optional(
		z
			.string()
			.datetime()
			.describe(
				"The end date, in `yyyy-MM-dd'T'HH:mm:ss'Z'` UTC format, used to retrieve the meeting summaries' creation date range.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`\n\nSuccessfully listed meeting summaries of an account.
 */
export const listmeetingsummaries200Schema = z.object({
	page_size: z.optional(
		z.int().max(300).default(30).describe("The number of records returned with a single API call."),
	),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through a large set of results. The next page token returns whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	from: z.optional(
		z
			.string()
			.datetime()
			.describe(
				"The start date, in `yyyy-MM-dd'T'HH:mm:ss'Z'` UTC format, used to retrieve the meeting summaries' creation date range.",
			),
	),
	to: z.optional(
		z
			.string()
			.datetime()
			.describe(
				"The end date, in `yyyy-MM-dd'T'HH:mm:ss'Z'` UTC format, used to retrieve the meeting summaries' creation date range.",
			),
	),
	summaries: z.optional(
		z
			.array(
				z
					.object({
						meeting_host_id: z.optional(
							z.string().describe("The ID of the user who is set as the meeting host."),
						),
						meeting_host_email: z.optional(z.email().describe("The meeting host's email address.")),
						meeting_uuid: z.optional(
							z
								.string()
								.describe(
									"Unique meeting ID. Each meeting instance generates its own meeting UUID. After a meeting ends, a new UUID is generated for the next instance of the meeting. Retrieve a list of UUIDs from past meeting instances using the [**List past meeting instances**](/docs/api-reference/zoom-api/methods#operation/pastMeetings) API. [Double encode](/docs/api/using-zoom-apis/#meeting-id-and-uuid) your UUID when using it for API calls if the UUID begins with a `/` or contains `//` in it.\n",
								),
						),
						meeting_id: z.optional(
							z
								.int()
								.describe(
									"[Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-) - the meeting's unique identifier in **long** format, represented as int64 data type in JSON, also known as the meeting number.",
								),
						),
						meeting_topic: z.optional(z.string().describe("Meeting topic.")),
						meeting_start_time: z.optional(
							z.string().datetime().describe("The meeting's start date and time."),
						),
						meeting_end_time: z.optional(
							z.string().datetime().describe("The meeting's end date and time."),
						),
						summary_start_time: z.optional(
							z.string().datetime().describe("The summary's start date and time."),
						),
						summary_end_time: z.optional(
							z.string().datetime().describe("The summary's end date and time."),
						),
						summary_created_time: z.optional(
							z
								.string()
								.datetime()
								.describe("The date and time when the meeting summary was created."),
						),
						summary_last_modified_time: z.optional(
							z
								.string()
								.datetime()
								.describe("The date and time when the meeting summary was last modified."),
						),
					})
					.describe("The meeting summary object."),
			)
			.describe("List of meeting summary objects."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n**Error Code:** `3000` <br>\n Meeting summary disabled. To enable this feature, enable the **Meeting Summary with AI Companion** setting in the Zoom web portal\'s **Settings** interface. <br>\n**Error Code:** `200` <br>\n Only available for Paid account. <br>\n
 */
export const listmeetingsummaries400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n **Error Code:** `2305` <br>\n Access to meeting summaries is restricted by account settings. To use this feature, disable the **Only share meeting summaries by email** setting in the **Account Settings** page of the Zoom web portal. <br>\n**Error Code:** `2305` <br>\n Access to meeting summaries is restricted to specific IP address ranges. To allow access, go to the **Settings** page in the Zoom web portal and update the **IP address access control** setting. <br>\n
 */
export const listmeetingsummaries403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const listmeetingsummaries429Schema = z.unknown();

export const listmeetingsummariesQueryResponseSchema = z.lazy(() => listmeetingsummaries200Schema);

export const getameetingsummaryPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"The meeting's universally unique ID (UUID). When you provide a meeting UUID that begins with a `/` character or contains the `//` characters, you **must** double-encode the meeting UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200` Meeting summary object returned.
 */
export const getameetingsummary200Schema = z.object({
	meeting_host_id: z.optional(
		z.string().describe("The ID of the user who is set as the meeting host."),
	),
	meeting_host_email: z.optional(z.email().describe("The meeting host's email address.")),
	meeting_uuid: z.optional(
		z
			.string()
			.describe(
				"The unique meeting ID. \n\nEach meeting instance generates its own meeting UUID. After a meeting ends, a new UUID is generated for the next instance of the meeting.\n\n Use the [**List past meeting instances**](/docs/api-reference/zoom-api/methods#operation/pastMeetings) API to retrieve a list of UUIDs from past meeting instances. [Double encode](/docs/api/rest/using-zoom-apis/#meeting-id-and-uuid) your UUID when using it for API calls if the UUID begins with a `/` or contains `//` in it.\n",
			),
	),
	meeting_id: z.optional(
		z
			.int()
			.describe(
				"[The meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-) \nThe meeting's unique identifier in **long** format, represented as int64 data type in JSON. Also known as the meeting number.",
			),
	),
	meeting_topic: z.optional(z.string().describe("The meeting topic.")),
	meeting_start_time: z.optional(
		z.string().datetime().describe("The meeting's start date and time."),
	),
	meeting_end_time: z.optional(z.string().datetime().describe("The meeting's end date and time.")),
	summary_start_time: z.optional(
		z.string().datetime().describe("The summary's start date and time."),
	),
	summary_end_time: z.optional(z.string().datetime().describe("The summary's end date and time.")),
	summary_created_time: z.optional(
		z.string().datetime().describe("The date and time when the meeting summary was created."),
	),
	summary_last_modified_time: z.optional(
		z.string().datetime().describe("The date and time when the meeting summary was last modified."),
	),
	summary_last_modified_user_id: z.optional(
		z.string().describe("The user ID of the user who last modified the meeting summary."),
	),
	summary_last_modified_user_email: z.optional(
		z.string().describe("The user email of the user who last modified the meeting summary."),
	),
	summary_title: z.optional(z.string().describe("The summary title.")),
	summary_overview: z.optional(z.string().describe("The summary overview.")),
	summary_details: z.optional(
		z
			.array(
				z
					.object({
						label: z.optional(z.string().describe("The summary label.")),
						summary: z.optional(z.string().describe("The summary content.")),
					})
					.describe("The summary detail object."),
			)
			.describe("The summary content details."),
	),
	next_steps: z.optional(
		z.array(z.string().describe("The next step.")).describe("The next steps."),
	),
	edited_summary: z.optional(
		z
			.object({
				summary_overview: z.optional(z.string().describe("The user edited summary overview.")),
				summary_details: z.optional(z.string().describe("The user edited summary details.")),
				next_steps: z.optional(
					z
						.array(z.string().describe("The user edited next step."))
						.describe("The user edited next steps."),
				),
			})
			.describe("The edited summary content."),
	),
	summary_content: z.optional(
		z
			.string()
			.describe(
				"The complete meeting summary in Markdown format. This unified field is used for all summaries. For compatibility, the legacy fields `summary_overview`, `summary_details`, `next_steps`, and `edited_summary` are still returned, but are deprecated and will not be supported in the future.",
			),
	),
	summary_doc_url: z.optional(
		z.url().describe("The URL to view the full summary document in Zoom Docs."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n Only available for Paid account. <br>\n**Error Code:** `300` <br>\n Invalid meeting ID. <br>\n
 */
export const getameetingsummary400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n **Error Code:** `2305` <br>\n Access to meeting summaries is restricted by account settings. To use this feature, disable the **Only share meeting summaries by email** setting in the **Account Settings** page of the Zoom web portal. <br>\n**Error Code:** `2305` <br>\n Access to meeting summaries is restricted to specific IP address ranges. To allow access, go to the **Settings** page in the Zoom web portal and update the **IP address access control** setting. <br>\n**Error Code:** `2305` <br>\n The meeting summary has been moved to Trash and cannot be accessed. <br>\n
 */
export const getameetingsummary403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const getameetingsummary404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const getameetingsummary429Schema = z.unknown();

export const getameetingsummaryQueryResponseSchema = z.lazy(() => getameetingsummary200Schema);

export const deletemeetingorwebinarsummaryPathParamsSchema = z.object({
	meetingId: z
		.string()
		.describe(
			"The meeting's universally unique ID (UUID). When you provide a meeting UUID that begins with a `/` character or contains the `//` characters, you **must** double-encode the meeting UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `204` Meeting summary deleted.
 */
export const deletemeetingorwebinarsummary204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n Only available for Paid account. <br>\n**Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `2313` <br>\n Failed to delete meeting summary. <br>\n
 */
export const deletemeetingorwebinarsummary400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `403` <br>\n Forbidden  \n\n **Error Code:** `2305` <br>\n Access to meeting summaries is restricted by account settings. To use this feature, disable the **Only share meeting summaries by email** setting in the **Account Settings** page of the Zoom web portal. <br>\n**Error Code:** `2305` <br>\n Access to meeting summaries is restricted to specific IP address ranges. To allow access, go to the **Settings** page in the Zoom web portal and update the **IP address access control** setting. <br>\n**Error Code:** `2305` <br>\n The meeting summary has been moved to Trash and cannot be accessed. <br>\n
 */
export const deletemeetingorwebinarsummary403Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const deletemeetingorwebinarsummary404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const deletemeetingorwebinarsummary429Schema = z.unknown();

export const deletemeetingorwebinarsummaryMutationResponseSchema = z.lazy(
	() => deletemeetingorwebinarsummary204Schema,
);

export const meetingSurveyGetPathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, store it as a long-format integer and **not** a simple integer. Meeting IDs can be more than 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `200`   \n \n Meeting survey object returned.
 */
export const meetingSurveyGet200Schema = z
	.object({
		custom_survey: z.optional(
			z
				.object({
					title: z.optional(
						z.string().max(64).describe("The survey's title, up to 64 characters."),
					),
					anonymous: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Allow participants to anonymously answer survey questions. \n\n This value defaults to `true`.",
							),
					),
					numbered_questions: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the number in the question name. \n\n This value defaults to `true`.",
							),
					),
					show_question_type: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the question type in the question name. \n\n This value defaults to `false`.",
							),
					),
					feedback: z.optional(
						z
							.string()
							.max(320)
							.describe(
								"The survey's feedback, up to 320 characters. \n\n This value defaults to `Thank you so much for taking the time to complete the survey. Your feedback really makes a difference.`.",
							),
					),
					questions: z.optional(
						z
							.array(
								z.object({
									name: z.optional(
										z.string().describe("The survey question, up to 420 characters."),
									),
									type: z.optional(
										z
											.enum([
												"single",
												"multiple",
												"matching",
												"rank_order",
												"short_answer",
												"long_answer",
												"fill_in_the_blank",
												"rating_scale",
											])
											.describe(
												"The survey's question and answer type. \n* `single` - Single choice. \n* `multiple` - Multiple choice. \n* `matching` - Matching. \n* `rank_order` - Rank order \n* `short_answer` - Short answer \n* `long_answer` - Long answer. \n* `fill_in_the_blank` - Fill in the blank \n* `rating_scale` - Rating scale.",
											),
									),
									answer_required: z.optional(
										z
											.boolean()
											.default(false)
											.describe(
												"Whether participants must answer the question. \n* `true` - The participant must answer the question. \n* `false` - The participant does not need to answer the question. \n\n This value defaults to `false`.",
											),
									),
									show_as_dropdown: z.optional(
										z
											.boolean()
											.default(false)
											.describe(
												"Whether to display the radio selection as a drop-down box. \n* `true` - Show as a drop-down box. \n* `false` - Do not show as a drop-down box. \n\n This value defaults to `false`.",
											),
									),
									answers: z.optional(
										z
											.array(z.string().max(200))
											.min(2)
											.describe(
												"The survey question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` questions, you can only provide a maximum of 50 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
											),
									),
									prompts: z.optional(
										z
											.array(
												z.object({
													prompt_question: z.optional(
														z.string().max(200).describe("The question prompt's title."),
													),
												}),
											)
											.min(2)
											.max(10)
											.describe(
												"Information about the prompt questions. This field only applies to `matching` and `rank_order` questions. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
											),
									),
									answer_min_character: z.optional(
										z
											.int()
											.min(1)
											.describe(
												"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` questions. You must provide at least a **one** character minimum value.",
											),
									),
									answer_max_character: z.optional(
										z
											.int()
											.describe(
												"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` questions. \n* For `short_answer` question, a maximum of 500 characters. \n* For `long_answer` question, a maximum of 2,000 characters.",
											),
									),
									rating_min_value: z.optional(
										z
											.int()
											.min(0)
											.describe(
												"The rating scale's minimum value. This value cannot be less than zero. \n\n This field only applies to the `rating_scale` survey.",
											),
									),
									rating_max_value: z.optional(
										z
											.int()
											.max(10)
											.describe(
												"The rating scale's maximum value, up to a maximum value of 10. \n\n This field only applies to the `rating_scale` survey.",
											),
									),
									rating_min_label: z.optional(
										z
											.string()
											.max(50)
											.describe(
												"The low score label used for the `rating_min_value` field, up to 50 characters. \n\n This field only applies to the `rating_scale` survey.",
											),
									),
									rating_max_label: z.optional(
										z
											.string()
											.max(50)
											.describe(
												"The high score label used for the `rating_max_value` field, up to 50 characters. \n\n This field only applies to the `rating_scale` survey.",
											),
									),
								}),
							)
							.min(1)
							.max(100)
							.describe("Information about the meeting survey's questions."),
					),
				})
				.describe("Information about the customized meeting survey."),
		),
		show_in_the_browser: z.optional(
			z
				.boolean()
				.default(true)
				.describe(
					"Whether the **Show in the browser when the meeting ends** option is enabled. \n* `true` - Enabled. \n* `false` - Disabled. \n\n This value defaults to `true`.",
				),
		),
		third_party_survey: z.optional(
			z.string().max(64).describe("The link to the third party meeting survey."),
		),
	})
	.describe("Information about the meeting survey.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `3000` <br>\n Cannot access webinar information. <br>\n**Error Code:** `3000` <br>\n Meeting survey disabled. To enable this feature, enable the \"Meeting Survey\" setting in the Zoom web portal\'s \"Settings\" interface. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingSurveyGet400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `300` <br>\n Meeting ID does not exist. <br>\n**Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingSurveyGet404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingSurveyGet429Schema = z.unknown();

export const meetingSurveyGetQueryResponseSchema = z.lazy(() => meetingSurveyGet200Schema);

export const meetingSurveyDeletePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, you must store it as a long format integer and **not** an integer. Meeting IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `204`   \n \n Meeting survey deleted.
 */
export const meetingSurveyDelete204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `3000` <br>\n * Cannot access webinar information. <br>\n * Meeting survey disabled. To enable this feature, enable the **Meeting Survey** setting in the Zoom web portal\'s **Settings** interface. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const meetingSurveyDelete400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `300` <br>\n Meeting ID does not exist. <br>\n**Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingSurveyDelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingSurveyDelete429Schema = z.unknown();

export const meetingSurveyDeleteMutationResponseSchema = z.lazy(() => meetingSurveyDelete204Schema);

export const meetingSurveyUpdatePathParamsSchema = z.object({
	meetingId: z.coerce
		.number()
		.int()
		.describe(
			"The meeting's ID. \n\n When storing this value in your database, store it as a long-format integer and **not** a simple integer. Meeting IDs can be over 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `204`   \n \n Meeting survey updated.
 */
export const meetingSurveyUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid meeting ID. <br>\n**Error Code:** `300` <br>\n Invalid third party survey: {third_party_survey}. <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n**Error Code:** `3000` <br>\n Cannot access Webinar information. <br>\n**Error Code:** `3000` <br>\n Meeting survey disabled. To enable this feature, enable the **Meeting Survey** setting in the Zoom web portal\'s **Settings** interface. <br>\n**Error Code:** `3000` <br>\n Not allowed host to use a 3rd-party survey link. To use this feature, enable the \"Allow host to use a 3rd-party survey link\" setting in the \"Account Settings\" page of the Zoom web portal. <br>\n
 */
export const meetingSurveyUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `300` <br>\n Meeting ID does not exist. <br>\n**Error Code:** `3001` <br>\n Meeting does not exist: {meetingId}. <br>\n
 */
export const meetingSurveyUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingSurveyUpdate429Schema = z.unknown();

export const meetingSurveyUpdateMutationRequestSchema = z
	.object({
		custom_survey: z.optional(
			z
				.object({
					title: z.optional(
						z.string().max(64).describe("The survey's title, up to 64 characters."),
					),
					anonymous: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Allow participants to anonymously answer survey questions. \n\n This value defaults to `true`.",
							),
					),
					numbered_questions: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the number in the question name. \n\n This value defaults to `true`.",
							),
					),
					show_question_type: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the question type in the question name. \n\n This value defaults to `false`.",
							),
					),
					feedback: z.optional(
						z
							.string()
							.max(320)
							.describe(
								"The survey's feedback, up to 320 characters. \n\n This value defaults to `Thank you so much for taking the time to complete the survey. Your feedback really makes a difference.`.",
							),
					),
					questions: z.optional(
						z
							.array(
								z.object({
									name: z.optional(
										z.string().describe("The survey question, up to 420 characters."),
									),
									type: z.optional(
										z
											.enum([
												"single",
												"multiple",
												"matching",
												"rank_order",
												"short_answer",
												"long_answer",
												"fill_in_the_blank",
												"rating_scale",
											])
											.describe(
												"The survey's question and answer type. \n* `single` - Single choice. \n* `multiple` - Multiple choice. \n* `matching` - Matching. \n* `rank_order` - Rank order \n* `short_answer` - Short answer \n* `long_answer` - Long answer. \n* `fill_in_the_blank` - Fill in the blank \n* `rating_scale` - Rating scale.",
											),
									),
									answer_required: z.optional(
										z
											.boolean()
											.default(false)
											.describe(
												"Whether participants must answer the question. \n* `true` - The participant must answer the question. \n* `false` - The participant does not need to answer the question. \n\n This value defaults to `false`.",
											),
									),
									show_as_dropdown: z.optional(
										z
											.boolean()
											.default(false)
											.describe(
												"Whether to display the radio selection as a drop-down box. \n* `true` - Show as a drop-down box. \n* `false` - Do not show as a drop-down box. \n\n This value defaults to `false`.",
											),
									),
									answers: z.optional(
										z
											.array(z.string().max(200))
											.min(2)
											.describe(
												"The survey question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` questions, you can only provide a maximum of 50 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
											),
									),
									prompts: z.optional(
										z
											.array(
												z.object({
													prompt_question: z.optional(
														z.string().max(200).describe("The question prompt's title."),
													),
												}),
											)
											.min(2)
											.max(10)
											.describe(
												"Information about the prompt questions. This field only applies to `matching` and `rank_order` questions. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
											),
									),
									answer_min_character: z.optional(
										z
											.int()
											.min(1)
											.describe(
												"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` questions. You must provide at least a **one** character minimum value.",
											),
									),
									answer_max_character: z.optional(
										z
											.int()
											.describe(
												"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` questions. \n* For `short_answer` question, a maximum of 500 characters. \n* For `long_answer` question, a maximum of 2,000 characters.",
											),
									),
									rating_min_value: z.optional(
										z
											.int()
											.min(0)
											.describe(
												"The rating scale's minimum value. This value cannot be less than zero. \n\n This field only applies to the `rating_scale` survey.",
											),
									),
									rating_max_value: z.optional(
										z
											.int()
											.max(10)
											.describe(
												"The rating scale's maximum value, up to a maximum value of 10. \n\n This field only applies to the `rating_scale` survey.",
											),
									),
									rating_min_label: z.optional(
										z
											.string()
											.max(50)
											.describe(
												"The low score label used for the `rating_min_value` field, up to 50 characters. \n\n This field only applies to the `rating_scale` survey.",
											),
									),
									rating_max_label: z.optional(
										z
											.string()
											.max(50)
											.describe(
												"The high score label used for the `rating_max_value` field, up to 50 characters. \n\n This field only applies to the `rating_scale` survey.",
											),
									),
								}),
							)
							.min(1)
							.max(100)
							.describe("Information about the meeting survey's questions."),
					),
				})
				.describe("Information about the customized meeting survey."),
		),
		show_in_the_browser: z.optional(
			z
				.boolean()
				.default(true)
				.describe(
					"Whether the **Show in the browser when the meeting ends** option is enabled. \n* `true` - Enabled. \n* `false` - Disabled. \n\n This value defaults to `true`.",
				),
		),
		third_party_survey: z.optional(
			z.string().max(64).describe("The link to the third party meeting survey."),
		),
	})
	.describe("Information about the meeting survey.");

export const meetingSurveyUpdateMutationResponseSchema = z.lazy(() => meetingSurveyUpdate204Schema);

/**
 * @description **HTTP Status Code:** `200`  \n \nTSP account detail returned successfully.
 */
export const tsp200Schema = z.object({
	dial_in_number_unrestricted: z.optional(
		z
			.boolean()
			.describe(
				"Control restriction on account users adding a TSP number outside of account's dial in numbers.",
			),
	),
	dial_in_numbers: z.optional(
		z
			.array(
				z.object({
					code: z.optional(z.string().describe("Country code.")),
					number: z.optional(
						z.string().max(16).describe("Dial-in number. Length is less than 16."),
					),
					type: z.optional(z.string().describe("Dial-in number type.")),
				}),
			)
			.describe("List of dial in numbers."),
	),
	enable: z.optional(z.boolean().describe("Enable Telephony Service Provider for account users.")),
	master_account_setting_extended: z.optional(
		z
			.boolean()
			.describe(
				"For master account, extend its TSP setting to all sub accounts. For sub account, extend TSP setting from master account.",
			),
	),
	modify_credential_forbidden: z.optional(
		z
			.boolean()
			.describe("Control restriction on account users being able to modify their TSP credentials."),
	),
	tsp_bridge: z.optional(z.enum(["US_TSP_TB", "EU_TSP_TB"]).describe("Telephony bridge zone")),
	tsp_enabled: z.optional(
		z
			.boolean()
			.describe(
				"Enable TSP feature for account. This has to be enabled to use any other tsp settings/features.",
			),
	),
	tsp_provider: z.optional(z.string().describe("Telephony service provider.")),
});

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const tsp429Schema = z.unknown();

export const tspQueryResponseSchema = z.lazy(() => tsp200Schema);

/**
 * @description **HTTP Status Code:** `204` **No Content**  \n \nTSP Account updated.
 */
export const tspUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid parameter: `tsp_bridge`. <br>\n
 */
export const tspUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const tspUpdate429Schema = z.unknown();

/**
 * @description TSP Account
 */
export const tspUpdateMutationRequestSchema = z.object({
	dial_in_number_unrestricted: z.optional(
		z
			.boolean()
			.describe(
				"Control restriction on account users adding a TSP number outside of account's dial in numbers.",
			),
	),
	enable: z.optional(z.boolean().describe("Enable 3rd party audio conferencing for account users")),
	master_account_setting_extended: z.optional(
		z
			.boolean()
			.describe(
				"For master account, extend its TSP setting to all sub accounts. For sub account, extend TSP setting from master account.",
			),
	),
	modify_credential_forbidden: z.optional(
		z
			.boolean()
			.describe("Control restriction on account users being able to modify their TSP credentials."),
	),
	tsp_bridge: z.optional(z.enum(["US_TSP_TB", "EU_TSP_TB"]).describe("Telephony bridge")),
	tsp_enabled: z.optional(
		z
			.boolean()
			.describe(
				"Enable TSP feature for account. This has to be enabled to use any other tsp settings/features.",
			),
	),
	tsp_provider: z.optional(z.string().describe("3rd party audio conferencing provider")),
});

export const tspUpdateMutationResponseSchema = z.lazy(() => tspUpdate204Schema);

export const userTSPsPathParamsSchema = z.object({
	userId: z
		.string()
		.describe(
			"The user ID or email address of the user. For user-level apps, pass the `me` value.",
		),
});

/**
 * @description **HTTP Status Code:** `200` **OK**  \n \nTSP account list returned successfully.
 */
export const userTSPs200Schema = z.object({
	tsp_accounts: z.optional(
		z
			.array(
				z
					.object({
						conference_code: z
							.string()
							.min(1)
							.max(16)
							.describe("Conference code: numeric value, length is less than 16."),
						dial_in_numbers: z.optional(
							z
								.array(
									z.object({
										code: z.optional(z.string().max(6).describe("Country code.")),
										country_label: z.optional(
											z
												.string()
												.max(10)
												.describe("Country label, if passed, will display in place of code."),
										),
										number: z.optional(
											z.string().min(1).max(16).describe("Dial-in number. Length is less than 16."),
										),
										type: z.optional(
											z
												.enum(["toll", "tollfree", "media_link"])
												.describe(
													"Dial-in number types. \n `toll` - Toll number.  \n `tollfree` - Toll free number.  \n \n`media_link` - Media link.",
												),
										),
									}),
								)
								.describe("List of dial in numbers."),
						),
						id: z.optional(z.enum(["1", "2"]).describe("The TSP account's ID.")),
						leader_pin: z
							.string()
							.min(1)
							.max(16)
							.describe("Leader PIN. Mumeric value, length is less than 16."),
						tsp_bridge: z.optional(
							z.enum(["US_TSP_TB", "EU_TSP_TB"]).describe("Telephony bridge\n"),
						),
					})
					.describe("Details of a TSP account."),
			)
			.describe("List of the user's TSP accounts."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `2024` <br>\n Account has not enabled TSP. <br>\n
 */
export const userTSPs400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: $userId.<br> <br>\n**Error Code:** `1120` <br>\n No valid invitation to join the Zoom account was found for this user.<br>\r\nThis error is thrown if you added a user in your account but the user did not accept the invitation on time and the invitation expired, making the `userId` invalid. <br>\n
 */
export const userTSPs404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const userTSPs429Schema = z.unknown();

export const userTSPsQueryResponseSchema = z.lazy(() => userTSPs200Schema);

export const userTSPCreatePathParamsSchema = z.object({
	userId: z
		.string()
		.describe("The user's user ID or email address. For user-level apps, pass the `me` value."),
});

/**
 * @description **HTTP Status Code:** `201`  \n \nTSP account added.
 */
export const userTSPCreate201Schema = z.object({
	id: z.optional(z.string().describe("The ID of the TSP account.")),
	conference_code: z
		.string()
		.min(1)
		.max(16)
		.describe("Conference code: numeric value, length is less than 16."),
	dial_in_numbers: z.optional(
		z
			.array(
				z.object({
					code: z.optional(z.string().max(6).describe("Country code.")),
					country_label: z.optional(
						z.string().max(10).describe("Country Label, if passed, will display in place of code."),
					),
					number: z.optional(
						z.string().min(1).max(16).describe("Dial-in number: length is less than 16."),
					),
					type: z.optional(
						z
							.enum(["toll", "tollfree", "media_link"])
							.describe(
								"Dial-in number types:  \n `toll` - Toll number.  \n `tollfree` -Toll free number.  \n \n`media_link` - Media link.",
							),
					),
				}),
			)
			.describe("List of dial in numbers."),
	),
	leader_pin: z
		.string()
		.min(1)
		.max(16)
		.describe("Leader PIN: numeric value, length is less than 16."),
	tsp_bridge: z.optional(z.enum(["US_TSP_TB", "EU_TSP_TB"]).describe("Telephony bridge")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `2024` <br>\n This account has not enabled TSP.<br> <br>\n**Error Code:** `300` <br>\n Media link is required for AT&T TSP accounts.<br> <br>\n**Error Code:** `300` <br>\n You can add a maximum of two TSP configs. <br>\n
 */
export const userTSPCreate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: $userId.<br> <br>\n**Error Code:** `1120` <br>\n No valid invitation to join the Zoom account was found for this user.<br>\r\nThis error is thrown if you added a user in your account but the user did not accept the invitation on time and the invitation expired, making the `userId` invalid. <br>\n
 */
export const userTSPCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const userTSPCreate429Schema = z.unknown();

export const userTSPCreateMutationRequestSchema = z
	.object({
		conference_code: z
			.string()
			.min(1)
			.max(16)
			.describe("Conference code. A numeric value, with a length less than 16."),
		dial_in_numbers: z.optional(
			z
				.array(
					z.object({
						code: z.optional(z.string().max(6).describe("Country code.")),
						country_label: z.optional(
							z
								.string()
								.max(10)
								.describe("Country Label, if passed, will display in place of code."),
						),
						number: z.optional(
							z.string().min(1).max(16).describe("Dial-in number: length is less than 16."),
						),
						type: z.optional(
							z
								.enum(["toll", "tollfree", "media_link"])
								.describe(
									"Dial-in number types:  \n `toll` - Toll number.  \n `tollfree` -Toll free number.  \n \n`media_link` - Media link.",
								),
						),
					}),
				)
				.describe("List of dial in numbers."),
		),
		leader_pin: z
			.string()
			.min(1)
			.max(16)
			.describe("Leader PIN: numeric value, length is less than 16."),
		tsp_bridge: z.optional(z.enum(["US_TSP_TB", "EU_TSP_TB"]).describe("Telephony bridge")),
	})
	.describe("List of TSP accounts.");

export const userTSPCreateMutationResponseSchema = z.lazy(() => userTSPCreate201Schema);

export const tspUrlUpdatePathParamsSchema = z.object({
	userId: z.string().describe("The user's user ID or email address."),
});

/**
 * @description **Status Code:** `204` **No Content**   \n \nURL set successfully.
 */
export const tspUrlUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `2000` <br>\n Not TSP special account.<br>\n\nThs error means that the account does not have special TSP privileges. Contact Zoom Developer Support for details.<br> <br>\n**Error Code:** `2024` <br>\n Account has not enabled TSP. <br>\n
 */
export const tspUrlUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User {userId} does not exist, or doesn\'t belong to this account. <br>\n**Error Code:** `1120` <br>\n Invite does not exist.\n\nThis error is thrown if you added a user in your account but the user did not accept the invitation on time and the invitation expired, making the `userId` invalid. <br>\n
 */
export const tspUrlUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const tspUrlUpdate429Schema = z.unknown();

/**
 * @description The user\'s global dial-in URL.
 */
export const tspUrlUpdateMutationRequestSchema = z.object({
	audio_url: z.optional(
		z
			.string()
			.max(512)
			.describe(
				"The global dial-in URL for a TSP enabled account. The URL must be valid, with a maximum length of 512 characters.",
			),
	),
});

export const tspUrlUpdateMutationResponseSchema = z.lazy(() => tspUrlUpdate204Schema);

export const userTSPPathParamsSchema = z.object({
	userId: z
		.string()
		.describe(
			"The user ID or email address of the user. For user-level apps, pass the `me` value.",
		),
	tspId: z.enum(["1", "2"]).describe("TSP account ID."),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nTSP account retrieved successfully.
 */
export const userTSP200Schema = z
	.object({
		conference_code: z
			.string()
			.min(1)
			.max(16)
			.describe("Conference code: numeric value, length is less than 16."),
		dial_in_numbers: z.optional(
			z
				.array(
					z.object({
						code: z.optional(z.string().max(6).describe("Country code.")),
						country_label: z.optional(
							z
								.string()
								.max(10)
								.describe("Country Label, if passed, will display in place of code."),
						),
						number: z.optional(
							z.string().min(1).max(16).describe("Dial-in number: length is less than 16."),
						),
						type: z.optional(
							z
								.enum(["toll", "tollfree", "media_link"])
								.describe(
									"Dial-in number types:  \n `toll` - Toll number.  \n `tollfree` -Toll free number.   \n  `media_link` - Media link phone number. This is used for PSTN integration instead of a paid bridge number.",
								),
						),
					}),
				)
				.describe("List of dial in numbers."),
		),
		id: z.optional(z.string().describe("The TSP account's ID.")),
		leader_pin: z
			.string()
			.min(1)
			.max(16)
			.describe("Leader PIN. A numeric value, with a length of less than 16."),
		tsp_bridge: z.optional(z.enum(["US_TSP_TB", "EU_TSP_TB"]).describe("Telephony bridge")),
	})
	.describe("TSP account of the user.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n The TSP ID provided does not exist.<br> <br>\n**Error Code:** `300` <br>\n TSP config does not exist.<br> <br>\n**Error Code:** `2024` <br>\n Account has not enabled TSP. <br>\n
 */
export const userTSP400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: $userId.<br> <br>\n**Error Code:** `1120` <br>\n No valid invitation to join the Zoom account was found for this user.<br>\nThis error is thrown if you added a user in your account but the user did not accept the invitation on time and the invitation expired, making the `userId` invalid. <br>\n
 */
export const userTSP404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const userTSP429Schema = z.unknown();

export const userTSPQueryResponseSchema = z.lazy(() => userTSP200Schema);

export const userTSPDeletePathParamsSchema = z.object({
	userId: z
		.string()
		.describe("The user's user ID or email address. For user-level apps, pass the `me` value."),
	tspId: z.enum(["1", "2"]).describe("TSP account ID."),
});

/**
 * @description **Status Code:** `204` **No Content**  \n \nTSP account deleted.
 */
export const userTSPDelete204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `2024` <br>\n This account has not enabled TSP.<br> <br>\n**Error Code:** `300` <br>\n The provided TSP ID does not exist.<br> <br>\n**Error Code:** `300` <br>\n TSP config does not exist.<br> <br>\n**Error Code:** `300` <br>\n At least one TSP config must be available. <br>\n
 */
export const userTSPDelete400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: $userId.<br> <br>\n**Error Code:** `1120` <br>\n No valid invitation to join the Zoom account was found for this user.<br>\nThis error is thrown if you added a user in your account but the user did not accept the invitation on time and the invitation expired, making the `userId` invalid. <br>\n
 */
export const userTSPDelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const userTSPDelete429Schema = z.unknown();

export const userTSPDeleteMutationResponseSchema = z.lazy(() => userTSPDelete204Schema);

export const userTSPUpdatePathParamsSchema = z.object({
	userId: z
		.string()
		.describe(
			"The user ID or email address of the user. For user-level apps, pass the `me` value.",
		),
	tspId: z.enum(["1", "2"]).describe("TSP account ID."),
});

/**
 * @description **HTTP Status Code:**`204` **No Content**  \n \nTSP account updated.
 */
export const userTSPUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `2024` <br>\n Account has not enabled TSP. <br>\n**Error Code:** `300` <br>\n The TSP ID provided does not exist. <br>\n**Error Code:** `300` <br>\n TSP config does not exist. <br>\n**Error Code:** `300` <br>\n At least one TSP config must be available. <br>\n**Error Code:** `300` <br>\n Media link is required for AT&T TSP accounts. <br>\n**Error Code:** `300` <br>\n Invalid parameter: `tsp_bridge`. <br>\n
 */
export const userTSPUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: $userId. <br>\n**Error Code:** `1120` <br>\n A valid invitation to join the Zoom account was not found for this user.<br>\nThis error is thrown if you added a user in your account but the user did not accept the invitation on time and the invitation expired - making the `userId` invalid. <br>\n
 */
export const userTSPUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api//rate-limits/). \n\n
 */
export const userTSPUpdate429Schema = z.unknown();

/**
 * @description TSP account.
 */
export const userTSPUpdateMutationRequestSchema = z
	.object({
		conference_code: z
			.string()
			.min(1)
			.max(16)
			.describe("Conference code. Numeric value. Length is less than 16."),
		dial_in_numbers: z.optional(
			z
				.array(
					z.object({
						code: z.optional(z.string().max(6).describe("Country code.")),
						country_label: z.optional(
							z
								.string()
								.max(10)
								.describe("Country label, if passed, will display in place of code."),
						),
						number: z.optional(
							z.string().min(1).max(16).describe("Dial-in number. Length is less than 16."),
						),
						type: z.optional(
							z
								.enum(["toll", "tollfree", "media_link"])
								.describe(
									"Dial-in number types.\n `toll` - Toll number.  \n `tollfree` -Toll free number.  \n `media_link` - Media Link Phone Number. It is used for PSTN integration instead of paid bridge number.",
								),
						),
					}),
				)
				.describe("List of dial in numbers."),
		),
		leader_pin: z
			.string()
			.min(1)
			.max(16)
			.describe("Leader PIN. Numeric value. Length is less than 16."),
		tsp_bridge: z.optional(z.enum(["US_TSP_TB", "EU_TSP_TB"]).describe("Telephony bridge.")),
	})
	.describe("TSP account.");

export const userTSPUpdateMutationResponseSchema = z.lazy(() => userTSPUpdate204Schema);

export const listMeetingTemplatesPathParamsSchema = z.object({
	userId: z
		.string()
		.describe(
			"The user ID retrievable from the [List users](/api-reference/zoom-api/methods#operation/users) API.",
		),
});

/**
 * @description **HTTP Status Code:** `200` **OK**   \n
 */
export const listMeetingTemplates200Schema = z.object({
	templates: z.optional(
		z.array(
			z.object({
				id: z.optional(z.string().describe("The template ID.")),
				name: z.optional(z.string().describe("The template name.")),
				type: z.optional(
					z
						.int()
						.describe(
							"The template type:   \n \n`1`: Meeting template   \n \n`2`: Admin meeting template",
						),
				),
			}),
		),
	),
	total_records: z.optional(z.int().describe("Total records found for this request.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n
 */
export const listMeetingTemplates400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: {userId}. <br>\n
 */
export const listMeetingTemplates404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const listMeetingTemplates429Schema = z.unknown();

export const listMeetingTemplatesQueryResponseSchema = z.lazy(() => listMeetingTemplates200Schema);

export const meetingTemplateCreatePathParamsSchema = z.object({
	userId: z
		.string()
		.describe(
			"The user ID retrievable from the [List users](/docs/api/rest/reference/user/methods/#operation/users) API.",
		),
});

/**
 * @description **HTTP Status Code:** `201`  \n \nMeeting template created.
 */
export const meetingTemplateCreate201Schema = z.object({
	id: z.optional(z.string().describe("The template ID.")),
	name: z.optional(z.string().describe("The template name.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n You can only create up to 40 meeting templates. <br>\n**Error Code:** `3001` <br>\n Meeting does not exist: {meetingId} <br>\n**Error Code:** `3161` <br>\n Meeting hosting and scheduling capabilities are not allowed for your user account. <br>\n**Error Code:** `3000` <br>\n Cannot access webinar information. <br>\n**Error Code:** `3000` <br>\n Meeting template name already exists: {templateName}. <br>\n
 */
export const meetingTemplateCreate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist. <br>\n
 */
export const meetingTemplateCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const meetingTemplateCreate429Schema = z.unknown();

export const meetingTemplateCreateMutationRequestSchema = z.object({
	meeting_id: z.optional(
		z.int().describe("The meeting ID - the meeting number in long (int64) format."),
	),
	name: z.optional(z.string().describe("The template name.")),
	save_recurrence: z.optional(
		z
			.boolean()
			.default(false)
			.describe(
				"If the field is set to `true`, the recurrence meeting template will be saved as the scheduled meeting.",
			),
	),
	overwrite: z.optional(
		z
			.boolean()
			.default(false)
			.describe(
				"Overwrite an existing meeting template if the template is created from same existing meeting.",
			),
	),
});

export const meetingTemplateCreateMutationResponseSchema = z.lazy(
	() => meetingTemplateCreate201Schema,
);

/**
 * @description **HTTP Status Code:** `200` List of Tracking Fields returned.
 */
export const trackingfieldList200Schema = z
	.object({
		total_records: z.optional(
			z.int().describe("The number of all records available across pages."),
		),
		tracking_fields: z.optional(
			z
				.array(
					z
						.object({
							id: z.optional(z.string().describe("Tracking field's ID.")),
							field: z.optional(z.string().describe("Label or name for the tracking field.")),
							recommended_values: z.optional(
								z.array(z.string()).describe("Array of recommended values"),
							),
							required: z.optional(z.boolean().describe("Tracking field required.")),
							visible: z.optional(z.boolean().describe("Tracking field visible.")),
						})
						.describe("Tracking Field"),
				)
				.describe("Array of tracking fields."),
		),
	})
	.describe("Tracking field list.");

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const trackingfieldList429Schema = z.unknown();

export const trackingfieldListQueryResponseSchema = z.lazy(() => trackingfieldList200Schema);

/**
 * @description **HTTP Status Code:** `201`  \n \nTracking Field created
 */
export const trackingfieldCreate201Schema = z.object({
	id: z.optional(z.string().describe("Tracking Field ID")),
	field: z.optional(z.string().describe("Label/ Name for the tracking field.")),
	recommended_values: z.optional(z.array(z.string()).describe("Array of recommended values")),
	required: z.optional(z.boolean().describe("Tracking Field Required")),
	visible: z.optional(z.boolean().describe("Tracking Field Visible")),
});

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const trackingfieldCreate429Schema = z.unknown();

/**
 * @description Tracking Field
 */
export const trackingfieldCreateMutationRequestSchema = z
	.object({
		field: z.optional(z.string().describe("Label/ Name for the tracking field.")),
		recommended_values: z.optional(z.array(z.string()).describe("Array of recommended values")),
		required: z.optional(z.boolean().describe("Tracking Field Required")),
		visible: z.optional(z.boolean().describe("Tracking Field Visible")),
	})
	.describe("Tracking Field");

export const trackingfieldCreateMutationResponseSchema = z.lazy(() => trackingfieldCreate201Schema);

export const trackingfieldGetPathParamsSchema = z.object({
	fieldId: z.string().describe("The tracking field ID."),
});

/**
 * @description **HTTP Status Code:** `200` Tracking field object returned.
 */
export const trackingfieldGet200Schema = z
	.object({
		id: z.optional(z.string().describe("Tracking field ID.")),
		field: z.optional(z.string().describe("Label or name for the tracking field.")),
		recommended_values: z.optional(z.array(z.string()).describe("Array of recommended values.")),
		required: z.optional(z.boolean().describe("Tracking field required.")),
		visible: z.optional(z.boolean().describe("Tracking field visible.")),
	})
	.describe("Tracking field");

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `5110` <br>\n Tracking field does not exist: {fieldId}. <br>\n
 */
export const trackingfieldGet404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const trackingfieldGet429Schema = z.unknown();

export const trackingfieldGetQueryResponseSchema = z.lazy(() => trackingfieldGet200Schema);

export const trackingfieldDeletePathParamsSchema = z.object({
	fieldId: z.string().describe("The tracking field ID."),
});

/**
 * @description **HTTP Status Code:** `204` Tracking Field deleted.
 */
export const trackingfieldDelete204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `5110` <br>\n Tracking field does not exist: {fieldId}. <br>\n
 */
export const trackingfieldDelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const trackingfieldDelete429Schema = z.unknown();

export const trackingfieldDeleteMutationResponseSchema = z.lazy(() => trackingfieldDelete204Schema);

export const trackingfieldUpdatePathParamsSchema = z.object({
	fieldId: z.string().describe("The tracking field ID."),
});

/**
 * @description **HTTP Status Code:** `204` Tracking field updated.
 */
export const trackingfieldUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n Tracking field {field} already exists. <br>\n
 */
export const trackingfieldUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `5110` <br>\n Tracking field does not exist: {fieldId}. <br>\n
 */
export const trackingfieldUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const trackingfieldUpdate429Schema = z.unknown();

export const trackingfieldUpdateMutationRequestSchema = z
	.object({
		field: z.optional(z.string().describe("Label or name for the tracking field.")),
		recommended_values: z.optional(z.array(z.string()).describe("Array of recommended values.")),
		required: z.optional(z.boolean().describe("Tracking field required.")),
		visible: z.optional(z.boolean().describe("Tracking field visible.")),
	})
	.describe("Tracking field");

export const trackingfieldUpdateMutationResponseSchema = z.lazy(() => trackingfieldUpdate204Schema);

export const deleteWebinarChatMessageByIdPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
	messageId: z
		.string()
		.describe(
			"The live webinar chat message's unique identifier (UUID), in base64-encoded format.",
		),
});

export const deleteWebinarChatMessageByIdQueryParamsSchema = z
	.object({
		file_ids: z.optional(
			z
				.string()
				.describe(
					"The live webinar chat file's universally unique identifier (UUID), in base64-encoded format. Separate multiple values with commas.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `204`   \n \nWebinar chat message deleted.
 */
export const deleteWebinarChatMessageById204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `300` <br>\n DLP is not enabled on this account. <br>\n
 */
export const deleteWebinarChatMessageById400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const deleteWebinarChatMessageById404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const deleteWebinarChatMessageById429Schema = z.unknown();

export const deleteWebinarChatMessageByIdMutationResponseSchema = z.lazy(
	() => deleteWebinarChatMessageById204Schema,
);

export const webinarAbsenteesPathParamsSchema = z.object({
	webinarId: z
		.string()
		.describe(
			"The webinar's ID or universally unique ID (UUID). \n* If you provide a webinar ID, the API will return a response for the latest webinar instance. \n* If you provide a webinar UUID that begins with a `/` character or contains the `//` characters, you **must** [double encode](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#meeting-id-and-uuid) the webinar UUID before making an API request.",
		),
});

export const webinarAbsenteesQueryParamsSchema = z.object({
	occurrence_id: z.optional(z.string().describe("The meeting or webinar occurrence ID.")),
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nSuccess.  \n **Error Code:** `200`  \n \nWebinar plan subscription is missing. Enable webinar for this user once the subscription is added:{userId}.
 */
export const webinarAbsentees200Schema = z
	.object({
		next_page_token: z.optional(
			z
				.string()
				.describe(
					"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
				),
		),
		page_count: z.optional(z.int().describe("The number of pages returned for the request made.")),
		page_number: z.optional(
			z
				.int()
				.default(1)
				.describe(
					"**Deprecated.** This field is deprecated. We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.",
				),
		),
		page_size: z.optional(
			z
				.int()
				.max(300)
				.default(30)
				.describe("The number of records returned with a single API call."),
		),
		total_records: z.optional(
			z.int().describe("The total number of all the records available across pages."),
		),
		registrants: z.optional(
			z
				.array(
					z
						.object({
							address: z.optional(z.string().describe("The registrant's address.")),
							city: z.optional(z.string().describe("The registrant's city.")),
							comments: z.optional(z.string().describe("The registrant's questions and comments.")),
							country: z.optional(
								z
									.string()
									.describe(
										"The registrant's two-letter ISO [country code](https://developers.zoom.us/docs/api/rest/other-references/abbreviation-lists/#countries).",
									),
							),
							custom_questions: z.optional(
								z
									.array(
										z
											.object({
												title: z.optional(z.string().describe("The title of the custom question.")),
												value: z.optional(
													z
														.string()
														.max(128)
														.describe(
															"The custom question's response value. This has a limit of 128 characters.",
														),
												),
											})
											.describe("Information about custom questions."),
									)
									.describe("Information about custom questions."),
							),
							email: z
								.email()
								.max(128)
								.describe(
									"The registrant's email address. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for return value details.",
								),
							first_name: z.string().max(64).describe("The registrant's first name."),
							industry: z.optional(z.string().describe("The registrant's industry.")),
							job_title: z.optional(z.string().describe("The registrant's job title.")),
							last_name: z.optional(z.string().max(64).describe("The registrant's last name.")),
							no_of_employees: z.optional(
								z
									.enum([
										"",
										"1-20",
										"21-50",
										"51-100",
										"101-250",
										"251-500",
										"501-1,000",
										"1,001-5,000",
										"5,001-10,000",
										"More than 10,000",
									])
									.describe(
										"The registrant's number of employees. \n* `1-20` \n* `21-50` \n* `51-100` \n* `101-250` \n* `251-500` \n* `501-1,000` \n* `1,001-5,000` \n* `5,001-10,000` \n* `More than 10,000`",
									),
							),
							org: z.optional(z.string().describe("The registrant's organization.")),
							phone: z.optional(z.string().describe("The registrant's phone number.")),
							purchasing_time_frame: z.optional(
								z
									.enum([
										"",
										"Within a month",
										"1-3 months",
										"4-6 months",
										"More than 6 months",
										"No timeframe",
									])
									.describe(
										"The registrant's purchasing time frame. \n* `Within a month` \n* `1-3 months` \n* `4-6 months` \n* `More than 6 months` \n* `No timeframe`",
									),
							),
							role_in_purchase_process: z.optional(
								z
									.enum([
										"",
										"Decision Maker",
										"Evaluator/Recommender",
										"Influencer",
										"Not involved",
									])
									.describe(
										"The registrant's role in the purchase process. \n* `Decision Maker` \n* `Evaluator/Recommender` \n* `Influencer` \n* `Not involved`",
									),
							),
							state: z.optional(z.string().describe("The registrant's state or province.")),
							status: z.optional(
								z
									.enum(["approved", "denied", "pending"])
									.describe(
										"The registrant's status. \n* `approved` - Registrant is approved. \n* `denied` - Registrant is denied. \n* `pending` - Registrant is waiting for approval.",
									),
							),
							zip: z.optional(z.string().describe("The registrant's ZIP or postal code.")),
						})
						.and(
							z.object({
								id: z.optional(z.string().describe("Registrant ID.")),
								create_time: z.optional(
									z.string().datetime().describe("The time when the registrant registered."),
								),
								join_url: z.optional(
									z
										.string()
										.describe(
											"The URL that an approved registrant can use to join the meeting or webinar.",
										),
								),
								status: z.optional(
									z
										.string()
										.describe(
											"The status of the registrant's registration.\n  `approved` - User has been successfully approved for the webinar.  \n  `pending` -  The registration is still pending.  \n  `denied` - User has been denied from joining the webinar.",
										),
								),
							}),
						),
				)
				.describe("List of registrant objects."),
		),
	})
	.describe("List of users.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n The request could not be completed because you have provided an invalid occurrence ID: {occurrenceId}.<br> <br>\n**Error Code:** `1010` <br>\n User does not belong to this account: {accountId}.<br> <br>\n**Error Code:** `3000` <br>\n This webinar doesn\'t have registration required: {webinarUUID}. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n
 */
export const webinarAbsentees400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar {webinarUUID} not found or expired. <br>\n
 */
export const webinarAbsentees404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rate-limits/). \n\n
 */
export const webinarAbsentees429Schema = z.unknown();

export const webinarAbsenteesQueryResponseSchema = z.lazy(() => webinarAbsentees200Schema);

export const pastWebinarsPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nList of past webinar instances returned.
 */
export const pastWebinars200Schema = z
	.object({
		webinars: z.optional(
			z
				.array(
					z.object({
						start_time: z.optional(z.string().datetime().describe("Start time.")),
						uuid: z.optional(z.string().describe("Webinar UUID.")),
					}),
				)
				.describe("List of ended webinar instances."),
		),
	})
	.describe("List of webinars.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n
 */
export const pastWebinars400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n
 */
export const pastWebinars404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const pastWebinars429Schema = z.unknown();

export const pastWebinarsQueryResponseSchema = z.lazy(() => pastWebinars200Schema);

export const listWebinarParticipantsPathParamsSchema = z.object({
	webinarId: z
		.string()
		.describe(
			"The webinar's ID or universally unique ID (UUID). \n* If you provide a webinar ID, the API returns a response for the latest webinar instance. \n* If you provide a webinar UUID that begins with a `/` character or contains the `//` characters, you **must** [double encode](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#meeting-id-and-uuid) the webinar UUID before making an API request.",
		),
});

export const listWebinarParticipantsQueryParamsSchema = z.object({
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200` **OK**  \n \nParticipants list returned.
 */
export const listWebinarParticipants200Schema = z.object({
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
	page_count: z.optional(z.int().describe("The number of pages returned for this request.")),
	page_size: z.optional(
		z
			.int()
			.max(300)
			.default(30)
			.describe("The total number of records returned from a single API call."),
	),
	participants: z.optional(
		z
			.array(
				z.object({
					id: z.optional(z.string().describe("The participant's unique identifier.")),
					name: z.optional(z.string().describe("The participant's name.")),
					user_id: z.optional(
						z
							.string()
							.describe(
								"The participant's ID. This ID is assigned to the participant upon joining the webinar and is only valid for that webinar.",
							),
					),
					registrant_id: z.optional(
						z
							.string()
							.describe(
								"The participant's unique registrant ID. This field only returns if you pass the `registrant_id` value for the `include_fields` query parameter. \n\nThis field does not return if the `type` query parameter is the `live` value.",
							),
					),
					user_email: z.optional(
						z
							.email()
							.describe(
								"Email address of the participant. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for details.",
							),
					),
					join_time: z.optional(z.string().datetime().describe("The participant's join time.")),
					leave_time: z.optional(z.string().datetime().describe("The participant's leave time.")),
					duration: z.optional(
						z
							.int()
							.describe(
								"Participant duration, in seconds, calculated by subtracting the `leave_time` from the `join_time` for the `user_id`. If the participant leaves and rejoins the same meeting, they will be assigned a different `user_id` and Zoom displays their new duration in a separate object. Note that because of this, the duration may not reflect the total time the user was in the meeting.",
							),
					),
					failover: z.optional(
						z.boolean().describe("Whether failover occurred during the webinar."),
					),
					status: z.optional(
						z
							.enum(["in_meeting", "in_waiting_room"])
							.describe(
								"The participant's status. \n* `in_meeting` - In a meeting. \n* `in_waiting_room` - In a waiting room.",
							),
					),
					internal_user: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Whether the webinar participant is an internal user."),
					),
				}),
			)
			.describe("Array of webinar participant objects."),
	),
	total_records: z.optional(
		z.int().describe("The total number of records available across all pages."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `300` <br>\n The next page token is invalid or expired. <br>\n**Error Code:** `200` <br>\n Only available for Paid or ZMP account: {accountId}. <br>\n
 */
export const listWebinarParticipants400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist. <br>\n
 */
export const listWebinarParticipants404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const listWebinarParticipants429Schema = z.unknown();

export const listWebinarParticipantsQueryResponseSchema = z.lazy(
	() => listWebinarParticipants200Schema,
);

export const listPastWebinarPollResultsPathParamsSchema = z.object({
	webinarId: z
		.string()
		.describe(
			"The webinar's ID or universally unique ID (UUID). \n* If you provide a webinar ID, the API returns a response for the latest webinar instance. \n* If you provide a webinar UUID that begins with a `/` character or contains the `//` characters, you **must** [double encode](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#meeting-id-and-uuid) the webinar UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200` **OK**  \n \nPolls returned successfully.
 */
export const listPastWebinarPollResults200Schema = z.object({
	id: z.optional(
		z
			.int()
			.describe(
				"Webinar ID in **long** format, represented as int64 data type in JSON, also known as the webinar number.",
			),
	),
	questions: z.optional(
		z.array(
			z.object({
				email: z.optional(
					z
						.string()
						.describe(
							"Email address of the user who submitted answers to the poll. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for details.",
						),
				),
				name: z.optional(
					z
						.string()
						.describe(
							"Name of the user who submitted answers to the poll. If the `anonymous` option is enabled for a poll, the participant's polling information will be kept anonymous and the value of `name` field will be `Anonymous Attendee`.",
						),
				),
				question_details: z.optional(
					z.array(
						z.object({
							answer: z.optional(z.string().describe("Answer submitted by the user.")),
							date_time: z.optional(
								z
									.string()
									.datetime()
									.describe("Date and time when the answer to the poll was submitted."),
							),
							polling_id: z.optional(z.string().describe("Unique identifier of the poll.")),
							question: z.optional(z.string().describe("Question asked during the poll.")),
						}),
					),
				),
			}),
		),
	),
	start_time: z.optional(z.string().datetime().describe("The webinar's start time.")),
	uuid: z.optional(z.string().describe("Webinar UUID.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n No permission. <br>\n
 */
export const listPastWebinarPollResults400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar ID is invalid or not end. <br>\n
 */
export const listPastWebinarPollResults404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const listPastWebinarPollResults429Schema = z.unknown();

export const listPastWebinarPollResultsQueryResponseSchema = z.lazy(
	() => listPastWebinarPollResults200Schema,
);

export const listPastWebinarQAPathParamsSchema = z.object({
	webinarId: z
		.string()
		.describe(
			"The webinar's ID or universally unique ID (UUID). \n* If you provide a webinar ID, the API returns a response for the latest webinar instance. \n* If you provide a webinar UUID that begins with a `/` character or contains the `//` characters, you **must** [double encode](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#meeting-id-and-uuid) the webinar UUID before making an API request.",
		),
});

/**
 * @description **HTTP Status Code:** `200` **OK**  \n \nQ&amp;A returned successfully.
 */
export const listPastWebinarQA200Schema = z.object({
	id: z.optional(
		z
			.int()
			.describe(
				"Webinar ID in **long** format, represented as int64 data type in JSON, also known as the webinar number.",
			),
	),
	questions: z.optional(
		z.array(
			z.object({
				email: z.optional(
					z
						.string()
						.describe(
							"Email address of the user. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for details.",
						),
				),
				name: z.optional(
					z
						.string()
						.describe(
							"Name of the user. If `anonymous` option is enabled for the Q&amp;A, the participant's information will be kept anonymous and the value of `name` field will be `Anonymous Attendee`.",
						),
				),
				question_details: z.optional(
					z.array(
						z.object({
							answer: z.optional(
								z
									.string()
									.describe(
										"Answer submitted for the question. The value will be 'live answered' if this is a live answer.",
									),
							),
							question: z.optional(z.string().describe("Question asked during the Q&amp;A.")),
						}),
					),
				),
			}),
		),
	),
	start_time: z.optional(z.string().datetime().describe("The webinar's start time.")),
	uuid: z.optional(z.string().describe("Webinar UUID.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n No permission. <br>\n
 */
export const listPastWebinarQA400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar ID is invalid or not end. <br>\n
 */
export const listPastWebinarQA404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const listPastWebinarQA429Schema = z.unknown();

export const listPastWebinarQAQueryResponseSchema = z.lazy(() => listPastWebinarQA200Schema);

export const listWebinarTemplatesPathParamsSchema = z.object({
	userId: z
		.string()
		.describe(
			"The user's ID. To get a user's ID, use the [**List users**](/docs/api-reference/zoom-api/ma#operation/users) API. For user-level apps, pass the `me` value instead of the user ID value.",
		),
});

/**
 * @description **HTTP Status Code:** `200` **OK**  List of existing templates returned.
 */
export const listWebinarTemplates200Schema = z.object({
	templates: z.optional(
		z
			.array(
				z.object({
					id: z.optional(z.string().describe("The webinar template's ID.")),
					name: z.optional(z.string().describe("The webinar template's name.")),
					type: z.optional(
						z
							.int()
							.describe(
								"The webinar template type.  `1`: Webinar template    `2`: Admin webinar template",
							),
					),
				}),
			)
			.describe("Information about the webinar templates."),
	),
	total_records: z.optional(z.int().describe("The total number of records returned.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `300` <br>\n You can only create up to 40 webinar templates. <br>\n**Error Code:** `3000` <br>\n Webinar template name already exists {name}. <br>\n
 */
export const listWebinarTemplates400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: {userId}. <br>\n
 */
export const listWebinarTemplates404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests  For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const listWebinarTemplates429Schema = z.unknown();

export const listWebinarTemplatesQueryResponseSchema = z.lazy(() => listWebinarTemplates200Schema);

export const webinarTemplateCreatePathParamsSchema = z.object({
	userId: z
		.string()
		.describe(
			"The user ID retrievable from the [List users](/api-reference/zoom-api/methods#operation/users) API.",
		),
});

/**
 * @description **HTTP Status Code:** `201`  \n \nWebinar template created.
 */
export const webinarTemplateCreate201Schema = z.object({
	id: z.optional(z.string().describe("The webinar template's ID.")),
	name: z.optional(z.string().describe("The webinar template's name.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `300` <br>\n You can only create up to 40 webinar templates. <br>\n**Error Code:** `3000` <br>\n Cannot access meeting info. <br>\n**Error Code:** `3000` <br>\n Webinar template name already exists: {templateName}. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n
 */
export const webinarTemplateCreate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: {userId}. <br>\n
 */
export const webinarTemplateCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarTemplateCreate429Schema = z.unknown();

export const webinarTemplateCreateMutationRequestSchema = z.object({
	webinar_id: z.optional(z.int().describe("The webinar ID in long (int64) format.")),
	name: z.optional(z.string().describe("The webinar template's name.")),
	save_recurrence: z.optional(
		z
			.boolean()
			.default(false)
			.describe(
				"If the field is set to true, the recurrence webinar template will be saved as the scheduled webinar.",
			),
	),
	overwrite: z.optional(
		z
			.boolean()
			.default(false)
			.describe(
				"Overwrite an existing webinar template if the template is created from same existing webinar.",
			),
	),
});

export const webinarTemplateCreateMutationResponseSchema = z.lazy(
	() => webinarTemplateCreate201Schema,
);

export const webinarsPathParamsSchema = z.object({
	userId: z
		.string()
		.describe("The user's user ID or email address. For user-level apps, pass the `me` value."),
});

export const webinarsQueryParamsSchema = z.object({
	type: z
		.enum(["scheduled", "upcoming"])
		.default("scheduled")
		.describe(
			"The type of webinar. \n* `scheduled` - All valid previous (unexpired) webinars, live webinars, and upcoming scheduled webinars. \n* `upcoming` - All upcoming webinars, including live webinars.",
		),
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	page_number: z.coerce
		.number()
		.int()
		.default(1)
		.describe(
			"**Deprecated** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.",
		),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nList of webinar objects returned.
 */
export const webinars200Schema = z
	.object({
		next_page_token: z.optional(
			z
				.string()
				.describe(
					"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
				),
		),
		page_count: z.optional(z.int().describe("The number of pages returned for the request made.")),
		page_number: z.optional(
			z
				.int()
				.default(1)
				.describe(
					"**Deprecated** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.",
				),
		),
		page_size: z.optional(
			z
				.int()
				.max(300)
				.default(30)
				.describe("The number of records returned with a single API call."),
		),
		total_records: z.optional(
			z.int().describe("The total number of all the records available across pages."),
		),
		webinars: z.optional(
			z
				.array(
					z.object({
						agenda: z.optional(
							z
								.string()
								.describe(
									"Webinar description. The agenda length gets truncated to 250 characters when you list all webinars for a user. To view the complete agenda, retrieve details for a single webinar, use the [**Get a webinar**](/docs/api-reference/zoom-api/methods#operation/webinar) API.",
								),
						),
						created_at: z.optional(z.string().datetime().describe("The webinar's creation time.")),
						duration: z.optional(z.int().describe("The webinar's duration, in minutes.")),
						host_id: z.optional(z.string().describe("The host's ID.")),
						id: z.optional(z.int().describe("The webinar ID.")),
						join_url: z.optional(z.string().describe("The URL to join the webinar.")),
						start_time: z.optional(z.string().datetime().describe("The webinar's start time.")),
						timezone: z.optional(
							z
								.string()
								.describe(
									"The webinar's [timezone](https://developers.zoom.us/docs/api/rest/other-references/abbreviation-lists/#timezones).",
								),
						),
						topic: z.optional(z.string().describe("The webinar's topic.")),
						type: z.optional(
							z
								.union([z.literal(5), z.literal(6), z.literal(9)])
								.default(5)
								.describe(
									"The webinar type. \n* `5` - A webinar. \n* `6` - A recurring webinar without a fixed time. \n* `9` - A recurring webinar with a fixed time.",
								),
						),
						uuid: z.optional(
							z
								.string()
								.describe(
									"The webinar's universally unique identifier (UUID). Each webinar instance generates a webinar UUID.",
								),
						),
						is_simulive: z.optional(z.boolean().describe("Whether the webinar is `simulive`.")),
					}),
				)
				.describe("List of webinar objects."),
		),
	})
	.describe("List of webinars.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinars400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User does not exist: {userId}. <br>\n
 */
export const webinars404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests  For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinars429Schema = z.unknown();

export const webinarsQueryResponseSchema = z.lazy(() => webinars200Schema);

export const webinarCreatePathParamsSchema = z.object({
	userId: z
		.string()
		.describe(
			"The user ID or email address of the user. For user-level apps, pass the `me` value.",
		),
});

/**
 * @description **HTTP Status Code:** `201`  \n \nWebinar created.
 */
export const webinarCreate201Schema = z
	.object({
		host_email: z.optional(z.email().describe("Email address of the meeting host.")),
		host_id: z.optional(z.string().describe("ID of the user set as host of the webinar.")),
		id: z.optional(
			z
				.int()
				.describe(
					"Webinar ID in **long** format, represented as int64 data type in JSON. Also known as the webinar number.",
				),
		),
		registrants_confirmation_email: z.optional(
			z
				.boolean()
				.describe(
					"Specify whether or not registrants of this webinar should receive confirmation emails.",
				),
		),
		template_id: z.optional(
			z
				.string()
				.describe(
					"Unique identifier of the webinar template. Use this field only if you would like to [schedule the webinar using an existing template](https://support.zoom.us/hc/en-us/articles/115001079746-Webinar-Templates#schedule). The value of this field can be retrieved from [**List webinar templates**](/docs/api/rest/reference/zoom-api/methods#operation/listWebinarTemplates) API.\nYou must provide the user ID of the host instead of the email address in the `userId` path parameter in order to use a template for scheduling a Webinar.",
				),
		),
		uuid: z.optional(
			z
				.string()
				.describe(
					"Unique identifier of a webinar. Each webinar instance will generate its own UUID. Ror example, after a webinar ends, a new UUID will be generated for the next instance of the Webinar). Once a Webinar ends, the value of the UUID for the same webinar will be different from when it was scheduled.",
				),
		),
		agenda: z.optional(z.string().describe("The webinar's agenda.")),
		created_at: z.optional(z.string().datetime().describe("Create time.")),
		duration: z.optional(z.int().describe("The webinar's duration.")),
		join_url: z.optional(
			z
				.string()
				.describe(
					"URL to join the webinar. Only share this URL with the users who should be invited to the Webinar.",
				),
		),
		occurrences: z.optional(
			z
				.array(
					z
						.object({
							duration: z.optional(z.int().describe("Duration.")),
							occurrence_id: z.optional(
								z
									.string()
									.describe(
										"Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.",
									),
							),
							start_time: z.optional(z.string().datetime().describe("Start time.")),
							status: z.optional(
								z
									.enum(["available", "deleted"])
									.describe(
										"Occurrence status. \n `available` - Available occurrence.  \n `deleted` -  Deleted occurrence.",
									),
							),
						})
						.describe("Occurrence object. This object is only returned for recurring webinars."),
				)
				.describe("Array of occurrence objects."),
		),
		password: z.optional(
			z
				.string()
				.max(10)
				.describe(
					"The webinar passcode. By default, it can be up to 10 characters in length and may contain alphanumeric characters as well as special characters such as !, @, #, etc.",
				),
		),
		encrypted_passcode: z.optional(
			z.string().describe("Encrypted passcode for third party endpoints (H323/SIP)."),
		),
		h323_passcode: z.optional(z.string().describe("H.323/SIP room system passcode.")),
		recurrence: z.optional(
			z
				.object({
					end_date_time: z.optional(
						z
							.string()
							.datetime()
							.describe(
								"Select a date when the webinar will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. Can't be used with `end_times`.",
							),
					),
					end_times: z.optional(
						z
							.int()
							.max(60)
							.default(1)
							.describe(
								"Select how many times the webinar will recur before it is canceled. The maximum number of recurring is 60. Can't be used with `end_date_time`.",
							),
					),
					monthly_day: z.optional(
						z
							.int()
							.describe(
								"Use this field **only if you're scheduling a recurring webinar of type** `3` to state which day in a month the webinar should recur. The value range is from 1 to 31.\n\nFor instance, if you would like the webinar to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the webinar to recur once every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.",
							),
					),
					monthly_week: z.optional(
						z
							.union([z.literal(-1), z.literal(1), z.literal(2), z.literal(3), z.literal(4)])
							.describe(
								"Use this field **only if you're scheduling a recurring webinar of type** `3` to state the week of the month when the webinar should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the webinar should recur.**   \n `-1` - Last week of the month.  \n `1` - First week of the month.  \n `2` - Second week of the month.  \n `3` - Third week of the month.  \n `4` - Fourth week of the month.",
							),
					),
					monthly_week_day: z.optional(
						z
							.union([
								z.literal(1),
								z.literal(2),
								z.literal(3),
								z.literal(4),
								z.literal(5),
								z.literal(6),
								z.literal(7),
							])
							.describe(
								"Use this field **only if you're scheduling a recurring webinar of type** `3` to state a specific day in a week when the monthly webinar should recur. To use this field, you must also use the `monthly_week` field.   \n `1` - Sunday.  \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` - Thursday.  \n `6` - Friday.  \n `7` - Saturday.",
							),
					),
					repeat_interval: z.optional(
						z
							.int()
							.describe(
								"Define the interval when the webinar should recur. For instance, if you would like to schedule a Webinar that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. \n\nFor a daily webinar, the maximum interval you can set is `90` days. For a weekly webinar, the maximum interval that you can set is `12` weeks. For a monthly webinar, the maximum interval that you can set is `3` months.",
							),
					),
					type: z
						.union([z.literal(1), z.literal(2), z.literal(3)])
						.describe(
							"Recurrence webinar types. \n `1` - Daily.  \n `2` - Weekly.  \n `3` - Monthly.",
						),
					weekly_days: z.optional(
						z
							.string()
							.describe(
								"Use this field **only if you're scheduling a recurring webinar of type** `2` to state which day(s) of the week the webinar should repeat.   \n  The value for this field could be a number between `1` to `7` in string format. For instance, if the Webinar should recur on Sunday, provide `1` as the value of this field.\n\n**Note:** If you would like the webinar to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the webinar should recur on Sundays and Tuesdays, provide `1,3` as the value of this field.\n\n  \n `1` - Sunday.   \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` -  Thursday.  \n `6` - Friday.  \n `7` - Saturday.\n\n",
							),
					),
				})
				.describe(
					"Recurrence object. Use this object only for a webinar of type `9` i.e., a recurring webinar with fixed time. ",
				),
		),
		settings: z.optional(
			z
				.object({
					allow_multiple_devices: z.optional(
						z.boolean().describe("Allow attendees to join from multiple devices."),
					),
					alternative_hosts: z.optional(
						z
							.string()
							.describe("Alternative host emails or IDs. Multiple values separated by comma."),
					),
					alternative_host_update_polls: z.optional(
						z
							.boolean()
							.describe(
								"Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.",
							),
					),
					approval_type: z.optional(
						z
							.union([z.literal(0), z.literal(1), z.literal(2)])
							.default(2)
							.describe(
								"`0` - Automatically approve.  \n `1` - Manually approve.  \n `2` - No registration required.",
							),
					),
					attendees_and_panelists_reminder_email_notification: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Send reminder email to attendees and panelists.\n\n* `false` - Do not send reminder email to attendees and panelists.",
										),
								),
								type: z.optional(
									z
										.union([
											z.literal(0),
											z.literal(1),
											z.literal(2),
											z.literal(3),
											z.literal(4),
											z.literal(5),
											z.literal(6),
											z.literal(7),
										])
										.describe(
											"`0` - No plan.  \n `1` - Send 1 hour before webinar.  \n `2` - Send 1 day before webinar.  \n `3` - Send 1 hour and 1 day before webinar.  \n `4` - Send 1 week before webinar.  \n `5` - Send 1 hour and 1 week before webinar.  \n `6` - Send 1 day and 1 week before webinar.  \n `7` - Send 1 hour, 1 day and 1 week before webinar.",
										),
								),
							})
							.describe("Send reminder email to attendees and panelists."),
					),
					audio: z.optional(
						z
							.enum(["both", "telephony", "voip", "thirdParty"])
							.default("both")
							.describe("Determine how participants can join the audio portion of the webinar."),
					),
					audio_conference_info: z.optional(
						z.string().max(2048).describe("Third party audio conference info."),
					),
					authentication_domains: z.optional(
						z
							.string()
							.describe(
								"If user has configured [**Sign Into Zoom with Specified Domains**](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.",
							),
					),
					authentication_name: z.optional(
						z
							.string()
							.describe(
								"Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).",
							),
					),
					authentication_option: z.optional(
						z.string().describe("Webinar authentication option ID."),
					),
					auto_recording: z.optional(
						z
							.enum(["local", "cloud", "none"])
							.default("none")
							.describe(
								"Automatic recording. \n `local` - Record on local.  \n `cloud` -  Record on cloud.  \n `none` - Disabled.",
							),
					),
					close_registration: z.optional(
						z.boolean().describe("Close registration after event date."),
					),
					contact_email: z.optional(z.string().describe("Contact email for registration")),
					contact_name: z.optional(z.string().describe("Contact name for registration")),
					email_language: z.optional(
						z
							.string()
							.describe(
								"Set the email language.\n`en-US`,`de-DE`,`es-ES`,`fr-FR`,`jp-JP`,`pt-PT`,`ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.",
							),
					),
					enforce_login: z.optional(
						z
							.boolean()
							.describe(
								"Only signed in users can join this meeting.\n\n**This field is deprecated and will not be supported in the future.**\n\n As an alternative, use the `meeting_authentication`, `authentication_option` and `authentication_domains` fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the webinar.",
							),
					),
					enforce_login_domains: z.optional(
						z
							.string()
							.describe(
								"Only signed in users with specified domains can join meetings.\n\n**This field is deprecated and will not be supported in the future.**\n\n As an alternative, use the `meeting_authentication`, `authentication_option` and `authentication_domains` fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the webinar.",
							),
					),
					follow_up_absentees_email_notification: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Send follow-up email to absentees.\n\n* `false` - Do not send follow-up email to absentees.",
										),
								),
								type: z.optional(
									z
										.union([
											z.literal(0),
											z.literal(1),
											z.literal(2),
											z.literal(3),
											z.literal(4),
											z.literal(5),
											z.literal(6),
											z.literal(7),
										])
										.describe(
											"`0` - No plan.  \n `1` - Send 1 days after the scheduled end date.  \n `2` - Send 2 days after the scheduled end date.  \n `3` - Send 3 days after the scheduled end date.  \n `4` - Send 4 days after the scheduled end date.  \n `5` - Send 5 days after the scheduled end date.  \n `6` - Send 6 days after the scheduled end date.  \n `7` - Send 7 days after the scheduled end date.",
										),
								),
							})
							.describe("Send follow-up email to absentees."),
					),
					follow_up_attendees_email_notification: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Send follow-up email to attendees.\n\n* `false` - Do not send follow-up email to attendees.",
										),
								),
								type: z.optional(
									z
										.union([
											z.literal(0),
											z.literal(1),
											z.literal(2),
											z.literal(3),
											z.literal(4),
											z.literal(5),
											z.literal(6),
											z.literal(7),
										])
										.describe(
											"`0` - No plan.  \n `1` - Send 1 day after the scheduled end date.  \n `2` - Send 2 days after the scheduled end date.  \n `3` - Send 3 days after the scheduled end date.  \n `4` - Send 4 days after the scheduled end date.  \n `5` - Send 5 days after the scheduled end date.  \n `6` - Send 6 days after the scheduled end date.  \n `7` - Send 7 days after the scheduled end date.",
										),
								),
							})
							.describe("Send follow-up email to attendees."),
					),
					global_dial_in_countries: z.optional(
						z.array(z.string()).describe("List of global dial-in countries"),
					),
					global_dial_in_numbers: z.optional(
						z
							.array(
								z.object({
									city: z.optional(z.string().describe("City of the number.")),
									country: z.optional(z.string().describe("The country code.")),
									country_name: z.optional(z.string().describe("Full name of country.")),
									number: z.optional(z.string().describe("Dial-in phone number.")),
									type: z.optional(
										z.enum(["toll", "tollfree", "premium"]).describe("Dial-in number type."),
									),
								}),
							)
							.describe("A list of available dial-in numbers for different countries or regions."),
					),
					hd_video: z.optional(z.boolean().default(false).describe("Default to HD video.")),
					hd_video_for_attendees: z.optional(
						z.boolean().default(false).describe("Whether HD video for attendees is enabled."),
					),
					host_video: z.optional(z.boolean().describe("Start video when host joins webinar.")),
					language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [language interpretation](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768) for the webinar. If not provided, the default value will be based on the user's setting.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two country IDs.\n\nOnly system-supported languages are allowed: `US` (English), `CN` (Chinese), `JP` (Japanese), `DE` (German), `FR` (French), `RU` (Russian), `PT` (Portuguese), `ES` (Spanish), and `KR` (Korean).\n\nFor example, to set an interpreter translating from English to Chinese, use `US,CN`.",
														),
												),
												interpreter_languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two languages.\n\nTo get this value, use the `language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/docs/api/users/#tag/users/GET/users/{userId}/settings) API response.\n\n**languages**: System-supported languages include `English`, `Chinese`, `Japanese`, `German`, `French`, `Russian`, `Portuguese`, `Spanish`, and `Korean`.\n\n**custom_languages**: User-defined languages added by the user.\n\nFor example, an interpreter translating between English and French should use `English,French`.",
														),
												),
											}),
										)
										.describe("Information about the webinar's language interpreters."),
								),
							})
							.describe(
								"The webinar's [language interpretation settings](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768). Make sure to add the language in the web portal in order to use it in the API. See link for details. \n\n**Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar. This is not supported for simulive webinars.",
							),
					),
					sign_language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the webinar. If not provided, the default value will be based on the user's setting.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												sign_language: z.optional(
													z
														.string()
														.describe(
															"The interpreter's sign language. \n\n To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/docs/api/rest/reference/zoom-api/methods#operation/userSettings) API response.",
														),
												),
											}),
										)
										.max(20)
										.describe("Information about the webinar's sign language interpreters."),
								),
							})
							.describe(
								"The webinar's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details. \n\n**Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.",
							),
					),
					panelist_authentication: z.optional(
						z
							.boolean()
							.describe(
								"Require panelists to authenticate to join. If not provided, the default value will be based on the user's setting.",
							),
					),
					meeting_authentication: z.optional(
						z.boolean().describe("Only authenticated users can join Webinar."),
					),
					add_watermark: z.optional(
						z
							.boolean()
							.describe(
								"Add watermark that identifies the viewing participant. If not provided, the default value will be based on the user's setting.",
							),
					),
					add_audio_watermark: z.optional(
						z
							.boolean()
							.describe(
								"Add audio watermark that identifies the participants. If not provided, the default value will be based on the user's setting.",
							),
					),
					on_demand: z.optional(z.boolean().default(false).describe("Make the webinar on demand.")),
					panelists_invitation_email_notification: z.optional(
						z
							.boolean()
							.describe(
								"Send invitation email to panelists. If `false`, do not send invitation email to panelists.",
							),
					),
					panelists_video: z.optional(
						z.boolean().describe("Start video when panelists join the webinar."),
					),
					post_webinar_survey: z.optional(
						z
							.boolean()
							.describe(
								"Zoom will open a survey page in attendees' browsers after leaving the webinar.",
							),
					),
					practice_session: z.optional(
						z.boolean().default(false).describe("Enable practice session."),
					),
					question_and_answer: z.optional(
						z
							.object({
								allow_submit_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to submit questions.\n\n* `false` - Do not allow submit questions.",
										),
								),
								allow_anonymous_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to send questions without providing their name to the host, co-host, and panelists.\n\n* `false` - Do not allow anonymous questions.",
										),
								),
								answer_questions: z.optional(
									z
										.enum(["only", "all"])
										.describe(
											"Indicate whether you want attendees to be able to view only answered questions, or view all questions.\n\n* `only` - Attendees are able to view answered questions only.\n\n* `all` - Attendees are able to view all questions submitted in the Q&amp;A.",
										),
								),
								attendees_can_comment: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can answer questions or leave a comment in the question thread.\n\n* `false` - Attendees can not answer questions or leave a comment in the question thread",
										),
								),
								attendees_can_upvote: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can click the thumbs up button to bring popular questions to the top of the Q&amp;A window.\n\n* `false` - Attendees can not click the thumbs up button on questions.",
										),
								),
								allow_auto_reply: z.optional(
									z
										.boolean()
										.describe(
											"If simulive webinar, \n\n* `true` - allow auto-reply to attendees. \n\n* `false` - don't allow auto-reply to the attendees.",
										),
								),
								auto_reply_text: z.optional(
									z
										.string()
										.describe(
											"If `allow_auto_reply` = true, the text to be included in the automatic response. ",
										),
								),
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true`: Enable [Q&amp;A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.\n\n* `false`: Disable Q&amp;A for webinar. If not provided, the default value will be based on the user's setting.",
										),
								),
							})
							.describe(
								"[Q&amp;A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.",
							),
					),
					registrants_confirmation_email: z.optional(
						z.boolean().describe("Send confirmation email to registrants."),
					),
					registrants_email_notification: z.optional(
						z
							.boolean()
							.describe(
								"Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.",
							),
					),
					registrants_restrict_number: z.optional(
						z
							.int()
							.min(0)
							.max(20000)
							.default(0)
							.describe(
								"Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.",
							),
					),
					registration_type: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3)])
							.default(1)
							.describe(
								"Registration types. Only used for recurring webinars with a fixed time.  \n `1` - Attendees register once and can attend any of the webinar sessions.  \n `2` - Attendees need to register for each session in order to attend.  \n `3` - Attendees register once and can choose one or more sessions to attend.",
							),
					),
					send_1080p_video_to_attendees: z.optional(
						z.boolean().default(false).describe("Always send 1080p video to attendees."),
					),
					show_share_button: z.optional(
						z.boolean().describe("Show social share buttons on the registration page."),
					),
					survey_url: z.optional(z.string().describe("Survey url for post webinar survey.")),
					enable_session_branding: z.optional(
						z
							.boolean()
							.describe(
								"Whether the **Webinar Session Branding** setting is enabled. This setting lets hosts visually customize a webinar by setting a session background. This also lets hosts use [Webinar Session Branding](https://support.zoom.us/hc/en-us/articles/4836268732045-Using-Webinar-Session-Branding) to set the Virtual Background for and apply name tags to hosts, alternative hosts, panelists, interpreters, and speakers.",
							),
					),
					request_permission_to_unmute_participants: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to enable the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting) setting. Not supported for simulive webinar. This option cannot be used together with `allow_host_control_participant_mute_state`, only one of the two can be enabled at a time.",
							),
					),
					allow_host_control_participant_mute_state: z.optional(
						z
							.boolean()
							.describe(
								"Whether to allow the host and cohosts to fully control the mute state of participants. Not supported for simulive webinar. If not provided, the default value will be based on the user's setting. This option cannot be used together with `request_permission_to_unmute_participants`, only one of the two can be enabled at a time.",
							),
					),
					email_in_attendee_report: z.optional(
						z
							.boolean()
							.describe(
								"Whether to include guest's email addresses in attendee reports for webinars.",
							),
					),
				})
				.describe("Webinar settings."),
		),
		start_time: z.optional(z.string().datetime().describe("Webinar start time in GMT/UTC.")),
		start_url: z.optional(
			z
				.string()
				.describe(
					"  \n The `start_url` of a webinar is a URL using which a host or an alternative host can start the webinar. This URL should only be used by the host of the meeting and should not be shared with anyone other than the host of the webinar. \n\nThe expiration time for the `start_url` field listed in the response of the [**Create a webinar**](/docs/api/rest/reference/zoom-api/methods#operation/webinarCreate) API is two hours for all regular users. \n\t\nFor users created using the `custCreate` option via the [**Create users**](/docs/api/rest/reference/zoom-api/methods#operation/userCreate) API, the expiration time of the `start_url` field is 90 days.\n\t\nFor security reasons, to retrieve the latest value for the `start_url` field programmatically after expiry, call the [**Get a webinar**](/docs/api/rest/reference/zoom-api/methods#operation/webinar) API and refer to the value of the `start_url` field in the response.  \n   \n   \n ",
				),
		),
		timezone: z.optional(z.string().describe("Time zone to format `start_time`.")),
		topic: z.optional(z.string().max(200).describe("The webinar's topic.")),
		tracking_fields: z.optional(
			z
				.array(
					z.object({
						field: z.optional(z.string().describe("Tracking fields type.")),
						value: z.optional(z.string().describe("Tracking fields value.")),
					}),
				)
				.describe("Tracking fields."),
		),
		type: z.optional(
			z
				.union([z.literal(5), z.literal(6), z.literal(9)])
				.default(5)
				.describe(
					"Webinar types.  \n `5` - Webinar.  \n `6` - Recurring webinar with no fixed time.  \n `9` - Recurring webinar with a fixed time.",
				),
		),
		is_simulive: z.optional(z.boolean().describe("Whether the webinar is `simulive`.")),
		record_file_id: z.optional(
			z.string().describe("The previously recorded file's ID for `simulive`."),
		),
		transition_to_live: z.optional(
			z
				.boolean()
				.describe(
					"Whether to transition a simulive webinar to live. The host must be present at the time of transition.",
				),
		),
		simulive_delay_start: z.optional(
			z
				.object({
					enable: z.optional(z.boolean().describe("Whether simulive need delay playback.")),
					time: z.optional(z.int().describe("The time for delayed playback.")),
					timeunit: z.optional(z.string().describe("The time unit for delayed playback.")),
				})
				.describe('{"enable":false,"time":0,"timeunit":"second"}'),
		),
		creation_source: z.optional(
			z
				.enum(["other", "open_api", "web_portal"])
				.describe(
					"The platform through which the meeting was created.\n* `other` - Created through another platform.\n* `open_api` - Created through Open API.\n* `web_portal` - Created through the web portal.",
				),
		),
	})
	.describe("Webinar object.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for user {userID} in order to perform this action. <br>\n**Error Code:** `300` <br>\n The value that you entered for the `schedule_for` field is invalid. Enter a valid value and try again. <br>\n**Error Code:** `300` <br>\n Can not schedule simulive webinar for others. <br>\n**Error Code:** `300` <br>\n Account hasn\'t enabled simulive webinar. <br>\n**Error Code:** `300` <br>\n Record file does not exist. <br>\n**Error Code:** `3000` <br>\n You cannot schedule a meeting for {userId}. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `4505` <br>\n Simulive can\'t select `No Fixed Time`. <br>\n
 */
export const webinarCreate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `1001` <br>\n User {userId} does not exist. <br>\n
 */
export const webinarCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const webinarCreate429Schema = z.unknown();

export const webinarCreateMutationRequestSchema = z
	.object({
		agenda: z.optional(z.string().describe("Webinar description.")),
		duration: z.optional(
			z.int().describe("Webinar duration, in minutes. Used for scheduled webinars only."),
		),
		password: z.optional(
			z
				.string()
				.max(10)
				.describe(
					"The webinar passcode. By default, it can be up to 10 characters in length and may contain alphanumeric characters as well as special characters like !, @, #, and others.\n\n**Note**\n- If the account owner or administrator has configured [Passcode Requirement](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0063160#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode **must** meet those requirements. You can retrieve the requirements using the [**Get user settings**](/docs/api/users/#tag/users/GET/users/{userId}/settings) API or the [**Get account settings**](/docs/api/accounts/#tag/accounts/GET/accounts/{accountId}/settings) API.\n- If the **Passcode** user setting is enabled and `default_passcode` is not explicitly set to `false`, a passcode will be automatically generated when one is not provided.\n- If the **Passcode** setting is enabled and [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, a passcode will be automatically generated when one is not provided.",
				),
		),
		default_passcode: z.optional(
			z
				.boolean()
				.default(true)
				.describe(
					"Determines whether to automatically generate a passcode for the webinar when no passcode is provided and the user's **Passcode** setting is enabled. Defaults to `true`. When set to `false`, webinars will only have a passcode if one is explicitly provided.",
				),
		),
		recurrence: z.optional(
			z
				.object({
					end_date_time: z.optional(
						z
							.string()
							.datetime()
							.describe(
								"Select a date when the webinar will recur before it is canceled. Should be in UTC time, such as `2017-11-25T12:00:00Z`. Cannot be used with `end_times`.",
							),
					),
					end_times: z.optional(
						z
							.int()
							.max(60)
							.default(1)
							.describe(
								"Select how many times the webinar will recur before it is canceled. The maximum number of recurring is 60. Cannot be used with `end_date_time`.",
							),
					),
					monthly_day: z.optional(
						z
							.int()
							.describe(
								"Use this field **only if you're scheduling a recurring webinar of type `3`** to state which day in a month the webinar should recur. The value range is from 1 to 31.\n\nFor instance, if you would like the webinar to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the webinar to recur once every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.",
							),
					),
					monthly_week: z.optional(
						z
							.union([z.literal(-1), z.literal(1), z.literal(2), z.literal(3), z.literal(4)])
							.describe(
								"Use this field **only if you're scheduling a recurring webinar of type `3`** to state the week of the month when the webinar should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the webinar should recur.**   \n `-1` - Last week of the month.  \n `1` - First week of the month.  \n `2` - Second week of the month.  \n `3` - Third week of the month.  \n `4` - Fourth week of the month.",
							),
					),
					monthly_week_day: z.optional(
						z
							.union([
								z.literal(1),
								z.literal(2),
								z.literal(3),
								z.literal(4),
								z.literal(5),
								z.literal(6),
								z.literal(7),
							])
							.describe(
								"Use this field **only if you're scheduling a recurring webinar of type `3`** to state a specific day in a week when the monthly webinar should recur. To use this field, you must also use the `monthly_week` field.   \n `1` - Sunday.  \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` - Thursday.  \n `6` - Friday.  \n `7` - Saturday.",
							),
					),
					repeat_interval: z.optional(
						z
							.int()
							.describe(
								"Define the interval when the webinar should recur. For instance, to schedule a webinar that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. \n\nFor a daily webinar, the maximum interval you can set is `90` days. For a weekly webinar, the maximum interval that you can set is `12` weeks. For a monthly webinar, the maximum interval that you can set is `3` months.",
							),
					),
					type: z
						.union([z.literal(1), z.literal(2), z.literal(3)])
						.describe(
							"Recurrence webinar types.\n `1` - Daily.  \n `2` - Weekly.  \n `3` - Monthly.",
						),
					weekly_days: z.optional(
						z
							.string()
							.describe(
								"Use this field **only if you're scheduling a recurring webinar of type** `2` to state which day(s) of the week the webinar should repeat.\nThe value for this field could be a number between `1` to `7` in string format. For instance, if the webinar should recur on Sunday, provide `1` as the value of this field.    \n   \n  **Note:** If you would like the webinar to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the webinar should recur on Sundays and Tuesdays, provide `1,3` as the value of this field.\n\n  \n `1`  - Sunday.   \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` -  Thursday.  \n `6` - Friday.  \n `7` - Saturday.\n\n",
							),
					),
				})
				.describe(
					"Recurrence object. Use this object only for a webinar of type `9`, a recurring webinar with fixed time. ",
				),
		),
		schedule_for: z.optional(
			z.string().describe("The email address or user ID of the user to schedule a webinar for."),
		),
		settings: z.optional(
			z
				.object({
					allow_multiple_devices: z.optional(
						z.boolean().describe("Allow attendees to join from multiple devices."),
					),
					alternative_hosts: z.optional(
						z
							.string()
							.describe("Alternative host emails or IDs. Multiple values separated by comma."),
					),
					alternative_host_update_polls: z.optional(
						z
							.boolean()
							.describe(
								"Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.",
							),
					),
					approval_type: z.optional(
						z
							.union([z.literal(0), z.literal(1), z.literal(2)])
							.default(2)
							.describe(
								"The default value is `2`. To enable registration required, set the approval type to `0` or `1`.  Values include:  \n \n\n`0` - Automatically approve.  \n `1` - Manually approve.  \n `2` - No registration required.",
							),
					),
					attendees_and_panelists_reminder_email_notification: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` -  Send reminder email to attendees and panelists.\n\n* `false` - Do not send reminder email to attendees and panelists.",
										),
								),
								type: z.optional(
									z
										.union([
											z.literal(0),
											z.literal(1),
											z.literal(2),
											z.literal(3),
											z.literal(4),
											z.literal(5),
											z.literal(6),
											z.literal(7),
										])
										.describe(
											"`0` - No plan.  \n `1` - Send 1 hour before webinar.  \n `2` - Send 1 day before webinar.  \n `3` - Send 1 hour and 1 day before webinar.  \n `4` - Send 1 week before webinar.  \n `5` - Send 1 hour and 1 week before webinar.  \n `6` - Send 1 day and 1 week before webinar.  \n `7` - Send 1 hour, 1 day and 1 week before webinar.",
										),
								),
							})
							.describe("Send reminder email to attendees and panelists."),
					),
					audio: z.optional(
						z
							.enum(["both", "telephony", "voip", "thirdParty"])
							.default("both")
							.describe(
								"Determine how participants can join the audio portion of the meeting.(Not supported for simulive webinar.)",
							),
					),
					audio_conference_info: z.optional(
						z.string().max(2048).describe("Third party audio conference information."),
					),
					authentication_domains: z.optional(
						z
							.string()
							.describe(
								"Meeting authentication domains. This option allows you to specify the rule so that Zoom users whose email address contains a certain domain can join the webinar. You can either provide multiple comma-separated domains, use a wildcard for listing domains, or use both methods.",
							),
					),
					authentication_option: z.optional(
						z
							.string()
							.describe(
								"Specify the authentication type for users to join a webinar with `meeting_authentication` setting set to `true`. The value of this field can be retrieved from the `id` field within `authentication_options` array in the response of [**Get user settings**](/docs/api/rest/reference/zoom-api/methods#operation/userSettings) API.",
							),
					),
					auto_recording: z.optional(
						z
							.enum(["local", "cloud", "none"])
							.default("none")
							.describe(
								"Automatic recording. Not supported for simulive webinar.   \n `local` - Record on local.  \n `cloud` -  Record on cloud.  \n `none` - Disabled.",
							),
					),
					close_registration: z.optional(
						z.boolean().describe("Close registration after event date."),
					),
					contact_email: z.optional(z.string().describe("Contact email for registration")),
					contact_name: z.optional(z.string().describe("Contact name for registration")),
					email_language: z.optional(
						z
							.string()
							.describe(
								"Set the email language.\n`en-US`,`de-DE`,`es-ES`,`fr-FR`,`id-ID`,`jp-JP`,`nl-NL`,`pl-PL`,`pt-PT`,`ru-RU`,`tr-TR`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.",
							),
					),
					enforce_login: z.optional(
						z
							.boolean()
							.describe(
								"Only signed-in users can join this meeting. \n\n**This field is deprecated and will not be supported in future.**   \n   \n  Instead of this field, use the `meeting_authentication`, `authentication_option`, or `authentication_domains` fields to establish the authentication mechanism for this Webinar. ",
							),
					),
					enforce_login_domains: z.optional(
						z
							.string()
							.describe(
								"Only signed-in users with specified domains can join meetings.\n\n**This field is deprecated and will not be supported in future.**   \n \n  Instead of this field, use the `authentication_domains` field for this webinar. ",
							),
					),
					follow_up_absentees_email_notification: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Send follow-up email to absentees.\n\n* `false` - Do not send follow-up email to absentees.",
										),
								),
								type: z.optional(
									z
										.union([
											z.literal(0),
											z.literal(1),
											z.literal(2),
											z.literal(3),
											z.literal(4),
											z.literal(5),
											z.literal(6),
											z.literal(7),
										])
										.describe(
											"`0` - No plan.  \n `1` - Send 1 days after the scheduled end date.  \n `2` - Send 2 days after the scheduled end date.  \n `3` - Send 3 days after the scheduled end date.  \n `4` - Send 4 days after the scheduled end date.  \n `5` - Send 5 days after the scheduled end date.  \n `6` - Send 6 days after the scheduled end date.  \n `7` - Send 7 days after the scheduled end date.",
										),
								),
							})
							.describe("Send follow-up email to absentees."),
					),
					follow_up_attendees_email_notification: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true`: Send follow-up email to attendees.\n\n* `false`: Do not send follow-up email to attendees.",
										),
								),
								type: z.optional(
									z
										.union([
											z.literal(0),
											z.literal(1),
											z.literal(2),
											z.literal(3),
											z.literal(4),
											z.literal(5),
											z.literal(6),
											z.literal(7),
										])
										.describe(
											"`0` - No plan.  \n `1` - Send 1 day after the scheduled end date.  \n `2` - Send 2 days after the scheduled end date.  \n `3` - Send 3 days after the scheduled end date.  \n `4` - Send 4 days after the scheduled end date.  \n `5` - Send 5 days after the scheduled end date.  \n `6` - Send 6 days after the scheduled end date.  \n `7` - Send 7 days after the scheduled end date.",
										),
								),
							})
							.describe("Send follow-up email to attendees."),
					),
					global_dial_in_countries: z.optional(
						z.array(z.string()).describe("List of global dial-in countries"),
					),
					hd_video: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Default to HD video. Not supported for simulive webinar."),
					),
					hd_video_for_attendees: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether HD video for attendees is enabled. This value defaults to `false`. Not supported for simulive webinar.",
							),
					),
					host_video: z.optional(
						z
							.boolean()
							.describe("Start video when host joins webinar. Not supported for simulive webinar."),
					),
					language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [language interpretation](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768) for the webinar. If not provided, the default value will be based on the user's setting.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two country IDs.\n\nOnly system-supported languages are allowed: `US` (English), `CN` (Chinese), `JP` (Japanese), `DE` (German), `FR` (French), `RU` (Russian), `PT` (Portuguese), `ES` (Spanish), and `KR` (Korean).\n\nFor example, to set an interpreter translating from English to Chinese, use `US,CN`.",
														),
												),
												interpreter_languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two languages.\n\nTo get this value, use the `language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/docs/api/users/#tag/users/GET/users/{userId}/settings) API response.\n\n**languages**: System-supported languages include `English`, `Chinese`, `Japanese`, `German`, `French`, `Russian`, `Portuguese`, `Spanish`, and `Korean`.\n\n**custom_languages**: User-defined languages added by the user.\n\nFor example, an interpreter translating between English and French should use `English,French`.",
														),
												),
											}),
										)
										.describe("Information about the webinar's language interpreters."),
								),
							})
							.describe(
								"The webinar's [language interpretation settings](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768). Make sure to add the language in the web portal in order to use it in the API. See link for details. \n\n**Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar. This is not supported for simulive webinars.",
							),
					),
					sign_language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the webinar. If not provided, the default value will be based on the user's setting.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												sign_language: z.optional(
													z
														.string()
														.describe(
															"The interpreter's sign language. \n\n To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/docs/api/rest/reference/zoom-api/methods#operation/userSettings) API response.",
														),
												),
											}),
										)
										.max(20)
										.describe("Information about the webinar's sign language interpreters."),
								),
							})
							.describe(
								"The webinar's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details. \n\n**Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.",
							),
					),
					panelist_authentication: z.optional(
						z
							.boolean()
							.describe(
								"Require panelists to authenticate to join. If not provided, the default value will be based on the user's setting.",
							),
					),
					meeting_authentication: z.optional(
						z
							.boolean()
							.describe(
								"Only [authenticated](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) users can join meeting if the value of this field is set to `true`.",
							),
					),
					add_watermark: z.optional(
						z
							.boolean()
							.describe(
								"Add watermark that identifies the viewing participant. Not supported for simulive webinar. If not provided, the default value will be based on the user's setting.",
							),
					),
					add_audio_watermark: z.optional(
						z
							.boolean()
							.describe(
								"Add audio watermark that identifies the participants. Not supported for simulive webinar. If not provided, the default value will be based on the user's setting.",
							),
					),
					on_demand: z.optional(
						z
							.boolean()
							.default(false)
							.describe("Make the webinar on-demand. Not supported for simulive webinar."),
					),
					panelists_invitation_email_notification: z.optional(
						z
							.boolean()
							.describe(
								"Send invitation email to panelists. If `false`, do not send invitation email to panelists.",
							),
					),
					panelists_video: z.optional(
						z
							.boolean()
							.describe(
								"Start video when panelists join webinar. Not supported for simulive webinar.",
							),
					),
					post_webinar_survey: z.optional(
						z
							.boolean()
							.describe(
								"Zoom will open a survey page in attendees' browsers after leaving the webinar",
							),
					),
					practice_session: z.optional(
						z.boolean().default(false).describe("Enable practice session."),
					),
					question_and_answer: z.optional(
						z
							.object({
								allow_submit_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to submit questions.\n\n* `false` - Do not allow submit questions.",
										),
								),
								allow_anonymous_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to send questions without providing their name to the host, co-host, and panelists..\n\n* `false` - Do not allow anonymous questions.(Not supported for simulive webinar.)",
										),
								),
								answer_questions: z.optional(
									z
										.enum(["only", "all"])
										.describe(
											"Indicate whether you want attendees to be able to view answered questions only or view all questions.\n\n* `only` - Attendees are able to view answered questions only.\n\n*  `all` - Attendees are able to view all questions submitted in the Q&amp;A.",
										),
								),
								attendees_can_comment: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can answer questions or leave a comment in the question thread.\n\n* `false` - Attendees can not answer questions or leave a comment in the question thread",
										),
								),
								attendees_can_upvote: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can click the thumbs up button to bring popular questions to the top of the Q&amp;A window.\n\n* `false` - Attendees can not click the thumbs up button on questions.",
										),
								),
								allow_auto_reply: z.optional(
									z
										.boolean()
										.describe(
											"If simulive webinar, \n\n* `true` - allow auto-reply to attendees. \n\n* `false` - don't allow auto-reply to the attendees.",
										),
								),
								auto_reply_text: z.optional(
									z
										.string()
										.describe(
											"If `allow_auto_reply` = true, the text to be included in the automatic response. ",
										),
								),
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Enable [Q&amp;A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.\n\n* `false` - Disable Q&amp;A for webinar. If not provided, the default value will be based on the user's setting.",
										),
								),
							})
							.describe(
								"[Q&amp;A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.",
							),
					),
					registrants_email_notification: z.optional(
						z
							.boolean()
							.describe(
								"Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.",
							),
					),
					registrants_restrict_number: z.optional(
						z
							.int()
							.min(0)
							.max(20000)
							.default(0)
							.describe(
								"Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.",
							),
					),
					registration_type: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3)])
							.default(1)
							.describe(
								"Registration types. Only used for recurring webinars with a fixed time.  \n `1` - Attendees register once and can attend any of the webinar sessions.  \n `2` - Attendees need to register for each session in order to attend.  \n `3` - Attendees register once and can choose one or more sessions to attend.",
							),
					),
					send_1080p_video_to_attendees: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to always send 1080p video to attendees. This value defaults to `false`.(Not supported for simulive webinar.)",
							),
					),
					show_share_button: z.optional(
						z.boolean().describe("Show social share buttons on the registration page."),
					),
					survey_url: z.optional(z.string().describe("Survey URL for post webinar survey.")),
					enable_session_branding: z.optional(
						z
							.boolean()
							.describe(
								"Whether the **Webinar Session Branding** setting is enabled. This setting lets hosts visually customize a webinar by setting a session background. This also lets hosts set Virtual Background and apply name tags to hosts, alternative hosts, panelists, interpreters, and speakers.",
							),
					),
					request_permission_to_unmute_participants: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to enable the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting) setting. Not supported for simulive webinar. This option cannot be used together with `allow_host_control_participant_mute_state`, only one of the two can be enabled at a time.",
							),
					),
					allow_host_control_participant_mute_state: z.optional(
						z
							.boolean()
							.describe(
								"Whether to allow the host and cohosts to fully control the mute state of participants. Not supported for simulive webinar. If not provided, the default value will be based on the user's setting. This option cannot be used together with `request_permission_to_unmute_participants`, only one of the two can be enabled at a time.",
							),
					),
					email_in_attendee_report: z.optional(
						z
							.boolean()
							.describe(
								"Whether to include guest's email addresses in webinars' attendee reports.",
							),
					),
				})
				.describe("Create webinar settings."),
		),
		start_time: z.optional(
			z
				.string()
				.datetime()
				.describe(
					"Webinar start time. We support two formats for `start_time` - local time and GMT.  \n  \n\nTo set time as GMT the format should be `yyyy-MM-dd`T`HH:mm:ssZ`.\n\nTo set time using a specific timezone, use `yyyy-MM-dd`T`HH:mm:ss` format and specify the timezone [ID](/docs/api/references/abbreviations/#timezones) in the `timezone` field OR leave it blank and the timezone set on your Zoom account will be used. You can also set the time as UTC as the timezone field.\n\nThe `start_time` should only be used for scheduled and / or recurring webinars with fixed time.",
				),
		),
		template_id: z.optional(
			z
				.string()
				.describe(
					"The webinar template ID to schedule a webinar using a [webinar template](https://support.zoom.us/hc/en-us/articles/115001079746-Webinar-Templates) or a [admin webinar template](https://support.zoom.us/hc/en-us/articles/8137753618957-Configuring-admin-webinar-templates). For a list of webinar templates, use the [**List webinar templates**](/docs/api/rest/reference/zoom-api/methods#operation/listWebinarTemplates) API.",
				),
		),
		timezone: z.optional(
			z
				.string()
				.describe(
					"The timezone to assign to the `start_time` value. This field is only used for scheduled or recurring webinars with a fixed time.\n\nFor a list of supported timezones and their formats, see our [timezone list](/docs/api/references/abbreviations/#timezones).",
				),
		),
		topic: z.optional(z.string().describe("The webinar's topic.")),
		tracking_fields: z.optional(
			z
				.array(
					z.object({
						field: z.string().describe("Tracking fields type."),
						value: z.optional(z.string().describe("Tracking fields value.")),
					}),
				)
				.describe("Tracking fields."),
		),
		type: z.optional(
			z
				.union([z.literal(5), z.literal(6), z.literal(9)])
				.default(5)
				.describe(
					"Webinar types.\n `5` - Webinar.  \n `6` - Recurring webinar with no fixed time.  \n `9` - Recurring webinar with a fixed time.",
				),
		),
		is_simulive: z.optional(z.boolean().describe("Whether to set the webinar to simulive.")),
		record_file_id: z.optional(
			z.string().describe("The previously recorded file's ID for `simulive`."),
		),
		transition_to_live: z.optional(
			z
				.boolean()
				.describe(
					"Whether to transition a simulive webinar to live. The host must be present at the time of transition.",
				),
		),
		simulive_delay_start: z.optional(
			z
				.object({
					enable: z.optional(z.boolean().describe("Whether simulive need delay playback.")),
					time: z.optional(
						z
							.int()
							.describe(
								"The time for delayed playback\nIf the time unit is seconds, then the maximum value is 60 and the minimum value is 1.\nIf the time unit is minutes, then the maximum value is 10 and the minimum value is 1.",
							),
					),
					timeunit: z.optional(
						z
							.enum(["second", "minute"])
							.default("second")
							.describe(
								"The time unit for delayed playback\n`second` - The time unit for delayed playback is seconds.\n`minute` - The time unit for delayed playback is minutes.",
							),
					),
				})
				.describe('{"enable":false,"time":0,"timeunit":"second"}'),
		),
	})
	.describe("Webinar object.");

export const webinarCreateMutationResponseSchema = z.lazy(() => webinarCreate201Schema);

export const webinarPathParamsSchema = z.object({
	webinarId: z.string().describe("The webinar's ID or universally unique ID (UUID)."),
});

export const webinarQueryParamsSchema = z
	.object({
		occurrence_id: z.optional(
			z
				.string()
				.describe(
					"Unique identifier for an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences. When you create a recurring Webinar using [**Create a webinar**](/docs/api-reference/zoom-api/methods#operation/webinarCreate) API, you can retrieve the Occurrence ID from the response of the API call.",
				),
		),
		show_previous_occurrences: z.optional(
			z
				.boolean()
				.describe(
					"Set the value of this field to `true` to view webinar details of all previous occurrences of a recurring webinar.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `200`  \n \nSuccess
 */
export const webinar200Schema = z
	.object({
		host_email: z.optional(z.email().describe("The meeting host's email address.")),
		host_id: z.optional(z.string().describe("ID of the user set as host of webinar.")),
		id: z.optional(
			z
				.int()
				.describe(
					"The webinar ID in **long** format, represented as int64 data type in JSON, also known as the webinar number.",
				),
		),
		uuid: z.optional(
			z
				.string()
				.describe(
					"Unique webinar ID. Each webinar instance generates its own webinar UUID. After a webinar ends, a new UUID is generated for the next instance of the webinar. Retrieve a list of UUIDs from past webinar instances using the [**List past webinar instances**](/docs/api-reference/zoom-api/methods#operation/pastWebinars) API. [Double encode](/docs/api/using-zoom-apis/#meeting-id-and-uuid) your UUID when using it for API calls if the UUID begins with a `/` or contains `//` in it.\n\n",
				),
		),
		agenda: z.optional(z.string().describe("Webinar agenda.")),
		created_at: z.optional(z.string().datetime().describe("Create time.")),
		duration: z.optional(z.int().describe("Webinar duration.")),
		join_url: z.optional(
			z
				.string()
				.describe(
					"URL to join the webinar. Only share this URL with the users who should be invited to the webinar.",
				),
		),
		occurrences: z.optional(
			z
				.array(
					z
						.object({
							duration: z.optional(z.int().describe("Duration.")),
							occurrence_id: z.optional(
								z
									.string()
									.describe(
										"The occurrence ID, a unique identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.",
									),
							),
							start_time: z.optional(z.string().datetime().describe("Start time.")),
							status: z.optional(
								z
									.enum(["available", "deleted"])
									.describe(
										"Occurrence status. \n `available` - Available occurrence.  \n `deleted` -  Deleted occurrence.",
									),
							),
						})
						.describe("Occurrence object. This object is only returned for recurring webinars."),
				)
				.describe("Array of occurrence objects."),
		),
		password: z.optional(
			z
				.string()
				.max(10)
				.describe(
					"Webinar passcode. Passcode may only contain the characters [a-z A-Z 0-9 @ - _ * !]. Maximum of 10 characters.\n\nIf **Webinar Passcode** setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the passcode field will be autogenerated for the Webinar in the response even if it is not provided in the API request. \n\n **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements. \n\n If the requirements are enabled, you can view those requirements by calling the [**Get account settings**](/docs/api/rest/reference/account/methods/#operation/accountSettings) API.",
				),
		),
		encrypted_passcode: z.optional(
			z.string().describe("Encrypted passcode for third party endpoints (H323/SIP)."),
		),
		h323_passcode: z.optional(z.string().describe("H.323/SIP room system passcode.")),
		recurrence: z.optional(
			z
				.object({
					end_date_time: z.optional(
						z
							.string()
							.datetime()
							.describe(
								"Select a date when the webinar will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. Cannot be used with `end_times`.",
							),
					),
					end_times: z.optional(
						z
							.int()
							.max(60)
							.default(1)
							.describe(
								"Select how many times the webinar will recur before it is canceled. The maximum number of recurring is 60. Cannot be used with `end_date_time`.",
							),
					),
					monthly_day: z.optional(
						z
							.int()
							.describe(
								"Use this field **only if you're scheduling a recurring webinar of type** `3` to state which day in a month, the webinar should recur. The value range is from 1 to 31.\n\nFor instance, if you would like the webinar to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the webinar to recur once every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.",
							),
					),
					monthly_week: z.optional(
						z
							.union([z.literal(-1), z.literal(1), z.literal(2), z.literal(3), z.literal(4)])
							.describe(
								"Use this field **only if you're scheduling a recurring webinar of type** `3` to state the week of the month when the webinar should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the webinar should recur.**   \n `-1` - Last week of the month.  \n `1` - First week of the month.  \n `2` - Second week of the month.  \n `3` - Third week of the month.  \n `4` - Fourth week of the month.",
							),
					),
					monthly_week_day: z.optional(
						z
							.union([
								z.literal(1),
								z.literal(2),
								z.literal(3),
								z.literal(4),
								z.literal(5),
								z.literal(6),
								z.literal(7),
							])
							.describe(
								"Use this field **only if you're scheduling a recurring webinar of type** `3` to state a specific day in a week when the monthly webinar should recur. To use this field, you must also use the `monthly_week` field.   \n `1` - Sunday.  \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` - Thursday.  \n `6` - Friday.  \n `7` - Saturday.",
							),
					),
					repeat_interval: z.optional(
						z
							.int()
							.describe(
								"Define the interval when the webinar should recur. For instance, to schedule a webinar that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. \n\nFor a daily webinar, the maximum interval you can set is `90` days. For a weekly webinar, the maximum interval that you can set is `12` weeks. For a monthly webinar, the maximum interval that you can set is `3` months.",
							),
					),
					type: z
						.union([z.literal(1), z.literal(2), z.literal(3)])
						.describe(
							"Recurrence webinar types.  \n `1` - Daily.  \n `2` - Weekly.  \n `3` - Monthly.",
						),
					weekly_days: z.optional(
						z
							.string()
							.describe(
								"Use this field **only if you're scheduling a recurring webinar of type** `2` to state which days of the week the webinar should repeat.   \n  The value for this field could be a number between `1` to `7` in string format. For instance, if the Webinar should recur on Sunday, provide `1` as the value of this field.    \n   \n  **Note:** If you would like the webinar to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the Webinar should recur on Sundays and Tuesdays provide `1,3` as the value of this field.\n\n  \n `1`  - Sunday.   \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` -  Thursday.  \n `6` - Friday.  \n `7` - Saturday.\n\n",
							),
					),
				})
				.describe(
					"Recurrence object. Use this object only for a webinar of type `9` - a recurring webinar with fixed time. ",
				),
		),
		settings: z.optional(
			z
				.object({
					allow_multiple_devices: z.optional(
						z.boolean().describe("Allow attendees to join from multiple devices."),
					),
					alternative_hosts: z.optional(
						z
							.string()
							.describe("Alternative host emails or IDs. Multiple values separated by comma."),
					),
					alternative_host_update_polls: z.optional(
						z
							.boolean()
							.describe(
								"Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.",
							),
					),
					approval_type: z.optional(
						z
							.union([z.literal(0), z.literal(1), z.literal(2)])
							.default(2)
							.describe(
								"`0` - Automatically approve.  \n `1` - Manually approve.  \n `2` - No registration required.",
							),
					),
					attendees_and_panelists_reminder_email_notification: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Send reminder email to attendees and panelists.\n\n* `false` - Do not send reminder email to attendees and panelists.",
										),
								),
								type: z.optional(
									z
										.union([
											z.literal(0),
											z.literal(1),
											z.literal(2),
											z.literal(3),
											z.literal(4),
											z.literal(5),
											z.literal(6),
											z.literal(7),
										])
										.describe(
											"`0` - No plan.  \n `1` - Send 1 hour before webinar.  \n `2` - Send 1 day before webinar.  \n `3` - Send 1 hour and 1 day before webinar.  \n `4` - Send 1 week before webinar.  \n `5` - Send 1 hour and 1 week before webinar.  \n `6` - Send 1 day and 1 week before webinar.  \n `7` - Send 1 hour, 1 day and 1 week before webinar.",
										),
								),
							})
							.describe("Send reminder email to attendees and panelists."),
					),
					audio: z.optional(
						z
							.enum(["both", "telephony", "voip", "thirdParty"])
							.default("both")
							.describe("Determine how participants can join the audio portion of the webinar."),
					),
					audio_conference_info: z.optional(
						z.string().max(2048).describe("Third party audio conference info."),
					),
					authentication_domains: z.optional(
						z
							.string()
							.describe(
								"If user has configured [**Sign Into Zoom with Specified Domains**](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.",
							),
					),
					authentication_name: z.optional(
						z
							.string()
							.describe(
								"Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).",
							),
					),
					authentication_option: z.optional(
						z.string().describe("Webinar authentication option ID."),
					),
					auto_recording: z.optional(
						z
							.enum(["local", "cloud", "none"])
							.default("none")
							.describe(
								"Automatic recording. \n `local` - Record on local.  \n `cloud` -  Record on cloud.  \n `none` - Disabled.",
							),
					),
					close_registration: z.optional(
						z.boolean().describe("Close registration after event date."),
					),
					contact_email: z.optional(z.string().describe("Contact email for registration.")),
					contact_name: z.optional(z.string().describe("Contact name for registration.")),
					email_language: z.optional(
						z
							.string()
							.describe(
								"Set the email language.\n`en-US`, `de-DE`, `es-ES`, `fr-FR`, `jp-JP`, `pt-PT`, `ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, or `vi-VN`.",
							),
					),
					enforce_login: z.optional(
						z
							.boolean()
							.describe(
								"Only signed in users can join this meeting.\n\n**This field is deprecated and will not be supported in the future.**    \n\n As an alternative, use the `meeting_authentication`, `authentication_option` and `authentication_domains` fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the webinar.",
							),
					),
					enforce_login_domains: z.optional(
						z
							.string()
							.describe(
								"Only signed in users with specified domains can join meetings.\n\n**This field is deprecated and will not be supported in the future.**    \n\n As an alternative, use the `meeting_authentication`, `authentication_option`, and `authentication_domains` fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the webinar.",
							),
					),
					follow_up_absentees_email_notification: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Send follow-up email to absentees.\n\n* `false` - Do not send follow-up email to absentees.",
										),
								),
								type: z.optional(
									z
										.union([
											z.literal(0),
											z.literal(1),
											z.literal(2),
											z.literal(3),
											z.literal(4),
											z.literal(5),
											z.literal(6),
											z.literal(7),
										])
										.describe(
											"`0` - No plan.  \n `1` - Send 1 days after the scheduled end date.  \n `2` - Send 2 days after the scheduled end date.  \n `3` - Send 3 days after the scheduled end date.  \n `4` - Send 4 days after the scheduled end date.  \n `5` - Send 5 days after the scheduled end date.  \n `6` - Send 6 days after the scheduled end date.  \n `7` - Send 7 days after the scheduled end date.",
										),
								),
							})
							.describe("Send follow-up email to absentees."),
					),
					follow_up_attendees_email_notification: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Send follow-up email to attendees.\n\n* `false` - Do not send follow-up email to attendees.",
										),
								),
								type: z.optional(
									z
										.union([
											z.literal(0),
											z.literal(1),
											z.literal(2),
											z.literal(3),
											z.literal(4),
											z.literal(5),
											z.literal(6),
											z.literal(7),
										])
										.describe(
											"`0` - No plan.  \n `1` - Send 1 day after the scheduled end date.  \n `2` - Send 2 days after the scheduled end date.  \n `3` - Send 3 days after the scheduled end date.  \n `4` - Send 4 days after the scheduled end date.  \n `5` - Send 5 days after the scheduled end date.  \n `6` - Send 6 days after the scheduled end date.  \n `7` - Send 7 days after the scheduled end date.",
										),
								),
							})
							.describe("Send follow-up email to attendees."),
					),
					global_dial_in_countries: z.optional(
						z.array(z.string()).describe("List of global dial-in countries."),
					),
					global_dial_in_numbers: z.optional(
						z
							.array(
								z.object({
									city: z.optional(z.string().describe("The number's city.")),
									country: z.optional(z.string().describe("The country code.")),
									country_name: z.optional(z.string().describe("Full name of country.")),
									number: z.optional(z.string().describe("Dial-in phone number.")),
									type: z.optional(
										z.enum(["toll", "tollfree", "premium"]).describe("Dial-in number type."),
									),
								}),
							)
							.describe("A list of available dial-in numbers for different countries or regions."),
					),
					hd_video: z.optional(z.boolean().default(false).describe("Default to HD video.")),
					hd_video_for_attendees: z.optional(
						z.boolean().default(false).describe("Whether HD video for attendees is enabled."),
					),
					host_video: z.optional(
						z.boolean().describe("Start video when the host joins the webinar."),
					),
					language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [language interpretation](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768) for the webinar.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two country IDs.\n\nOnly system-supported languages are allowed: `US` (English), `CN` (Chinese), `JP` (Japanese), `DE` (German), `FR` (French), `RU` (Russian), `PT` (Portuguese), `ES` (Spanish), and `KR` (Korean).\n\nFor example, to set an interpreter translating from English to Chinese, use `US,CN`.",
														),
												),
												interpreter_languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two languages.\n\nTo get this value, use the `language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/docs/api/users/#tag/users/GET/users/{userId}/settings) API response.\n\n**languages**: System-supported languages include `English`, `Chinese`, `Japanese`, `German`, `French`, `Russian`, `Portuguese`, `Spanish`, and `Korean`.\n\n**custom_languages**: User-defined languages added by the user.\n\nFor example, an interpreter translating between English and French should use `English,French`.",
														),
												),
											}),
										)
										.describe("Information about the webinar's language interpreters."),
								),
							})
							.describe(
								"The webinar's [language interpretation settings](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768). Make sure to add the language in the web portal in order to use it in the API. See link for details. \n\n**Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar. This is not supported for simulive webinars.",
							),
					),
					sign_language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the webinar.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												sign_language: z.optional(
													z
														.string()
														.describe(
															"The interpreter's sign language. \n\n To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/api-reference/zoom-api/methods#operation/userSettings) API response.",
														),
												),
											}),
										)
										.max(20)
										.describe("Information about the webinar's sign language interpreters."),
								),
							})
							.describe(
								"The webinar's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details. \n\n**Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.",
							),
					),
					panelist_authentication: z.optional(
						z.boolean().describe("Require panelists to authenticate to join."),
					),
					meeting_authentication: z.optional(
						z.boolean().describe("Only authenticated users can join the webinar."),
					),
					add_watermark: z.optional(
						z.boolean().describe("Add watermark that identifies the viewing participant."),
					),
					add_audio_watermark: z.optional(
						z.boolean().describe("Add audio watermark that identifies the participants."),
					),
					on_demand: z.optional(z.boolean().default(false).describe("Make the webinar on-demand.")),
					panelists_invitation_email_notification: z.optional(
						z
							.boolean()
							.describe(
								"Send invitation email to panelists. If `false`, do not send invitation email to panelists.",
							),
					),
					panelists_video: z.optional(
						z.boolean().describe("Start video when panelists join webinar."),
					),
					post_webinar_survey: z.optional(
						z
							.boolean()
							.describe(
								"Zoom will open a survey page in attendees' browsers after leaving the webinar.",
							),
					),
					practice_session: z.optional(
						z.boolean().default(false).describe("Enable practice session."),
					),
					question_and_answer: z.optional(
						z
							.object({
								allow_submit_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to submit questions.\n\n* `false` - Do not allow submit questions.",
										),
								),
								allow_anonymous_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to send questions without providing their name to the host, co-host, and panelists.\n\n* `false` - Do not allow anonymous questions.",
										),
								),
								answer_questions: z.optional(
									z
										.enum(["only", "all"])
										.describe(
											"Indicate whether you want attendees to be able to view answered questions only or view all questions.\n\n* `only` - Attendees are able to view answered questions only.\n\n*  `all` - Attendees are able to view all questions submitted in the Q&amp;A.",
										),
								),
								attendees_can_comment: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can answer questions or leave a comment in the question thread.\n\n* `false` - Attendees can not answer questions or leave a comment in the question thread",
										),
								),
								attendees_can_upvote: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can click the thumbs up button to bring popular questions to the top of the Q&amp;A window.\n\n* `false` - Attendees can not click the thumbs up button on questions.",
										),
								),
								allow_auto_reply: z.optional(
									z
										.boolean()
										.describe(
											"If simulive webinar, \n\n* `true` - allow auto-reply to attendees. \n\n* `false` - don't allow auto-reply to the attendees.",
										),
								),
								auto_reply_text: z.optional(
									z
										.string()
										.describe(
											"If `allow_auto_reply` = true, the text to be included in the automatic response. ",
										),
								),
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Enable [Q&amp;A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.\n\n* `false` - Disable Q&amp;A for webinar.",
										),
								),
							})
							.describe(
								"[Q&amp;A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.",
							),
					),
					registrants_confirmation_email: z.optional(
						z.boolean().describe("Send confirmation email to registrants"),
					),
					registrants_email_notification: z.optional(
						z
							.boolean()
							.describe(
								"Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.",
							),
					),
					registrants_restrict_number: z.optional(
						z
							.int()
							.min(0)
							.max(20000)
							.default(0)
							.describe(
								"Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.",
							),
					),
					registration_type: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3)])
							.default(1)
							.describe(
								"Registration types. Only used for recurring webinars with a fixed time.  \n `1` - Attendees register once and can attend any of the webinar sessions.  \n `2` - Attendees need to register for each session in order to attend.  \n `3` - Attendees register once and can choose one or more sessions to attend.",
							),
					),
					send_1080p_video_to_attendees: z.optional(
						z.boolean().default(false).describe("Always send 1080p video to attendees."),
					),
					show_share_button: z.optional(
						z.boolean().describe("Show social share buttons on the registration page."),
					),
					survey_url: z.optional(z.string().describe("Survey URL for post webinar survey.")),
					enable_session_branding: z.optional(
						z
							.boolean()
							.describe(
								"Whether the **Webinar Session Branding** setting is enabled. This setting lets hosts visually customize a webinar by setting a session background. This also lets hosts use [webinar session branding](https://support.zoom.us/hc/en-us/articles/4836268732045-Using-Webinar-Session-Branding) to set the Virtual Background for and apply name tags to hosts, alternative hosts, panelists, interpreters, and speakers.",
							),
					),
					request_permission_to_unmute_participants: z.optional(
						z
							.boolean()
							.describe(
								"Whether to enable the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting) setting. Not supported for simulive webinar. This option cannot be used together with `allow_host_control_participant_mute_state`, only one of the two can be enabled at a time.",
							),
					),
					allow_host_control_participant_mute_state: z.optional(
						z
							.boolean()
							.describe(
								"Whether to allow the host and co-hosts to fully control the mute state of participants. Not supported for simulive webinar. This option cannot be used together with `request_permission_to_unmute_participants`, only one of the two can be enabled at a time.",
							),
					),
					email_in_attendee_report: z.optional(
						z
							.boolean()
							.describe(
								"Whether to include guest's email addresses in webinars' attendee reports.",
							),
					),
				})
				.describe("Webinar settings."),
		),
		start_time: z.optional(z.string().datetime().describe("Webinar start time in GMT/UTC.")),
		start_url: z.optional(
			z
				.string()
				.describe(
					"The `start_url` of a webinar is a URL using which a host or an alternative host can start the webinar. This URL should only be used by the host of the meeting and should not be shared with anyone other than the host of the webinar. \n\nThe expiration time for the `start_url` field listed in the response of the [**Create a webinar**](/docs/api-reference/zoom-api/methods#operation/webinarCreate) API is two hours for all regular users. \n\t\nFor users created using the `custCreate` option via the [**Create users**](/docs/api-reference/zoom-api/methods#operation/userCreate) API, the expiration time of the `start_url` field is 90 days.\n\t\nFor security reasons, to retrieve the latest value for the `start_url` field programmatically (after expiry), you must call the [**Get a webinar**](/docs/api-reference/zoom-api/methods#operation/webinar) API and refer to the value of the `start_url` field in the response.\n\n\n ",
				),
		),
		timezone: z.optional(z.string().describe("Time zone to format `start_time`.")),
		topic: z.optional(z.string().max(200).describe("Webinar topic.")),
		tracking_fields: z.optional(
			z
				.array(
					z.object({
						field: z.optional(z.string().describe("Tracking fields type.")),
						value: z.optional(z.string().describe("Tracking fields value.")),
					}),
				)
				.describe("Tracking fields."),
		),
		type: z.optional(
			z
				.union([z.literal(5), z.literal(6), z.literal(9)])
				.default(5)
				.describe(
					"Webinar types. \n `5` - Webinar.  \n `6` - Recurring webinar with no fixed time.  \n `9` - Recurring webinar with a fixed time.",
				),
		),
		is_simulive: z.optional(z.boolean().describe("Whether the webinar is `simulive`.")),
		record_file_id: z.optional(
			z.string().describe("The previously recorded file's ID for `simulive`."),
		),
		transition_to_live: z.optional(
			z
				.boolean()
				.describe(
					"Whether to transition a simulive webinar to live. The host must be present at the time of transition.",
				),
		),
		simulive_delay_start: z.optional(
			z
				.object({
					enable: z.optional(z.boolean().describe("Whether simulive needs to delay playback.")),
					time: z.optional(
						z
							.int()
							.describe(
								"The time for delayed playback.\nIf the time unit is seconds, then the maximum value is 60 and the minimum value is 1.\nIf the time unit is minutes, then the maximum value is 10 and the minimum value is 1.",
							),
					),
					timeunit: z.optional(
						z
							.enum(["second", "minute"])
							.default("second")
							.describe(
								"The time unit for delayed playback.\n`second` - The time unit for delayed playback is seconds.\n`minute` - The time unit for delayed playback is minutes.",
							),
					),
				})
				.describe('{"enable":false,"time":0,"timeunit":"second"}'),
		),
		creation_source: z.optional(
			z
				.enum(["other", "open_api", "web_portal"])
				.describe(
					"The platform used when creating the meeting.\n* `other` - Created through another platform.\n* `open_api` - Created through Open API.\n* `web_portal` - Created through the web portal.",
				),
		),
	})
	.describe("Webinar object.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for user {userId} to perform this action. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n
 */
export const webinar400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinar404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const webinar429Schema = z.unknown();

export const webinarQueryResponseSchema = z.lazy(() => webinar200Schema);

export const webinarDeletePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

export const webinarDeleteQueryParamsSchema = z
	.object({
		occurrence_id: z.optional(z.string().describe("The meeting or webinar occurrence ID.")),
		cancel_webinar_reminder: z.optional(
			z
				.boolean()
				.describe(
					"`true` - Notify panelists and registrants about the webinar cancellation via email. \n\n`false` - Do not send any email notification to webinar registrants and panelists. \n\nThe default value of this field is `false`.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `204` <br>\n Webinar deleted.
 */
export const webinarDelete204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3000` <br>\n Your request could not be processed because webinars created via event directory can not be updated or deleted using this method. <br>\n**Error Code:** `3000` <br>\n You cannot update or delete simulive webinars that have started using this method. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `3000` <br>\n Webinar occurrence does not exist. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n
 */
export const webinarDelete400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarDelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarDelete429Schema = z.unknown();

export const webinarDeleteMutationResponseSchema = z.lazy(() => webinarDelete204Schema);

export const webinarUpdatePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

export const webinarUpdateQueryParamsSchema = z
	.object({
		occurrence_id: z.optional(
			z
				.string()
				.describe(
					"Webinar occurrence ID. Support change of agenda, start time, duration, and settings `host_video`, `panelist_video`, `hd_video, watermark`, `auto_recording`.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `204`  \n \nWebinar updated.
 */
export const webinarUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3003` <br>\n Users in **{domains}** have been blocked from joining meetings and webinars. To unblock them, go to the **Settings** page in the Zoom web portal and update the **Block users in specific domains from joining meetings and webinars** setting. <br>\n**Error Code:** `3000` <br>\n You cannot update or delete simulive webinars that have started using this method. <br>\n**Error Code:** `300` <br>\n The value that you entered for the `schedule_for` field is invalid. Enter a valid value and try again. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action: {userId}. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `4505` <br>\n Simulive can\'t select `No Fixed Time`. <br>\n
 */
export const webinarUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rate-limits/). \n\n
 */
export const webinarUpdate429Schema = z.unknown();

/**
 * @description Webinar.
 */
export const webinarUpdateMutationRequestSchema = z
	.object({
		agenda: z.optional(z.string().describe("Webinar description.")),
		duration: z.optional(
			z.int().describe("Webinar duration, in minutes. Used for scheduled webinar only."),
		),
		password: z.optional(
			z
				.string()
				.max(10)
				.describe(
					"Webinar passcode. Passcode may only contain the characters [a-z A-Z 0-9 @ - _ * !]. Maximum of 10 characters.\n\nIf **Webinar Passcode** setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the passcode field will be autogenerated for the Webinar in the response even if it is not provided in the API request. \n\n **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements. \n\n If the requirements are enabled, you can view those requirements by calling the [**Get account settings**](/docs/api/rest/reference/account/methods/#operation/accountSettings) API.",
				),
		),
		schedule_for: z.optional(
			z.string().describe("The user's email address or `userId` to schedule a webinar for."),
		),
		recurrence: z.optional(
			z
				.object({
					end_date_time: z.optional(
						z
							.string()
							.datetime()
							.describe(
								"Select the final date when the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. Cannot be used with `end_times`.",
							),
					),
					end_times: z.optional(
						z
							.int()
							.max(60)
							.default(1)
							.describe(
								"Select how many times the webinar will recur before it is canceled. The maximum number of recurring is 60. Cannot be used with `end_date_time`.",
							),
					),
					monthly_day: z.optional(
						z
							.int()
							.default(1)
							.describe(
								"Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.\n\nIf you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. If you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.",
							),
					),
					monthly_week: z.optional(
						z
							.union([z.literal(-1), z.literal(1), z.literal(2), z.literal(3), z.literal(4)])
							.describe(
								"Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.**   \n `-1` - Last week of the month.  \n `1` - First week of the month.  \n `2` - Second week of the month.  \n `3` - Third week of the month.  \n `4` - Fourth week of the month.",
							),
					),
					monthly_week_day: z.optional(
						z
							.union([
								z.literal(1),
								z.literal(2),
								z.literal(3),
								z.literal(4),
								z.literal(5),
								z.literal(6),
								z.literal(7),
							])
							.describe(
								"Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. \n\n  \n `1` - Sunday.  \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` - Thursday.  \n `6` - Friday.  \n `7` - Saturday.",
							),
					),
					repeat_interval: z.optional(
						z
							.int()
							.describe(
								"Define the interval when the meeting should recur. If you would like to schedule a meeting that recurs every two months, set the value of this field as `2` and the value of the `type` parameter as `3`. \n\nFor a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.\n\n",
							),
					),
					type: z
						.union([z.literal(1), z.literal(2), z.literal(3)])
						.describe(
							"Recurrence meeting types. \n `1` - Daily.  \n `2` - Weekly.  \n `3` - Monthly.",
						),
					weekly_days: z.optional(
						z
							.enum(["1", "2", "3", "4", "5", "6", "7"])
							.default("1")
							.describe(
								"This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat.   \n    \n  The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `1` as the value of this field.  \n   \n  **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `1,3` as the value of this field.\n\n   \n `1`  - Sunday.   \n `2` - Monday.  \n `3` - Tuesday.  \n `4` -  Wednesday.  \n `5` -  Thursday.  \n `6` - Friday.  \n `7` - Saturday.",
							),
					),
				})
				.describe(
					"Recurrence object. Use this object only for a meeting with type `8`, a recurring meeting with fixed time. ",
				),
		),
		settings: z.optional(
			z
				.object({
					allow_multiple_devices: z.optional(
						z.boolean().describe("Allow attendees to join from multiple devices."),
					),
					alternative_hosts: z.optional(
						z
							.string()
							.describe("Alternative host emails or IDs. Separate multiple values by commas."),
					),
					alternative_host_update_polls: z.optional(
						z
							.boolean()
							.describe(
								"Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.",
							),
					),
					approval_type: z.optional(
						z
							.union([z.literal(0), z.literal(1), z.literal(2)])
							.default(2)
							.describe(
								"`0` - Automatically approve.  \n `1` - Manually approve.  \n `2` - No registration required.",
							),
					),
					attendees_and_panelists_reminder_email_notification: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Send reminder email to attendees and panelists.\n\n* `false` - Do not send reminder email to attendees and panelists.",
										),
								),
								type: z.optional(
									z
										.union([
											z.literal(0),
											z.literal(1),
											z.literal(2),
											z.literal(3),
											z.literal(4),
											z.literal(5),
											z.literal(6),
											z.literal(7),
										])
										.describe(
											"`0` - No plan.  \n `1` - Send 1 hour before webinar.  \n `2` - Send 1 day before webinar.  \n `3` - Send 1 hour and 1 day before webinar.  \n `4` - Send 1 week before webinar.  \n `5` - Send 1 hour and 1 week before webinar.  \n `6` - Send 1 day and 1 week before webinar.  \n `7` - Send 1 hour, 1 day and 1 week before webinar.",
										),
								),
							})
							.describe("Send reminder email to attendees and panelists."),
					),
					audio: z.optional(
						z
							.enum(["both", "telephony", "voip", "thirdParty"])
							.default("both")
							.describe("Determine how participants can join the audio portion of the webinar."),
					),
					audio_conference_info: z.optional(
						z.string().max(2048).describe("Third party audio conference info."),
					),
					authentication_domains: z.optional(
						z
							.string()
							.describe(
								"If user has configured [**Sign Into Zoom with Specified Domains**](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.",
							),
					),
					authentication_name: z.optional(
						z
							.string()
							.describe(
								"Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).",
							),
					),
					authentication_option: z.optional(
						z.string().describe("Webinar authentication option ID."),
					),
					auto_recording: z.optional(
						z
							.enum(["local", "cloud", "none"])
							.default("none")
							.describe(
								"Automatic recording. \n `local` - Record on local.  \n `cloud` -  Record on cloud.  \n `none` - Disabled.",
							),
					),
					close_registration: z.optional(
						z.boolean().describe("Close registration after event date."),
					),
					contact_email: z.optional(z.string().describe("Contact email for registration")),
					contact_name: z.optional(z.string().describe("Contact name for registration")),
					email_language: z.optional(
						z
							.string()
							.describe(
								"Set the email language to one of the following.\n`en-US`,`de-DE`,`es-ES`,`fr-FR`,`jp-JP`,`pt-PT`,`ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.",
							),
					),
					enforce_login: z.optional(
						z
							.boolean()
							.describe(
								"Only signed in users can join this meeting.\n\n**This field is deprecated and will not be supported in the future.** \n\n As an alternative, use the ``meeting_authentication`, `authentication_option`, and `authentication_domains` fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the webinar.",
							),
					),
					enforce_login_domains: z.optional(
						z
							.string()
							.describe(
								"Only signed in users with specified domains can join meetings.\n\n**This field is deprecated and will not be supported in the future.**\n\n As an alternative, use the `meeting_authentication`, `authentication_option`, and `authentication_domains` fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the webinar.",
							),
					),
					follow_up_absentees_email_notification: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Send follow-up email to absentees.\n\n* `false` - Do not send follow-up email to absentees.",
										),
								),
								type: z.optional(
									z
										.union([
											z.literal(0),
											z.literal(1),
											z.literal(2),
											z.literal(3),
											z.literal(4),
											z.literal(5),
											z.literal(6),
											z.literal(7),
										])
										.describe(
											"`0` - No plan.  \n `1` - Send 1 days after the scheduled end date.  \n `2` - Send 2 days after the scheduled end date.  \n `3` - Send 3 days after the scheduled end date.  \n `4` - Send 4 days after the scheduled end date.  \n `5` - Send 5 days after the scheduled end date.  \n `6` - Send 6 days after the scheduled end date.  \n `7` - Send 7 days after the scheduled end date.",
										),
								),
							})
							.describe("Send follow-up email to absentees."),
					),
					follow_up_attendees_email_notification: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Send follow-up email to attendees.\n\n* `false` - Do not send follow-up email to attendees.",
										),
								),
								type: z.optional(
									z
										.union([
											z.literal(0),
											z.literal(1),
											z.literal(2),
											z.literal(3),
											z.literal(4),
											z.literal(5),
											z.literal(6),
											z.literal(7),
										])
										.describe(
											"`0` - No plan.  \n `1` - Send 1 day after the scheduled end date.  \n `2` - Send 2 days after the scheduled end date.  \n `3` - Send 3 days after the scheduled end date.  \n `4` - Send 4 days after the scheduled end date.  \n `5` - Send 5 days after the scheduled end date.  \n `6` - Send 6 days after the scheduled end date.  \n `7` - Send 7 days after the scheduled end date.",
										),
								),
							})
							.describe("Send follow-up email to attendees."),
					),
					global_dial_in_countries: z.optional(
						z.array(z.string()).describe("List of global dial-in countries"),
					),
					hd_video: z.optional(z.boolean().default(false).describe("Default to HD video.")),
					hd_video_for_attendees: z.optional(
						z.boolean().default(false).describe("Whether HD video for attendees is enabled."),
					),
					host_video: z.optional(z.boolean().describe("Start video when host joins the webinar.")),
					language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [language interpretation](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768) for the webinar.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two country IDs.\n\nOnly system-supported languages are allowed: `US` (English), `CN` (Chinese), `JP` (Japanese), `DE` (German), `FR` (French), `RU` (Russian), `PT` (Portuguese), `ES` (Spanish), and `KR` (Korean).\n\nFor example, to set an interpreter translating from English to Chinese, use `US,CN`.",
														),
												),
												interpreter_languages: z.optional(
													z
														.string()
														.describe(
															"A comma-separated list of the interpreter's languages. The string must contain exactly two languages.\n\nTo get this value, use the `language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/docs/api/users/#tag/users/GET/users/{userId}/settings) API response.\n\n**languages**: System-supported languages include `English`, `Chinese`, `Japanese`, `German`, `French`, `Russian`, `Portuguese`, `Spanish`, and `Korean`.\n\n**custom_languages**: User-defined languages added by the user.\n\nFor example, an interpreter translating between English and French should use `English,French`.",
														),
												),
											}),
										)
										.describe("Information about the webinar's language interpreters."),
								),
							})
							.describe(
								"The webinar's [language interpretation settings](https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0064768). Make sure to add the language in the web portal in order to use it in the API. See link for details. \n\n**Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar. This is not supported for simulive webinars.",
							),
					),
					sign_language_interpretation: z.optional(
						z
							.object({
								enable: z.optional(
									z
										.boolean()
										.describe(
											"Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the webinar.",
										),
								),
								interpreters: z.optional(
									z
										.array(
											z.object({
												email: z.optional(z.email().describe("The interpreter's email address.")),
												sign_language: z.optional(
													z
														.string()
														.describe(
															"The interpreter's sign language. \n\n To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/api-reference/zoom-api/methods#operation/userSettings) API response.",
														),
												),
											}),
										)
										.max(20)
										.describe("Information about the webinar's sign language interpreters."),
								),
							})
							.describe(
								"The webinar's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details. \n\n**Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.",
							),
					),
					panelist_authentication: z.optional(
						z.boolean().describe("Require panelists to authenticate to join."),
					),
					meeting_authentication: z.optional(
						z.boolean().describe("Only authenticated users can join the webinar."),
					),
					add_watermark: z.optional(
						z.boolean().describe("Add watermark that identifies the viewing participant."),
					),
					add_audio_watermark: z.optional(
						z.boolean().describe("Add audio watermark that identifies the participants."),
					),
					notify_registrants: z.optional(
						z
							.boolean()
							.describe("Send notification email to registrants when the host updates a webinar."),
					),
					on_demand: z.optional(z.boolean().default(false).describe("Make the webinar on-demand.")),
					panelists_invitation_email_notification: z.optional(
						z
							.boolean()
							.describe(
								"Send invitation email to panelists. If `false`, do not send invitation email to panelists.",
							),
					),
					panelists_video: z.optional(
						z.boolean().describe("Start video when panelists join the webinar."),
					),
					post_webinar_survey: z.optional(
						z
							.boolean()
							.describe(
								"Zoom will open a survey page in attendees' browsers after leaving the webinar.",
							),
					),
					practice_session: z.optional(
						z.boolean().default(false).describe("Enable practice session."),
					),
					question_and_answer: z.optional(
						z
							.object({
								allow_submit_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to submit questions.\n\n* `false` - Do not allow submit questions.",
										),
								),
								allow_anonymous_questions: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Allow participants to send questions without providing their name to the host, co-host, and panelists..\n\n* `false` - Do not allow anonymous questions.",
										),
								),
								answer_questions: z.optional(
									z
										.enum(["only", "all"])
										.describe(
											"Indicate whether you want attendees to be able to view answered questions only or view all questions.\n\n* `only` - Attendees are able to view answered questions only.\n\n*  `all` - Attendees are able to view all questions submitted in the Q&amp;A.",
										),
								),
								attendees_can_comment: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can answer questions or leave a comment in the question thread.\n\n* `false` - Attendees can't answer questions or leave a comment in the question thread.",
										),
								),
								attendees_can_upvote: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Attendees can click the thumbs up button to bring popular questions to the top of the Q&amp;A window.\n\n* `false` - Attendees can't click the thumbs up button on questions.",
										),
								),
								allow_auto_reply: z.optional(
									z
										.boolean()
										.describe(
											"If simulive webinar, \n\n* `true` - allow auto-reply to attendees. \n\n* `false` - don't allow auto-reply to the attendees.",
										),
								),
								auto_reply_text: z.optional(
									z
										.string()
										.describe(
											"If `allow_auto_reply` = true, the text to be included in the automatic response. ",
										),
								),
								enable: z.optional(
									z
										.boolean()
										.describe(
											"* `true` - Enable [Q&amp;A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.\n\n* `false` - Disable Q&amp;A for webinar.",
										),
								),
							})
							.describe(
								"[Q&amp;A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.",
							),
					),
					registrants_confirmation_email: z.optional(
						z.boolean().describe("Send confirmation email to registrants"),
					),
					registrants_email_notification: z.optional(
						z
							.boolean()
							.describe(
								"Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.",
							),
					),
					registrants_restrict_number: z.optional(
						z
							.int()
							.min(0)
							.max(20000)
							.default(0)
							.describe(
								"Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.",
							),
					),
					registration_type: z.optional(
						z
							.union([z.literal(1), z.literal(2), z.literal(3)])
							.default(1)
							.describe(
								"Registration types. Only used for recurring webinars with a fixed time.  \n `1` - Attendees register once and can attend any of the webinar sessions.  \n `2` - Attendees need to register for each session in order to attend.  \n `3` - Attendees register once and can choose one or more sessions to attend.",
							),
					),
					send_1080p_video_to_attendees: z.optional(
						z.boolean().default(false).describe("Always send 1080p video to attendees."),
					),
					show_share_button: z.optional(
						z.boolean().describe("Show social share buttons on the registration page."),
					),
					survey_url: z.optional(z.string().describe("Survey url for post webinar survey")),
					enable_session_branding: z.optional(
						z
							.boolean()
							.describe(
								"Whether the **Webinar Session Branding** setting is enabled. This setting lets hosts visually customize a webinar by setting a session background. This also lets hosts use [Webinar Session Branding](https://support.zoom.us/hc/en-us/articles/4836268732045-Using-Webinar-Session-Branding) to set the virtual background for and apply name tags to hosts, alternative hosts, panelists, interpreters, and speakers.",
							),
					),
					request_permission_to_unmute_participants: z.optional(
						z
							.boolean()
							.describe(
								"Whether to enable the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting) setting. Not supported for simulive webinar. This option cannot be used together with `allow_host_control_participant_mute_state`, only one of the two can be enabled at a time.",
							),
					),
					allow_host_control_participant_mute_state: z.optional(
						z
							.boolean()
							.describe(
								"Whether to allow the host and co-hosts to fully control the mute state of participants. Not supported for simulive webinar. This option cannot be used together with `request_permission_to_unmute_participants`, only one of the two can be enabled at a time.",
							),
					),
					email_in_attendee_report: z.optional(
						z
							.boolean()
							.describe(
								"Whether to include guest's email addresses in webinars' attendee reports.",
							),
					),
				})
				.describe("Webinar settings."),
		),
		start_time: z.optional(
			z
				.string()
				.datetime()
				.describe(
					"Webinar start time, in the format `yyyy-MM-dd'T'HH:mm:ss'Z'`. Should be in GMT time. In the format `yyyy-MM-dd'T'HH:mm:ss`. This should be in local time and the timezone should be specified. Only used for scheduled webinars and recurring webinars with a fixed time.",
				),
		),
		timezone: z.optional(
			z
				.string()
				.describe(
					"The timezone to assign to the `start_time` value. This field is only used for scheduled or recurring webinars with a fixed time.\n\nFor a list of supported timezones and their formats, see our [timezone list](/docs/api/references/abbreviations/#timezones).",
				),
		),
		topic: z.optional(z.string().describe("The webinar topic.")),
		tracking_fields: z.optional(
			z
				.array(
					z.object({
						field: z.optional(z.string().describe("Tracking fields type.")),
						value: z.optional(z.string().describe("Tracking fields value.")),
					}),
				)
				.describe("Tracking fields."),
		),
		type: z.optional(
			z
				.union([z.literal(5), z.literal(6), z.literal(9)])
				.default(5)
				.describe(
					"Webinar types. \n `5` - webinar.  \n `6` - Recurring webinar with no fixed time.  \n `9` - Recurring webinar with a fixed time.",
				),
		),
		is_simulive: z.optional(z.boolean().describe("Whether to set the webinar to simulive.")),
		record_file_id: z.optional(
			z.string().describe("The previously recorded file's ID for `simulive`."),
		),
		transition_to_live: z.optional(
			z
				.boolean()
				.describe(
					"Whether to transition a simulive webinar to live. The host must be present at the time of transition.",
				),
		),
		simulive_delay_start: z.optional(
			z
				.object({
					enable: z.optional(z.boolean().describe("Whether simulive need delay playback.")),
					time: z.optional(
						z
							.int()
							.describe(
								"The time for delayed playback.\nIf the time unit is seconds, then the maximum value is 60 and the minimum value is 1.\nIf the time unit is minutes, then the maximum value is 10 and the minimum value is 1.",
							),
					),
					timeunit: z.optional(
						z
							.enum(["second", "minute"])
							.default("second")
							.describe(
								"The time unit for delayed playback.\n`second` - The time unit for delayed playback is seconds.\n`minute` - The time unit for delayed playback is minutes.",
							),
					),
				})
				.describe('{"enable":false,"time":0,"timeunit":"second"}'),
		),
	})
	.describe("Webinar object.");

export const webinarUpdateMutationResponseSchema = z.lazy(() => webinarUpdate204Schema);

export const addBatchWebinarRegistrantsPathParamsSchema = z.object({
	webinarId: z.string().describe("The webinar's unique identifier."),
});

/**
 * @description **HTTP Status Code:** `200` **OK**   \n \nRegistrants added.
 */
export const addBatchWebinarRegistrants201Schema = z.object({
	registrants: z.optional(
		z.array(
			z.object({
				email: z.optional(z.string().describe("The registrant's email address.")),
				join_url: z.optional(
					z.string().describe("Unique URL using which registrant can join the webinar."),
				),
				registrant_id: z.optional(z.string().describe("The registrant's unique identifier.")),
			}),
		),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `300` <br>\n This API can only be used for scheduled webinars (type 5). Batch registration is not supported for other webinar types. <br>\n**Error Code:** `3038` <br>\n The webinar is over. You cannot register now. If you have any questions, contact the webinar\'s host. <br>\n**Error Code:** `3000` <br>\n You have reached the limit for the number of attendees you can add. Contact Zoom Support for more information. <br>\n**Error Code:** `3000` <br>\n The Zoom REST API does not support paid registration. <br>\n**Error Code:** `3043` <br>\n Webinar has reached maximum attendee capacity. <br>\n**Error Code:** `3000` <br>\n Registration has not been enabled for this webinar: {webinarId}. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n
 */
export const addBatchWebinarRegistrants400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const addBatchWebinarRegistrants404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const addBatchWebinarRegistrants429Schema = z.unknown();

export const addBatchWebinarRegistrantsMutationRequestSchema = z.object({
	auto_approve: z.optional(
		z
			.boolean()
			.describe(
				"If a meeting was scheduled with approval_type `1` (manual approval), but you want to automatically approve registrants added via this API, set the value of this field to `true`. \n\nYou **cannot** use this field to change approval setting for a meeting that was originally scheduled with approval_type `0` (automatic approval).",
			),
	),
	registrants: z.optional(
		z.array(
			z.object({
				email: z.email().describe("The registrant's email address."),
				first_name: z.string().describe("The registrant's first name."),
				last_name: z.optional(z.string().describe("The registrant's last name.")),
			}),
		),
	),
});

export const addBatchWebinarRegistrantsMutationResponseSchema = z.lazy(
	() => addBatchWebinarRegistrants201Schema,
);

export const getWebinarBrandingPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `200`   \n \nWebinar session branding returned.
 */
export const getWebinarBranding200Schema = z
	.object({
		wallpaper: z.optional(
			z
				.object({
					id: z.optional(z.string().describe("The wallpaper's file ID.")),
				})
				.describe("Information about the webinar's [wallpaper] file."),
		),
		virtual_backgrounds: z.optional(
			z
				.array(
					z.object({
						id: z.optional(z.string().describe("The virtual background's file ID.")),
						name: z.optional(z.string().describe("The virtual background's file name.")),
						is_default: z.optional(
							z.boolean().describe("Whether the file is the default virtual background file."),
						),
					}),
				)
				.describe(
					"Information about the webinar's [virtual background](https://support.zoom.us/hc/en-us/articles/210707503-Virtual-Background) files.",
				),
		),
		name_tags: z.optional(
			z
				.array(
					z.object({
						id: z.optional(z.string().describe("The name tag's ID.")),
						name: z.optional(z.string().describe("The name tag's name.")),
						text_color: z.optional(z.string().describe("The name tag's text color.")),
						accent_color: z.optional(z.string().describe("The name tag's accent color.")),
						background_color: z.optional(z.string().describe("The name tag's background color.")),
						is_default: z.optional(
							z.boolean().describe("Whether the file is the default name tag or not."),
						),
					}),
				)
				.describe("Information about the webinar's name tag."),
		),
	})
	.describe("Information about the webinar's sessions branding.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3000` <br>\n You cannot enable session branding for this webinar. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const getWebinarBranding400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const getWebinarBranding404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const getWebinarBranding429Schema = z.unknown();

export const getWebinarBrandingQueryResponseSchema = z.lazy(() => getWebinarBranding200Schema);

export const createWebinarBrandingNameTagPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `201`   \n \nName tag created.
 */
export const createWebinarBrandingNameTag201Schema = z.object({
	id: z.optional(z.string().describe("The name tag's ID.")),
	name: z.optional(z.string().describe("The name tag's name.")),
	text_color: z.optional(z.string().describe("The name tag's text color.")),
	accent_color: z.optional(z.string().describe("The name tag's accent color.")),
	background_color: z.optional(z.string().describe("The name tag's background_color color.")),
	is_default: z.optional(
		z.boolean().describe("Whether the name tag is the default name tag or not."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `3000` <br>\n This webinar does not have session branding enabled. <br>\n**Error Code:** `3000` <br>\n You have reached the limit for the number of name tags you can add for this webinar. The limit is 20. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n
 */
export const createWebinarBrandingNameTag400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const createWebinarBrandingNameTag404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const createWebinarBrandingNameTag429Schema = z.unknown();

export const createWebinarBrandingNameTagMutationRequestSchema = z
	.object({
		name: z
			.string()
			.describe(
				"The name tag's name.\n\n**Note:** This value cannot exceed more than 50 characters.",
			),
		text_color: z.string().describe("The name tag's text color."),
		accent_color: z.string().describe("The name tag's accent color."),
		background_color: z.string().describe("The name tag's background color."),
		is_default: z.optional(
			z
				.boolean()
				.default(false)
				.describe("Whether set the name tag as the default name tag or not."),
		),
		set_default_for_all_panelists: z.optional(
			z
				.boolean()
				.default(true)
				.describe(
					"Whether to set the name tag as the new default for all panelists or not. This includes panelists not currently assigned a default name tag.",
				),
		),
	})
	.describe("Name tag information");

export const createWebinarBrandingNameTagMutationResponseSchema = z.lazy(
	() => createWebinarBrandingNameTag201Schema,
);

export const deleteWebinarBrandingNameTagPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

export const deleteWebinarBrandingNameTagQueryParamsSchema = z
	.object({
		name_tag_ids: z.optional(
			z.string().describe("A comma-separated list of the name tag IDs to delete."),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `204`   \n \n* No content. \n* Name tag(s) deleted.
 */
export const deleteWebinarBrandingNameTag204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid parameter: `name_tag_ids`. <br>\n**Error Code:** `3000` <br>\n This webinar does not have session branding enabled. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const deleteWebinarBrandingNameTag400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const deleteWebinarBrandingNameTag404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const deleteWebinarBrandingNameTag429Schema = z.unknown();

export const deleteWebinarBrandingNameTagMutationResponseSchema = z.lazy(
	() => deleteWebinarBrandingNameTag204Schema,
);

export const updateWebinarBrandingNameTagPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
	nameTagId: z.string().describe("The name tag's ID."),
});

/**
 * @description **HTTP Status Code:** `204`   \n \n* No content. \n* Name tag updated.
 */
export const updateWebinarBrandingNameTag204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3000` <br>\n This webinar does not have session branding enabled. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `300` <br>\n Name Tag does not exist. <br>\n
 */
export const updateWebinarBrandingNameTag400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const updateWebinarBrandingNameTag404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const updateWebinarBrandingNameTag429Schema = z.unknown();

export const updateWebinarBrandingNameTagMutationRequestSchema = z
	.object({
		name: z.optional(
			z
				.string()
				.describe(
					"The name tag's name.\n\n**Note:** This value cannot exceed more than 50 characters.",
				),
		),
		text_color: z.optional(z.string().describe("The name tag's text color.")),
		accent_color: z.optional(z.string().describe("The name tag's accent color.")),
		background_color: z.optional(z.string().describe("The name tag's background color.")),
		is_default: z.optional(
			z
				.boolean()
				.default(false)
				.describe("Whether set the name tag as the default name tag or not."),
		),
		set_default_for_all_panelists: z.optional(
			z
				.boolean()
				.default(true)
				.describe(
					"Whether to set the name tag as the new default for all panelists or not, including panelists not currently assigned a default name tag.",
				),
		),
	})
	.describe("Name tag information.");

export const updateWebinarBrandingNameTagMutationResponseSchema = z.lazy(
	() => updateWebinarBrandingNameTag204Schema,
);

export const uploadWebinarBrandingVBPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `201`    Virtual background uploaded.
 */
export const uploadWebinarBrandingVB201Schema = z.object({
	id: z.optional(z.string().describe("The virtual background file's ID.")),
	name: z.optional(z.string().describe("The virtual background file's name.")),
	is_default: z.optional(
		z.boolean().describe("Whether the file is the default virtual background file."),
	),
	size: z.optional(z.int().describe("The virtual background file's size, in bytes.")),
	type: z.optional(
		z
			.enum(["image"])
			.describe("The virtual background file's file type. \n* `image` - An image file."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3000` <br>\n This webinar does not have session branding enabled. <br>\n**Error Code:** `120` <br>\n You may only upload JPG/JPEG, GIF, or PNG image files. <br>\n**Error Code:** `120` <br>\n No file uploaded. Verify that a file has been uploaded. <br>\n**Error Code:** `120` <br>\n File size cannot exceed 15M. <br>\n**Error Code:** `120` <br>\n A maximum of 10 files are allowed for a webinar. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const uploadWebinarBrandingVB400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const uploadWebinarBrandingVB404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const uploadWebinarBrandingVB429Schema = z.unknown();

export const uploadWebinarBrandingVBMutationResponseSchema = z.lazy(
	() => uploadWebinarBrandingVB201Schema,
);

export const deleteWebinarBrandingVBPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

export const deleteWebinarBrandingVBQueryParamsSchema = z
	.object({
		ids: z.optional(
			z.string().describe("A comma-separated list of the virtual background file IDs to delete."),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `204`   \n \n* No content. \n* Virtual background file(s) deleted.
 */
export const deleteWebinarBrandingVB204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid parameter: `ids`. <br>\n**Error Code:** `3000` <br>\n This webinar does not have session branding enabled. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const deleteWebinarBrandingVB400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const deleteWebinarBrandingVB404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const deleteWebinarBrandingVB429Schema = z.unknown();

export const deleteWebinarBrandingVBMutationResponseSchema = z.lazy(
	() => deleteWebinarBrandingVB204Schema,
);

export const setWebinarBrandingVBPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

export const setWebinarBrandingVBQueryParamsSchema = z
	.object({
		id: z.optional(z.string().describe("The virtual background file ID to update.")),
		set_default_for_all_panelists: z.optional(
			z
				.boolean()
				.describe(
					"Whether to set the virtual background file as the new default for all panelists. This includes panelists not currently assigned a default virtual background.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `204`    * No content. * Virtual background updated.
 */
export const setWebinarBrandingVB204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid parameter: {id} <br>\n**Error Code:** `3000` <br>\n This webinar does not have session branding enabled. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const setWebinarBrandingVB400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const setWebinarBrandingVB404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const setWebinarBrandingVB429Schema = z.unknown();

export const setWebinarBrandingVBMutationResponseSchema = z.lazy(
	() => setWebinarBrandingVB204Schema,
);

export const uploadWebinarBrandingWallpaperPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `201`   \n \nWebinar wallpaper uploaded.
 */
export const uploadWebinarBrandingWallpaper201Schema = z.object({
	id: z.optional(z.string().describe("The wallpaper file's ID.")),
	name: z.optional(z.string().describe("The wallpaper file's name.")),
	size: z.optional(z.int().describe("The wallpaper file's size, in bytes.")),
	type: z.optional(
		z.enum(["image"]).describe("The wallpaper file's file type. \n* `image` - An image file."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3000` <br>\n This webinar does not have session branding enabled. <br>\n**Error Code:** `120` <br>\n No file uploaded. Verify that a file has been uploaded. <br>\n**Error Code:** `120` <br>\n File size cannot exceed 15M. <br>\n**Error Code:** `120` <br>\n You can only upload JPG/JPEG, GIF, or PNG image files. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const uploadWebinarBrandingWallpaper400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const uploadWebinarBrandingWallpaper404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const uploadWebinarBrandingWallpaper429Schema = z.unknown();

export const uploadWebinarBrandingWallpaperMutationResponseSchema = z.lazy(
	() => uploadWebinarBrandingWallpaper201Schema,
);

export const deleteWebinarBrandingWallpaperPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `204`   \n \n* No content. \n* Webinar wallpaper deleted.
 */
export const deleteWebinarBrandingWallpaper204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `3000` <br>\n This webinar does not have session branding enabled. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const deleteWebinarBrandingWallpaper400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const deleteWebinarBrandingWallpaper404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests  For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const deleteWebinarBrandingWallpaper429Schema = z.unknown();

export const deleteWebinarBrandingWallpaperMutationResponseSchema = z.lazy(
	() => deleteWebinarBrandingWallpaper204Schema,
);

export const webinarInviteLinksCreatePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `201` Webinar Invite Links Created
 */
export const webinarInviteLinksCreate201Schema = z
	.object({
		attendees: z.optional(
			z
				.array(
					z.object({
						join_url: z.optional(z.string().describe("The URL to join the meeting.")),
						name: z.optional(z.string().describe("The user's display name.")),
					}),
				)
				.min(1)
				.max(500)
				.describe("The attendee list."),
		),
	})
	.describe("Invite links response.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid Webinar Id. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarInviteLinksCreate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarInviteLinksCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](/docs/api/rest/rate-limits/). \n\n
 */
export const webinarInviteLinksCreate429Schema = z.unknown();

/**
 * @description Webinar invite link object.
 */
export const webinarInviteLinksCreateMutationRequestSchema = z
	.object({
		attendees: z.optional(
			z
				.array(
					z.object({
						name: z.string().max(64).describe("User display name."),
						disable_video: z.optional(
							z
								.boolean()
								.default(false)
								.describe(
									"Whether to disable participant video when joining the meeting. If not provided or set to `false`, the participant video will follow the meeting's default settings.",
								),
						),
						disable_audio: z.optional(
							z
								.boolean()
								.default(false)
								.describe(
									"Whether to disable participant audio when joining the meeting. If not provided or set to `false`, the participant audio will follow the meeting's default settings.",
								),
						),
					}),
				)
				.min(1)
				.max(500)
				.describe("The attendees list."),
		),
		ttl: z.optional(
			z
				.int()
				.min(0)
				.max(7776000)
				.default(7200)
				.describe(
					"The invite link's expiration time, in seconds. \n\nThis value defaults to `7200`.",
				),
		),
	})
	.describe("Invite Links");

export const webinarInviteLinksCreateMutationResponseSchema = z.lazy(
	() => webinarInviteLinksCreate201Schema,
);

export const webinarLiveStreamingJoinTokenPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `200`   \n \nWebinar live streaming token returned.
 */
export const webinarLiveStreamingJoinToken200Schema = z
	.object({
		expire_in: z.optional(
			z
				.literal(120)
				.describe(
					"The number of seconds the join token is valid for before it expires. This value always returns `120`.",
				),
		),
		token: z.optional(z.string().describe("The join token.")),
	})
	.describe("Information about the webinar's join token.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `124` <br>\n This API only supports OAuth2 authorization. <br>\n**Error Code:** `3000` <br>\n Not allowed to start live streaming. To use this feature, enable the **Allow livestreaming of webinars** setting in the **Settings** page of the Zoom web portal. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarLiveStreamingJoinToken400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarLiveStreamingJoinToken404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests  For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarLiveStreamingJoinToken429Schema = z.unknown();

export const webinarLiveStreamingJoinTokenQueryResponseSchema = z.lazy(
	() => webinarLiveStreamingJoinToken200Schema,
);

export const webinarLocalArchivingArchiveTokenPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `200`   \n \nWebinar local archiving token returned.
 */
export const webinarLocalArchivingArchiveToken200Schema = z
	.object({
		expire_in: z.optional(
			z
				.literal(120)
				.describe(
					"The number of seconds the archive token is valid for before it expires. This value always returns `120`.",
				),
		),
		token: z.optional(z.string().describe("The archive token.")),
	})
	.describe("Information about the webinar's local archive token.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `124` <br>\n This API only supports OAuth2 authorization. <br>\n**Error Code:** `3000` <br>\n Not allowed to start local archiving. To use this feature, enable the **Archive meetings and webinars** setting in the **Settings** page of the Zoom web portal. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarLocalArchivingArchiveToken400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarLocalArchivingArchiveToken404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests  For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarLocalArchivingArchiveToken429Schema = z.unknown();

export const webinarLocalArchivingArchiveTokenQueryResponseSchema = z.lazy(
	() => webinarLocalArchivingArchiveToken200Schema,
);

export const webinarLocalRecordingJoinTokenPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `200`   \n \nWebinar local recording token returned.
 */
export const webinarLocalRecordingJoinToken200Schema = z
	.object({
		expire_in: z.optional(
			z
				.literal(120)
				.describe(
					"The number of seconds the join token is valid for before it expires. This value always returns `120`.",
				),
		),
		token: z.optional(z.string().describe("The join token.")),
	})
	.describe("Information about the webinar's local recorder join token.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `124` <br>\n This API only supports OAuth2 authorization. <br>\n**Error Code:** `3000` <br>\n Not allowed to start local recording. To use this feature, enable the **Local Recording** setting in the **Settings** page of the Zoom web portal. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarLocalRecordingJoinToken400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarLocalRecordingJoinToken404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarLocalRecordingJoinToken429Schema = z.unknown();

export const webinarLocalRecordingJoinTokenQueryResponseSchema = z.lazy(
	() => webinarLocalRecordingJoinToken200Schema,
);

export const getWebinarLiveStreamDetailsPathParamsSchema = z.object({
	webinarId: z.string().describe("The webinar's unique ID."),
});

/**
 * @description **HTTP Status Code:** `200` **OK**   Live stream details returned.
 */
export const getWebinarLiveStreamDetails200Schema = z.object({
	page_url: z.optional(
		z
			.string()
			.describe(
				"Live streaming page URL. This is the URL using which anyone can view the live stream of the webinar.",
			),
	),
	stream_key: z.optional(z.string().describe("Stream key.")),
	stream_url: z.optional(z.string().describe("Stream URL.")),
	resolution: z.optional(
		z
			.string()
			.describe("The number of pixels in each dimension that the video camera can display."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n The current user has not enabled the custom live streaming feature of the webinar. <br>\n
 */
export const getWebinarLiveStreamDetails400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const getWebinarLiveStreamDetails404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests  For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const getWebinarLiveStreamDetails429Schema = z.unknown();

export const getWebinarLiveStreamDetailsQueryResponseSchema = z.lazy(
	() => getWebinarLiveStreamDetails200Schema,
);

export const webinarLiveStreamUpdatePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `204`  \n \nMeeting live stream updated.
 */
export const webinarLiveStreamUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n The current user has not enabled the custom live streaming feature of the webinar. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarLiveStreamUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarLiveStreamUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarLiveStreamUpdate429Schema = z.unknown();

/**
 * @description Webinar
 */
export const webinarLiveStreamUpdateMutationRequestSchema = z
	.object({
		page_url: z.url().max(1024).describe("The webinar live stream page's URL."),
		stream_key: z.string().max(512).describe("The webinar live stream name and key."),
		stream_url: z.string().max(1024).describe("The webinar live stream URL."),
		resolution: z.optional(
			z
				.string()
				.describe(
					"The number of pixels in each dimension that the video camera can display, required when a user enables 1080p. Use a value of `720p` or `1080p`",
				),
		),
	})
	.describe("Webinar live stream.");

export const webinarLiveStreamUpdateMutationResponseSchema = z.lazy(
	() => webinarLiveStreamUpdate204Schema,
);

export const webinarLiveStreamStatusUpdatePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `204`   \n \nMeeting live stream updated.\n\n
 */
export const webinarLiveStreamStatusUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `1001` <br>\n User does not exist: {userId}. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `3000` <br>\n The current webinar is not configured with a custom streaming service. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `200` <br>\n Webinar {webinarId} has not started. <br>\n**Error Code:** `3000` <br>\n The current webinar is not configured with a custom streaming service. <br>\n
 */
export const webinarLiveStreamStatusUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarLiveStreamStatusUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarLiveStreamStatusUpdate429Schema = z.unknown();

/**
 * @description Webinar
 */
export const webinarLiveStreamStatusUpdateMutationRequestSchema = z
	.object({
		action: z.optional(
			z
				.enum(["start", "stop"])
				.describe(
					"Update the live stream's status. \n\n* `start` - Start a webinar live stream.\n\n* `stop`- Stop an ongoing webinar live stream.",
				),
		),
		settings: z.optional(
			z
				.object({
					active_speaker_name: z.optional(
						z.boolean().describe("Display the name of the active speaker during a live stream."),
					),
					display_name: z.optional(
						z.string().min(1).max(50).describe("Display the live stream's name."),
					),
				})
				.describe(
					"Update the live stream session's settings.  **Only** settings for a stopped live stream can be updated.",
				),
		),
	})
	.describe("Webinar live stream status.");

export const webinarLiveStreamStatusUpdateMutationResponseSchema = z.lazy(
	() => webinarLiveStreamStatusUpdate204Schema,
);

export const webinarPanelistsPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nWebinar plan subscription missing. Enable webinar for this user once the subscription is added.
 */
export const webinarPanelists200Schema = z
	.object({
		panelists: z.optional(
			z
				.array(
					z.object({
						id: z.optional(z.string().describe("Panelist's ID.")),
						email: z.optional(
							z
								.email()
								.describe(
									"Panelist's email. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for return value details.",
								),
						),
						name: z.optional(
							z
								.string()
								.describe(
									"The panelist's full name.\n\n**Note** This value cannot exceed more than 12 Chinese characters.",
								),
						),
						join_url: z.optional(z.string().describe("Join URL.")),
						virtual_background_id: z.optional(z.string().describe("The virtual background's ID.")),
						name_tag_id: z.optional(z.string().describe("The name tag ID to bind.")),
						name_tag_name: z.optional(
							z.string().describe("The panelist's name to display in the name tag."),
						),
						name_tag_pronouns: z.optional(
							z.string().describe("The pronouns to display in the name tag."),
						),
						name_tag_description: z.optional(
							z.string().describe("The description for the name tag, such as the person's title."),
						),
					}),
				)
				.describe("List of panelist objects."),
		),
		total_records: z.optional(z.int().describe("Total records.")),
	})
	.describe("Webinar panelist.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarPanelists400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarPanelists404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarPanelists429Schema = z.unknown();

export const webinarPanelistsQueryResponseSchema = z.lazy(() => webinarPanelists200Schema);

export const webinarPanelistCreatePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `201`  \n \nPanelist created.
 */
export const webinarPanelistCreate201Schema = z.object({
	id: z.optional(z.string().describe("Webinar ID.")),
	updated_at: z.optional(z.string().datetime().describe("The time when the panelist was added.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3000` <br>\n You have reached the limit for the number of panelists you can add. Contact Zoom Support for more information. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n
 */
export const webinarPanelistCreate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarPanelistCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarPanelistCreate429Schema = z.unknown();

export const webinarPanelistCreateMutationRequestSchema = z
	.object({
		panelists: z.optional(
			z
				.array(
					z.object({
						email: z.optional(
							z
								.email()
								.describe(
									"Panelist's email. See the [email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for return value details.",
								),
						),
						name: z.optional(
							z
								.string()
								.describe(
									"The panelist's full name.\n\n**Note:** This value cannot exceed more than 12 Chinese characters.",
								),
						),
						virtual_background_id: z.optional(
							z.string().describe("The virtual background ID to bind."),
						),
						name_tag_id: z.optional(z.string().describe("The name tag ID to bind.")),
						name_tag_name: z.optional(
							z.string().describe("The panelist's name to display in the name tag."),
						),
						name_tag_pronouns: z.optional(
							z.string().describe("The pronouns to display in the name tag."),
						),
						name_tag_description: z.optional(
							z.string().describe("The description for the name tag, such the person's title."),
						),
					}),
				)
				.max(30)
				.describe("List of panelist objects."),
		),
	})
	.describe("Webinar panelist.");

export const webinarPanelistCreateMutationResponseSchema = z.lazy(
	() => webinarPanelistCreate201Schema,
);

export const webinarPanelistsDeletePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `204`  \n \nPanelists removed.
 */
export const webinarPanelistsDelete204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarPanelistsDelete400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarPanelistsDelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarPanelistsDelete429Schema = z.unknown();

export const webinarPanelistsDeleteMutationResponseSchema = z.lazy(
	() => webinarPanelistsDelete204Schema,
);

export const webinarPanelistDeletePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
	panelistId: z.string().describe("The panelist's ID or email."),
});

/**
 * @description **HTTP Status Code:** `204`  \n \nPanelist removed.
 */
export const webinarPanelistDelete204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarPanelistDelete400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarPanelistDelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarPanelistDelete429Schema = z.unknown();

export const webinarPanelistDeleteMutationResponseSchema = z.lazy(
	() => webinarPanelistDelete204Schema,
);

export const webinarPollsPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

export const webinarPollsQueryParamsSchema = z
	.object({
		anonymous: z.optional(
			z
				.boolean()
				.describe(
					"Whether to query for polls with the **Anonymous** option enabled: \n* `true` &mdash; Query for polls with the **Anonymous** option enabled. \n* `false` &mdash; Do not query for polls with the **Anonymous** option enabled.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `200`  \n \nList polls of a Webinar  returned
 */
export const webinarPolls200Schema = z
	.object({
		polls: z.optional(
			z
				.array(
					z.object({
						id: z.optional(z.string().describe("The poll ID.")),
						status: z.optional(
							z
								.enum(["notstart", "started", "ended", "sharing", "deactivated"])
								.describe(
									"The status of the webinar poll:\n`notstart` - Poll not started\n`started` - Poll started\n`ended` - Poll ended\n`sharing` - Sharing poll results\n`deactivated` - Poll deactivated",
								),
						),
						anonymous: z.optional(
							z
								.boolean()
								.default(false)
								.describe(
									"Whether meeting participants answer poll questions anonymously. \n\nThis value defaults to `false`.",
								),
						),
						poll_type: z.optional(
							z
								.union([z.literal(1), z.literal(2), z.literal(3)])
								.describe(
									"The type of poll: \n* `1` &mdash; Poll. \n* `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account. \n* `3` &mdash; Quiz. This feature must be enabled in your Zoom account. \n\n This value defaults to `1`.",
								),
						),
						questions: z.optional(
							z
								.array(
									z.object({
										answer_max_character: z.optional(
											z
												.int()
												.describe(
													"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: \n* For `short_answer` polls, a maximum of 500 characters. \n* For `long_answer` polls, a maximum of 2,000 characters.",
												),
										),
										answer_min_character: z.optional(
											z
												.int()
												.min(1)
												.describe(
													"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.",
												),
										),
										answer_required: z.optional(
											z
												.boolean()
												.default(false)
												.describe(
													"Whether participants must answer the question: \n* `true` &mdash; The participant must answer the question. \n* `false` &mdash; The participant does not need to answer the question. \n\n**Note:** \n* When the poll's `type` value is `1` (Poll), this value defaults to `true`. \n* When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.",
												),
										),
										answers: z.optional(
											z
												.array(z.string())
												.min(2)
												.describe(
													"The poll question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` polls, you can only provide a maximum of 10 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
												),
										),
										case_sensitive: z.optional(
											z
												.boolean()
												.default(false)
												.describe(
													"Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: \n* `true` &mdash; The answer is case-sensitive. \n* `false` &mdash; The answer is not case-sensitive. \n\nThis value defaults to `false`.",
												),
										),
										name: z.optional(
											z
												.string()
												.max(1024)
												.describe(
													"The poll question, up to 1024 characters. \n\nFor `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.",
												),
										),
										prompts: z.optional(
											z
												.array(
													z.object({
														prompt_question: z.optional(
															z.string().describe("The question prompt's title."),
														),
														prompt_right_answers: z.optional(
															z
																.array(z.string())
																.describe(
																	"The question prompt's correct answers: \n* For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. \n* For `rank_order` polls, you can only provide one correct answer.",
																),
														),
													}),
												)
												.describe(
													"The information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
												),
										),
										rating_max_label: z.optional(
											z
												.string()
												.describe(
													"The high score label for the `rating_max_value` field. \n\nThis field only applies to the `rating_scale` poll.",
												),
										),
										rating_max_value: z.optional(
											z
												.int()
												.max(10)
												.describe(
													"The rating scale's maximum value, up to a maximum value of 10. \n\nThis field only applies to the `rating_scale` poll.",
												),
										),
										rating_min_label: z.optional(
											z
												.string()
												.describe(
													"The low score label for the `rating_min_value` field. \n\nThis field only applies to the `rating_scale` poll.",
												),
										),
										rating_min_value: z.optional(
											z
												.int()
												.min(0)
												.describe(
													"The rating scale's minimum value. This value cannot be less than zero. \n\nThis field only applies to the `rating_scale` poll.",
												),
										),
										right_answers: z.optional(
											z
												.array(z.string())
												.min(1)
												.describe(
													"The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). \n\n For `single` and `matching` polls, this field only accepts one answer.",
												),
										),
										show_as_dropdown: z.optional(
											z
												.boolean()
												.default(false)
												.describe(
													"Whether to display the radio selection as a drop-down box: \n* `true` &mdash; Show as a drop-down box. \n* `false` &mdash; Do not show as a drop-down box. \n\nThis value defaults to `false`.",
												),
										),
										type: z.optional(
											z
												.enum([
													"single",
													"multiple",
													"matching",
													"rank_order",
													"short_answer",
													"long_answer",
													"fill_in_the_blank",
													"rating_scale",
												])
												.describe(
													"The poll's question and answer type: \n* `single` &mdash; Single choice. \n* `multiple` &mdash; Multiple choice. \n* `matching` &mdash; Matching. \n* `rank_order` &mdash; Rank order. \n* `short_answer` &mdash; Short answer. \n* `long_answer` &mdash; Long answer. \n* `fill_in_the_blank` &mdash; Fill in the blank. \n* `rating_scale` &mdash; Rating scale.",
												),
										),
									}),
								)
								.describe("The information about the poll's questions."),
						),
						title: z.optional(
							z.string().max(64).describe("The poll's title, up to 64 characters."),
						),
					}),
				)
				.describe("An array of polls."),
		),
		total_records: z.optional(
			z.int().describe("The number of all records available across pages."),
		),
	})
	.describe("The poll List.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `4400` <br>\n Webinar polls disabled. To enable this feature, enable the **Webinar Polls/Quizzes** setting in the Zoom web portal\'s **Settings** interface. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarPolls400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarPolls404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarPolls429Schema = z.unknown();

export const webinarPollsQueryResponseSchema = z.lazy(() => webinarPolls200Schema);

export const webinarPollCreatePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `201`  \n \nWebinar Poll Created
 */
export const webinarPollCreate201Schema = z.object({
	id: z.optional(z.string().describe("The webinar poll ID.")),
	status: z.optional(
		z
			.enum(["notstart", "started", "ended", "sharing"])
			.describe(
				"The status of the webinar poll:  \n `notstart` - Poll not started  \n `started` - Poll started  \n `ended` - Poll ended  \n `sharing` - Sharing poll results",
			),
	),
	anonymous: z.optional(
		z
			.boolean()
			.default(false)
			.describe(
				"Whether meeting participants answer poll questions anonymously. \n\nThis value defaults to `false`.",
			),
	),
	poll_type: z.optional(
		z
			.union([z.literal(1), z.literal(2), z.literal(3)])
			.describe(
				"The type of poll. \n* `1` - Poll. \n* `2` - Advanced Poll. This feature must be enabled in your Zoom account. \n* `3` - Quiz. This feature must be enabled in your Zoom account. \n\n This value defaults to `1`.",
			),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					answer_max_character: z.optional(
						z
							.int()
							.describe(
								"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: \n* For `short_answer` polls, a maximum of 500 characters. \n* For `long_answer` polls, a maximum of 2,000 characters.",
							),
					),
					answer_min_character: z.optional(
						z
							.int()
							.min(1)
							.describe(
								"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.",
							),
					),
					answer_required: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether participants must answer the question. \n* `true` - The participant must answer the question. \n* `false` - The participant does not need to answer the question. \n\n**Note:** \n* When the poll's `type` value is `1` (Poll), this value defaults to `true`. \n* When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.",
							),
					),
					answers: z.optional(
						z
							.array(z.string())
							.min(2)
							.describe(
								"The poll question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` polls, you can only provide a maximum of 10 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
							),
					),
					case_sensitive: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls. \n* `true` - The answer is case-sensitive. \n* `false` - The answer is not case-sensitive. \n\nThis value defaults to `false`.",
							),
					),
					name: z.optional(
						z
							.string()
							.max(1024)
							.describe(
								"The poll question, up to 1024 characters. \n\nFor `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.",
							),
					),
					prompts: z.optional(
						z
							.array(
								z.object({
									prompt_question: z.optional(z.string().describe("The question prompt's title.")),
									prompt_right_answers: z.optional(
										z
											.array(z.string())
											.describe(
												"The question prompt's correct answers: \n* For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. \n* For `rank_order` polls, you can only provide one correct answer.",
											),
									),
								}),
							)
							.describe(
								"The information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
							),
					),
					rating_max_label: z.optional(
						z
							.string()
							.describe(
								"The high score label for the `rating_max_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_max_value: z.optional(
						z
							.int()
							.max(10)
							.describe(
								"The rating scale's maximum value, up to a maximum value of 10. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_label: z.optional(
						z
							.string()
							.describe(
								"The low score label for the `rating_min_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_value: z.optional(
						z
							.int()
							.min(0)
							.describe(
								"The rating scale's minimum value. This value cannot be less than zero. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					right_answers: z.optional(
						z
							.array(z.string())
							.min(1)
							.describe(
								"The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). \n\n For `single` and `matching` polls, this field only accepts one answer.",
							),
					),
					show_as_dropdown: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the radio selection as a drop-down box. \n* `true` - Show as a drop-down box. \n* `false` - Do not show as a drop-down box. \n\nThis value defaults to `false`.",
							),
					),
					type: z.optional(
						z
							.enum([
								"single",
								"multiple",
								"matching",
								"rank_order",
								"short_answer",
								"long_answer",
								"fill_in_the_blank",
								"rating_scale",
							])
							.describe(
								"The poll's question and answer type. \n* `single` - Single choice. \n* `multiple` - Multiple choice. \n* `matching` - Matching. \n* `rank_order` - Rank order. \n* `short_answer` - Short answer. \n* `long_answer` - Long answer. \n* `fill_in_the_blank` - Fill in the blank. \n* `rating_scale` - Rating scale.",
							),
					),
				}),
			)
			.describe("The information about the poll's questions."),
	),
	title: z.optional(z.string().max(64).describe("The poll's title, up to 64 characters.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `4400` <br>\n Webinar polls disabled. To enable this feature, enable the **Webinar Polls/Quizzes** setting in the Zoom web portal\'s **Settings** interface. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarPollCreate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarPollCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarPollCreate429Schema = z.unknown();

/**
 * @description The Webinar poll object.
 */
export const webinarPollCreateMutationRequestSchema = z.object({
	anonymous: z.optional(
		z
			.boolean()
			.default(false)
			.describe(
				"Whether meeting participants answer poll questions anonymously. \n\nThis value defaults to `false`.",
			),
	),
	poll_type: z.optional(
		z
			.union([z.literal(1), z.literal(2), z.literal(3)])
			.describe(
				"The type of poll. \n* `1` - Poll. \n* `2` - Advanced Poll. This feature must be enabled in your Zoom account. \n* `3` - Quiz. This feature must be enabled in your Zoom account. \n\n This value defaults to `1`.",
			),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					answer_max_character: z.optional(
						z
							.int()
							.describe(
								"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: \n* For `short_answer` polls, a maximum of 500 characters. \n* For `long_answer` polls, a maximum of 2,000 characters.",
							),
					),
					answer_min_character: z.optional(
						z
							.int()
							.min(1)
							.describe(
								"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.",
							),
					),
					answer_required: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether participants must answer the question. \n* `true` - The participant must answer the question. \n* `false` - The participant does not need to answer the question. \n\n**Note:** \n* When the poll's `type` value is `1` (Poll), this value defaults to `true`. \n* When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.",
							),
					),
					answers: z.optional(
						z
							.array(z.string())
							.min(2)
							.describe(
								"The poll question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` polls, you can only provide a maximum of 10 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
							),
					),
					case_sensitive: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls. \n* `true` - The answer is case-sensitive. \n* `false` - The answer is not case-sensitive. \n\nThis value defaults to `false`.",
							),
					),
					name: z.optional(
						z
							.string()
							.max(1024)
							.describe(
								"The poll question, up to 1024 characters. \n\nFor `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.",
							),
					),
					prompts: z.optional(
						z
							.array(
								z.object({
									prompt_question: z.optional(z.string().describe("The question prompt's title.")),
									prompt_right_answers: z.optional(
										z
											.array(z.string())
											.describe(
												"The question prompt's correct answers: \n* For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. \n* For `rank_order` polls, you can only provide one correct answer.",
											),
									),
								}),
							)
							.describe(
								"The information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
							),
					),
					rating_max_label: z.optional(
						z
							.string()
							.describe(
								"The high score label for the `rating_max_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_max_value: z.optional(
						z
							.int()
							.max(10)
							.describe(
								"The rating scale's maximum value, up to a maximum value of 10. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_label: z.optional(
						z
							.string()
							.describe(
								"The low score label for the `rating_min_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_value: z.optional(
						z
							.int()
							.min(0)
							.describe(
								"The rating scale's minimum value. This value cannot be less than zero. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					right_answers: z.optional(
						z
							.array(z.string())
							.min(1)
							.describe(
								"The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). \n\n For `single` and `matching` polls, this field only accepts one answer.",
							),
					),
					show_as_dropdown: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the radio selection as a drop-down box. \n* `true` - Show as a drop-down box. \n* `false` - Do not show as a drop-down box. \n\nThis value defaults to `false`.",
							),
					),
					type: z.optional(
						z
							.enum([
								"single",
								"multiple",
								"matching",
								"rank_order",
								"short_answer",
								"long_answer",
								"fill_in_the_blank",
								"rating_scale",
							])
							.describe(
								"The poll's question and answer type. \n* `single` - Single choice. \n* `multiple` - Multiple choice. \n* `matching` - Matching. \n* `rank_order` - Rank order. \n* `short_answer` - Short answer. \n* `long_answer` - Long answer. \n* `fill_in_the_blank` - Fill in the blank. \n* `rating_scale` - Rating scale.",
							),
					),
				}),
			)
			.describe("The information about the poll's questions."),
	),
	title: z.optional(z.string().max(64).describe("The poll's title, up to 64 characters.")),
});

export const webinarPollCreateMutationResponseSchema = z.lazy(() => webinarPollCreate201Schema);

export const webinarPollGetPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
	pollId: z.string().describe("The poll ID."),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nWebinar Poll object returned
 */
export const webinarPollGet200Schema = z.object({
	id: z.optional(z.string().describe("The webinar poll ID.")),
	status: z.optional(
		z
			.enum(["notstart", "started", "ended", "sharing", "deactivated"])
			.describe(
				"The status of the webinar poll:\n`notstart` - Poll not started\n`started` - Poll started\n`ended` - Poll ended\n`sharing` - Sharing poll results\n`deactivated` - Poll deactivated",
			),
	),
	anonymous: z.optional(
		z
			.boolean()
			.default(false)
			.describe(
				"Whether meeting participants answer poll questions anonymously. \n\nThis value defaults to `false`.",
			),
	),
	poll_type: z.optional(
		z
			.union([z.literal(1), z.literal(2), z.literal(3)])
			.describe(
				"The type of poll: \n* `1` &mdash; Poll. \n* `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account. \n* `3` &mdash; Quiz. This feature must be enabled in your Zoom account. \n\n This value defaults to `1`.",
			),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					answer_max_character: z.optional(
						z
							.int()
							.describe(
								"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: \n* For `short_answer` polls, a maximum of 500 characters. \n* For `long_answer` polls, a maximum of 2,000 characters.",
							),
					),
					answer_min_character: z.optional(
						z
							.int()
							.min(1)
							.describe(
								"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.",
							),
					),
					answer_required: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether participants must answer the question: \n* `true` &mdash; The participant must answer the question. \n* `false` &mdash; The participant does not need to answer the question. \n\n**Note:** \n* When the poll's `type` value is `1` (Poll), this value defaults to `true`. \n* When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.",
							),
					),
					answers: z.optional(
						z
							.array(z.string())
							.min(2)
							.describe(
								"The poll question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` polls, you can only provide a maximum of 10 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
							),
					),
					case_sensitive: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: \n* `true` &mdash; The answer is case-sensitive. \n* `false` &mdash; The answer is not case-sensitive. \n\nThis value defaults to `false`.",
							),
					),
					name: z.optional(
						z
							.string()
							.max(1024)
							.describe(
								"The poll question, up to 1024 characters. \n\nFor `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.",
							),
					),
					prompts: z.optional(
						z
							.array(
								z.object({
									prompt_question: z.optional(z.string().describe("The question prompt's title.")),
									prompt_right_answers: z.optional(
										z
											.array(z.string())
											.describe(
												"The question prompt's correct answers: \n* For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. \n* For `rank_order` polls, you can only provide one correct answer.",
											),
									),
								}),
							)
							.describe(
								"The information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
							),
					),
					rating_max_label: z.optional(
						z
							.string()
							.describe(
								"The high score label for the `rating_max_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_max_value: z.optional(
						z
							.int()
							.max(10)
							.describe(
								"The rating scale's maximum value, up to a maximum value of 10. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_label: z.optional(
						z
							.string()
							.describe(
								"The low score label for the `rating_min_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_value: z.optional(
						z
							.int()
							.min(0)
							.describe(
								"The rating scale's minimum value. This value cannot be less than zero. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					right_answers: z.optional(
						z
							.array(z.string())
							.min(1)
							.describe(
								"The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). \n\n For `single` and `matching` polls, this field only accepts one answer.",
							),
					),
					show_as_dropdown: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the radio selection as a drop-down box: \n* `true` &mdash; Show as a drop-down box. \n* `false` &mdash; Do not show as a drop-down box. \n\nThis value defaults to `false`.",
							),
					),
					type: z.optional(
						z
							.enum([
								"single",
								"multiple",
								"matching",
								"rank_order",
								"short_answer",
								"long_answer",
								"fill_in_the_blank",
								"rating_scale",
							])
							.describe(
								"The poll's question and answer type: \n* `single` &mdash; Single choice. \n* `multiple` &mdash; Multiple choice. \n* `matching` &mdash; Matching. \n* `rank_order` &mdash; Rank order. \n* `short_answer` &mdash; Short answer. \n* `long_answer` &mdash; Long answer. \n* `fill_in_the_blank` &mdash; Fill in the blank. \n* `rating_scale` &mdash; Rating scale.",
							),
					),
				}),
			)
			.describe("The information about the poll's questions."),
	),
	title: z.optional(z.string().max(64).describe("The poll's title, up to 64 characters.")),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `4400` <br>\n Webinar polls disabled. To enable this feature, enable the **Webinar Polls/Quizzes** setting in the Zoom web portal\'s **Settings** interface. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarPollGet400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarPollGet404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarPollGet429Schema = z.unknown();

export const webinarPollGetQueryResponseSchema = z.lazy(() => webinarPollGet200Schema);

export const webinarPollUpdatePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
	pollId: z.string().describe("The poll ID."),
});

/**
 * @description **HTTP Status Code:** `204`  \n \nWebinar Poll Updated
 */
export const webinarPollUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `4400` <br>\n Webinar polls disabled. To enable this feature, enable the **Webinar Polls/Quizzes** setting in the Zoom web portal\'s **Settings** interface.  <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarPollUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarPollUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarPollUpdate429Schema = z.unknown();

/**
 * @description The webinar poll.
 */
export const webinarPollUpdateMutationRequestSchema = z.object({
	anonymous: z.optional(
		z
			.boolean()
			.default(false)
			.describe(
				"Whether meeting participants answer poll questions anonymously. \n\nThis value defaults to `false`.",
			),
	),
	poll_type: z.optional(
		z
			.union([z.literal(1), z.literal(2), z.literal(3)])
			.describe(
				"The type of poll: \n* `1` &mdash; Poll. \n* `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account. \n* `3` &mdash; Quiz. This feature must be enabled in your Zoom account. \n\n This value defaults to `1`.",
			),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					answer_max_character: z.optional(
						z
							.int()
							.describe(
								"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: \n* For `short_answer` polls, a maximum of 500 characters. \n* For `long_answer` polls, a maximum of 2,000 characters.",
							),
					),
					answer_min_character: z.optional(
						z
							.int()
							.min(1)
							.describe(
								"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.",
							),
					),
					answer_required: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether participants must answer the question: \n* `true` &mdash; The participant must answer the question. \n* `false` &mdash; The participant does not need to answer the question. \n\n**Note:** \n* When the poll's `type` value is `1` (Poll), this value defaults to `true`. \n* When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.",
							),
					),
					answers: z.optional(
						z
							.array(z.string())
							.min(2)
							.describe(
								"The poll question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` polls, you can only provide a maximum of 10 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
							),
					),
					case_sensitive: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: \n* `true` &mdash; The answer is case-sensitive. \n* `false` &mdash; The answer is not case-sensitive. \n\nThis value defaults to `false`.",
							),
					),
					name: z.optional(
						z
							.string()
							.max(1024)
							.describe(
								"The poll question, up to 1024 characters. \n\nFor `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.",
							),
					),
					prompts: z.optional(
						z
							.array(
								z.object({
									prompt_question: z.optional(z.string().describe("The question prompt's title.")),
									prompt_right_answers: z.optional(
										z
											.array(z.string())
											.describe(
												"The question prompt's correct answers: \n* For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. \n* For `rank_order` polls, you can only provide one correct answer.",
											),
									),
								}),
							)
							.describe(
								"The information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
							),
					),
					rating_max_label: z.optional(
						z
							.string()
							.describe(
								"The high score label for the `rating_max_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_max_value: z.optional(
						z
							.int()
							.max(10)
							.describe(
								"The rating scale's maximum value, up to a maximum value of 10. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_label: z.optional(
						z
							.string()
							.describe(
								"The low score label for the `rating_min_value` field. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					rating_min_value: z.optional(
						z
							.int()
							.min(0)
							.describe(
								"The rating scale's minimum value. This value cannot be less than zero. \n\nThis field only applies to the `rating_scale` poll.",
							),
					),
					right_answers: z.optional(
						z
							.array(z.string())
							.min(1)
							.describe(
								"The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). \n\n For `single` and `matching` polls, this field only accepts one answer.",
							),
					),
					show_as_dropdown: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the radio selection as a drop-down box: \n* `true` &mdash; Show as a drop-down box. \n* `false` &mdash; Do not show as a drop-down box. \n\nThis value defaults to `false`.",
							),
					),
					type: z.optional(
						z
							.enum([
								"single",
								"multiple",
								"matching",
								"rank_order",
								"short_answer",
								"long_answer",
								"fill_in_the_blank",
								"rating_scale",
							])
							.describe(
								"The poll's question and answer type: \n* `single` &mdash; Single choice. \n* `multiple` &mdash; Multiple choice. \n* `matching` &mdash; Matching. \n* `rank_order` &mdash; Rank order. \n* `short_answer` &mdash; Short answer. \n* `long_answer` &mdash; Long answer. \n* `fill_in_the_blank` &mdash; Fill in the blank. \n* `rating_scale` &mdash; Rating scale.",
							),
					),
				}),
			)
			.describe("The information about the poll's questions."),
	),
	title: z.optional(z.string().max(64).describe("The poll's title, up to 64 characters.")),
});

export const webinarPollUpdateMutationResponseSchema = z.lazy(() => webinarPollUpdate204Schema);

export const webinarPollDeletePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
	pollId: z.string().describe("The poll ID"),
});

/**
 * @description **HTTP Status Code:** `204`  \n \nWebinar Poll deleted
 */
export const webinarPollDelete204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `4400` <br>\n Webinar polls disabled. To enable this feature, enable the **Webinar Polls/Quizzes** setting in the Zoom web portal\'s **Settings** interface. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `4400` <br>\n Invalid poll IDs. <br>\n**Error Code:** `4400` <br>\n Cannot update or delete the poll within the Survey Library. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n
 */
export const webinarPollDelete400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarPollDelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarPollDelete429Schema = z.unknown();

export const webinarPollDeleteMutationResponseSchema = z.lazy(() => webinarPollDelete204Schema);

export const webinarRegistrantsPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

export const webinarRegistrantsQueryParamsSchema = z.object({
	occurrence_id: z.optional(z.string().describe("The meeting or webinar occurrence ID.")),
	status: z
		.enum(["pending", "approved", "denied"])
		.default("approved")
		.describe(
			"Query by the registrant's status. \n* `pending` - The registration is pending. \n* `approved` - The registrant is approved. \n* `denied` - The registration is denied.",
		),
	tracking_source_id: z.optional(
		z
			.string()
			.describe(
				"The tracking source ID for the registrants. Useful if you share the webinar registration page in multiple locations. See [Creating source tracking links for webinar registration](https://support.zoom.us/hc/en-us/articles/360000315683-Creating-source-tracking-links-for-webinar-registration) for details.",
			),
	),
	page_size: z.coerce
		.number()
		.int()
		.max(300)
		.default(30)
		.describe("The number of records returned within a single API call."),
	page_number: z.coerce
		.number()
		.int()
		.default(1)
		.describe(
			"**Deprecated** This field will be deprecated. We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.",
		),
	next_page_token: z.optional(
		z
			.string()
			.describe(
				"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `200`  \n \nWebinar plan subscription is missing. Enable webinar for this user once the subscription is added:{userId}.
 */
export const webinarRegistrants200Schema = z
	.object({
		next_page_token: z.optional(
			z
				.string()
				.describe(
					"Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.",
				),
		),
		page_count: z.optional(z.int().describe("The number of pages returned for the request made.")),
		page_number: z.optional(
			z
				.int()
				.default(1)
				.describe(
					"**Deprecated** This field will be deprecated. We will no longer support this field in a future release. Instead, use `next_page_token` for pagination.",
				),
		),
		page_size: z.optional(
			z
				.int()
				.max(300)
				.default(30)
				.describe("The number of records returned with a single API call."),
		),
		total_records: z.optional(
			z.int().describe("The total number of all the records available across pages."),
		),
		registrants: z.optional(
			z
				.array(
					z
						.object({
							address: z.optional(z.string().describe("The registrant's address.")),
							city: z.optional(z.string().describe("The registrant's city.")),
							comments: z.optional(z.string().describe("The registrant's questions and comments.")),
							country: z.optional(
								z
									.string()
									.describe(
										"The registrant's two-letter ISO [country code](https://developers.zoom.us/docs/api/rest/other-references/abbreviation-lists/#countries).",
									),
							),
							custom_questions: z.optional(
								z
									.array(
										z
											.object({
												title: z.optional(z.string().describe("The title of the custom question.")),
												value: z.optional(
													z
														.string()
														.max(128)
														.describe(
															"The custom question's response value. This has a limit of 128 characters.",
														),
												),
											})
											.describe("Information about custom questions."),
									)
									.describe("Information about custom questions."),
							),
							email: z
								.email()
								.max(128)
								.describe(
									"The registrant's email address. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for return value details.",
								),
							first_name: z.string().max(64).describe("The registrant's first name."),
							industry: z.optional(z.string().describe("The registrant's industry.")),
							job_title: z.optional(z.string().describe("The registrant's job title.")),
							last_name: z.optional(z.string().max(64).describe("The registrant's last name.")),
							no_of_employees: z.optional(
								z
									.enum([
										"",
										"1-20",
										"21-50",
										"51-100",
										"101-250",
										"251-500",
										"501-1,000",
										"1,001-5,000",
										"5,001-10,000",
										"More than 10,000",
									])
									.describe(
										"The registrant's number of employees. \n* `1-20` \n* `21-50` \n* `51-100` \n* `101-250` \n* `251-500` \n* `501-1,000` \n* `1,001-5,000` \n* `5,001-10,000` \n* `More than 10,000`",
									),
							),
							org: z.optional(z.string().describe("The registrant's organization.")),
							phone: z.optional(z.string().describe("The registrant's phone number.")),
							purchasing_time_frame: z.optional(
								z
									.enum([
										"",
										"Within a month",
										"1-3 months",
										"4-6 months",
										"More than 6 months",
										"No timeframe",
									])
									.describe(
										"The registrant's purchasing time frame. \n* `Within a month.` \n* `1-3 months.` \n* `4-6 months.` \n* `More than 6 months.` \n* `No timeframe.`",
									),
							),
							role_in_purchase_process: z.optional(
								z
									.enum([
										"",
										"Decision Maker",
										"Evaluator/Recommender",
										"Influencer",
										"Not involved",
									])
									.describe(
										"The registrant's role in the purchase process. \n* `Decision maker` \n* `Evaluator/Recommender.` \n* `Influencer.` \n* `Not involved.`",
									),
							),
							state: z.optional(z.string().describe("The registrant's state or province.")),
							status: z.optional(
								z
									.enum(["approved", "denied", "pending"])
									.describe(
										"The registrant's status. \n* `approved` - Registrant is approved. \n* `denied` - Registrant is denied. \n* `pending` - Registrant is waiting for approval.",
									),
							),
							zip: z.optional(z.string().describe("The registrant's ZIP or postal code.")),
						})
						.and(
							z.object({
								id: z.optional(z.string().describe("Registrant ID.")),
								create_time: z.optional(
									z.string().datetime().describe("The time when the registrant registered."),
								),
								join_url: z.optional(
									z
										.string()
										.describe(
											"The URL that an approved registrant can use to join the meeting or webinar.",
										),
								),
								status: z.optional(
									z
										.string()
										.describe(
											"The status of the registrant's registration.   \n  `approved` - User has been successfully approved for the webinar.  \n  `pending` -  The registration is still pending.  \n  `denied` - User has been denied from joining the webinar.",
										),
								),
							}),
						),
				)
				.describe("List of registrant objects."),
		),
	})
	.describe("List of users.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarRegistrants400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarRegistrants404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarRegistrants429Schema = z.unknown();

export const webinarRegistrantsQueryResponseSchema = z.lazy(() => webinarRegistrants200Schema);

export const webinarRegistrantCreatePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

export const webinarRegistrantCreateQueryParamsSchema = z
	.object({
		occurrence_ids: z.optional(
			z
				.string()
				.describe(
					"A comma-separated list of webinar occurrence IDs. Get this value with the [Get a webinar](/docs/api/rest/reference/zoom-api/methods/#operation/webinar) API. Make sure the `registration_type` is 3 if updating multiple occurrences with this API.",
				),
		),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `201`   \n \nWebinar registration created.
 */
export const webinarRegistrantCreate201Schema = z.object({
	id: z.optional(z.int().describe("The webinar's ID.")),
	join_url: z.optional(z.string().describe("The URL the registrant can use to join the webinar.")),
	registrant_id: z.optional(z.string().describe("The registrant's ID.")),
	start_time: z.optional(z.string().datetime().describe("The webinar's start time.")),
	topic: z.optional(z.string().max(200).describe("The webinar's topic.")),
	occurrences: z.optional(
		z
			.array(
				z
					.object({
						duration: z.optional(z.int().describe("Duration.")),
						occurrence_id: z.optional(
							z
								.string()
								.describe(
									"Occurrence ID: Unique identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.",
								),
						),
						start_time: z.optional(z.string().datetime().describe("Start time.")),
						status: z.optional(z.string().describe("Occurrence status.")),
					})
					.describe("Occurrence object. This object is only returned for recurring webinars."),
			)
			.describe("Array of occurrence objects."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3000` <br>\n This webinar does not have registration as required: {webinarId}. <br>\n**Error Code:** `3027` <br>\n Host cannot register. <br>\n**Error Code:** `3034` <br>\n If you have been invited, please input your work email address. <br>\n**Error Code:** `3038` <br>\n Webinar is over, you cannot register now. If you have any questions, contact the webinar host. <br>\n**Error Code:** `3000` <br>\n You have reached the limit for the number of attendees you can add. Contact Zoom Support for more information. <br>\n**Error Code:** `3000` <br>\n The Zoom REST API does not support paid registration. <br>\n**Error Code:** `3000` <br>\n You have been invited as a panelist for the webinar, please check your email to find more information about this webinar. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n
 */
export const webinarRegistrantCreate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarRegistrantCreate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarRegistrantCreate429Schema = z.unknown();

export const webinarRegistrantCreateMutationRequestSchema = z
	.object({
		first_name: z.string().max(64).describe("The registrant's first name."),
		last_name: z.optional(z.string().max(64).describe("The registrant's last name.")),
		email: z.email().max(128).describe("The registrant's email address."),
		address: z.optional(z.string().describe("The registrant's address.")),
		city: z.optional(z.string().describe("The registrant's city.")),
		state: z.optional(z.string().describe("The registrant's state or province.")),
		zip: z.optional(z.string().describe("The registrant's ZIP or postal code.")),
		country: z.optional(
			z
				.string()
				.describe(
					"The registrant's two-letter [country code](https://developers.zoom.us/docs/api/rest/other-references/abbreviation-lists/#countries).",
				),
		),
		phone: z.optional(z.string().describe("The registrant's phone number.")),
		comments: z.optional(z.string().describe("The registrant's questions and comments.")),
		custom_questions: z.optional(
			z
				.array(
					z
						.object({
							title: z.optional(z.string().describe("The custom question's title.")),
							value: z.optional(
								z
									.string()
									.max(128)
									.describe(
										"The custom question's response value. This has a limit of 128 characters.",
									),
							),
						})
						.describe("Information about custom questions."),
				)
				.describe("Information about custom questions."),
		),
		industry: z.optional(z.string().describe("The registrant's industry.")),
		job_title: z.optional(z.string().describe("The registrant's job title.")),
		no_of_employees: z.optional(
			z
				.enum([
					"",
					"1-20",
					"21-50",
					"51-100",
					"101-500",
					"500-1,000",
					"1,001-5,000",
					"5,001-10,000",
					"More than 10,000",
				])
				.describe(
					"The registrant's number of employees: \n* `1-20` \n* `21-50` \n* `51-100` \n* `101-500` \n* `500-1,000` \n* `1,001-5,000` \n* `5,001-10,000` \n* `More than 10,000`",
				),
		),
		org: z.optional(z.string().describe("The registrant's organization.")),
		purchasing_time_frame: z.optional(
			z
				.enum([
					"",
					"Within a month",
					"1-3 months",
					"4-6 months",
					"More than 6 months",
					"No timeframe",
				])
				.describe(
					"The registrant's purchasing time frame: \n* `Within a month` \n* `1-3 months` \n* `4-6 months` \n* `More than 6 months` \n* `No timeframe`",
				),
		),
		role_in_purchase_process: z.optional(
			z
				.enum(["", "Decision Maker", "Evaluator/Recommender", "Influencer", "Not involved"])
				.describe(
					"The registrant's role in the purchase process: \n* `Decision Maker` \n* `Evaluator/Recommender` \n* `Influencer` \n* `Not involved`",
				),
		),
		language: z.optional(
			z
				.enum([
					"en-US",
					"de-DE",
					"es-ES",
					"fr-FR",
					"jp-JP",
					"pt-PT",
					"ru-RU",
					"zh-CN",
					"zh-TW",
					"ko-KO",
					"it-IT",
					"vi-VN",
					"pl-PL",
					"Tr-TR",
				])
				.describe(
					"Specifies the registrant's preferred language for the confirmation email sent upon successful registration.\n\n**Note** This field is only effective if the webinar's 'Select Email Language' setting is set to 'Same as recipients' default language' in the Zoom web portal. If a fixed language is selected, this value will be ignored.\n\n**Supported values**\n\n* `en-US` - English (US)\n* `de-DE` - German (Germany)\n* `es-ES` - Spanish (Spain)\n* `fr-FR` - French (France)\n* `jp-JP` - Japanese\n* `pt-PT` - Portuguese (Portugal)\n* `ru-RU` - Russian\n* `zh-CN` - Chinese (PRC)\n* `zh-TW` - Chinese (Taiwan)\n* `ko-KO` - Korean\n* `it-IT` - Italian (Italy)\n* `vi-VN` - Vietnamese\n* `pl-PL` - Polish\n* `Tr-TR` - Turkish",
				),
		),
		source_id: z.optional(z.string().describe("The tracking source's unique identifier.")),
	})
	.describe("Information about the webinar registrant.");

export const webinarRegistrantCreateMutationResponseSchema = z.lazy(
	() => webinarRegistrantCreate201Schema,
);

export const webinarRegistrantsQuestionsGetPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `200`   Webinar registrant question object returned.
 */
export const webinarRegistrantsQuestionsGet200Schema = z.object({
	custom_questions: z.optional(
		z
			.array(
				z.object({
					answers: z.optional(
						z
							.array(z.string())
							.describe("An array of answer choices. Can't be used for short answer type."),
					),
					required: z.optional(
						z
							.boolean()
							.describe(
								"State whether or not the custom question is required to be answered by a registrant.",
							),
					),
					title: z.optional(z.string().describe("Custom question.")),
					type: z.optional(
						z
							.enum(["short", "single_radio", "single_dropdown", "multiple"])
							.describe("The question-answer type."),
					),
				}),
			)
			.describe("Array of Registrant Custom Questions."),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					field_name: z.optional(
						z
							.enum([
								"last_name",
								"address",
								"city",
								"country",
								"zip",
								"state",
								"phone",
								"industry",
								"org",
								"job_title",
								"purchasing_time_frame",
								"role_in_purchase_process",
								"no_of_employees",
								"comments",
							])
							.describe("Field name"),
					),
					required: z.optional(
						z.boolean().describe("State whether the selected fields are required or optional."),
					),
				}),
			)
			.describe(
				"Array of registration fields whose values should be provided by registrants during registration.",
			),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `3000` <br>\n Registration has not been enabled for this webinar: {webinarId}. <br>\n
 */
export const webinarRegistrantsQuestionsGet400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarRegistrantsQuestionsGet404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests  For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarRegistrantsQuestionsGet429Schema = z.unknown();

export const webinarRegistrantsQuestionsGetQueryResponseSchema = z.lazy(
	() => webinarRegistrantsQuestionsGet200Schema,
);

export const webinarRegistrantQuestionUpdatePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `204`   Webinar registrant questions updated.
 */
export const webinarRegistrantQuestionUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `3000` <br>\n Registration has not been enabled for this webinar: {webinarId}. <br>\n
 */
export const webinarRegistrantQuestionUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarRegistrantQuestionUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarRegistrantQuestionUpdate429Schema = z.unknown();

/**
 * @description Webinar registrant questions
 */
export const webinarRegistrantQuestionUpdateMutationRequestSchema = z.object({
	custom_questions: z.optional(
		z
			.array(
				z.object({
					answers: z.optional(
						z
							.array(z.string())
							.describe("An array of answer choices. Can't be used for short answer type."),
					),
					required: z.optional(
						z
							.boolean()
							.describe(
								"State whether or not a registrant is required to answer the custom question.",
							),
					),
					title: z.optional(z.string().describe("Custom question.")),
					type: z.optional(
						z
							.enum(["short", "single_radio", "single_dropdown", "multiple"])
							.describe("The question-answer type."),
					),
				}),
			)
			.describe("Array of custom questions for registrants."),
	),
	questions: z.optional(
		z
			.array(
				z.object({
					field_name: z.optional(
						z
							.enum([
								"last_name",
								"address",
								"city",
								"country",
								"zip",
								"state",
								"phone",
								"industry",
								"org",
								"job_title",
								"purchasing_time_frame",
								"role_in_purchase_process",
								"no_of_employees",
								"comments",
							])
							.describe("Field name"),
					),
					required: z.optional(
						z.boolean().describe("State whether the selected fields are required or optional."),
					),
				}),
			)
			.describe("Array of registration fields whose values should be provided by registrants."),
	),
});

export const webinarRegistrantQuestionUpdateMutationResponseSchema = z.lazy(
	() => webinarRegistrantQuestionUpdate204Schema,
);

export const webinarRegistrantStatusPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

export const webinarRegistrantStatusQueryParamsSchema = z
	.object({
		occurrence_id: z.optional(z.string().describe("The meeting or webinar occurrence ID.")),
	})
	.optional();

/**
 * @description **HTTP Status Code:** `204` <br>\n Registrant status updated.
 */
export const webinarRegistrantStatus204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3035` <br>\n Webinar has reached maximum attendee capacity. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `300` <br>\n Registration has not been enabled for this meeting: {webinarId}. <br>\n
 */
export const webinarRegistrantStatus400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarRegistrantStatus404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarRegistrantStatus429Schema = z.unknown();

export const webinarRegistrantStatusMutationRequestSchema = z.object({
	action: z
		.enum(["approve", "deny", "cancel"])
		.describe(
			"The registration action to perform. \n* `approve` - Approve the registrant. \n* `deny` - Reject the registrant. \n* `cancel` - Cancel the registrant's approval.",
		),
	registrants: z.optional(
		z
			.array(
				z.object({
					email: z.optional(z.email().describe("The registrant's email address.")),
					id: z.optional(z.string().describe("The registrant's ID.")),
				}),
			)
			.max(30)
			.describe("The registrant information."),
	),
});

export const webinarRegistrantStatusMutationResponseSchema = z.lazy(
	() => webinarRegistrantStatus204Schema,
);

export const webinarRegistrantGetPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
	registrantId: z.string().describe("The registrant ID."),
});

export const webinarRegistrantGetQueryParamsSchema = z
	.object({
		occurrence_id: z.optional(z.string().describe("The meeting or webinar occurrence ID.")),
	})
	.optional();

/**
 * @description Success.
 */
export const webinarRegistrantGet200Schema = z
	.object({
		address: z.optional(z.string().describe("The registrant's address.")),
		city: z.optional(z.string().describe("The registrant's city.")),
		comments: z.optional(z.string().describe("The registrant's questions and comments.")),
		country: z.optional(
			z
				.string()
				.describe(
					"The registrant's two-letter ISO [country code](https://developers.zoom.us/docs/api/rest/other-references/abbreviation-lists/#countries).",
				),
		),
		custom_questions: z.optional(
			z
				.array(
					z
						.object({
							title: z.optional(z.string().describe("The title of the custom question.")),
							value: z.optional(
								z
									.string()
									.max(128)
									.describe(
										"The custom question's response value. This has a limit of 128 characters.",
									),
							),
						})
						.describe("Information about custom questions."),
				)
				.describe("Information about custom questions."),
		),
		email: z
			.email()
			.max(128)
			.describe(
				"The registrant's email address. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for return value details.",
			),
		first_name: z.string().max(64).describe("The registrant's first name."),
		industry: z.optional(z.string().describe("The registrant's industry.")),
		job_title: z.optional(z.string().describe("The registrant's job title.")),
		last_name: z.optional(z.string().max(64).describe("The registrant's last name.")),
		no_of_employees: z.optional(
			z
				.enum([
					"",
					"1-20",
					"21-50",
					"51-100",
					"101-250",
					"251-500",
					"501-1,000",
					"1,001-5,000",
					"5,001-10,000",
					"More than 10,000",
				])
				.describe(
					"The registrant's number of employees: \n* `1-20` \n* `21-50` \n* `51-100` \n* `101-250` \n* `251-500` \n* `501-1,000` \n* `1,001-5,000` \n* `5,001-10,000` \n* `More than 10,000`",
				),
		),
		org: z.optional(z.string().describe("The registrant's organization.")),
		phone: z.optional(z.string().describe("The registrant's phone number.")),
		purchasing_time_frame: z.optional(
			z
				.enum([
					"",
					"Within a month",
					"1-3 months",
					"4-6 months",
					"More than 6 months",
					"No timeframe",
				])
				.describe(
					"The registrant's purchasing time frame: \n* `Within a month` \n* `1-3 months` \n* `4-6 months` \n* `More than 6 months` \n* `No timeframe`",
				),
		),
		role_in_purchase_process: z.optional(
			z
				.enum(["", "Decision Maker", "Evaluator/Recommender", "Influencer", "Not involved"])
				.describe(
					"The registrant's role in the purchase process: \n* `Decision Maker` \n* `Evaluator/Recommender` \n* `Influencer` \n* `Not involved`",
				),
		),
		state: z.optional(z.string().describe("The registrant's state or province.")),
		status: z.optional(
			z
				.enum(["approved", "denied", "pending"])
				.describe(
					"The registrant's status: \n* `approved` &mdash; Registrant is approved. \n* `denied` &mdash; Registrant is denied. \n* `pending` &mdash; Registrant is waiting for approval.",
				),
		),
		zip: z.optional(z.string().describe("The registrant's ZIP or postal code.")),
		language: z.optional(
			z
				.enum([
					"en-US",
					"de-DE",
					"es-ES",
					"fr-FR",
					"jp-JP",
					"pt-PT",
					"ru-RU",
					"zh-CN",
					"zh-TW",
					"ko-KO",
					"it-IT",
					"vi-VN",
					"pl-PL",
					"Tr-TR",
				])
				.describe(
					"The registrant's language preference for confirmation emails: \n* `en-US` &mdash; English (US) \n* `de-DE` &mdash; German (Germany) \n* `es-ES` &mdash; Spanish (Spain) \n* `fr-FR` &mdash; French (France) \n* `jp-JP` &mdash; Japanese \n* `pt-PT` &mdash; Portuguese (Portugal) \n* `ru-RU` &mdash; Russian \n* `zh-CN` &mdash; Chinese (PRC) \n* `zh-TW` &mdash; Chinese (Taiwan) \n* `ko-KO` &mdash; Korean \n* `it-IT` &mdash; Italian (Italy) \n* `vi-VN` &mdash; Vietnamese \n* `pl-PL` &mdash; Polish \n* `Tr-TR` &mdash; Turkish",
				),
		),
	})
	.and(
		z.object({
			id: z.optional(z.string()),
			create_time: z.optional(z.string().datetime()),
			join_url: z.optional(z.string()),
			status: z.optional(z.string()),
		}),
	);

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `3000` <br>\n Registration has not been enabled for this webinar: {webinarId}. <br>\n**Error Code:** `3079` <br>\n This registrant does not exist: {registrantId}. <br>\n
 */
export const webinarRegistrantGet400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarRegistrantGet404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests  For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarRegistrantGet429Schema = z.unknown();

export const webinarRegistrantGetQueryResponseSchema = z.lazy(() => webinarRegistrantGet200Schema);

export const deleteWebinarRegistrantPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar ID."),
	registrantId: z.string().describe("The registrant ID."),
});

export const deleteWebinarRegistrantQueryParamsSchema = z
	.object({
		occurrence_id: z.optional(z.string().describe("The webinar occurrence ID.")),
	})
	.optional();

/**
 * @description **HTTP status code:** `204`   \n \nOK
 */
export const deleteWebinarRegistrant204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n**Error Code:** `300` <br>\n The value that you entered for the Registrant ID field is invalid. Enter a valid value and try again. <br>\n**Error Code:** `3000` <br>\n Registration has not been enabled for this webinar: {webinarId}. <br>\n**Error Code:** `3000` <br>\n Registrant {registrantId} was not found. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n
 */
export const deleteWebinarRegistrant400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const deleteWebinarRegistrant404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const deleteWebinarRegistrant429Schema = z.unknown();

export const deleteWebinarRegistrantMutationResponseSchema = z.lazy(
	() => deleteWebinarRegistrant204Schema,
);

export const getWebinarSipDialingWithPasscodePathParamsSchema = z.object({
	webinarId: z.coerce
		.number()
		.int()
		.describe(
			"The webinar's ID. \n\n When storing this value in your database, store it as a long format integer and **not** an integer. Webinar IDs can exceed 10 digits.",
		),
});

/**
 * @description **HTTP Status Code:** `201`  Webinar\'s encoded SIP URI returned.
 */
export const getWebinarSipDialingWithPasscode201Schema = z
	.object({
		sip_dialing: z.optional(z.string().describe("The webinar's encoded SIP URI.")),
		paid_crc_plan_participant: z.optional(
			z.boolean().describe("Whether the API caller has a Conference Room Connector (CRC) plan."),
		),
		participant_identifier_code: z.optional(
			z
				.string()
				.describe(
					"This value identifies the webinar participant. It is automatically embedded in the SIP URI if the API caller has a CRC plan.",
				),
		),
		expire_in: z.optional(
			z.int().describe("The number of seconds the encoded SIP URI is valid before it expires."),
		),
	})
	.describe("Information about the webinar's encoded SIP URI.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `3000` <br>\n Cannot access meeting information. <br>\n**Error Code:** `3000` <br>\n The webinar\'s SIP URI does not exist: {webinarId}. <br>\n
 */
export const getWebinarSipDialingWithPasscode400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const getWebinarSipDialingWithPasscode429Schema = z.unknown();

export const getWebinarSipDialingWithPasscodeMutationRequestSchema = z.object({
	passcode: z.optional(
		z
			.string()
			.describe(
				"If customers want a passcode to be embedded in the SIP URI dial string, they must supply the passcode. Zoom will not validate the passcode.",
			),
	),
});

export const getWebinarSipDialingWithPasscodeMutationResponseSchema = z.lazy(
	() => getWebinarSipDialingWithPasscode201Schema,
);

export const webinarStatusPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description Webinar plan subscription is missing. Enable webinar for this user once the subscription is added: {userId}.
 */
export const webinarStatus200Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `3063` <br>\n You can not end an on-premise user\'s meeting: {webinarId} using this API. <br>\n**Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarStatus400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarStatus404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarStatus429Schema = z.unknown();

export const webinarStatusMutationRequestSchema = z.object({
	action: z.optional(z.enum(["end"])),
});

export const webinarStatusMutationResponseSchema = z.lazy(() => webinarStatus200Schema);

export const webinarSurveyGetPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `200`   \n \n Webinar survey object returned.
 */
export const webinarSurveyGet200Schema = z
	.object({
		custom_survey: z.optional(
			z
				.object({
					title: z.optional(
						z.string().max(64).describe("The survey's title, up to 64 characters."),
					),
					anonymous: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Allow participants to anonymously answer survey questions. \n* `true` - Anonymous survey enabled. \n* `false` - Participants cannot answer survey questions anonymously. \n\n This value defaults to `true`.",
							),
					),
					numbered_questions: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the number in the question name. \n\n This value defaults to `true`.",
							),
					),
					show_question_type: z.optional(
						z
							.boolean()
							.default(false)
							.describe(
								"Whether to display the question type in the question name. \n\n This value defaults to `false`.",
							),
					),
					feedback: z.optional(
						z
							.string()
							.max(320)
							.describe(
								"The survey's feedback, up to 320 characters. \n\n This value defaults to `Thank you so much for taking the time to complete the survey, your feedback really makes a difference.`.",
							),
					),
					questions: z.optional(
						z
							.array(
								z.object({
									name: z.optional(
										z.string().describe("The survey question, up to 420 characters."),
									),
									type: z.optional(
										z
											.enum([
												"single",
												"multiple",
												"matching",
												"rank_order",
												"short_answer",
												"long_answer",
												"fill_in_the_blank",
												"rating_scale",
											])
											.describe(
												"The survey's question and answer type. \n* `single` - Single choice. \n* `multiple` - Multiple choice. \n* `matching` - Matching. \n* `rank_order` - Rank order \n* `short_answer` - Short answer \n* `long_answer` - Long answer. \n* `fill_in_the_blank` - Fill in the blank \n* `rating_scale` - Rating scale.",
											),
									),
									answer_required: z.optional(
										z
											.boolean()
											.default(false)
											.describe(
												"Whether participants must answer the question. \n* `true` - The participant must answer the question. \n* `false` - The participant does not need to answer the question. \n\n This value defaults to `false`.",
											),
									),
									show_as_dropdown: z.optional(
										z
											.boolean()
											.default(false)
											.describe(
												"Whether to display the radio selection as a drop-down box. \n* `true` - Show as a drop-down box. \n* `false` - Do not show as a drop-down box. \n\n This value defaults to `false`.",
											),
									),
									answers: z.optional(
										z
											.array(z.string().max(200))
											.min(2)
											.describe(
												"The survey question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` questions, you can only provide a maximum of 50 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
											),
									),
									prompts: z.optional(
										z
											.array(
												z.object({
													prompt_question: z.optional(
														z.string().max(200).describe("The question prompt's title."),
													),
												}),
											)
											.min(2)
											.max(10)
											.describe(
												"Information about the prompt questions. This field only applies to `matching` and `rank_order` questions. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
											),
									),
									answer_min_character: z.optional(
										z
											.int()
											.min(1)
											.describe(
												"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` questions. You must provide at least a **one** character minimum value.",
											),
									),
									answer_max_character: z.optional(
										z
											.int()
											.describe(
												"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` questions. \n* For `short_answer` question, a maximum of 500 characters. \n* For `long_answer` question, a maximum of 2,000 characters.",
											),
									),
									rating_min_value: z.optional(
										z
											.int()
											.min(0)
											.describe(
												"The rating scale's minimum value. This value cannot be less than zero. \n\n This field only applies to the `rating_scale` survey.",
											),
									),
									rating_max_value: z.optional(
										z
											.int()
											.max(10)
											.describe(
												"The rating scale's maximum value, up to a maximum value of 10. \n\n This field only applies to the `rating_scale` survey.",
											),
									),
									rating_min_label: z.optional(
										z
											.string()
											.max(50)
											.describe(
												"The low score label used for the `rating_min_value` field, up to 50 characters. \n\n This field only applies to the `rating_scale` survey.",
											),
									),
									rating_max_label: z.optional(
										z
											.string()
											.max(50)
											.describe(
												"The high score label used for the `rating_max_value` field, up to 50 characters. \n\n This field only applies to the `rating_scale` survey.",
											),
									),
								}),
							)
							.min(1)
							.max(100)
							.describe("Information about the webinar survey's questions."),
					),
				})
				.describe("Information about the customized webinar survey."),
		),
		show_in_the_browser: z.optional(
			z
				.boolean()
				.default(true)
				.describe(
					"Whether the **Show in the browser when the webinar ends** option is enabled. \n* `true` - Enabled. \n* `false` - Disabled. \n\n This value defaults to `true`.",
				),
		),
		show_in_the_follow_up_email: z.optional(
			z
				.boolean()
				.default(false)
				.describe(
					"Whether the **Show the link on the follow-up email** option is enabled. \n* `true` - Enabled. \n* `false` - Disabled. \n\n This value defaults to `false`.",
				),
		),
		third_party_survey: z.optional(
			z.string().max(64).describe("The link to the third party webinar survey."),
		),
	})
	.describe("Information about the webinar survey.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `3000` <br>\n Webinar survey disabled. To enable this feature, enable the **Webinar Survey** setting in the Zoom web portal\'s **Settings** interface. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarSurveyGet400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarSurveyGet404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarSurveyGet429Schema = z.unknown();

export const webinarSurveyGetQueryResponseSchema = z.lazy(() => webinarSurveyGet200Schema);

export const webinarSurveyDeletePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `204`   \n \n Webinar survey deleted.
 */
export const webinarSurveyDelete204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `3000` <br>\n Webinar survey disabled. To enable this feature, enable the **Webinar Survey** setting in the Zoom web portal\'s **Settings** interface. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarSurveyDelete400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarSurveyDelete404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarSurveyDelete429Schema = z.unknown();

export const webinarSurveyDeleteMutationResponseSchema = z.lazy(() => webinarSurveyDelete204Schema);

export const webinarSurveyUpdatePathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `204`   \n \n Webinar survey updated.
 */
export const webinarSurveyUpdate204Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `300` <br>\n Invalid third party survey: {third_party_survey}. <br>\n**Error Code:** `3000` <br>\n Webinar survey disabled. To use this feature, enable the **Webinar Survey** setting in the Zoom web portal\'s **Settings** interface. <br>\n**Error Code:** `3000` <br>\n The host isn\'t allowed to use a third party survey link. To use this feature, enable the \"Allow host to use a 3rd-party survey link\" setting in the \"Account Settings\" page of the Zoom web portal. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarSurveyUpdate400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarSurveyUpdate404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarSurveyUpdate429Schema = z.unknown();

export const webinarSurveyUpdateMutationRequestSchema = z.object({
	custom_survey: z.optional(
		z
			.object({
				title: z.optional(z.string().max(64).describe("The survey's title, up to 64 characters.")),
				anonymous: z.optional(
					z
						.boolean()
						.default(false)
						.describe(
							"Allow participants to anonymously answer survey questions. \n* `true` - Anonymous survey enabled. \n* `false` - Participants cannot answer survey questions anonymously. \n\n This value defaults to `true`.",
						),
				),
				numbered_questions: z.optional(
					z
						.boolean()
						.default(false)
						.describe(
							"Whether to display the number in the question name. \n\n This value defaults to `true`.",
						),
				),
				show_question_type: z.optional(
					z
						.boolean()
						.default(false)
						.describe(
							"Whether to display the question type in the question name. \n\n This value defaults to `false`.",
						),
				),
				feedback: z.optional(
					z
						.string()
						.max(320)
						.describe(
							"The survey's feedback, up to 320 characters. \n\n This value defaults to `Thank you so much for taking the time to complete the survey, your feedback really makes a difference.`.",
						),
				),
				questions: z.optional(
					z
						.array(
							z.object({
								name: z.optional(z.string().describe("The survey question, up to 420 characters.")),
								type: z.optional(
									z
										.enum([
											"single",
											"multiple",
											"matching",
											"rank_order",
											"short_answer",
											"long_answer",
											"fill_in_the_blank",
											"rating_scale",
										])
										.describe(
											"The survey's question and answer type. \n* `single` - Single choice. \n* `multiple` - Multiple choice. \n* `matching` - Matching. \n* `rank_order` - Rank order \n* `short_answer` - Short answer \n* `long_answer` - Long answer. \n* `fill_in_the_blank` - Fill in the blank \n* `rating_scale` - Rating scale.",
										),
								),
								answer_required: z.optional(
									z
										.boolean()
										.default(false)
										.describe(
											"Whether participants must answer the question. \n* `true` - The participant must answer the question. \n* `false` - The participant does not need to answer the question. \n\n This value defaults to `false`.",
										),
								),
								show_as_dropdown: z.optional(
									z
										.boolean()
										.default(false)
										.describe(
											"Whether to display the radio selection as a drop-down box. \n* `true` - Show as a drop-down box. \n* `false` - Do not show as a drop-down box. \n\n This value defaults to `false`.",
										),
								),
								answers: z.optional(
									z
										.array(z.string().max(200))
										.min(2)
										.describe(
											"The survey question's available answers. This field requires a **minimum** of two answers. \n\n* For `single` and `multiple` questions, you can only provide a maximum of 50 answers. \n* For `matching` polls, you can only provide a maximum of 16 answers. \n* For `rank_order` polls, you can only provide a maximum of seven answers.",
										),
								),
								prompts: z.optional(
									z
										.array(
											z.object({
												prompt_question: z.optional(
													z.string().max(200).describe("The question prompt's title."),
												),
											}),
										)
										.min(2)
										.max(10)
										.describe(
											"Information about the prompt questions. This field only applies to `matching` and `rank_order` questions. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.",
										),
								),
								answer_min_character: z.optional(
									z
										.int()
										.min(1)
										.describe(
											"The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` questions. You must provide at least a **one** character minimum value.",
										),
								),
								answer_max_character: z.optional(
									z
										.int()
										.describe(
											"The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` questions. \n* For `short_answer` question, a maximum of 500 characters. \n* For `long_answer` question, a maximum of 2,000 characters.",
										),
								),
								rating_min_value: z.optional(
									z
										.int()
										.min(0)
										.describe(
											"The rating scale's minimum value. This value can't be less than zero. \n\n This field only applies to the `rating_scale` survey.",
										),
								),
								rating_max_value: z.optional(
									z
										.int()
										.max(10)
										.describe(
											"The rating scale's maximum value, up to a maximum value of 10. \n\n This field only applies to the `rating_scale` survey.",
										),
								),
								rating_min_label: z.optional(
									z
										.string()
										.max(50)
										.describe(
											"The low score label used for the `rating_min_value` field, up to 50 characters. \n\n This field only applies to the `rating_scale` survey.",
										),
								),
								rating_max_label: z.optional(
									z
										.string()
										.max(50)
										.describe(
											"The high score label used for the `rating_max_value` field, up to 50 characters. \n\n This field only applies to the `rating_scale` survey.",
										),
								),
							}),
						)
						.min(1)
						.max(100)
						.describe("Information about the webinar survey's questions."),
				),
			})
			.describe("Information about the customized webinar survey."),
	),
	show_in_the_browser: z.optional(
		z
			.boolean()
			.default(true)
			.describe(
				"Whether the **Show in the browser when the webinar ends** option is enabled. \n* `true` - Enabled. \n* `false` - Disabled. \n\n This value defaults to `true`.",
			),
	),
	show_in_the_follow_up_email: z.optional(
		z
			.boolean()
			.default(false)
			.describe(
				"Whether the **Show the link on the follow-up email** option is enabled. \n* `true` - Enabled. \n* `false` - Disabled. \n\n This value defaults to `false`.",
			),
	),
	third_party_survey: z.optional(
		z.string().max(64).describe("The link to the third party webinar survey."),
	),
});

export const webinarSurveyUpdateMutationResponseSchema = z.lazy(() => webinarSurveyUpdate204Schema);

export const webinarTokenPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

export const webinarTokenQueryParamsSchema = z.object({
	type: z
		.enum(["closed_caption_token"])
		.default("closed_caption_token")
		.describe(
			"The webinar token type: \n* `closed_caption_token` &mdash; The third-party closed caption API token. \n\nThis defaults to `closed_caption_token`.",
		),
});

/**
 * @description **HTTP Status Code:** `200`   \n \nWebinar token returned.
 */
export const webinarToken200Schema = z
	.object({
		token: z.optional(z.string().describe("The generated webinar token.")),
	})
	.describe("Information about the webinar token.");

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `3000` <br>\n Closed captioning disabled. To enable this feature, enable the **Closed captioning** and **Allow use of caption API Token to integrate with 3rd-party Closed Captioning services** settings in the Zoom web portal\'s **Settings** interface. <br>\n**Error Code:** `3000` <br>\n Webinar {webinarId} has not started. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const webinarToken400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const webinarToken404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const webinarToken429Schema = z.unknown();

export const webinarTokenQueryResponseSchema = z.lazy(() => webinarToken200Schema);

export const getTrackingSourcesPathParamsSchema = z.object({
	webinarId: z.coerce.number().int().describe("The webinar's ID."),
});

/**
 * @description **HTTP Status Code:** `200`
 */
export const getTrackingSources200Schema = z.object({
	total_records: z.optional(
		z.int().describe("The total number of registration records for this Webinar."),
	),
	tracking_sources: z.optional(
		z
			.array(
				z.object({
					id: z.optional(z.string().describe("Unique Identifier of the tracking source.")),
					registration_count: z.optional(
						z.int().describe("Number of registrations made from this source."),
					),
					source_name: z.optional(
						z
							.string()
							.describe("Name of the source (platform) where the registration URL was shared."),
					),
					tracking_url: z.optional(
						z.string().describe("Tracking URL. The URL that was shared for the registration."),
					),
					visitor_count: z.optional(
						z
							.int()
							.describe("Number of visitors who visited the registration page from this source."),
					),
				}),
			)
			.describe("Tracking Sources object."),
	),
});

/**
 * @description **HTTP Status Code:** `400` <br>\n Bad Request  \n\n **Error Code:** `300` <br>\n Invalid webinar ID. <br>\n**Error Code:** `200` <br>\n No permission. <br>\n**Error Code:** `200` <br>\n Webinar plan is missing. You must subscribe to the webinar plan and enable webinars for this user in order to perform this action. <br>\n
 */
export const getTrackingSources400Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `404` <br>\n Not Found  \n\n **Error Code:** `3001` <br>\n Webinar does not exist: {webinarId}. <br>\n
 */
export const getTrackingSources404Schema = z.unknown();

/**
 * @description **HTTP Status Code:** `429` <br>\n Too Many Requests. For more information, see [rate limits](https://developers.zoom.us/docs/api/rest/rate-limits/). \n\n
 */
export const getTrackingSources429Schema = z.unknown();

export const getTrackingSourcesQueryResponseSchema = z.lazy(() => getTrackingSources200Schema);
