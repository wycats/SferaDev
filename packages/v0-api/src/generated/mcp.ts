/**
 * Generated by Kubb (https://kubb.dev/).
 * Do not edit manually.
 */

import type { ErrorWrapper, FetcherConfig } from "../utils/fetcher";
import client from "../utils/fetcher";
import type { CallToolResult } from "../utils/mcp";
import {
	chatsDeletePathParamsSchema,
	chatsDownloadVersionPathParamsSchema,
	chatsDownloadVersionQueryParamsSchema,
	chatsFavoritePathParamsSchema,
	chatsFindMessagesPathParamsSchema,
	chatsFindMessagesQueryParamsSchema,
	chatsFindQueryParamsSchema,
	chatsFindVersionsPathParamsSchema,
	chatsFindVersionsQueryParamsSchema,
	chatsForkPathParamsSchema,
	chatsGetByIdPathParamsSchema,
	chatsGetMessagePathParamsSchema,
	chatsGetVersionPathParamsSchema,
	chatsGetVersionQueryParamsSchema,
	chatsResumePathParamsSchema,
	chatsSendMessagePathParamsSchema,
	chatsUpdatePathParamsSchema,
	chatsUpdateVersionPathParamsSchema,
	deploymentsDeletePathParamsSchema,
	deploymentsFindErrorsPathParamsSchema,
	deploymentsFindLogsPathParamsSchema,
	deploymentsFindLogsQueryParamsSchema,
	deploymentsFindQueryParamsSchema,
	deploymentsGetByIdPathParamsSchema,
	hooksDeletePathParamsSchema,
	hooksGetByIdPathParamsSchema,
	hooksUpdatePathParamsSchema,
	projectsAssignPathParamsSchema,
	projectsCreateEnvVarsPathParamsSchema,
	projectsCreateEnvVarsQueryParamsSchema,
	projectsDeleteEnvVarsPathParamsSchema,
	projectsDeletePathParamsSchema,
	projectsFindEnvVarsPathParamsSchema,
	projectsFindEnvVarsQueryParamsSchema,
	projectsGetByChatIdPathParamsSchema,
	projectsGetByIdPathParamsSchema,
	projectsGetEnvVarPathParamsSchema,
	projectsGetEnvVarQueryParamsSchema,
	projectsUpdateEnvVarsPathParamsSchema,
	projectsUpdateEnvVarsQueryParamsSchema,
	projectsUpdatePathParamsSchema,
	rateLimitsFindQueryParamsSchema,
	reportsGetUsageQueryParamsSchema,
	userGetBillingQueryParamsSchema,
} from "./schemas";
import type {
	ChatsCreate401,
	ChatsCreate403,
	ChatsCreate404,
	ChatsCreate409,
	ChatsCreate413,
	ChatsCreate422,
	ChatsCreate429,
	ChatsCreate500,
	ChatsCreateMutationResponse,
	ChatsDelete401,
	ChatsDelete403,
	ChatsDelete404,
	ChatsDelete409,
	ChatsDelete413,
	ChatsDelete422,
	ChatsDelete429,
	ChatsDelete500,
	ChatsDeleteMutationResponse,
	ChatsDeletePathParams,
	ChatsDownloadVersion401,
	ChatsDownloadVersion403,
	ChatsDownloadVersion404,
	ChatsDownloadVersion409,
	ChatsDownloadVersion413,
	ChatsDownloadVersion422,
	ChatsDownloadVersion429,
	ChatsDownloadVersion500,
	ChatsDownloadVersionPathParams,
	ChatsDownloadVersionQueryParams,
	ChatsDownloadVersionQueryResponse,
	ChatsFavorite401,
	ChatsFavorite403,
	ChatsFavorite404,
	ChatsFavorite409,
	ChatsFavorite413,
	ChatsFavorite422,
	ChatsFavorite429,
	ChatsFavorite500,
	ChatsFavoriteMutationResponse,
	ChatsFavoritePathParams,
	ChatsFind401,
	ChatsFind403,
	ChatsFind404,
	ChatsFind409,
	ChatsFind413,
	ChatsFind422,
	ChatsFind429,
	ChatsFind500,
	ChatsFindMessages401,
	ChatsFindMessages403,
	ChatsFindMessages404,
	ChatsFindMessages409,
	ChatsFindMessages413,
	ChatsFindMessages422,
	ChatsFindMessages429,
	ChatsFindMessages500,
	ChatsFindMessagesPathParams,
	ChatsFindMessagesQueryParams,
	ChatsFindMessagesQueryResponse,
	ChatsFindQueryParams,
	ChatsFindQueryResponse,
	ChatsFindVersions401,
	ChatsFindVersions403,
	ChatsFindVersions404,
	ChatsFindVersions409,
	ChatsFindVersions413,
	ChatsFindVersions422,
	ChatsFindVersions429,
	ChatsFindVersions500,
	ChatsFindVersionsPathParams,
	ChatsFindVersionsQueryParams,
	ChatsFindVersionsQueryResponse,
	ChatsFork401,
	ChatsFork403,
	ChatsFork404,
	ChatsFork409,
	ChatsFork413,
	ChatsFork422,
	ChatsFork429,
	ChatsFork500,
	ChatsForkMutationResponse,
	ChatsForkPathParams,
	ChatsGetById401,
	ChatsGetById403,
	ChatsGetById404,
	ChatsGetById409,
	ChatsGetById413,
	ChatsGetById422,
	ChatsGetById429,
	ChatsGetById500,
	ChatsGetByIdPathParams,
	ChatsGetByIdQueryResponse,
	ChatsGetMessage401,
	ChatsGetMessage403,
	ChatsGetMessage404,
	ChatsGetMessage409,
	ChatsGetMessage413,
	ChatsGetMessage422,
	ChatsGetMessage429,
	ChatsGetMessage500,
	ChatsGetMessagePathParams,
	ChatsGetMessageQueryResponse,
	ChatsGetVersion401,
	ChatsGetVersion403,
	ChatsGetVersion404,
	ChatsGetVersion409,
	ChatsGetVersion413,
	ChatsGetVersion422,
	ChatsGetVersion429,
	ChatsGetVersion500,
	ChatsGetVersionPathParams,
	ChatsGetVersionQueryParams,
	ChatsGetVersionQueryResponse,
	ChatsInit401,
	ChatsInit403,
	ChatsInit404,
	ChatsInit409,
	ChatsInit413,
	ChatsInit422,
	ChatsInit429,
	ChatsInit500,
	ChatsInitMutationResponse,
	ChatsResume401,
	ChatsResume403,
	ChatsResume404,
	ChatsResume409,
	ChatsResume413,
	ChatsResume422,
	ChatsResume429,
	ChatsResume500,
	ChatsResumeMutationResponse,
	ChatsResumePathParams,
	ChatsSendMessage401,
	ChatsSendMessage403,
	ChatsSendMessage404,
	ChatsSendMessage409,
	ChatsSendMessage413,
	ChatsSendMessage422,
	ChatsSendMessage429,
	ChatsSendMessage500,
	ChatsSendMessageMutationResponse,
	ChatsSendMessagePathParams,
	ChatsUpdate401,
	ChatsUpdate403,
	ChatsUpdate404,
	ChatsUpdate409,
	ChatsUpdate413,
	ChatsUpdate422,
	ChatsUpdate429,
	ChatsUpdate500,
	ChatsUpdateMutationResponse,
	ChatsUpdatePathParams,
	ChatsUpdateVersion401,
	ChatsUpdateVersion403,
	ChatsUpdateVersion404,
	ChatsUpdateVersion409,
	ChatsUpdateVersion413,
	ChatsUpdateVersion422,
	ChatsUpdateVersion429,
	ChatsUpdateVersion500,
	ChatsUpdateVersionMutationResponse,
	ChatsUpdateVersionPathParams,
	DeploymentsCreate401,
	DeploymentsCreate403,
	DeploymentsCreate404,
	DeploymentsCreate409,
	DeploymentsCreate413,
	DeploymentsCreate422,
	DeploymentsCreate429,
	DeploymentsCreate500,
	DeploymentsCreateMutationResponse,
	DeploymentsDelete401,
	DeploymentsDelete403,
	DeploymentsDelete404,
	DeploymentsDelete409,
	DeploymentsDelete413,
	DeploymentsDelete422,
	DeploymentsDelete429,
	DeploymentsDelete500,
	DeploymentsDeleteMutationResponse,
	DeploymentsDeletePathParams,
	DeploymentsFind401,
	DeploymentsFind403,
	DeploymentsFind404,
	DeploymentsFind409,
	DeploymentsFind413,
	DeploymentsFind422,
	DeploymentsFind429,
	DeploymentsFind500,
	DeploymentsFindErrors401,
	DeploymentsFindErrors403,
	DeploymentsFindErrors404,
	DeploymentsFindErrors409,
	DeploymentsFindErrors413,
	DeploymentsFindErrors422,
	DeploymentsFindErrors429,
	DeploymentsFindErrors500,
	DeploymentsFindErrorsPathParams,
	DeploymentsFindErrorsQueryResponse,
	DeploymentsFindLogs401,
	DeploymentsFindLogs403,
	DeploymentsFindLogs404,
	DeploymentsFindLogs409,
	DeploymentsFindLogs413,
	DeploymentsFindLogs422,
	DeploymentsFindLogs429,
	DeploymentsFindLogs500,
	DeploymentsFindLogsPathParams,
	DeploymentsFindLogsQueryParams,
	DeploymentsFindLogsQueryResponse,
	DeploymentsFindQueryParams,
	DeploymentsFindQueryResponse,
	DeploymentsGetById401,
	DeploymentsGetById403,
	DeploymentsGetById404,
	DeploymentsGetById409,
	DeploymentsGetById413,
	DeploymentsGetById422,
	DeploymentsGetById429,
	DeploymentsGetById500,
	DeploymentsGetByIdPathParams,
	DeploymentsGetByIdQueryResponse,
	HooksCreate401,
	HooksCreate403,
	HooksCreate404,
	HooksCreate409,
	HooksCreate413,
	HooksCreate422,
	HooksCreate429,
	HooksCreate500,
	HooksCreateMutationResponse,
	HooksDelete401,
	HooksDelete403,
	HooksDelete404,
	HooksDelete409,
	HooksDelete413,
	HooksDelete422,
	HooksDelete429,
	HooksDelete500,
	HooksDeleteMutationResponse,
	HooksDeletePathParams,
	HooksFind401,
	HooksFind403,
	HooksFind404,
	HooksFind409,
	HooksFind413,
	HooksFind422,
	HooksFind429,
	HooksFind500,
	HooksFindQueryResponse,
	HooksGetById401,
	HooksGetById403,
	HooksGetById404,
	HooksGetById409,
	HooksGetById413,
	HooksGetById422,
	HooksGetById429,
	HooksGetById500,
	HooksGetByIdPathParams,
	HooksGetByIdQueryResponse,
	HooksUpdate401,
	HooksUpdate403,
	HooksUpdate404,
	HooksUpdate409,
	HooksUpdate413,
	HooksUpdate422,
	HooksUpdate429,
	HooksUpdate500,
	HooksUpdateMutationResponse,
	HooksUpdatePathParams,
	IntegrationsVercelProjectsCreate401,
	IntegrationsVercelProjectsCreate403,
	IntegrationsVercelProjectsCreate404,
	IntegrationsVercelProjectsCreate409,
	IntegrationsVercelProjectsCreate413,
	IntegrationsVercelProjectsCreate422,
	IntegrationsVercelProjectsCreate429,
	IntegrationsVercelProjectsCreate500,
	IntegrationsVercelProjectsCreateMutationResponse,
	IntegrationsVercelProjectsFind401,
	IntegrationsVercelProjectsFind403,
	IntegrationsVercelProjectsFind404,
	IntegrationsVercelProjectsFind409,
	IntegrationsVercelProjectsFind413,
	IntegrationsVercelProjectsFind422,
	IntegrationsVercelProjectsFind429,
	IntegrationsVercelProjectsFind500,
	IntegrationsVercelProjectsFindQueryResponse,
	ProjectsAssign401,
	ProjectsAssign403,
	ProjectsAssign404,
	ProjectsAssign409,
	ProjectsAssign413,
	ProjectsAssign422,
	ProjectsAssign429,
	ProjectsAssign500,
	ProjectsAssignMutationResponse,
	ProjectsAssignPathParams,
	ProjectsCreate401,
	ProjectsCreate403,
	ProjectsCreate404,
	ProjectsCreate409,
	ProjectsCreate413,
	ProjectsCreate422,
	ProjectsCreate429,
	ProjectsCreate500,
	ProjectsCreateEnvVars401,
	ProjectsCreateEnvVars403,
	ProjectsCreateEnvVars404,
	ProjectsCreateEnvVars409,
	ProjectsCreateEnvVars413,
	ProjectsCreateEnvVars422,
	ProjectsCreateEnvVars429,
	ProjectsCreateEnvVars500,
	ProjectsCreateEnvVarsMutationResponse,
	ProjectsCreateEnvVarsPathParams,
	ProjectsCreateEnvVarsQueryParams,
	ProjectsCreateMutationResponse,
	ProjectsDelete401,
	ProjectsDelete403,
	ProjectsDelete404,
	ProjectsDelete409,
	ProjectsDelete413,
	ProjectsDelete422,
	ProjectsDelete429,
	ProjectsDelete500,
	ProjectsDeleteEnvVars401,
	ProjectsDeleteEnvVars403,
	ProjectsDeleteEnvVars404,
	ProjectsDeleteEnvVars409,
	ProjectsDeleteEnvVars413,
	ProjectsDeleteEnvVars422,
	ProjectsDeleteEnvVars429,
	ProjectsDeleteEnvVars500,
	ProjectsDeleteEnvVarsMutationResponse,
	ProjectsDeleteEnvVarsPathParams,
	ProjectsDeleteMutationResponse,
	ProjectsDeletePathParams,
	ProjectsFind401,
	ProjectsFind403,
	ProjectsFind404,
	ProjectsFind409,
	ProjectsFind413,
	ProjectsFind422,
	ProjectsFind429,
	ProjectsFind500,
	ProjectsFindEnvVars401,
	ProjectsFindEnvVars403,
	ProjectsFindEnvVars404,
	ProjectsFindEnvVars409,
	ProjectsFindEnvVars413,
	ProjectsFindEnvVars422,
	ProjectsFindEnvVars429,
	ProjectsFindEnvVars500,
	ProjectsFindEnvVarsPathParams,
	ProjectsFindEnvVarsQueryParams,
	ProjectsFindEnvVarsQueryResponse,
	ProjectsFindQueryResponse,
	ProjectsGetByChatId401,
	ProjectsGetByChatId403,
	ProjectsGetByChatId404,
	ProjectsGetByChatId409,
	ProjectsGetByChatId413,
	ProjectsGetByChatId422,
	ProjectsGetByChatId429,
	ProjectsGetByChatId500,
	ProjectsGetByChatIdPathParams,
	ProjectsGetByChatIdQueryResponse,
	ProjectsGetById401,
	ProjectsGetById403,
	ProjectsGetById404,
	ProjectsGetById409,
	ProjectsGetById413,
	ProjectsGetById422,
	ProjectsGetById429,
	ProjectsGetById500,
	ProjectsGetByIdPathParams,
	ProjectsGetByIdQueryResponse,
	ProjectsGetEnvVar401,
	ProjectsGetEnvVar403,
	ProjectsGetEnvVar404,
	ProjectsGetEnvVar409,
	ProjectsGetEnvVar413,
	ProjectsGetEnvVar422,
	ProjectsGetEnvVar429,
	ProjectsGetEnvVar500,
	ProjectsGetEnvVarPathParams,
	ProjectsGetEnvVarQueryParams,
	ProjectsGetEnvVarQueryResponse,
	ProjectsUpdate401,
	ProjectsUpdate403,
	ProjectsUpdate404,
	ProjectsUpdate409,
	ProjectsUpdate413,
	ProjectsUpdate422,
	ProjectsUpdate429,
	ProjectsUpdate500,
	ProjectsUpdateEnvVars401,
	ProjectsUpdateEnvVars403,
	ProjectsUpdateEnvVars404,
	ProjectsUpdateEnvVars409,
	ProjectsUpdateEnvVars413,
	ProjectsUpdateEnvVars422,
	ProjectsUpdateEnvVars429,
	ProjectsUpdateEnvVars500,
	ProjectsUpdateEnvVarsMutationResponse,
	ProjectsUpdateEnvVarsPathParams,
	ProjectsUpdateEnvVarsQueryParams,
	ProjectsUpdateMutationResponse,
	ProjectsUpdatePathParams,
	RateLimitsFind401,
	RateLimitsFind403,
	RateLimitsFind404,
	RateLimitsFind409,
	RateLimitsFind413,
	RateLimitsFind422,
	RateLimitsFind429,
	RateLimitsFind500,
	RateLimitsFindQueryParams,
	RateLimitsFindQueryResponse,
	ReportsGetUsage401,
	ReportsGetUsage403,
	ReportsGetUsage404,
	ReportsGetUsage409,
	ReportsGetUsage413,
	ReportsGetUsage422,
	ReportsGetUsage429,
	ReportsGetUsage500,
	ReportsGetUsageQueryParams,
	ReportsGetUsageQueryResponse,
	UserGet401,
	UserGet403,
	UserGet404,
	UserGet409,
	UserGet413,
	UserGet422,
	UserGet429,
	UserGet500,
	UserGetBilling401,
	UserGetBilling403,
	UserGetBilling404,
	UserGetBilling409,
	UserGetBilling413,
	UserGetBilling422,
	UserGetBilling429,
	UserGetBilling500,
	UserGetBillingQueryParams,
	UserGetBillingQueryResponse,
	UserGetPlan401,
	UserGetPlan403,
	UserGetPlan404,
	UserGetPlan409,
	UserGetPlan413,
	UserGetPlan422,
	UserGetPlan429,
	UserGetPlan500,
	UserGetPlanQueryResponse,
	UserGetQueryResponse,
	UserGetScopes401,
	UserGetScopes403,
	UserGetScopes404,
	UserGetScopes409,
	UserGetScopes413,
	UserGetScopes422,
	UserGetScopes429,
	UserGetScopes500,
	UserGetScopesQueryResponse,
} from "./types";

/**
 * @description Creates a new chat using a user message, optional system context, and model configuration. Useful for prompting the model within the scope of a specific project.
 * @summary Create Chat
 * {@link /chats}
 */
export async function chatsCreate({
	config = {},
}: {
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		ChatsCreateMutationResponse,
		ErrorWrapper<
			| ChatsCreate401
			| ChatsCreate403
			| ChatsCreate404
			| ChatsCreate409
			| ChatsCreate413
			| ChatsCreate422
			| ChatsCreate429
			| ChatsCreate500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		Record<string, string>
	>({
		method: "POST",
		url: `/chats`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves a list of existing chats, with support for pagination and filtering by favorite status. Helps manage and navigate chat history.
 * @summary Find Chats
 * {@link /chats}
 */
export async function chatsFind({
	queryParams,
	config = {},
}: {
	queryParams?: ChatsFindQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		ChatsFindQueryResponse,
		ErrorWrapper<
			| ChatsFind401
			| ChatsFind403
			| ChatsFind404
			| ChatsFind409
			| ChatsFind413
			| ChatsFind422
			| ChatsFind429
			| ChatsFind500
		>,
		null,
		Record<string, string>,
		ChatsFindQueryParams,
		Record<string, string>
	>({
		method: "GET",
		url: `/chats`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Initializes a new chat from source content such as files, repositories, registries, or zip archives. Enables context-rich conversations based on code or assets.
 * @summary Initialize Chat
 * {@link /chats/init}
 */
export async function chatsInit({
	config = {},
}: {
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		ChatsInitMutationResponse,
		ErrorWrapper<
			| ChatsInit401
			| ChatsInit403
			| ChatsInit404
			| ChatsInit409
			| ChatsInit413
			| ChatsInit422
			| ChatsInit429
			| ChatsInit500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		Record<string, string>
	>({
		method: "POST",
		url: `/chats/init`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Deletes a specific chat based on the provided chatId. This operation is irreversible and permanently removes the chat and its contents.
 * @summary Delete Chat
 * {@link /chats/:chatId}
 */
export async function chatsDelete({
	pathParams: { chatId },
	config = {},
}: {
	pathParams: ChatsDeletePathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}
	const data = await request<
		ChatsDeleteMutationResponse,
		ErrorWrapper<
			| ChatsDelete401
			| ChatsDelete403
			| ChatsDelete404
			| ChatsDelete409
			| ChatsDelete413
			| ChatsDelete422
			| ChatsDelete429
			| ChatsDelete500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ChatsDeletePathParams
	>({
		method: "DELETE",
		url: `/chats/${chatId}`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves the full details of a specific chat using its `chatId`. Includes messages, metadata, and associated configuration.
 * @summary Get Chat
 * {@link /chats/:chatId}
 */
export async function chatsGetById({
	pathParams: { chatId },
	config = {},
}: {
	pathParams: ChatsGetByIdPathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}
	const data = await request<
		ChatsGetByIdQueryResponse,
		ErrorWrapper<
			| ChatsGetById401
			| ChatsGetById403
			| ChatsGetById404
			| ChatsGetById409
			| ChatsGetById413
			| ChatsGetById422
			| ChatsGetById429
			| ChatsGetById500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ChatsGetByIdPathParams
	>({ method: "GET", url: `/chats/${chatId}`, baseUrl: "https://api.v0.dev/v1", ...requestConfig });
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Updates the metadata of an existing chat using its `chatId`. Supports changes to the chat name and privacy setting.
 * @summary Update Chat
 * {@link /chats/:chatId}
 */
export async function chatsUpdate({
	pathParams: { chatId },
	config = {},
}: {
	pathParams: ChatsUpdatePathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}
	const data = await request<
		ChatsUpdateMutationResponse,
		ErrorWrapper<
			| ChatsUpdate401
			| ChatsUpdate403
			| ChatsUpdate404
			| ChatsUpdate409
			| ChatsUpdate413
			| ChatsUpdate422
			| ChatsUpdate429
			| ChatsUpdate500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ChatsUpdatePathParams
	>({
		method: "PATCH",
		url: `/chats/${chatId}`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Marks or unmarks a chat as a favorite using its `chatId`. This helps with organizing and quickly accessing important chats.
 * @summary Favorite Chat
 * {@link /chats/:chatId/favorite}
 */
export async function chatsFavorite({
	pathParams: { chatId },
	config = {},
}: {
	pathParams: ChatsFavoritePathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}
	const data = await request<
		ChatsFavoriteMutationResponse,
		ErrorWrapper<
			| ChatsFavorite401
			| ChatsFavorite403
			| ChatsFavorite404
			| ChatsFavorite409
			| ChatsFavorite413
			| ChatsFavorite422
			| ChatsFavorite429
			| ChatsFavorite500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ChatsFavoritePathParams
	>({
		method: "PUT",
		url: `/chats/${chatId}/favorite`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Creates a new chat fork (duplicate) from a specific version within an existing chat. Useful for branching off alternate directions without modifying the original conversation.
 * @summary Fork Chat
 * {@link /chats/:chatId/fork}
 */
export async function chatsFork({
	pathParams: { chatId },
	config = {},
}: {
	pathParams: ChatsForkPathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}
	const data = await request<
		ChatsForkMutationResponse,
		ErrorWrapper<
			| ChatsFork401
			| ChatsFork403
			| ChatsFork404
			| ChatsFork409
			| ChatsFork413
			| ChatsFork422
			| ChatsFork429
			| ChatsFork500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ChatsForkPathParams
	>({
		method: "POST",
		url: `/chats/${chatId}/fork`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves the v0 project associated with a given chat. Useful for determining the context or scope of a chat session.
 * @summary Get Project by Chat ID
 * {@link /chats/:chatId/project}
 */
export async function projectsGetByChatId({
	pathParams: { chatId },
	config = {},
}: {
	pathParams: ProjectsGetByChatIdPathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}
	const data = await request<
		ProjectsGetByChatIdQueryResponse,
		ErrorWrapper<
			| ProjectsGetByChatId401
			| ProjectsGetByChatId403
			| ProjectsGetByChatId404
			| ProjectsGetByChatId409
			| ProjectsGetByChatId413
			| ProjectsGetByChatId422
			| ProjectsGetByChatId429
			| ProjectsGetByChatId500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ProjectsGetByChatIdPathParams
	>({
		method: "GET",
		url: `/chats/${chatId}/project`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves a list of all messages for a specific chat, ordered by creation date (newest first). Supports cursor-based pagination and includes message content, role, and type information.
 * @summary Find Chat Messages
 * {@link /chats/:chatId/messages}
 */
export async function chatsFindMessages({
	pathParams: { chatId },
	queryParams,
	config = {},
}: {
	pathParams: ChatsFindMessagesPathParams;
	queryParams?: ChatsFindMessagesQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}
	const data = await request<
		ChatsFindMessagesQueryResponse,
		ErrorWrapper<
			| ChatsFindMessages401
			| ChatsFindMessages403
			| ChatsFindMessages404
			| ChatsFindMessages409
			| ChatsFindMessages413
			| ChatsFindMessages422
			| ChatsFindMessages429
			| ChatsFindMessages500
		>,
		null,
		Record<string, string>,
		ChatsFindMessagesQueryParams,
		ChatsFindMessagesPathParams
	>({
		method: "GET",
		url: `/chats/${chatId}/messages`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Creates a new message in an existing chat. Triggers a model response using the provided prompt, with optional attachments and configuration settings.
 * @summary Send Message
 * {@link /chats/:chatId/messages}
 */
export async function chatsSendMessage({
	pathParams: { chatId },
	config = {},
}: {
	pathParams: ChatsSendMessagePathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}
	const data = await request<
		ChatsSendMessageMutationResponse,
		ErrorWrapper<
			| ChatsSendMessage401
			| ChatsSendMessage403
			| ChatsSendMessage404
			| ChatsSendMessage409
			| ChatsSendMessage413
			| ChatsSendMessage422
			| ChatsSendMessage429
			| ChatsSendMessage500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ChatsSendMessagePathParams
	>({
		method: "POST",
		url: `/chats/${chatId}/messages`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves detailed information about a specific message within a chat, including content, files, model configuration, and demo URLs.
 * @summary Get Chat Message
 * {@link /chats/:chatId/messages/:messageId}
 */
export async function chatsGetMessage({
	pathParams: { chatId, messageId },
	config = {},
}: {
	pathParams: ChatsGetMessagePathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}

	if (!messageId) {
		throw new Error(`Missing required path parameter: messageId`);
	}
	const data = await request<
		ChatsGetMessageQueryResponse,
		ErrorWrapper<
			| ChatsGetMessage401
			| ChatsGetMessage403
			| ChatsGetMessage404
			| ChatsGetMessage409
			| ChatsGetMessage413
			| ChatsGetMessage422
			| ChatsGetMessage429
			| ChatsGetMessage500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ChatsGetMessagePathParams
	>({
		method: "GET",
		url: `/chats/${chatId}/messages/${messageId}`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves a list of all versions (iterations) for a specific chat, ordered by creation date (newest first). Supports cursor-based pagination and includes version status and demo URLs.
 * @summary Find Chat Versions
 * {@link /chats/:chatId/versions}
 */
export async function chatsFindVersions({
	pathParams: { chatId },
	queryParams,
	config = {},
}: {
	pathParams: ChatsFindVersionsPathParams;
	queryParams?: ChatsFindVersionsQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}
	const data = await request<
		ChatsFindVersionsQueryResponse,
		ErrorWrapper<
			| ChatsFindVersions401
			| ChatsFindVersions403
			| ChatsFindVersions404
			| ChatsFindVersions409
			| ChatsFindVersions413
			| ChatsFindVersions422
			| ChatsFindVersions429
			| ChatsFindVersions500
		>,
		null,
		Record<string, string>,
		ChatsFindVersionsQueryParams,
		ChatsFindVersionsPathParams
	>({
		method: "GET",
		url: `/chats/${chatId}/versions`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves detailed information about a specific version of a chat, including all files with their content and lock status.
 * @summary Get Chat Version
 * {@link /chats/:chatId/versions/:versionId}
 */
export async function chatsGetVersion({
	pathParams: { chatId, versionId },
	queryParams,
	config = {},
}: {
	pathParams: ChatsGetVersionPathParams;
	queryParams?: ChatsGetVersionQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}

	if (!versionId) {
		throw new Error(`Missing required path parameter: versionId`);
	}
	const data = await request<
		ChatsGetVersionQueryResponse,
		ErrorWrapper<
			| ChatsGetVersion401
			| ChatsGetVersion403
			| ChatsGetVersion404
			| ChatsGetVersion409
			| ChatsGetVersion413
			| ChatsGetVersion422
			| ChatsGetVersion429
			| ChatsGetVersion500
		>,
		null,
		Record<string, string>,
		ChatsGetVersionQueryParams,
		ChatsGetVersionPathParams
	>({
		method: "GET",
		url: `/chats/${chatId}/versions/${versionId}`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Updates the source files of a specific chat version (block) manually. This allows editing generated files directly through the API.
 * @summary Update Chat Version Files
 * {@link /chats/:chatId/versions/:versionId}
 */
export async function chatsUpdateVersion({
	pathParams: { chatId, versionId },
	config = {},
}: {
	pathParams: ChatsUpdateVersionPathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}

	if (!versionId) {
		throw new Error(`Missing required path parameter: versionId`);
	}
	const data = await request<
		ChatsUpdateVersionMutationResponse,
		ErrorWrapper<
			| ChatsUpdateVersion401
			| ChatsUpdateVersion403
			| ChatsUpdateVersion404
			| ChatsUpdateVersion409
			| ChatsUpdateVersion413
			| ChatsUpdateVersion422
			| ChatsUpdateVersion429
			| ChatsUpdateVersion500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ChatsUpdateVersionPathParams
	>({
		method: "PATCH",
		url: `/chats/${chatId}/versions/${versionId}`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Download all files for a specific chat version as a zip or tarball archive. Use includeDefaultFiles=true to include all deployment files (package.json, configuration files, etc.) or false/omitted to return only the generated source files.
 * @summary Download version files
 * {@link /chats/:chatId/versions/:versionId/download}
 */
export async function chatsDownloadVersion({
	pathParams: { chatId, versionId },
	queryParams,
	config = {},
}: {
	pathParams: ChatsDownloadVersionPathParams;
	queryParams?: ChatsDownloadVersionQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}

	if (!versionId) {
		throw new Error(`Missing required path parameter: versionId`);
	}
	const data = await request<
		ChatsDownloadVersionQueryResponse,
		ErrorWrapper<
			| ChatsDownloadVersion401
			| ChatsDownloadVersion403
			| ChatsDownloadVersion404
			| ChatsDownloadVersion409
			| ChatsDownloadVersion413
			| ChatsDownloadVersion422
			| ChatsDownloadVersion429
			| ChatsDownloadVersion500
		>,
		null,
		Record<string, string>,
		ChatsDownloadVersionQueryParams,
		ChatsDownloadVersionPathParams
	>({
		method: "GET",
		url: `/chats/${chatId}/versions/${versionId}/download`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Resumes processing of a previously interrupted or incomplete message in a chat. Useful for continuing generation when a message was paused or stopped.
 * @summary Resume Message
 * {@link /chats/:chatId/messages/:messageId/resume}
 */
export async function chatsResume({
	pathParams: { chatId, messageId },
	config = {},
}: {
	pathParams: ChatsResumePathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!chatId) {
		throw new Error(`Missing required path parameter: chatId`);
	}

	if (!messageId) {
		throw new Error(`Missing required path parameter: messageId`);
	}
	const data = await request<
		ChatsResumeMutationResponse,
		ErrorWrapper<
			| ChatsResume401
			| ChatsResume403
			| ChatsResume404
			| ChatsResume409
			| ChatsResume413
			| ChatsResume422
			| ChatsResume429
			| ChatsResume500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ChatsResumePathParams
	>({
		method: "POST",
		url: `/chats/${chatId}/messages/${messageId}/resume`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Find deployments by project and chat IDs. This will return a list of deployments for the given project and chat IDs.
 * @summary Find Deployments
 * {@link /deployments}
 */
export async function deploymentsFind({
	queryParams,
	config = {},
}: {
	queryParams: DeploymentsFindQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		DeploymentsFindQueryResponse,
		ErrorWrapper<
			| DeploymentsFind401
			| DeploymentsFind403
			| DeploymentsFind404
			| DeploymentsFind409
			| DeploymentsFind413
			| DeploymentsFind422
			| DeploymentsFind429
			| DeploymentsFind500
		>,
		null,
		Record<string, string>,
		DeploymentsFindQueryParams,
		Record<string, string>
	>({
		method: "GET",
		url: `/deployments`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Create a new deployment for a specific chat and version. This will trigger a deployment to Vercel.
 * @summary Create Deployment
 * {@link /deployments}
 */
export async function deploymentsCreate({
	config = {},
}: {
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		DeploymentsCreateMutationResponse,
		ErrorWrapper<
			| DeploymentsCreate401
			| DeploymentsCreate403
			| DeploymentsCreate404
			| DeploymentsCreate409
			| DeploymentsCreate413
			| DeploymentsCreate422
			| DeploymentsCreate429
			| DeploymentsCreate500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		Record<string, string>
	>({
		method: "POST",
		url: `/deployments`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Get a deployment by ID. This will return the details of the deployment, including the inspector URL, chat ID, project ID, version ID, API URL, and web URL.
 * @summary Get Deployment
 * {@link /deployments/:deploymentId}
 */
export async function deploymentsGetById({
	pathParams: { deploymentId },
	config = {},
}: {
	pathParams: DeploymentsGetByIdPathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!deploymentId) {
		throw new Error(`Missing required path parameter: deploymentId`);
	}
	const data = await request<
		DeploymentsGetByIdQueryResponse,
		ErrorWrapper<
			| DeploymentsGetById401
			| DeploymentsGetById403
			| DeploymentsGetById404
			| DeploymentsGetById409
			| DeploymentsGetById413
			| DeploymentsGetById422
			| DeploymentsGetById429
			| DeploymentsGetById500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		DeploymentsGetByIdPathParams
	>({
		method: "GET",
		url: `/deployments/${deploymentId}`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Delete a deployment by ID. This will delete the deployment from Vercel.
 * @summary Delete Deployment
 * {@link /deployments/:deploymentId}
 */
export async function deploymentsDelete({
	pathParams: { deploymentId },
	config = {},
}: {
	pathParams: DeploymentsDeletePathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!deploymentId) {
		throw new Error(`Missing required path parameter: deploymentId`);
	}
	const data = await request<
		DeploymentsDeleteMutationResponse,
		ErrorWrapper<
			| DeploymentsDelete401
			| DeploymentsDelete403
			| DeploymentsDelete404
			| DeploymentsDelete409
			| DeploymentsDelete413
			| DeploymentsDelete422
			| DeploymentsDelete429
			| DeploymentsDelete500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		DeploymentsDeletePathParams
	>({
		method: "DELETE",
		url: `/deployments/${deploymentId}`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves logs for a specific deployment. Supports filtering by timestamp to fetch only recent logs.
 * @summary Find Deployment Logs
 * {@link /deployments/:deploymentId/logs}
 */
export async function deploymentsFindLogs({
	pathParams: { deploymentId },
	queryParams,
	config = {},
}: {
	pathParams: DeploymentsFindLogsPathParams;
	queryParams?: DeploymentsFindLogsQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!deploymentId) {
		throw new Error(`Missing required path parameter: deploymentId`);
	}
	const data = await request<
		DeploymentsFindLogsQueryResponse,
		ErrorWrapper<
			| DeploymentsFindLogs401
			| DeploymentsFindLogs403
			| DeploymentsFindLogs404
			| DeploymentsFindLogs409
			| DeploymentsFindLogs413
			| DeploymentsFindLogs422
			| DeploymentsFindLogs429
			| DeploymentsFindLogs500
		>,
		null,
		Record<string, string>,
		DeploymentsFindLogsQueryParams,
		DeploymentsFindLogsPathParams
	>({
		method: "GET",
		url: `/deployments/${deploymentId}/logs`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves a list of errors that occurred during a specific deployment. Useful for diagnosing and debugging deployment issues.
 * @summary Find Deployment Errors
 * {@link /deployments/:deploymentId/errors}
 */
export async function deploymentsFindErrors({
	pathParams: { deploymentId },
	config = {},
}: {
	pathParams: DeploymentsFindErrorsPathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!deploymentId) {
		throw new Error(`Missing required path parameter: deploymentId`);
	}
	const data = await request<
		DeploymentsFindErrorsQueryResponse,
		ErrorWrapper<
			| DeploymentsFindErrors401
			| DeploymentsFindErrors403
			| DeploymentsFindErrors404
			| DeploymentsFindErrors409
			| DeploymentsFindErrors413
			| DeploymentsFindErrors422
			| DeploymentsFindErrors429
			| DeploymentsFindErrors500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		DeploymentsFindErrorsPathParams
	>({
		method: "GET",
		url: `/deployments/${deploymentId}/errors`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves a list of existing hooks in your workspace. Useful for managing active webhooks tied to chat events or deployments.
 * @summary Find Hooks
 * {@link /hooks}
 */
export async function hooksFind({
	config = {},
}: {
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		HooksFindQueryResponse,
		ErrorWrapper<
			| HooksFind401
			| HooksFind403
			| HooksFind404
			| HooksFind409
			| HooksFind413
			| HooksFind422
			| HooksFind429
			| HooksFind500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		Record<string, string>
	>({ method: "GET", url: `/hooks`, baseUrl: "https://api.v0.dev/v1", ...requestConfig });
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Creates a new webhook that listens for specific events. Supports optional association with a chat.
 * @summary Create Hook
 * {@link /hooks}
 */
export async function hooksCreate({
	config = {},
}: {
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		HooksCreateMutationResponse,
		ErrorWrapper<
			| HooksCreate401
			| HooksCreate403
			| HooksCreate404
			| HooksCreate409
			| HooksCreate413
			| HooksCreate422
			| HooksCreate429
			| HooksCreate500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		Record<string, string>
	>({
		method: "POST",
		url: `/hooks`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves the details of a specific webhook using its ID.
 * @summary Get Hook
 * {@link /hooks/:hookId}
 */
export async function hooksGetById({
	pathParams: { hookId },
	config = {},
}: {
	pathParams: HooksGetByIdPathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!hookId) {
		throw new Error(`Missing required path parameter: hookId`);
	}
	const data = await request<
		HooksGetByIdQueryResponse,
		ErrorWrapper<
			| HooksGetById401
			| HooksGetById403
			| HooksGetById404
			| HooksGetById409
			| HooksGetById413
			| HooksGetById422
			| HooksGetById429
			| HooksGetById500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		HooksGetByIdPathParams
	>({ method: "GET", url: `/hooks/${hookId}`, baseUrl: "https://api.v0.dev/v1", ...requestConfig });
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Updates the configuration of an existing webhook, including its name, event subscriptions, or target URL.
 * @summary Update Hook
 * {@link /hooks/:hookId}
 */
export async function hooksUpdate({
	pathParams: { hookId },
	config = {},
}: {
	pathParams: HooksUpdatePathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!hookId) {
		throw new Error(`Missing required path parameter: hookId`);
	}
	const data = await request<
		HooksUpdateMutationResponse,
		ErrorWrapper<
			| HooksUpdate401
			| HooksUpdate403
			| HooksUpdate404
			| HooksUpdate409
			| HooksUpdate413
			| HooksUpdate422
			| HooksUpdate429
			| HooksUpdate500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		HooksUpdatePathParams
	>({
		method: "PATCH",
		url: `/hooks/${hookId}`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Deletes a webhook based on its ID. This action is irreversible.
 * @summary Delete Hook
 * {@link /hooks/:hookId}
 */
export async function hooksDelete({
	pathParams: { hookId },
	config = {},
}: {
	pathParams: HooksDeletePathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!hookId) {
		throw new Error(`Missing required path parameter: hookId`);
	}
	const data = await request<
		HooksDeleteMutationResponse,
		ErrorWrapper<
			| HooksDelete401
			| HooksDelete403
			| HooksDelete404
			| HooksDelete409
			| HooksDelete413
			| HooksDelete422
			| HooksDelete429
			| HooksDelete500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		HooksDeletePathParams
	>({
		method: "DELETE",
		url: `/hooks/${hookId}`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves a list of Vercel projects linked to your integration. Useful for associating chats, deployments, or hooks with specific Vercel projects.
 * @summary Find Vercel Projects
 * {@link /integrations/vercel/projects}
 */
export async function integrationsVercelProjectsFind({
	config = {},
}: {
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		IntegrationsVercelProjectsFindQueryResponse,
		ErrorWrapper<
			| IntegrationsVercelProjectsFind401
			| IntegrationsVercelProjectsFind403
			| IntegrationsVercelProjectsFind404
			| IntegrationsVercelProjectsFind409
			| IntegrationsVercelProjectsFind413
			| IntegrationsVercelProjectsFind422
			| IntegrationsVercelProjectsFind429
			| IntegrationsVercelProjectsFind500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		Record<string, string>
	>({
		method: "GET",
		url: `/integrations/vercel/projects`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Links a Vercel project to an existing v0 project. Enables Vercel-related features and deployment integration within the v0 workspace.
 * @summary Create Vercel Project
 * {@link /integrations/vercel/projects}
 */
export async function integrationsVercelProjectsCreate({
	config = {},
}: {
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		IntegrationsVercelProjectsCreateMutationResponse,
		ErrorWrapper<
			| IntegrationsVercelProjectsCreate401
			| IntegrationsVercelProjectsCreate403
			| IntegrationsVercelProjectsCreate404
			| IntegrationsVercelProjectsCreate409
			| IntegrationsVercelProjectsCreate413
			| IntegrationsVercelProjectsCreate422
			| IntegrationsVercelProjectsCreate429
			| IntegrationsVercelProjectsCreate500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		Record<string, string>
	>({
		method: "POST",
		url: `/integrations/vercel/projects`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Returns a list of all v0 projects in your workspace. Useful for browsing or managing projects across different chats or use cases.
 * @summary Find Projects
 * {@link /projects}
 */
export async function projectsFind({
	config = {},
}: {
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		ProjectsFindQueryResponse,
		ErrorWrapper<
			| ProjectsFind401
			| ProjectsFind403
			| ProjectsFind404
			| ProjectsFind409
			| ProjectsFind413
			| ProjectsFind422
			| ProjectsFind429
			| ProjectsFind500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		Record<string, string>
	>({ method: "GET", url: `/projects`, baseUrl: "https://api.v0.dev/v1", ...requestConfig });
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Creates a new v0 project with an optional description, icon, environment variables, and instructions. Projects help organize chats and manage context.
 * @summary Create Project
 * {@link /projects}
 */
export async function projectsCreate({
	config = {},
}: {
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		ProjectsCreateMutationResponse,
		ErrorWrapper<
			| ProjectsCreate401
			| ProjectsCreate403
			| ProjectsCreate404
			| ProjectsCreate409
			| ProjectsCreate413
			| ProjectsCreate422
			| ProjectsCreate429
			| ProjectsCreate500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		Record<string, string>
	>({
		method: "POST",
		url: `/projects`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves the details of a specific v0 project by its ID.
 * @summary Get Project by ID
 * {@link /projects/:projectId}
 */
export async function projectsGetById({
	pathParams: { projectId },
	config = {},
}: {
	pathParams: ProjectsGetByIdPathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!projectId) {
		throw new Error(`Missing required path parameter: projectId`);
	}
	const data = await request<
		ProjectsGetByIdQueryResponse,
		ErrorWrapper<
			| ProjectsGetById401
			| ProjectsGetById403
			| ProjectsGetById404
			| ProjectsGetById409
			| ProjectsGetById413
			| ProjectsGetById422
			| ProjectsGetById429
			| ProjectsGetById500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ProjectsGetByIdPathParams
	>({
		method: "GET",
		url: `/projects/${projectId}`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Updates the metadata of an existing project using its `projectId`. Supports changes to the project name and privacy setting.
 * @summary Update Project
 * {@link /projects/:projectId}
 */
export async function projectsUpdate({
	pathParams: { projectId },
	config = {},
}: {
	pathParams: ProjectsUpdatePathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!projectId) {
		throw new Error(`Missing required path parameter: projectId`);
	}
	const data = await request<
		ProjectsUpdateMutationResponse,
		ErrorWrapper<
			| ProjectsUpdate401
			| ProjectsUpdate403
			| ProjectsUpdate404
			| ProjectsUpdate409
			| ProjectsUpdate413
			| ProjectsUpdate422
			| ProjectsUpdate429
			| ProjectsUpdate500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ProjectsUpdatePathParams
	>({
		method: "PATCH",
		url: `/projects/${projectId}`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Deletes a specific project based on the provided projectId. This operation marks the project as deleted and is irreversible.
 * @summary Delete Project
 * {@link /projects/:projectId}
 */
export async function projectsDelete({
	pathParams: { projectId },
	config = {},
}: {
	pathParams: ProjectsDeletePathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!projectId) {
		throw new Error(`Missing required path parameter: projectId`);
	}
	const data = await request<
		ProjectsDeleteMutationResponse,
		ErrorWrapper<
			| ProjectsDelete401
			| ProjectsDelete403
			| ProjectsDelete404
			| ProjectsDelete409
			| ProjectsDelete413
			| ProjectsDelete422
			| ProjectsDelete429
			| ProjectsDelete500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ProjectsDeletePathParams
	>({
		method: "DELETE",
		url: `/projects/${projectId}`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Links an existing v0 project to a specific chat. Helps group conversations under a shared project context.
 * @summary Assign Project to Chat
 * {@link /projects/:projectId/assign}
 */
export async function projectsAssign({
	pathParams: { projectId },
	config = {},
}: {
	pathParams: ProjectsAssignPathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!projectId) {
		throw new Error(`Missing required path parameter: projectId`);
	}
	const data = await request<
		ProjectsAssignMutationResponse,
		ErrorWrapper<
			| ProjectsAssign401
			| ProjectsAssign403
			| ProjectsAssign404
			| ProjectsAssign409
			| ProjectsAssign413
			| ProjectsAssign422
			| ProjectsAssign429
			| ProjectsAssign500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ProjectsAssignPathParams
	>({
		method: "POST",
		url: `/projects/${projectId}/assign`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves all environment variables for a given project.
 * @summary Find Environment Variables
 * {@link /projects/:projectId/env-vars}
 */
export async function projectsFindEnvVars({
	pathParams: { projectId },
	queryParams,
	config = {},
}: {
	pathParams: ProjectsFindEnvVarsPathParams;
	queryParams?: ProjectsFindEnvVarsQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!projectId) {
		throw new Error(`Missing required path parameter: projectId`);
	}
	const data = await request<
		ProjectsFindEnvVarsQueryResponse,
		ErrorWrapper<
			| ProjectsFindEnvVars401
			| ProjectsFindEnvVars403
			| ProjectsFindEnvVars404
			| ProjectsFindEnvVars409
			| ProjectsFindEnvVars413
			| ProjectsFindEnvVars422
			| ProjectsFindEnvVars429
			| ProjectsFindEnvVars500
		>,
		null,
		Record<string, string>,
		ProjectsFindEnvVarsQueryParams,
		ProjectsFindEnvVarsPathParams
	>({
		method: "GET",
		url: `/projects/${projectId}/env-vars`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Creates new environment variables for a given project. This endpoint will fail if any of the specified environment variable keys already exist, unless upsert is set to true.
 * @summary Create Environment Variables
 * {@link /projects/:projectId/env-vars}
 */
export async function projectsCreateEnvVars({
	pathParams: { projectId },
	queryParams,
	config = {},
}: {
	pathParams: ProjectsCreateEnvVarsPathParams;
	queryParams?: ProjectsCreateEnvVarsQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!projectId) {
		throw new Error(`Missing required path parameter: projectId`);
	}
	const data = await request<
		ProjectsCreateEnvVarsMutationResponse,
		ErrorWrapper<
			| ProjectsCreateEnvVars401
			| ProjectsCreateEnvVars403
			| ProjectsCreateEnvVars404
			| ProjectsCreateEnvVars409
			| ProjectsCreateEnvVars413
			| ProjectsCreateEnvVars422
			| ProjectsCreateEnvVars429
			| ProjectsCreateEnvVars500
		>,
		null,
		Record<string, string>,
		ProjectsCreateEnvVarsQueryParams,
		ProjectsCreateEnvVarsPathParams
	>({
		method: "POST",
		url: `/projects/${projectId}/env-vars`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Updates multiple environment variables for a given project. Only the value of each environment variable can be updated.
 * @summary Update Environment Variables
 * {@link /projects/:projectId/env-vars}
 */
export async function projectsUpdateEnvVars({
	pathParams: { projectId },
	queryParams,
	config = {},
}: {
	pathParams: ProjectsUpdateEnvVarsPathParams;
	queryParams?: ProjectsUpdateEnvVarsQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!projectId) {
		throw new Error(`Missing required path parameter: projectId`);
	}
	const data = await request<
		ProjectsUpdateEnvVarsMutationResponse,
		ErrorWrapper<
			| ProjectsUpdateEnvVars401
			| ProjectsUpdateEnvVars403
			| ProjectsUpdateEnvVars404
			| ProjectsUpdateEnvVars409
			| ProjectsUpdateEnvVars413
			| ProjectsUpdateEnvVars422
			| ProjectsUpdateEnvVars429
			| ProjectsUpdateEnvVars500
		>,
		null,
		Record<string, string>,
		ProjectsUpdateEnvVarsQueryParams,
		ProjectsUpdateEnvVarsPathParams
	>({
		method: "PATCH",
		url: `/projects/${projectId}/env-vars`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Deletes multiple environment variables for a given project by their IDs.
 * @summary Delete Environment Variables
 * {@link /projects/:projectId/env-vars/delete}
 */
export async function projectsDeleteEnvVars({
	pathParams: { projectId },
	config = {},
}: {
	pathParams: ProjectsDeleteEnvVarsPathParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!projectId) {
		throw new Error(`Missing required path parameter: projectId`);
	}
	const data = await request<
		ProjectsDeleteEnvVarsMutationResponse,
		ErrorWrapper<
			| ProjectsDeleteEnvVars401
			| ProjectsDeleteEnvVars403
			| ProjectsDeleteEnvVars404
			| ProjectsDeleteEnvVars409
			| ProjectsDeleteEnvVars413
			| ProjectsDeleteEnvVars422
			| ProjectsDeleteEnvVars429
			| ProjectsDeleteEnvVars500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		ProjectsDeleteEnvVarsPathParams
	>({
		method: "POST",
		url: `/projects/${projectId}/env-vars/delete`,
		baseUrl: "https://api.v0.dev/v1",
		...requestConfig,
		headers: { "Content-Type": "applicationJson", ...requestConfig.headers },
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves a specific environment variable for a given project by its ID, including its value.
 * @summary Get Environment Variable
 * {@link /projects/:projectId/env-vars/:environmentVariableId}
 */
export async function projectsGetEnvVar({
	pathParams: { projectId, environmentVariableId },
	queryParams,
	config = {},
}: {
	pathParams: ProjectsGetEnvVarPathParams;
	queryParams?: ProjectsGetEnvVarQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	if (!projectId) {
		throw new Error(`Missing required path parameter: projectId`);
	}

	if (!environmentVariableId) {
		throw new Error(`Missing required path parameter: environmentVariableId`);
	}
	const data = await request<
		ProjectsGetEnvVarQueryResponse,
		ErrorWrapper<
			| ProjectsGetEnvVar401
			| ProjectsGetEnvVar403
			| ProjectsGetEnvVar404
			| ProjectsGetEnvVar409
			| ProjectsGetEnvVar413
			| ProjectsGetEnvVar422
			| ProjectsGetEnvVar429
			| ProjectsGetEnvVar500
		>,
		null,
		Record<string, string>,
		ProjectsGetEnvVarQueryParams,
		ProjectsGetEnvVarPathParams
	>({
		method: "GET",
		url: `/projects/${projectId}/env-vars/${environmentVariableId}`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves rate limit information for a given scope. Useful for monitoring usage limits and avoiding throttling.
 * @summary Find Rate Limit
 * {@link /rate-limits}
 */
export async function rateLimitsFind({
	queryParams,
	config = {},
}: {
	queryParams?: RateLimitsFindQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		RateLimitsFindQueryResponse,
		ErrorWrapper<
			| RateLimitsFind401
			| RateLimitsFind403
			| RateLimitsFind404
			| RateLimitsFind409
			| RateLimitsFind413
			| RateLimitsFind422
			| RateLimitsFind429
			| RateLimitsFind500
		>,
		null,
		Record<string, string>,
		RateLimitsFindQueryParams,
		Record<string, string>
	>({
		method: "GET",
		url: `/rate-limits`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves information about the authenticated user, including their ID, name, email, and account metadata.
 * @summary Get User
 * {@link /user}
 */
export async function userGet({
	config = {},
}: {
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		UserGetQueryResponse,
		ErrorWrapper<
			| UserGet401
			| UserGet403
			| UserGet404
			| UserGet409
			| UserGet413
			| UserGet422
			| UserGet429
			| UserGet500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		Record<string, string>
	>({ method: "GET", url: `/user`, baseUrl: "https://api.v0.dev/v1", ...requestConfig });
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Fetches billing usage and quota information for the authenticated user. Can be scoped to a specific context (e.g. project or namespace).
 * @summary Get Billing
 * {@link /user/billing}
 */
export async function userGetBilling({
	queryParams,
	config = {},
}: {
	queryParams?: UserGetBillingQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		UserGetBillingQueryResponse,
		ErrorWrapper<
			| UserGetBilling401
			| UserGetBilling403
			| UserGetBilling404
			| UserGetBilling409
			| UserGetBilling413
			| UserGetBilling422
			| UserGetBilling429
			| UserGetBilling500
		>,
		null,
		Record<string, string>,
		UserGetBillingQueryParams,
		Record<string, string>
	>({
		method: "GET",
		url: `/user/billing`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Returns the current subscription plan for the authenticated user, including tier details and feature limits.
 * @summary Get Plan
 * {@link /user/plan}
 */
export async function userGetPlan({
	config = {},
}: {
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		UserGetPlanQueryResponse,
		ErrorWrapper<
			| UserGetPlan401
			| UserGetPlan403
			| UserGetPlan404
			| UserGetPlan409
			| UserGetPlan413
			| UserGetPlan422
			| UserGetPlan429
			| UserGetPlan500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		Record<string, string>
	>({ method: "GET", url: `/user/plan`, baseUrl: "https://api.v0.dev/v1", ...requestConfig });
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves all accessible scopes for the authenticated user, such as personal workspaces or shared teams.
 * @summary Get User Scopes
 * {@link /user/scopes}
 */
export async function userGetScopes({
	config = {},
}: {
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		UserGetScopesQueryResponse,
		ErrorWrapper<
			| UserGetScopes401
			| UserGetScopes403
			| UserGetScopes404
			| UserGetScopes409
			| UserGetScopes413
			| UserGetScopes422
			| UserGetScopes429
			| UserGetScopes500
		>,
		null,
		Record<string, string>,
		Record<string, string>,
		Record<string, string>
	>({ method: "GET", url: `/user/scopes`, baseUrl: "https://api.v0.dev/v1", ...requestConfig });
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

/**
 * @description Retrieves detailed usage events for the authenticated user or team, including costs, event types, models used, and metadata. Shows the same data as displayed in the usage dashboard. Can be filtered by chatId to show usage for a specific chat, or by userId to show usage for a specific user.
 * @summary Get Usage Report
 * {@link /reports/usage}
 */
export async function reportsGetUsage({
	queryParams,
	config = {},
}: {
	queryParams?: ReportsGetUsageQueryParams;
	config?: Partial<FetcherConfig> & { client?: typeof client };
}): Promise<Promise<CallToolResult>> {
	const { client: request = client, ...requestConfig } = config;

	const data = await request<
		ReportsGetUsageQueryResponse,
		ErrorWrapper<
			| ReportsGetUsage401
			| ReportsGetUsage403
			| ReportsGetUsage404
			| ReportsGetUsage409
			| ReportsGetUsage413
			| ReportsGetUsage422
			| ReportsGetUsage429
			| ReportsGetUsage500
		>,
		null,
		Record<string, string>,
		ReportsGetUsageQueryParams,
		Record<string, string>
	>({
		method: "GET",
		url: `/reports/usage`,
		baseUrl: "https://api.v0.dev/v1",
		queryParams,
		...requestConfig,
	});
	return { content: [{ type: "text", text: JSON.stringify(data) }] };
}

import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

export function initMcpTools<Server>(serverLike: Server, config: FetcherConfig) {
	const server = serverLike as McpServer;

	server.tool(
		"chatsCreate",
		"Creates a new chat using a user message, optional system context, and model configuration. Useful for prompting the model within the scope of a specific project.",
		async () => {
			try {
				return await chatsCreate({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsFind",
		"Retrieves a list of existing chats, with support for pagination and filtering by favorite status. Helps manage and navigate chat history.",
		{ queryParams: chatsFindQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await chatsFind({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsInit",
		"Initializes a new chat from source content such as files, repositories, registries, or zip archives. Enables context-rich conversations based on code or assets.",
		async () => {
			try {
				return await chatsInit({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsDelete",
		"Deletes a specific chat based on the provided chatId. This operation is irreversible and permanently removes the chat and its contents.",
		{ chatId: chatsDeletePathParamsSchema.shape["chatId"] },
		async ({ chatId }) => {
			try {
				return await chatsDelete({ pathParams: { chatId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsGetById",
		"Retrieves the full details of a specific chat using its `chatId`. Includes messages, metadata, and associated configuration.",
		{ chatId: chatsGetByIdPathParamsSchema.shape["chatId"] },
		async ({ chatId }) => {
			try {
				return await chatsGetById({ pathParams: { chatId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsUpdate",
		"Updates the metadata of an existing chat using its `chatId`. Supports changes to the chat name and privacy setting.",
		{ chatId: chatsUpdatePathParamsSchema.shape["chatId"] },
		async ({ chatId }) => {
			try {
				return await chatsUpdate({ pathParams: { chatId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsFavorite",
		"Marks or unmarks a chat as a favorite using its `chatId`. This helps with organizing and quickly accessing important chats.",
		{ chatId: chatsFavoritePathParamsSchema.shape["chatId"] },
		async ({ chatId }) => {
			try {
				return await chatsFavorite({ pathParams: { chatId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsFork",
		"Creates a new chat fork (duplicate) from a specific version within an existing chat. Useful for branching off alternate directions without modifying the original conversation.",
		{ chatId: chatsForkPathParamsSchema.shape["chatId"] },
		async ({ chatId }) => {
			try {
				return await chatsFork({ pathParams: { chatId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"projectsGetByChatId",
		"Retrieves the v0 project associated with a given chat. Useful for determining the context or scope of a chat session.",
		{ chatId: projectsGetByChatIdPathParamsSchema.shape["chatId"] },
		async ({ chatId }) => {
			try {
				return await projectsGetByChatId({ pathParams: { chatId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsFindMessages",
		"Retrieves a list of all messages for a specific chat, ordered by creation date (newest first). Supports cursor-based pagination and includes message content, role, and type information.",
		{
			chatId: chatsFindMessagesPathParamsSchema.shape["chatId"],
			queryParams: chatsFindMessagesQueryParamsSchema,
		},
		async ({ chatId, queryParams }) => {
			try {
				return await chatsFindMessages({ pathParams: { chatId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsSendMessage",
		"Creates a new message in an existing chat. Triggers a model response using the provided prompt, with optional attachments and configuration settings.",
		{ chatId: chatsSendMessagePathParamsSchema.shape["chatId"] },
		async ({ chatId }) => {
			try {
				return await chatsSendMessage({ pathParams: { chatId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsGetMessage",
		"Retrieves detailed information about a specific message within a chat, including content, files, model configuration, and demo URLs.",
		{
			chatId: chatsGetMessagePathParamsSchema.shape["chatId"],
			messageId: chatsGetMessagePathParamsSchema.shape["messageId"],
		},
		async ({ chatId, messageId }) => {
			try {
				return await chatsGetMessage({ pathParams: { chatId, messageId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsFindVersions",
		"Retrieves a list of all versions (iterations) for a specific chat, ordered by creation date (newest first). Supports cursor-based pagination and includes version status and demo URLs.",
		{
			chatId: chatsFindVersionsPathParamsSchema.shape["chatId"],
			queryParams: chatsFindVersionsQueryParamsSchema,
		},
		async ({ chatId, queryParams }) => {
			try {
				return await chatsFindVersions({ pathParams: { chatId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsGetVersion",
		"Retrieves detailed information about a specific version of a chat, including all files with their content and lock status.",
		{
			chatId: chatsGetVersionPathParamsSchema.shape["chatId"],
			versionId: chatsGetVersionPathParamsSchema.shape["versionId"],
			queryParams: chatsGetVersionQueryParamsSchema,
		},
		async ({ chatId, versionId, queryParams }) => {
			try {
				return await chatsGetVersion({ pathParams: { chatId, versionId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsUpdateVersion",
		"Updates the source files of a specific chat version (block) manually. This allows editing generated files directly through the API.",
		{
			chatId: chatsUpdateVersionPathParamsSchema.shape["chatId"],
			versionId: chatsUpdateVersionPathParamsSchema.shape["versionId"],
		},
		async ({ chatId, versionId }) => {
			try {
				return await chatsUpdateVersion({ pathParams: { chatId, versionId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsDownloadVersion",
		"Download all files for a specific chat version as a zip or tarball archive. Use includeDefaultFiles=true to include all deployment files (package.json, configuration files, etc.) or false/omitted to return only the generated source files.",
		{
			chatId: chatsDownloadVersionPathParamsSchema.shape["chatId"],
			versionId: chatsDownloadVersionPathParamsSchema.shape["versionId"],
			queryParams: chatsDownloadVersionQueryParamsSchema,
		},
		async ({ chatId, versionId, queryParams }) => {
			try {
				return await chatsDownloadVersion({
					pathParams: { chatId, versionId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"chatsResume",
		"Resumes processing of a previously interrupted or incomplete message in a chat. Useful for continuing generation when a message was paused or stopped.",
		{
			chatId: chatsResumePathParamsSchema.shape["chatId"],
			messageId: chatsResumePathParamsSchema.shape["messageId"],
		},
		async ({ chatId, messageId }) => {
			try {
				return await chatsResume({ pathParams: { chatId, messageId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deploymentsFind",
		"Find deployments by project and chat IDs. This will return a list of deployments for the given project and chat IDs.",
		{ queryParams: deploymentsFindQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await deploymentsFind({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deploymentsCreate",
		"Create a new deployment for a specific chat and version. This will trigger a deployment to Vercel.",
		async () => {
			try {
				return await deploymentsCreate({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deploymentsGetById",
		"Get a deployment by ID. This will return the details of the deployment, including the inspector URL, chat ID, project ID, version ID, API URL, and web URL.",
		{ deploymentId: deploymentsGetByIdPathParamsSchema.shape["deploymentId"] },
		async ({ deploymentId }) => {
			try {
				return await deploymentsGetById({ pathParams: { deploymentId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deploymentsDelete",
		"Delete a deployment by ID. This will delete the deployment from Vercel.",
		{ deploymentId: deploymentsDeletePathParamsSchema.shape["deploymentId"] },
		async ({ deploymentId }) => {
			try {
				return await deploymentsDelete({ pathParams: { deploymentId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deploymentsFindLogs",
		"Retrieves logs for a specific deployment. Supports filtering by timestamp to fetch only recent logs.",
		{
			deploymentId: deploymentsFindLogsPathParamsSchema.shape["deploymentId"],
			queryParams: deploymentsFindLogsQueryParamsSchema,
		},
		async ({ deploymentId, queryParams }) => {
			try {
				return await deploymentsFindLogs({ pathParams: { deploymentId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deploymentsFindErrors",
		"Retrieves a list of errors that occurred during a specific deployment. Useful for diagnosing and debugging deployment issues.",
		{ deploymentId: deploymentsFindErrorsPathParamsSchema.shape["deploymentId"] },
		async ({ deploymentId }) => {
			try {
				return await deploymentsFindErrors({ pathParams: { deploymentId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"hooksFind",
		"Retrieves a list of existing hooks in your workspace. Useful for managing active webhooks tied to chat events or deployments.",
		async () => {
			try {
				return await hooksFind({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"hooksCreate",
		"Creates a new webhook that listens for specific events. Supports optional association with a chat.",
		async () => {
			try {
				return await hooksCreate({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"hooksGetById",
		"Retrieves the details of a specific webhook using its ID.",
		{ hookId: hooksGetByIdPathParamsSchema.shape["hookId"] },
		async ({ hookId }) => {
			try {
				return await hooksGetById({ pathParams: { hookId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"hooksUpdate",
		"Updates the configuration of an existing webhook, including its name, event subscriptions, or target URL.",
		{ hookId: hooksUpdatePathParamsSchema.shape["hookId"] },
		async ({ hookId }) => {
			try {
				return await hooksUpdate({ pathParams: { hookId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"hooksDelete",
		"Deletes a webhook based on its ID. This action is irreversible.",
		{ hookId: hooksDeletePathParamsSchema.shape["hookId"] },
		async ({ hookId }) => {
			try {
				return await hooksDelete({ pathParams: { hookId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"integrationsVercelProjectsFind",
		"Retrieves a list of Vercel projects linked to your integration. Useful for associating chats, deployments, or hooks with specific Vercel projects.",
		async () => {
			try {
				return await integrationsVercelProjectsFind({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"integrationsVercelProjectsCreate",
		"Links a Vercel project to an existing v0 project. Enables Vercel-related features and deployment integration within the v0 workspace.",
		async () => {
			try {
				return await integrationsVercelProjectsCreate({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"projectsFind",
		"Returns a list of all v0 projects in your workspace. Useful for browsing or managing projects across different chats or use cases.",
		async () => {
			try {
				return await projectsFind({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"projectsCreate",
		"Creates a new v0 project with an optional description, icon, environment variables, and instructions. Projects help organize chats and manage context.",
		async () => {
			try {
				return await projectsCreate({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"projectsGetById",
		"Retrieves the details of a specific v0 project by its ID.",
		{ projectId: projectsGetByIdPathParamsSchema.shape["projectId"] },
		async ({ projectId }) => {
			try {
				return await projectsGetById({ pathParams: { projectId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"projectsUpdate",
		"Updates the metadata of an existing project using its `projectId`. Supports changes to the project name and privacy setting.",
		{ projectId: projectsUpdatePathParamsSchema.shape["projectId"] },
		async ({ projectId }) => {
			try {
				return await projectsUpdate({ pathParams: { projectId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"projectsDelete",
		"Deletes a specific project based on the provided projectId. This operation marks the project as deleted and is irreversible.",
		{ projectId: projectsDeletePathParamsSchema.shape["projectId"] },
		async ({ projectId }) => {
			try {
				return await projectsDelete({ pathParams: { projectId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"projectsAssign",
		"Links an existing v0 project to a specific chat. Helps group conversations under a shared project context.",
		{ projectId: projectsAssignPathParamsSchema.shape["projectId"] },
		async ({ projectId }) => {
			try {
				return await projectsAssign({ pathParams: { projectId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"projectsFindEnvVars",
		"Retrieves all environment variables for a given project.",
		{
			projectId: projectsFindEnvVarsPathParamsSchema.shape["projectId"],
			queryParams: projectsFindEnvVarsQueryParamsSchema,
		},
		async ({ projectId, queryParams }) => {
			try {
				return await projectsFindEnvVars({ pathParams: { projectId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"projectsCreateEnvVars",
		"Creates new environment variables for a given project. This endpoint will fail if any of the specified environment variable keys already exist, unless upsert is set to true.",
		{
			projectId: projectsCreateEnvVarsPathParamsSchema.shape["projectId"],
			queryParams: projectsCreateEnvVarsQueryParamsSchema,
		},
		async ({ projectId, queryParams }) => {
			try {
				return await projectsCreateEnvVars({ pathParams: { projectId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"projectsUpdateEnvVars",
		"Updates multiple environment variables for a given project. Only the value of each environment variable can be updated.",
		{
			projectId: projectsUpdateEnvVarsPathParamsSchema.shape["projectId"],
			queryParams: projectsUpdateEnvVarsQueryParamsSchema,
		},
		async ({ projectId, queryParams }) => {
			try {
				return await projectsUpdateEnvVars({ pathParams: { projectId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"projectsDeleteEnvVars",
		"Deletes multiple environment variables for a given project by their IDs.",
		{ projectId: projectsDeleteEnvVarsPathParamsSchema.shape["projectId"] },
		async ({ projectId }) => {
			try {
				return await projectsDeleteEnvVars({ pathParams: { projectId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"projectsGetEnvVar",
		"Retrieves a specific environment variable for a given project by its ID, including its value.",
		{
			projectId: projectsGetEnvVarPathParamsSchema.shape["projectId"],
			environmentVariableId: projectsGetEnvVarPathParamsSchema.shape["environmentVariableId"],
			queryParams: projectsGetEnvVarQueryParamsSchema,
		},
		async ({ projectId, environmentVariableId, queryParams }) => {
			try {
				return await projectsGetEnvVar({
					pathParams: { projectId, environmentVariableId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"rateLimitsFind",
		"Retrieves rate limit information for a given scope. Useful for monitoring usage limits and avoiding throttling.",
		{ queryParams: rateLimitsFindQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await rateLimitsFind({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"userGet",
		"Retrieves information about the authenticated user, including their ID, name, email, and account metadata.",
		async () => {
			try {
				return await userGet({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"userGetBilling",
		"Fetches billing usage and quota information for the authenticated user. Can be scoped to a specific context (e.g. project or namespace).",
		{ queryParams: userGetBillingQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await userGetBilling({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"userGetPlan",
		"Returns the current subscription plan for the authenticated user, including tier details and feature limits.",
		async () => {
			try {
				return await userGetPlan({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"userGetScopes",
		"Retrieves all accessible scopes for the authenticated user, such as personal workspaces or shared teams.",
		async () => {
			try {
				return await userGetScopes({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"reportsGetUsage",
		"Retrieves detailed usage events for the authenticated user or team, including costs, event types, models used, and metadata. Shows the same data as displayed in the usage dashboard. Can be filtered by chatId to show usage for a specific chat, or by userId to show usage for a specific user.",
		{ queryParams: reportsGetUsageQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await reportsGetUsage({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);
}
